#!/bin/sh
#(c) Copyright 2007 Barry Kauler, www.puppylinux.com
#2007 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#Aug 2007, init script in initramfs, for puppy v2.20, Sept: v3.00, Oct: v3.01
#Nov 2007, v3.91: bugfix for humongous puppy.
#dec 2007, v3.93: update for 2.6.24 kernel, no /dev/hd*. v3.94: bugfix.
#v3.95 28dec07: load scsi_wait_scan.ko to fix sync problem with usb.
#v3.95 1jan08: fix for renaming of pmedia ide/sata -> ata.
#v3.96 26jan08: 2.6.24 kernel, remove scsi_wait_scan.ko and the delays.
#v3.97 31jan2008: restore support for hd* drives.
#v3.97 25feb2008: removed tmpfs on /tmp.
#v3.97 5mar2008: handle SAVEMARK file (see universal installer and rc.shutdown).
#v3.97 6mar2008: fix 'pfix=ram' for multisession cd/dvd.
#v3.97 6mar2008: multisession, copy saved .sfs files to '/' in ram.
#v3.98 3apr2008: partial fix, encrypted pup_save losetup failing.
#v4.00 21apr2008: ntfs-3g upgraded v1.417 to v1.2412.
#v4.00 26apr2008: slightly lowered threshold for copying pup_xxx.sfs to a tmpfs.
#v4.00 27apr2008: k2.6.25: strange sync problem. try restore scsi_wait_scan. NO, DO NOT.
#v4.01 7may2008: new system with all modules builtin to initrd, if ZDRVINIT='yes'
#v4.02 31may2008: export ZDRVINIT in /etc/rc.d/PUPSTATE
#v403 21jun08: reintroduce basic pcmcia support.
#v403 23jun08: fix for humongous initrd.
#v403 23jun08: fix boot from usb cd drive (classmate laptop).
#v404 13Jul08: pfix=noram removed, now need pfix=copy to copy .sfs to ram.
#v404 15jul08: prevent crash in PUPMODE 6,7. add pfix=fsck, otherwise never do fsck.
#v404 16jul08: fix for classmate with internal usb flash, PUPMODE now 13, not 12.
#v405 18jul08: default is now aufs. maybe won't even have unionfs module.
#v406 2aug08: restore support for old /dev/hd* ide devices.
#v406 9aug08: copy pup_xxx.sfs to same place as pup_save if fast media.
#v407 fix for module name change.
#v410 fix to allow 3 extra sfs files (a bug only allowed 2).
#v411 multisession, load saved /dev entries.
#v412 simplified module loading.
#v412 slight changes for new busybox v1.12.1.
#v412 fix usb-storage probe bug.
#v412 DISTRO_SPECS file. pup_xxx.sfs, zdrv_xxx.sfs renamed.
#v412 bugfix, /tmp/versioncleanup got overwritten by tmpfs mounted on /tmp.
#v412 bugfix, pup_ro6 was not created (for 3rd sfs file).
#w001 DISTRO_FILE_PREFIX, pup files renamed again, to woofsave.2fs, woofr001.sfs.
#w003 fix for loading yenta-socket module.
#w003 changed default to copy woofr001.sfs to ram >256MB ram.
#w003 /usr/sbin/snapmergepuppy now saves whiteout files to save-layer, change 'ro' to 'ro+wh'.
#w004 LANG=C
#w007 load nls_utf8.ko
#w012 bugfix. w014 usb flash can now have iso9660 f.s.
#w014 BootFlash utility can create 2 partitions in usb drive, one for boot, other for save.
#w015 allow 6 extra sfs files, up from 3.
#w019 pmedia=ataflash, PUPMODE=13 to constrain writes to drv.
#w460 bugfixes for zdrv, new name zu500629.sfs, handling 6 extra sfs files (7 incl. zdrv).
#w460 bugfix, boot usb, 1st shutdown was not offering to save session sometimes.
#w464 tidyup, make sure /etc/puppyversion is history.
#w468 load nls_cp850, now default for fat f.s. (2.6.29.2 kernel).
#w476 mnt_func() rewritten, support 'pkeys' boot param (work in progress).
#w478 modify sfs exclusion rules.
#w479 fix finding optical drive for kernel with old ide drivers.
#w481 record fast partitions, used by rc.shutdown.
#w482 lowered limit for copy sfs to ram, so multisession will work in 256mb pc.
#v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid.
#v423 problem recent kernels: hid-* extra drivers needed as well as usbhid.
#v423 need to reject wrong squashfs version, 3.x or 4.0.
#v424 BootManager no longer has checkbox to only load _nnn.sfs files.
#v424 try again, fix tmpfs overwrites /tmp/versioncleanup
#v424 whiteout processing for aufs2 fixed.
#v426 pkeys=de caused failure to boot from vfat partition.
#v426 record of layers needs to include zdrv.
#v431 piratesmack: fix boot from ext4.
#2009-11 TazOC Merged updates from LHP 4.43b
#2010-02 TazOC Mount spupsave.3fs as ext3; reject wrong squashfs
#2010-03 TazOC Accept spupsave.4fs & 4.43G bugfix: pupsave was mounted as host part fstype!
#2010-03 TazOC To avoid confusion, PUPSAVEFS=fstype of pupsave; what used to be
#            PUPSAVEFS is now: PUPSAVEHOSTFS=fstype of pupsave's host partition

#Unionfs layers setup by this script...
#unionfs layers:            RW (top)      RO1             RO2              PUPMODE
#full install, flash drive: tmpfs         PDEV1                            3
#First boot (or pfix=ram):  tmpfs                         pup_xxx.sfs      5
#pup_save is a partition:   PDEV1                         pup_xxx.sfs      6
#ditto, but flash drive:    tmpfs         PDEV1           pup_xxx.sfs      7
#Normal running puppy:      pup_save.3fs                  pup_xxx.sfs      12
#ditto, but flash drive:    tmpfs         pup_save.3fs    pup_xxx.sfs      13
#Multisession cd/dvd:       tmpfs         folders(tmpfs2) pup_xxx.sfs      77 (13+64)

# some user definable variables
# MINRAMSIZE2COPY* should be higher than PUPXXXSFS * 2, since it makes sense only to demand more RAM as minimum needed
#  to prevent sluggish behaviour in X with RAM consuming applications like firefox
MINRAMSIZE2COPY_DEF=     #default , was 220000 KB until and Lupu5x, then became 400000, now at Puppy6 is 700000
MINRAMSIZE2COPY_5=       #PUPMODE 5, if unset would fallback into PUPXXXSFS * 1.3
MINRAMSIZE2COPY_CD=      #Booting from CD with savefile on HD, if unset would faalback to PUPXXXSFS * 1.7
MINRAMSIZE2COPY_FRUGAL=  #Normal frugal boot, if unset would fallback to PUPXXXSFS * 2 * 1.3

if [ "$MINRAMSIZE2COPY_DEF" ];then
[ "$MINRAMSIZE2COPY_5" ]      || MINRAMSIZE2COPY_5=$MINRAMSIZE2COPY_DEF
[ "$MINRAMSIZE2COPY_CD" ]     || MINRAMSIZE2COPY_CD=$MINRAMSIZE2COPY_DEF
[ "$MINRAMSIZE2COPY_FRUGAL" ] || MINRAMSIZE2COPY_FRUGAL=$MINRAMSIZE2COPY_DEF
fi

#/bin/hotplug2stdout_notimeout > /tmp/pup_event_uevents_initrd &

reset_status(){ STATUS='';STATUSA=''; }

count_status(){
case $1 in #syntax: count_status ERRORNUMBER [line, marker or position in script]
0)  STATUS=$((STATUS+0));;
'') echo "WARNING: Missing returnvalue. Aussuming ZERO"
    STATUS=$((STATUS+0))
;;
[1-9]*)  STATUS=$((STATUS+1));;
*)  echo "ERROR: NON-DIGIT returnvalue. Aussuming ZERO"
    STATUS=$((STATUS+0))
;;
esac
STATUSA=$((STATUSA+1))
echo "STATUS=$STATUS STATUSA=$STATUSA : for $*" # should go to bootinit.log
return $1
}

check_status()
{
  local XPAUSE=10
  test "$1" || { echo "check_status:WARNING:Missing numerical parameter - defaulting to 0";set - 0; }

  #/bin/echo -en "\\033[72G" >/dev/console #move to column 72.
  if [ $1 -eq 0 ]
  then
    /bin/echo -en "\\033[72G"       >/dev/console
    /bin/echo -en "\\033[1;32mdone" >/dev/console
    /bin/echo -e "\\033[0;39m"      >/dev/console
  else
    [ "$STATUS" ]  || STATUS=1
    [ "$STATUSA" ] || STATUSA=$1
    /bin/echo -en "\\033[66G"  >/dev/console
    if [ $STATUS -lt $STATUSA ]; then
    /bin/echo -en "\\033[0;32m"             >/dev/console
    /bin/echo -en "$((STATUSA-STATUS))/$STATUSA compl." >/dev/console
    elif [ $STATUS -eq $STATUSA ]; then
    #/bin/echo -en "\\033[1;31mfailed" >/dev/console
    /bin/echo -en "\\033[1;31m$STATUS/$STATUSA failed"   >/dev/console
    else
    /bin/echo -en "\\033[0;31m"             >/dev/console
    /bin/echo -en "$STATUS/$STATUSA failed" >/dev/console
    fi
    /bin/echo -e "\\033[0;39m" >/dev/console

    echo -en "\\033[1;35m"     >/dev/console #35=purple
    echo -n "Dumping last lines of /tmp/bootinit.log..." >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;31m"     >/dev/console #31=red
    cat /tmp/bootinit.log | tail -n 4 >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console

    echo -en "\\033[1;35m"      >/dev/console #35=purple
    echo -n "Dumping last lines of kernel log..." >/dev/console
    /bin/echo -e "\\033[0;39m"  >/dev/console
    echo -en "\\033[1;31m"      >/dev/console #31=red
    dmesg | tail -n 4           >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console

    #exit to initial ramdisk shell...
    [ "$RDSH" = "yes" ] && exec /bin/sh >/dev/console 2>&1
    echo "Pausing for $XPAUSE seconds..."    >/dev/console
    sleep $XPAUSE
  fi
  reset_status
  return $1
}

_ass_layerfs(){
    local tLAYERFS fs
[ "$layerfs" ] && tLAYERFS=$layerfs
    for fs in $tLAYERFS aufs unionfs
    do
     grep $Q "[[:blank:]]\+${fs}$" /proc/filesystems && { LAYERFS=$fs; break; }
     [ "`modinfo $fs 2>/dev/null`" ] && { LAYERFS=$fs; break; }
    done
}

_load_drivers_main_new(){
###################LOAD MODULES TO ACCESS DRIVES#####################
echo -n "Loading drivers needed to access disk drives" > /dev/console #STEP ONE

#_load_serial_removable_driver(){
_load_drive_drivers(){
#100214 one config of 2.6.33 has base floppy and ps/2 mouse support not builtin...
#[ "`modinfo floppy 2>/dev/null`" != "" ]  && modprobe floppy
#[ "`modinfo psmouse 2>/dev/null`" != "" ] && modprobe psmouse

#w462 if present, load it. enables recognition of drives attached to parallel port.
#[ "`modinfo ppa 2>/dev/null`" != "" ] && modprobe ppa #also loads parport.ko
#modprobe sr_mod > /dev/null 2>&1 #v3.93 now built-in to kernel.

for ONEDRVMOD in floppy ppa sr_mod psmouse
do
 [ "`modinfo $ONEFSMOD 2>/dev/null`" != "" ] && modprobe $ONEDRVMOD
done
}
_load_drive_drivers
#_load_serial_removable_driver

ELSPCI="`elspci -l`" #jesses great little utility.

_load_pcmcia_drivers(){
#v403 pcmcia drive support. i think this may need extra delay though...
if [ "`echo "$ELSPCI" | grep '060700'`" != "" ];then
 modprobe yenta_socket
 #...may have to add on a couple of seconds, need to test with a pcmcia drive.
 #v412 yeah, my pccard-usb adaptor needs delay before elspci recognises 0C0310 (ohci-hcd) interface...
 echo -n "." > /dev/console
 sleep 2
fi
}
_load_pcmcia_drivers

_load_ehci_drivers(){
#v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid...
[ "`echo "$ELSPCI" | grep '0C0320'`" != "" ] && modprobe ehci-hcd
}
_load_ehci_drivers

_ass_layerfs

_load_fs_drivers(){
#121227 extra f.s. drivers may be modules (quirky6)... 130216 add f2fs...
for ONEFSMOD in ext2 ext3 ext4 fat msdos vfat ntfs reiserfs udf f2fs squashfs $LAYERFS fuse
do
 [ "`modinfo $ONEFSMOD 2>/dev/null`" != "" ] && modprobe $ONEFSMOD
done
}
_load_fs_drivers

echo -n "." > /dev/console

_load_other_drivers(){
MODALIASES="`cat /sys/bus/pci/devices/*/modalias`" #important, save to variable before loop.
for ONEMODALIAS in $MODALIASES
do
  modprobe -v $ONEMODALIAS #-v means verbose.
  #[ $? -eq 0 ] && echo -n "." > /dev/console
done
}
_load_other_drivers

_load_mmc_drivers(){
#091222 some mmc/sd interfaces need this...
#(above code loop may have loaded sdhci/sdhci_pci or tifm_core/tifm_7xx1)
[ "`lsmod | grep '^sdhci'`" != "" ] && modprobe mmc_core && modprobe mmc_block
[ "`lsmod | grep '^tifm'`" != "" ]  && modprobe mmc_core && modprobe mmc_block && modprobe tifm_sd
}
_load_mmc_drivers

#modprobe squashfs

#filesystems...
_load_codepage_drivers(){
modprobe nls_cp437     2>/dev/null #needed by windows filesystems.
modprobe nls_iso8859-1 2>/dev/null #needed by linux filesystems.
}
_load_codepage_drivers

#modprobe $LAYERFS #unionfs or aufs.
#modprobe fuse #for ntfs-3g driver.

###################LOAD MODULES TO ACCESS DRIVES#####################
}

_load_drivers_main(){
###################LOAD MODULES TO ACCESS DRIVES#####################
# TazOC Nice colors to start off
echo -e "                 ${bg_green}${white}  Starting Lighthouse Pup `cat /etc/LHPVERSION`  ${NC}" >/dev/console

echo -n "Loading drivers needed to access disk drives" > /dev/console #STEP ONE

#w462 if present, load it. enables recognition of drives attached to parallel port.
[ "`modinfo ppa 2>/dev/null`" != "" ] && modprobe ppa #also loads parport.ko

#w001 NOTE: in 4.1.2 I use elspci to determine if yenta-socket needs to be loaded.
#if so, need a delay -- i used sleep 2 -- before elspci can be used to detect 0C0310
#pci interface -- in the case of my pccard-usb adaptor, which needs ohci-hcd.
#my new code below will need to be fixed for that situation...

#w003 maybe this will fix... look for 'bc0Csc03i10' in modalias...
MODALIASES="`cat /sys/bus/pci/devices/*/modalias`" #important, save to variable before loop.
if [ "`echo "$MODALIASES" | grep 'bc0Csc03i10'`" != "" ];then
 modprobe yenta-socket
 [ $? -eq 0 ] && sleep 2
fi
#v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid
# this is contrary to my understanding all these years, but oh well, let's do it...
ELSPCI="`elspci -l`" #jesses great little utility.
[ "`echo "$ELSPCI" | grep '0C0320'`" != "" ] && modprobe ehci-hcd

for ONEMODALIAS in $MODALIASES
do
  modprobe -v $ONEMODALIAS #-v means verbose.
  [ $? -eq 0 ] && echo -n "." > /dev/console
done

modprobe squashfs
if [ -e /proc/ide ];then #v3.97
 modprobe cdrom
 modprobe ide-cd
fi
modprobe sr_mod > /dev/null 2>&1 #v3.93 now built-in to 2.6.25.x kernel.

#ATADRIVES="`cat /proc/partitions | grep "sd[a-z]$" | tr -s " " | cut -f 5 -d " " | tr "\n" " "`"
ATADRIVES="`ls -1 /sys/block | grep '^sd' | tr '\n' ' '`"

echo -n "$ATADRIVES" > /ATADRIVES #w479 for testing purposes if crash to console.

if [ "`lsmod | grep -E '^uhci|^ohci|^ehci'`" != "" ];then
  modprobe usb-storage & #run as separate process
  WAITUSB="yes"
  case `uname -r` in
  [0-2].*|3.[0-4].*)
  mount -t usbfs none /proc/bus/usb || {
    echo "FAILED mounting usbfs"
    echo "Hardware management may suffer"
    echo "Please check /etc/modules/DOTconfig for"
    echo "CONFIG_USB and CONFIG_USB_DEVICEFS"
    }
    #Slacko 5.5 3.4.17-PAE has CONFIG_USB_DEVICEFS not set
    ;;
  esac

  #v423 problem recent kernels: kernel configured to load hid-* extra drivers when
  #usbhid loads, but it doesn't work. Most unfortunate. Note, older kernels have the
  #hid-* (drivers for specific hardware, like Logitech wireless keyboard) builtin to
  #the usbhid driver. Now that they are separated out, it is a headache. Try this...
  ##note, --coldplug causes it to try and run 'udevtrigger', --dumb means use no rules
  #/bin/hotplug2 --persistent --no-coldplug --dumb &
  /bin/hotplug2stdout_notimeout >/tmp/uevents.log &
  PIDHOT=$!
  modprobe usbhid #for a usb keyboard.
fi


#v3.95 driver now builtin to libata pata kernel...
if [ -e /proc/ide ];then #v3.97
 #ide zip or ide ls-120 drive?...
 [ ! "`dmesg | grep "ATAPI FLOPPY"`" = "" ] && modprobe ide-floppy
fi

#filesystems...
modprobe nls_cp437     #needed by windows filesystems.
modprobe nls_iso8859-1 #needed by linux filesystems.
#modprobe nls_utf8  #w007
#modprobe nls_cp850 #w468 now default for fat f.s. (2.6.29.2 kernel)
_ass_layerfs
modprobe $LAYERFS #unionfs or aufs.
modprobe fuse     #for ntfs-3g driver.

if [ "$WAITUSB" = "yes" ];then #wait for device to register.
 #v3.94 Classmate laptop, needs more delay here... no, further down...
 sleep 1 #2 v403 bumped it up to 3. v412 try 1sec again.
 USBSTORAGES=0 ; CNTUSB=0
 while [ $USBSTORAGES -eq 0 ];do
  echo -n "." > /dev/console
  sleep 1
  #CNTUSB=`expr $CNTUSB + 1`
  CNTUSB=$((CNTUSB+1))
  [ $CNTUSB -gt 25 ] && break
  #v412 bug, ubuntu kernel, got duplicate 'device found at 2', need 'sort -u'...
  USBSTORAGES=`/bin/dmesg | grep "usb-storage: device found at" | sort -u | wc -l | sed -e 's/ //g'`
  #USBSTORAGES=`/bin/dmesg | grep "scsi.* : usb\-storage" | sort -u | wc -l`
  #if booting from usb, USBSTORAGES must be non-zero...
  [ "`echo "$PMEDIA" | grep 'usb'`" != "" ] && [ $USBSTORAGES -eq 0 ] && continue
  [ $USBSTORAGES -eq 0 ] && break
  AVAILABLEUSBSTORAGES=`/bin/dmesg | grep "usb-storage: device scan complete" | wc -l | sed -e 's/ //g'`
  #AVAILABLEUSBSTORAGES=`/bin/dmesg | grep "usb-storage .*: scan complete" | wc -l`
  [ $USBSTORAGES -ne $AVAILABLEUSBSTORAGES ] && USBSTORAGES=0
 done
 [ $USBSTORAGES -ne 0 ] && sleep 1 #v412 was needed for classmate. was 2, try 1sec.

 #v423 load hid-* driver...
 for ONEHID in `grep -o 'MODALIAS=hid:[^ ]*' /tmp/uevents.log | cut -f 2 -d '='`
 do
  modprobe $ONEHID
 done
 kill $PIDHOT

fi

check_status 0 #END STEP ONE
##############END MODULE LOADING TO ACCESS DRIVES####################
}


_test_kernel_param_root(){

if test "$root"; then

. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX


 case "$root" in
 /dev/ram0) return 0;;
 *)
    #test -e "$root" || return 0
    if [ -f /proc/mounts ]; then
    :
    else
    mount -t proc proc /proc
    mount -t sysfs sysfs /sys
    fi

    _load_drivers_main

    test -e "$root" || return 0

    mount -o ro "$root" /mnt/data || return 0
    test -e /mnt/data/etc/DISTRO_SPECS || {
    umount -lr /mnt/data
    return 0
    }

    origDISTRO_VERSION=$DISTRO_VERSION
    origDISTRO_NAME=$DISTRO_NAME

    unset DISTRO_VERSION DISTRO_NAME

    . /mnt/data/etc/DISTRO_SPECS
    umount -lr /mnt/data

    if test "$origDISTRO_VERSION" = "$DISTRO_VERSION" -a "$origDISTRO_NAME" = "$DISTRO_NAME"; then

     umount /sys
     umount /proc
     return 1
    else
     return 0
    fi
 ;;
 esac

fi

return 0
}

_test_kernel_param_root || exit 0

test -e /proc/mounts && { umount /sys; umount /proc; }

mount -o remount,rw /dev/root / || mount -o remount,rw rootfs /
for d in dev etc proc sys tmp; do [ -d "/$d" ] || mkdir "/$d"; done; unset d
mount -t proc none /proc
ln -sf /proc/mounts /etc/mtab #resize2fs,e2fsck need this.
mount -t sysfs none /sys

DEVTMPFSFLG=0 #130618 set it from 3builddistro.
_do_devtmpfs(){
# always use DEVTMPFS now.
#if grep $Q "[[:blank:]]\+devtmpfs$" /proc/filesystems; then
if grep $Q '[[:blank:]]\+devtmpfs$' /proc/filesystems; then
DEVTMPFSFLG=1 #130618 set it from 3builddistro.
 if grep $Q ' /dev ' /proc/mounts; then
 DEVTMPFSFLG=2
 elif [ -x /bin/mdev -o -x /bin/mknod ]; then
  mount -t devtmpfs devtmpfs /dev
  if [ $? = 0 ]; then
   if [ -e /bin/mdev ]; then
    /bin/mdev -s
   else
     oldIFS="$IFS"
     IFS=$'\n'
     find /sys -type f -name uevent -perm 644 |
     while read oneFILE
     do
     unset K MAJOR MINOR DEVPATH DEVNAME DEVTYPE DRIVER DEVICE PRODUCT TYPE BUSNUM DEVNUM INTERFACE MODALIAS DEVMODE
     source "$oneFILE" 2>>$ERR  || continue
     test "$MAJOR" -a "$MINOR"      || continue
     test "$DEVNAME" && { test -e /dev/$DEVNAME && continue; } || { DEVNAME=${oneFILE%/uevent*}; DEVNAME=${DEVNAME##*/}; test -e /dev/$DEVNAME && continue; }
     test "$DEVMODE" && DEVMODE=-m\ $DEVMODE
     test -e /dev/$DEVPATH/$DEVNAME || {
     test "$DEVTYPE" = disk -o "$DEVTYPE" = partition && K=b || K=c
     test ${DEVNAME%/*} = $DEVNAME || { test -d /dev/$DEVPATH/${DEVNAME%/*} || mkdir $VERB -p /dev/$DEVPATH/${DEVNAME%/*}; }
     mknod $DEVMODE /dev/$DEVPATH/$DEVNAME $K $MAJOR $MINOR
      }
     done
     IFS="$oldIFS"
   fi
  else
   DEVTMPFSFLG=0
  fi
 else
  DEVTMPFSFLG=0
 fi
fi
#DEVTMPFSFLG=1 #130618 set it from 3builddistro.
}
_do_devtmpfs

# Karl Godt: add debugging variables to commands like grep
unset Q QUIET S SILENT
VERB=-v; L_VERB=--verbose
[ $loglevel ] && LOGLEVEL=$loglevel #v2.22
#clear #clear the screen.
[ -d /tmp ] || mkdir /tmp
[ ! "$LOGLEVEL" ] && {
    # Karl Godt: add debugging variables to commands like grep
    Q=-q; QUIET=--quiet; S=-s; SILENT=--silent; VERB=''; L_VERB=''
    exec 1>/tmp/bootinit.log 2>&1 #remove o/p to console. v2.22 loglevel added.
}
readonly Q QUIET S SILENT VERB L_VERB

# pupmode=NUMBER parameter to force PUPMODE ie 13 on hd install
[ $pmode ]    && FPUPMODE=$pmode
[ $pupmode ]  && FPUPMODE=$pupmode
[ $ppupmode ] && FPUPMODE=$ppupmode

export LANG=C #w004
. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX

PATH="/bin:/sbin"
KERNELVER="`uname -r`"

KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-'` #v423
SFSSTR='squashfs, version 3' #v423
[ $KERNELSUBVER -gt 28 ] && SFSSTR='squashfs, version 4' #v423

#w020 compose name of 'zdrv', to fit 8+3 filename...
PREFIX1CHAR="`echo -n "$DISTRO_FILE_PREFIX" | cut -c 1`"
KERNEL3CHARS="`echo -n "$KERNELVER" | tr -d '.' | tr -d '\-' | tr -d '[a-z]' | rev | cut -c 1,2,3 | rev`"
ZDRVSFS="z${PREFIX1CHAR}${DISTRO_VERSION}${KERNEL3CHARS}.sfs"

#does this initrd have all the zdrv components inside it?...
ZDRVINIT='no'
if [ -f /lib/modules/$KERNELVER/modules.dep ]; then
[ `cat /lib/modules/$KERNELVER/modules.dep  | wc -l` -gt 200 ] && ZDRVINIT='yes'
else
[ -d /lib/modules/$KERNELVER ] || mkdir -p /lib/modules/$KERNELVER
touch /lib/modules/$KERNELVER/modules.dep
fi
#PUPPYVERSION=`cat /PUPPYVERSION`
#kernel with /proc/ide...
#pmedia= usbflash|usbhd|usbcd|ideflash|idehd|idecd|idezip|satahd|satacd|scsihd|scsicd|cd
#kernel without /proc/ide (libata PATA)...
#pmedia= usbflash|usbhd|usbcd|ataflash|atahd|atacd|atazip|scsihd|scsicd|cd
[ "$pmedia" ]  && PMEDIA="$pmedia"   #boot parameter, broad category of boot media. ex: cd.
#v3.95 for backwards naming compatibility...
if [ ! -e /proc/ide ];then #v3.97
 [ "$PMEDIA" = "ideflash" ] && PMEDIA="ataflash"
 [ "$PMEDIA" = "idezip" ]   && PMEDIA="atazip"
 [ "$PMEDIA" = "idehd" ]    && PMEDIA="atahd"
 [ "$PMEDIA" = "idecd" ]    && PMEDIA="atacd"
 [ "$PMEDIA" = "satahd" ]   && PMEDIA="atahd"
 [ "$PMEDIA" = "satacd" ]   && PMEDIA="atacd"
fi
[ "$pdev1" ]   && PDEV1="$pdev1"     #boot parameter, partition have booted off. ex: hda3
[ "$PDEV1" ]   && PDEV1=`basename "$PDEV1"`
[ "$psubdir" ] && PSUBDIR="$psubdir" #boot parameter, directory for puppy files. ex: puppy220

#now supporting a boot menu...
if [ "$pfix" ];then
 for ONEFIX in `echo -n "$pfix" | tr ',' ' '`
 do
  case $ONEFIX in
   ram)     PRAMONLY="yes";;      #run in ram only (do not load ${DISTRO_FILE_PREFIX}save).
   rdsh)    RDSH="yes";;          #exit to shell in initial ramdisk.
   nox)     PNOX="yes";;          #do not start X.
   clean)   PCLEAN="yes";;        #force version upgrade and cleanup.
   purge)   PPURGE="yes";;        #radical cleanup for broken system.
   copy)    PCOPY="yes";;         #copy .sfs files into ram.
   fsck)    PFSCK="yes";;         #do a fsck of ${DISTRO_FILE_PREFIX}save file.
   [0-9]*)  PIGNORELAST=$ONEFIX;; #blacklist last $ONEFIX folders (multisession).
  esac
 done
fi

[ "$pkeys" ]   && PKEYS="$pkeys"     #boot parameter, keyboard layout w476
_do_keymap(){
#120216 /PUPPYKEYMAP inserted in initrd by quicksetup (in future, by Woof too)...
FONTMAP=""
[ -f /PUPPYKEYMAP ] && [ ! "$PKEYS" ] && PKEYS="`cat /PUPPYKEYMAP`" #allow kernel boot param to override.
if [ "$PLANG" ];then
 if [ ! "$PKEYS" ];then
  #try to set PKEYS to match the language. first 2 letters of PLANG...
  #PKEYS=${PLANG:0:2} #rough as guts, assign first 2 chars of PLANG to PKEYS.
  PKEYS=`echo "$PLANG" | cut -b 1-2`
  case $PLANG in
   en*) PKEYS=us ;;
  esac
 fi
 #120216 L18L suggests load these, instead of what is below...
 case $PLANG in
  en*) echo ;;
  ar*|iw*) #L18L no Greek
   #setfont /lib/consolefonts/LatArCyrHeb-16.psfu.gz -C /dev/tty1
   [ -f /lib/consolefonts/LatArCyrHeb-16.psfu.gz ] && zcat /lib/consolefonts/LatArCyrHeb-16.psfu.gz | loadfont
   FONTMAP='LatArCyrHeb-16.psfu'
  ;;
  ru*) #vkvkvk for ru
   [ -f /lib/consolefonts/ter-u16n.psf.gz ] && zcat /lib/consolefonts/ter-u16n.psf.gz | loadfont
   FONTMAP='ter-u16n.psf'
  ;;
  *) #L18L All European languages; new default ?!
   [ -f /lib/consolefonts/LatGrkCyr-8x16.psfu.gz ] && zcat /lib/consolefonts/LatGrkCyr-8x16.psfu.gz | loadfont
   FONTMAP='LatGrkCyr-8x16.psfu'
  ;;
 esac
fi
}
_do_keymap

_do_keyboard(){
#091122 load keyboard layout if PKEYS boot param...
STATUS=0
VFAT_OUT_PARAM='shortname=mixed,quiet,utf8' #140102 rodin.s: added utf8 for flash drive to be mounted with utf-8 if boot is done from flash drive
CODEPAGE=""
KMAP=""
if [ "$PKEYS" ];then
 if [ ! -f /lib/keymaps/${PKEYS}.gz ];then
  PKEYS="`ls -1 /lib/keymaps/${PKEYS}*.gz | head -n 1 | rev | cut -f 1 -d '/' | cut -f 2 -d '.' | rev`"
 fi
 if [ -f /lib/keymaps/${PKEYS}.gz ];then
  echo "Loading '${PKEYS}' keyboard layout..." >/dev/console
  KMAP="$PKEYS"
  if [ -f /lib/keymaps/${PKEYS}.gz ]; then
   zcat /lib/keymaps/${PKEYS}.gz | loadkmap ;
  else
   false
  fi
  count_status $? #STATUS=$((STATUS + $?))
  case $PKEYS in #note, same code in /etc/rc.d/rc.country, /usr/sbin/input-wizard and init.
   de*|be*|br*|dk*|es*|fi*|fr*|it*|no*|se*|pt*)
    modprobe nls_cp850
    [ ! "$PLANG" ] && FONTMAP="lat1-12.psfu" #120216
    CODEPAGE="850"
    VFAT_OUT_PARAM="$OUT_PARAM"',codepage=850'
   ;;
   cz*|hu*|pl*|ro*|sk*|croat*|slovene*)
    modprobe nls_cp852
    modprobe nls_iso8859-2
    [ ! "$PLANG" ] && FONTMAP="lat2-12.psfu" #120216
    CODEPAGE="852"
    VFAT_OUT_PARAM="$OUT_PARAM"',codepage=852,iocharset=iso8859-2'
   ;;
  esac
  if [ ! "$PLANG" ];then #120216 old behaviour.
   if [ "$FONTMAP" ];then #100520 fix syntax error...
    if [ -f /lib/consolefonts/${FONTMAP}.gz ]; then
       zcat /lib/consolefonts/${FONTMAP}.gz | loadfont
    else
     false
    fi
    count_status $? #STATUS=$((STATUS + $?))
   fi
  fi
 else
  STATUS=1
 fi
 check_status $STATUS
fi
}
_do_keyboard

# TazOC Console color assignments
dkgreen="\\033[0;32m" # green
green="\\033[1;32m"   # bold green
yellow="\\033[1;33m"  # bold yellow
blue="\\033[1;34m"    # bold blue
purple="\\033[1;35m"  # bold purple
cyan="\\033[1;36m"    # bold cyan
white="\\033[1;37m"   # bold white
bg_blue="\\033[1;44m" # blue background
bg_green="\\033[1;42m" # green background
bg_white="\\033[1;47m" # white background
NC="\\033[0;39m"       # no color (white)

#v3.01 fsck for ext2/3 prior to mounting...
fsck_func() { #passed params: partition filesystem [filename]
 [ "$PFSCK" != "yes" ] && return 0 #v404 default is not do any checking.
 #v3.93 restrict to ext2 only... # TazOC or ext3/4
 [ "$2" != "ext2" -a "$2" != "ext3" -a "$2" != "ext4" ] && return 0 #precaution.
 CHKDEV=$1
 #[ $3 ] && CHKDEV="`basename $3`"
 echo "Performing filesystem check on /dev/$1..." >>/tmp/chkret
 e2fsck -y /dev/$1 >>/tmp/chkret &
 #sleep 1
 #if [ "`grep ': clean, ' /tmp/chkret`" = "" ];then
 # echo -e "\\033[1;35m" >/dev/console #35=purple
 # echo -n "Performing filesystem check on ${CHKDEV}, please wait" >/dev/console
 # echo -en "\\033[0;39m" >/dev/console
 #fi
 echo -en "\\033[1;35m" >/dev/console #35=purple
 MSGFSCK=" ${1} filesystem check, please wait..............."
 MSGFSCNT=1
 while [ "`pidof e2fsck`" != "" ];do
  if [ "${1}" = "loop1" ];then
   [ $MSGFSCNT -eq 1 ] && echo -n "filesystem check..." >/dev/console
  else
   [ $MSGFSCNT -lt 47 ] && MSGCHAR="`echo -n "$MSGFSCK" | cut -b $MSGFSCNT`"
   echo -n "$MSGCHAR" >/dev/console
  fi
  sleep 1
  #MSGFSCNT=`expr $MSGFSCNT + 1`
  MSGFSCNT=$((MSGFSCNT + 1))
 done
 resize2fs -pf /dev/$1 >>/tmp/chkret # TazOC
 sync # TazOC
 sleep 1 # TazOC
 echo -en "\\033[0;39m" >/dev/console
}

mnt_func() {
 MNT_T="$1"    #ex: vfat
 MNT_DEV="$2"  #ex: /dev/sda1
 MNT_DIR="$3"  #ex: /mnt/sda1
 MNT_O=""
 [ $4 ] && MNT_O="${4}" #ex: noatime

 grep $Q " $MNT_DIR " /proc/mounts && { echo "NOTICE:$* already mounted"; return 0; }
 [ -d "$MNT_DIR" ] || mkdir -p "$MNT_DIR"

 case $MNT_T in
  ntfs)
   ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw #default is rw
   ntfsRETVAL=$?
   [ $ntfsRETVAL -eq 0 ] && return 0
   if [ $ntfsRETVAL -eq 14 ];then
    #ntfs-3g $MNTPRMS -o umask=0,no_def_opts,noatime,rw,remove_hiberfile 2>/dev/null
    echo -e "\\033[1;31m" >/dev/console #31=red
    echo -n "ERROR: Windows NTFS hibernated partition, cannot mount" > /dev/console
    echo -e "\\033[0;39m" >/dev/console
    return 14
   else
    ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw,force
   fi
  ;;
  vfat) #w476
   ####TODO#### need to get rid of the old 2-letter keyboard layout, so PKEYS boot
   # param works for the main kbd layouts.
   #would like to introduce codepage and iocharset, maybe as kernel params...
   #ex: codepage=850 iocharset=iso8859-2 ...no, already have 'pkeys'
   OUT_PARAM='shortname=mixed,quiet'
   [ "$MNT_O" ] && OUT_PARAM="${OUT_PARAM},${MNT_O}"
   if [ "$PKEYS" ];then
    case $PKEYS in
     de|be|br|dk|es|fi|fr|it|no|se|pt)
      modprobe nls_cp850 #v426
      OUT_PARAM="$OUT_PARAM"',codepage=850'
     ;;
     slovene|croat|hu101|hu|cz-lat2|pl|ro_win)
      modprobe nls_cp852 #v426
      modprobe nls_iso8859-2 #v426
      OUT_PARAM="$OUT_PARAM"',codepage=852,iocharset=iso8859-2'
     ;;
    esac
   fi
   mount -t $MNT_T -o $OUT_PARAM $MNT_DEV $MNT_DIR
  ;;
  *)
   if [ "$MNT_O" = "" ];then
    mount -t $MNT_T $MNT_DEV $MNT_DIR
   else
    mount -t $MNT_T -o $MNT_O $MNT_DEV $MNT_DIR
   fi
  ;;
 esac
 return $?
}

umnt_func() {
 #warning umnt_func call must have mntpt param, not device name.
 LASTPARAM="`echo -n "$*" | tr '\t' ' ' | tr -s ' ' | tr ' ' '\n' | grep '^/mnt/'`"
 if [ "`mount | grep "$LASTPARAM" | grep -E 'ntfs|fuse'`" = "" ];then
  umount $@
 else
  fusermount -u $LASTPARAM
 fi
 return $?
}

__check_status__()
{
  /bin/echo -en "\\033[72G" >/dev/console #move to column 72.
  if [ $1 -eq 0 ]
  then
    /bin/echo -en "\\033[1;32mdone" >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
  else
    /bin/echo -en "\\033[1;31mfailed" >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;35m" >/dev/console #35=purple
    echo -n "Dumping last lines of /tmp/bootinit.log..." >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;31m" >/dev/console #31=red
    cat /tmp/bootinit.log | tail -n 4 >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console
    echo -en "\\033[1;35m" >/dev/console #35=purple
    echo -n "Dumping last lines of kernel log..." >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;31m" >/dev/console #31=red
    dmesg | tail -n 4 >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console
    #exit to initial ramdisk shell...
    [ "$RDSH" = "yes" ] && exec /bin/sh >/dev/console 2>&1
    echo "Pausing for 60 seconds..." >/dev/console
    sleep 60
  fi
}

__load_drivers_main__(){
###################LOAD MODULES TO ACCESS DRIVES#####################
# TazOC Nice colors to start off
echo -e "                 ${bg_green}${white}  Starting Lighthouse Pup `cat /etc/LHPVERSION`  ${NC}" >/dev/console

echo -n "Loading drivers needed to access disk drives" > /dev/console #STEP ONE

#w462 if present, load it. enables recognition of drives attached to parallel port.
[ "`modinfo ppa 2>/dev/null`" != "" ] && modprobe ppa #also loads parport.ko

#w001 NOTE: in 4.1.2 I use elspci to determine if yenta-socket needs to be loaded.
#if so, need a delay -- i used sleep 2 -- before elspci can be used to detect 0C0310
#pci interface -- in the case of my pccard-usb adaptor, which needs ohci-hcd.
#my new code below will need to be fixed for that situation...

#w003 maybe this will fix... look for 'bc0Csc03i10' in modalias...
MODALIASES="`cat /sys/bus/pci/devices/*/modalias`" #important, save to variable before loop.
if [ "`echo "$MODALIASES" | grep 'bc0Csc03i10'`" != "" ];then
 modprobe yenta-socket
 [ $? -eq 0 ] && sleep 2
fi
#v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid
# this is contrary to my understanding all these years, but oh well, let's do it...
ELSPCI="`elspci -l`" #jesses great little utility.
[ "`echo "$ELSPCI" | grep '0C0320'`" != "" ] && modprobe ehci-hcd

for ONEMODALIAS in $MODALIASES
do
  modprobe -v $ONEMODALIAS #-v means verbose.
  [ $? -eq 0 ] && echo -n "." > /dev/console
done

modprobe squashfs
if [ -e /proc/ide ];then #v3.97
 modprobe cdrom
 modprobe ide-cd
fi
modprobe sr_mod > /dev/null 2>&1 #v3.93 now built-in to 2.6.25.x kernel.

#ATADRIVES="`cat /proc/partitions | grep "sd[a-z]$" | tr -s " " | cut -f 5 -d " " | tr "\n" " "`"
ATADRIVES="`ls -1 /sys/block | grep '^sd' | tr '\n' ' '`"

echo -n "$ATADRIVES" > /ATADRIVES #w479 for testing purposes if crash to console.

if [ "`lsmod | grep -E '^uhci|^ohci|^ehci'`" != "" ];then
  modprobe usb-storage & #run as separate process
  WAITUSB="yes"
  mount -t usbfs none /proc/bus/usb

  #v423 problem recent kernels: kernel configured to load hid-* extra drivers when
  #usbhid loads, but it doesn't work. Most unfortunate. Note, older kernels have the
  #hid-* (drivers for specific hardware, like Logitech wireless keyboard) builtin to
  #the usbhid driver. Now that they are separated out, it is a headache. Try this...
  ##note, --coldplug causes it to try and run 'udevtrigger', --dumb means use no rules
  #/bin/hotplug2 --persistent --no-coldplug --dumb &
  /bin/hotplug2stdout_notimeout >/tmp/uevents.log &
  PIDHOT=$!
  modprobe usbhid #for a usb keyboard.
fi


#v3.95 driver now builtin to libata pata kernel...
if [ -e /proc/ide ];then #v3.97
 #ide zip or ide ls-120 drive?...
 [ ! "`dmesg | grep "ATAPI FLOPPY"`" = "" ] && modprobe ide-floppy
fi

#filesystems...
modprobe nls_cp437     #needed by windows filesystems.
modprobe nls_iso8859-1 #needed by linux filesystems.
#modprobe nls_utf8 #w007
#modprobe nls_cp850 #w468 now default for fat f.s. (2.6.29.2 kernel)
modprobe $LAYERFS #unionfs or aufs.
modprobe fuse #for ntfs-3g driver.

if [ "$WAITUSB" = "yes" ];then #wait for device to register.
 #v3.94 Classmate laptop, needs more delay here... no, further down...
 sleep 1 #2 v403 bumped it up to 3. v412 try 1sec again.
 USBSTORAGES=0 ; CNTUSB=0
 while [ $USBSTORAGES -eq 0 ];do
  echo -n "." > /dev/console
  sleep 1
  #CNTUSB=`expr $CNTUSB + 1`
  CNTUSB=$((CNTUSB + 1))
  [ $CNTUSB -gt 25 ] && break
  #v412 bug, ubuntu kernel, got duplicate 'device found at 2', need 'sort -u'...
  USBSTORAGES=`/bin/dmesg | grep "usb-storage: device found at" | sort -u | wc -l | sed -e 's/ //g'`
  #if booting from usb, USBSTORAGES must be non-zero...
  [ "`echo "$PMEDIA" | grep 'usb'`" != "" ] && [ $USBSTORAGES -eq 0 ] && continue
  [ $USBSTORAGES -eq 0 ] && break
  AVAILABLEUSBSTORAGES=`/bin/dmesg | grep "usb-storage: device scan complete" | wc -l | sed -e 's/ //g'`
  [ $USBSTORAGES -ne $AVAILABLEUSBSTORAGES ] && USBSTORAGES=0
 done
 [ $USBSTORAGES -ne 0 ] && sleep 1 #v412 was needed for classmate. was 2, try 1sec.

 #v423 load hid-* driver...
 for ONEHID in `grep -o 'MODALIAS=hid:[^ ]*' /tmp/uevents.log | cut -f 2 -d '='`
 do
  modprobe $ONEHID
 done
 kill $PIDHOT

fi

check_status 0 #END STEP ONE
##############END MODULE LOADING TO ACCESS DRIVES####################
}

_load_drivers_main

#[ "$PDEV1" ] && PDEV1=`basename "$PDEV1"`
#[ "$PDEV1" ] && { [ -e /dev/$PDEV1 ] || unset PDEV1; }

#######################FINDING PUPPY FILES###########################
echo -n "              :Searching for Puppy files in computer disk drives..." > /dev/console #STEP TWO
#locate all partitions (and superfloppy drives)...
PCPARTSALL="`probepart_init -k`"
PCPARTS0="`echo "$PCPARTSALL" | grep '^/dev/' | cut -f 1-2 -d '|'  | grep -E 'iso9660|udf|ext2|ext3|ext4|reiserfs|msdos|vfat|minix|ntfs' | sed -e 's/\/dev\///g'`" #v431
PCPARTS="`echo "$PCPARTS0" | tr "\n" " "`" #note, will have a space char on end.

#want separate lists of all internal (fast) partitions, and slow (usb) partitions...
FASTPARTS=""
PCPARTS0_NOCDS="`echo "$PCPARTS0" | grep -vE '^sr[0-9]+\||^scd[0-9]+\||^hd[a-z]\|'`" #w014 removed 'iso9660' test as now usb flash can have it.
#w479 ...not good enough. extra check for old kernel with ide drivers...
if [ -e /proc/ide ];then #w479
 OLDCDDRV="`echo "$PCPARTS0" | grep -E 'iso9660|udf' | grep '^hd' | cut -f 1 -d '|' | head -n 1`"
 [ "$OLDCDDRV" != "" ] && PCPARTS0_NOCDS="`echo "$PCPARTS0_NOCDS" | grep -v "$OLDCDDRV"`"
fi
SLOWPARTS0="$PCPARTS0_NOCDS" #not right, but will eliminate wrong ones.
#v3.97 last section superfluous for libata PATA kernel...
for ONEFAST in $ATADRIVES `cat /proc/partitions | grep "hd[a-z]$" | tr -s " " | cut -f 5 -d " " | tr "\n" " "`
do
 APATTERN="^${ONEFAST}"
 FASTPARTS="${FASTPARTS}`echo "$PCPARTS0_NOCDS" | grep "$APATTERN" | tr '\n' ' '`"
 SLOWPARTS0="`echo "$SLOWPARTS0" | grep -v "$APATTERN"`"
done
FASTPARTS0="`echo "$FASTPARTS" | tr -s ' ' | tr ' ' '\n'`"
SLOWPARTS="`echo "$SLOWPARTS0" | tr '\n' ' '`"
CDPARTS0="`echo "$PCPARTS0" | grep -E '^sr|^hd|^scd' | grep -E 'iso9660|udf'`" #w014 w479
CDPARTS="`echo "$CDPARTS0" | tr '\n' ' '`"

#need to narrow the search...
case $PMEDIA in
 *cd) #booting from usb, sata, or ide cd drive.
  LESSPARTS0="$PCPARTS0" #need to search everywhere.
  [ "$PRAMONLY" = "yes" ] && LESSPARTS0="$CDPARTS0" #v2.22
  ;;
 usb*) #external boot media. exs: usbflash, usbhd
  LESSPARTS0="$SLOWPARTS0"
  ;;
 *hd|*flash|*zip) #internal boot media. ex: idehd, satahd, ideflash, idezip, scsihd
  LESSPARTS0="$FASTPARTS0"
  ;;
 *)
  LESSPARTS0="$PCPARTS0" #need to search everywhere.
  ;;
esac
#in case PDEV1 boot param., override...
if [ "$PDEV1" ];then
 APATTERN="${PDEV1}|"
 LESSPARTS0="`echo "$PCPARTS0" | grep "$APATTERN"`"
fi
LESSPARTS="`echo "$LESSPARTS0" | tr '\n' ' '`"

#find puppy files in the pc...
touch /tmp/PUPPYFILES
[ "$PFSCK" = "yes" -a "`echo $LESSPARTS | grep 'ext'`" ] && echo -en " ${purple}e2fsck${NC}" >/dev/console # TazOC
for ONETRY in $LESSPARTS
do
 FND_FULLINSTALL=""
 ONEDEV="`echo -n "$ONETRY" | cut -f 1 -d '|'`"
 ONEFS="`echo -n "$ONETRY" | cut -f 2 -d '|'`"
 test "$ONEDEV" -a "$ONEFS" || continue
 echo -en '\r'"      " >/dev/console
 echo -en '\r'"$ONEDEV " >/dev/console

 # 2009-2 TazOC Check ext2/3/4 drives before mounting
 if [ "$PFSCK" = "yes" -a "`echo $ONEFS | grep 'ext'`" ]; then
  echo "Performing filesystem check on /dev/$ONEDEV..." >>/tmp/chkret
  echo -en " ${purple}/dev/$ONEDEV${NC}" >/dev/console
  e2fsck -y /dev/$ONEDEV >>/tmp/chkret &
  while [ "`pidof e2fsck`" != "" ]; do
   sleep 2; echo -n "." >/dev/console # progress dots
  done
  resize2fs -pf /dev/$ONEDEV >>/tmp/chkret # TazOC
  sync; sleep 2
 fi

 #v403 nasty bug: usb optical drive showing as /sys/block/sr0, but won't mount, needs more delay...
 #mnt_func $ONEFS /dev/$ONEDEV /mnt/data ro #-t $ONEFS /dev/$ONEDEV /mnt/data
 mnt_func $ONEFS /dev/$ONEDEV /mnt/$ONEDEV ro
 if [ $? -ne 0 ];then
  sleep 5 #2 wasn't enough.
  #mnt_func $ONEFS /dev/$ONEDEV /mnt/data ro #-t $ONEFS /dev/$ONEDEV /mnt/data
  mnt_func $ONEFS /dev/$ONEDEV /mnt/$ONEDEV ro
  [ $? -ne 0 ] && continue
 fi

 #[ -d /mnt/data ] && { rmdir /mnt/data || continue; } || true
 #[ -L /mnt/data ] && { rm    /mnt/data || continue; } || true
 #ln -snf $ONEDEV /mnt/data

 [ -f /mnt/$ONEDEV/etc/puppyversion ] && FND_FULLINSTALL="/etc/puppyversion" #pre-w464 installations.
 [ -f /mnt/$ONEDEV/etc/DISTRO_SPECS ] && FND_FULLINSTALL="/etc/DISTRO_SPECS"

 # REM: maxdepth setting for finding files
 defMAXD=2  # 2 was old default - could not find in PUPPY/DERIVATE/ directory
 if [ "$PSUBDIR" ]; then
  MAXDS=`echo "$PSUBDIR" | tr -s '/'`
  MAXDS=`echo "$MAXDS" | sed 's%^/*%%;s%/*$%%'`
  MAXDS="/${MAXDS}/"
  #MAXD=`echo "$MAXDS" | grep -o '/' | wc -l` # grep -o does not work correctly, greps only one /
  MAXD=`echo -n "$MAXDS" | tr '/' '\n' | wc -l`
 else
  MAXD=$defMAXD
 fi
 test "$MAXD" || MAXD=$defMAXD
 #test "${MAXD//[0-9]/}" && MAXD=$defMAXD # ash does not substitute // / as of bb v.1.4.2
 test "${MAXD##*[0-9]}"  && MAXD=$defMAXD

    FND_INITRDGZ="`find /mnt/$ONEDEV/ -maxdepth $MAXD -xdev -type f -name initrd.gz | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`"
 #v3.01 '*' means zero or more extra characters. this is for custom naming...
   FND_PUPXXXSFS="`find /mnt/$ONEDEV/ -maxdepth $MAXD -xdev -type f -name ${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`"
     FND_ZDRVSFS="`find /mnt/$ONEDEV/ -maxdepth $MAXD -xdev -type f -name ${ZDRVSFS} | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`"
  FND_PUPSAVE2FS="`find /mnt/$ONEDEV/ -maxdepth $MAXD -xdev -type f -name ${DISTRO_FILE_PREFIX}save*.[234]fs | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`" # 2010-03 TazOC accept .4fs
 FND_SWAPFILEPUP="`find /mnt/$ONEDEV/ -maxdepth $MAXD -xdev -type f -name pupswap.swp | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`"
 #v2.22 improved folder name search, avoid false hits...
 FND_MULTIFOLDER="`find /mnt/$ONEDEV/ -maxdepth 1 -xdev -type d -name 20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | grep -v ' ' | sed -e "s%^/mnt/$ONEDEV%%g" | tr '\n' ' '`"
 [ "$FND_MULTIFOLDER" != "" ] && echo "$ONEDEV $ONEFS $FND_MULTIFOLDER" >> /tmp/MULTIFOLDERS
 #all written on one line...
 echo -n "$ONEDEV $ONEFS " >> /tmp/PUPPYFILES
 echo "$FND_INITRDGZ $FND_PUPXXXSFS $FND_ZDRVSFS $FND_PUPSAVE2FS $FND_MULTIFOLDER $FND_FULLINSTALL $FND_SWAPFILEPUP" >> /tmp/PUPPYFILES
 [ -f /mnt/$ONEDEV/SAVEMARK ] && PSAVEMARK="`cat /mnt/$ONEDEV/SAVEMARK`" #v3.97 partition# that has or will-have ${DISTRO_FILE_PREFIX}save.

 #umnt_func -lr /mnt/data
 umnt_func -lr /mnt/$ONEDEV
 #_umount_mnt_data /mnt/$ONEDEV
done

#in case PSUBDIR boot param (path of puppy files), filter...
if [ "$PSUBDIR" ];then
 SPATTERN="/${PSUBDIR}/"
 PUPPYFILES="`grep "$SPATTERN" /tmp/PUPPYFILES | head -n 1 | tr -s ' '`" #v3.00...
 if [ "$PUPPYFILES" ];then
  PDEV1="`echo -n "$PUPPYFILES" | cut -f 1 -d ' '`" #v3.01
  DEV1FS="`echo -n "$PUPPYFILES" | cut -f 2 -d ' '`" #v3.01
  xpupfiles="`echo -n "$PUPPYFILES" | cut -f 3-99 -d ' ' | tr ' ' '\n' | grep "$SPATTERN" | tr '\n' ' '`" #v3.01
  PUPPYFILES="$PDEV1 $DEV1FS $xpupfiles"
 fi
else
 PUPPYFILES="`cat /tmp/PUPPYFILES | tr -s ' '`"
fi
echo "$PUPPYFILES" > /tmp/PUPPYFILES

#a humongous initrd has ${DISTRO_FILE_PREFIX}rxxx.sfs inside it...
if [ -f /${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs ];then
 #and maybe also ${ZDRVSFS}...
 if [ -f /${ZDRVSFS} ];then
  echo "rootfs rootfs /${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs /${ZDRVSFS}" >> /tmp/PUPPYFILES
 else
  echo "rootfs rootfs /${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs" >> /tmp/PUPPYFILES
 fi
 PUPPYFILES="`cat /tmp/PUPPYFILES`" #v3.91
fi

if [ ! "$PDEV1" ];then
 #note, if 'psubdir' defined, PDEV1 already found above.
 #if only one line in /tmp/PUPPYFILES has initrd.gz then that must be the boot partition...
 #w460 need extra test to avoid other initrd.gz's...
 SRCH1="`grep '/initrd\\.gz' /tmp/PUPPYFILES`"
 if [ "`echo "$SRCH1" | wc -l`" = "1" ];then
  PDEV1="`echo -n "$SRCH1" | cut -f 1 -d ' '`"
 else
  uPATTERN='/'"${DISTRO_FILE_PREFIX}\\-${DISTRO_VERSION}\\.sfs"
  SRCH2="`echo "$SRCH1" | grep "$uPATTERN"`"
  if [ "`echo "$SRCH2" | wc -l`" = "1" ];then
   PDEV1="`echo -n "$SRCH2" | cut -f 1 -d ' '`"
  fi
 fi
 #v2.20b or, if boot from cd, look for the iso9660 f.s...
 ISITACD="`echo -n "$PMEDIA" |  grep 'cd'`"
 [ "$ISITACD" != "" ] && [ "`grep '/initrd\\.gz' /tmp/PUPPYFILES | grep ' iso9660 ' | wc -l`" = "1" ] && PDEV1="`grep '/initrd\\.gz' /tmp/PUPPYFILES | grep ' iso9660 ' | cut -f 1 -d ' '`"
 [ "$ISITACD" != "" ] && [ "`grep '/initrd\\.gz' /tmp/PUPPYFILES | grep ' udf ' | wc -l`" = "1" ]     && PDEV1="`grep '/initrd\\.gz' /tmp/PUPPYFILES | grep ' udf ' | cut -f 1 -d ' '`"
fi

if [ "$PDEV1" -a ! "$PSAVEMARK" ];then #w014
 #new BootFlash utility can create 128MB boot partition, 2nd partition for pupsave...
 devnameonly="`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`"
 pdPATTERN='/dev/'"$PDEV1"'|'
 pdSIZEK=`echo "$PCPARTSALL" | grep "$pdPATTERN" | cut -f 3 -d '|'`
 if [ $pdSIZEK -lt 139264 ];then #136MB
  p1PATTERN='/dev/'"$devnameonly"'1|'
  p2PATTERN='/dev/'"$devnameonly"'2|'
  devnumonly="`echo -n "$PDEV1" | sed -e 's/sd[a-z]//'`"
  [ "$devnumonly" = "1" ] && [ "`echo "$PCPARTSALL" | grep "$p2PATTERN"`" != "" ] && PSAVEMARK="2" #USB-HDD or ISO9660.
  [ "$devnumonly" = "4" ] && [ "`echo "$PCPARTSALL" | grep "$p1PATTERN"`" != "" ] && PSAVEMARK="1" #USB-ZIP or ComboFormat.
 fi
fi
if [ "$PDEV1" -a "$PSAVEMARK" ];then #v3.97
 devnameonly="`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`"
 PUPSAVEDEV="${devnameonly}${PSAVEMARK}" #partition that has or will-have ${DISTRO_FILE_PREFIX}save.2fs.
fi

#find ${DISTRO_FILE_PREFIX}-xxx.sfs and ${DISTRO_FILE_PREFIX}save.2fs files...
touch /tmp/PUPXXXSFSS
touch /tmp/PUPSAVE2FSS
NUMPARTS=`wc -l /tmp/PUPPYFILES | tr -s ' ' | cut -f 2 -d ' '`
case $NUMPARTS in
 0) #nothing found.
  echo -en "\\033[1;31m" >/dev/console #31=red
  echo -n "No Puppy files found. Dropping out to initial-ramdisk console..." >/dev/console
  /bin/echo -e "\\033[0;39m" >/dev/console
  exec /bin/sh >/dev/console 2>&1
  ;;
 *) #files in one or more partitions.
  echo "$PUPPYFILES" |
  while read ONELINE
  do
   #ONELINE has part., f.s., then all puppy files found in that partition, space-delimited.
   #each line written to file has format: hda7,ext3,path/filename...
   ONEDEV="`echo -n "$ONELINE" | cut -f 1 -d ' '`" #ex: hda7
   ONEFS="`echo -n "$ONELINE" | cut -f 2 -d ' '`"  #ex: ext3
   LINEFILES="`echo -n "$ONELINE" | cut -f 3-99 -d ' '`" #ex: /pup220/${DISTRO_FILE_PREFIX}save.2fs /pup220/${DISTRO_FILE_PREFIX}r220.sfs
   APATTERN="/${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.*\\.sfs"
   for ONEPUPXXXSFS in `echo "$LINEFILES" | tr ' ' '\n' | grep "$APATTERN"`
   do
    echo "$ONEDEV,$ONEFS,$ONEPUPXXXSFS"  >> /tmp/PUPXXXSFSS
   done
   BPATTERN="/${DISTRO_FILE_PREFIX}save.*\\.[234]fs" #2010-03 TazOC accept .4fs
   for ONEPUPSAVE2FS in `echo "$LINEFILES" | tr ' ' '\n' | grep "$BPATTERN"`
   do
    [ "$PUPSAVEDEV" ] && [ "$ONEDEV" != "$PUPSAVEDEV" ] && continue #v3.97
    echo "$ONEDEV,$ONEFS,$ONEPUPSAVE2FS"  >> /tmp/PUPSAVE2FSS
   done
   ZPATTERN="/${ZDRVSFS}"
   for ONEZDRVXXXSFS in `echo "$LINEFILES" | tr ' ' '\n' | grep "$ZPATTERN"`
   do
    echo "$ONEDEV,$ONEFS,$ONEZDRVXXXSFS"  >> /tmp/ZDRVXXXSFSS #v2.22
   done
  done
  ;;
esac

PUPMODE=0
#choose which ${DISTRO_FILE_PREFIX}save.2fs to use...
if [ -f /tmp/MULTIFOLDERS ];then #multisession cd/dvd.
 if [ "$PRAMONLY" = "yes" ];then #v3.97 fix 'pfix=ram' for multisession dvd.
  PUPSAVE=""
 else
  PUPMODE=72 #77 v3.01 64+8, will become 77.
  PUPSAVE="`cat /tmp/MULTIFOLDERS | cut -f 1-3 -d ' ' | tr ' ' ','`" #only record 1st folder.
 fi
else
 tmpPUPSAVE2FSS=`sort -u /tmp/PUPSAVE2FSS`
 echo "$tmpPUPSAVE2FSS" > /tmp/PUPSAVE2FSS
 NUMPUPSAVES=`wc -l /tmp/PUPSAVE2FSS | tr -s ' ' | cut -f 2 -d ' '`
 [ "$PRAMONLY" = "yes" ] && NUMPUPSAVES=0 #pfix=ram is a boot param.
 case $NUMPUPSAVES in
  0)
   PUPSAVE=""
   ;;
  1)
   PUPMODE=8 #`expr $PUPMODE + 8`  #PUPMODE=12
   PUPSAVE="`cat /tmp/PUPSAVE2FSS`" #format: hda7,ext3,/pup220/${DISTRO_FILE_PREFIX}save.2fs
   ;;
  *)
   PUPSAVE=""
   CNTSAVE=1
   echo -e "\\033[1;36m" >/dev/console #36=aquablue
   echo "Type a number to choose which personal file to use:" > /dev/console
   echo "0  none" > /dev/console
   for ONECHOICE in `cat /tmp/PUPSAVE2FSS`
   do
    ONEFILE="`echo -n "$ONECHOICE" | cut -f 3 -d ','`"
    ONEPART="`echo -n "$ONECHOICE" | cut -f 1 -d ','`"
    echo -e "${CNTSAVE}  ${ONEPART}\\033[10G${ONEFILE}" > /dev/console #10 means move to that column.
    #CNTSAVE=`expr $CNTSAVE + 1`
    CNTSAVE=$((CNTSAVE+1))
   done
   echo -en "\\033[0;39m" >/dev/console
   read NUMSAVE
   #clear
   if [ $NUMSAVE -ne 0 ];then
    PUPMODE=8 #`expr $PUPMODE + 8`  #PUPMODE=12
    #PUPSAVE="`cat /tmp/PUPSAVE2FSS | tr '\n' ' ' | cut -f $NUMSAVE -d ' '`"
    PUPSAVE="`cat /tmp/PUPSAVE2FSS | sed -n "$NUMSAVE p"`"
   fi
   ;;
 esac
fi
#note, PUPSAVE has format: partition,f.s.-of-part.,path/name ex: hda3,ext2,/pup220/${DISTRO_FILE_PREFIX}save.2fs

#choose which ${DISTRO_FILE_PREFIX}-xxx.sfs to use...
PUPSFS=""
#if humongous initrd, use internal ${DISTRO_FILE_PREFIX}-xxx.sfs...
PUPSFS="`cat /tmp/PUPXXXSFSS | grep 'rootfs rootfs'`"
#if already chose a ${DISTRO_FILE_PREFIX}save prefer a ${DISTRO_FILE_PREFIX}-xxx.sfs in same place...
if [ "$PUPSFS" = "" -a "$PUPSAVE" != "" ];then
 PPATTERN='^'"`echo -n "$PUPSAVE" | cut -f 1 -d ','`"','
 PUPSFS="`grep "$PPATTERN" /tmp/PUPXXXSFSS | head -n 1`" #v3.00
fi

if [ "$PUPSFS" = "" ];then
 if [ ! -e /proc/ide ];then #w479
  PUPSFS="`grep -vE '^sr|^scd' /tmp/PUPXXXSFSS | head -n 1`" #w014 exclude optical, take top.
 else
  #w479 extra check for old kernel with ide drivers, exclude all optical drvs...
  PUPSFS="`grep -vE '^sr|^scd' /tmp/PUPXXXSFSS`"
  OLDCDDRV="`echo "$PCPARTS0" | grep -E 'iso9660|udf' | grep '^hd' | cut -f 1 -d '|' | head -n 1`"
  [ "$OLDCDDRV" != "" ] && PUPSFS="`echo "$PUPSFS" | grep -v "$OLDCDDRV" | head -n 1`"
 fi
fi

if [ "$PUPSFS" != "" -a "$PDEV1" != "" ];then #v3.01
 #if booting from cd, make sure chosen has same name as on cd...
 CDPATTERN="^${PDEV1},iso9660"
 CDSFSNAME="`grep "$CDPATTERN" /tmp/PUPXXXSFSS | head -n 1 | cut -f 3 -d ','`"
 if [ ! "$CDSFSNAME" ]; then
 CDPATTERN="^${PDEV1},udf"
 CDSFSNAME="`grep "$CDPATTERN" /tmp/PUPXXXSFSS | head -n 1 | cut -f 3 -d ','`"
 fi
 if [ "$CDSFSNAME" ];then
  CDSFSBASE="`basename $CDSFSNAME`"
  HDSFSNAME="`echo -n "$PUPSFS" | cut -f 3 -d ','`"
  HDSFSBASE="`basename $HDSFSNAME`"
  [ "$CDSFSBASE" != "$HDSFSBASE" ] && PUPSFS="`grep "$CDPATTERN" /tmp/PUPXXXSFSS | head -n 1`" #use file on cd.
 fi
fi

[ "$PUPSFS" = "" ] && PUPSFS="`cat /tmp/PUPXXXSFSS | head -n 1`"
if [ "$PUPSFS" = "" ];then
 echo -en "\\033[1;31m" >/dev/console #31=red
 echo -n "${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs not found. Dropping out to initial-ramdisk console..." >/dev/console
 /bin/echo -e "\\033[0;39m" >/dev/console
 exec /bin/sh >/dev/console 2>&1
else
 #PUPMODE=`expr $PUPMODE + 4` #${DISTRO_FILE_PREFIX}-xxx.sfs exists.
 PUPMODE=$((PUPMODE+4))
fi

#choose which ${ZDRVSFS} to use... v2.22
if [ -f /tmp/ZDRVXXXSFSS ];then
 if [ "$PUPSAVE" != "" ];then
  #use zdrv which should be in same place as the '${DISTRO_FILE_PREFIX}save' ${DISTRO_FILE_PREFIX}-xxx.2fs...
  ZPATTERN="^`echo -n "$PUPSAVE" | cut -f 1 -d ','`,"
  ZDRV="`grep "$ZPATTERN" /tmp/ZDRVXXXSFSS | head -n 1`"
 fi
 if [ "$ZDRV" = "" ];then
  #fall back to getting it from same place as ${DISTRO_FILE_PREFIX}-xxx.sfs file...
  ZPATTERN="^`echo -n "$PUPSFS" | cut -f 1 -d ','`,"
  ZDRV="`grep "$ZPATTERN" /tmp/ZDRVXXXSFSS | head -n 1`"
 fi
fi

#refine the PUPMODE...
#if a ${DISTRO_FILE_PREFIX}save was not found, perhaps boot partition has a full install of puppy...
__old_pupmode6__(){
if [ "$PUPSAVE" = "" -a "$PDEV1" != "" ];then
 APATTERN="^${PDEV1} "
 [ "`grep "$APATTERN" /tmp/PUPPYFILES | grep '/etc/puppyversion'`" != "" ] && DEV1PUP="yes" #pre-w464 installations.
 [ "`grep "$APATTERN" /tmp/PUPPYFILES | grep '/etc/DISTRO_SPECS'`" != "" ] && DEV1PUP="yes"
 #[ "$DEV1PUP" = "yes" ] && PUPMODE=`expr $PUPMODE + 2`
 [ "$DEV1PUP" = "yes" ] && PUPMODE=$((PUPMODE+2))
fi
}

if [ "$PUPMODE" = 1 ]; then #/etc/DISTRO_SPECS found
 [ "$FPUPMODE" ] && PUPMODE=$PUPMODE || PUPMODE=$((PUPMODE + 2))
elif [ ! "$PUPSAVE" ] && [ "$DEV1PUP" = "yes" -o "$DEV2PUP" != "" ] ; then #DEV1PUP is PUPMODE6 with pup_rw on its own partition ??
 [ "$FPUPMODE" ] && PUPMODE=$PUPMODE || PUPMODE=$((PUPMODE + 2))           #DEV2PUP is PUPMODE6 with pup_rw on another partition ??
else
 :
fi

#do we want a tmpfs top unionfs layer?...
#only if ${DISTRO_FILE_PREFIX}save (or PDEV1 for DEV1PUP=yes, or first boot) on a flash drive, usb or internal...

_check_removable(){
 test "$*" || case $PUPMODE in 12) set - "$PUPSAVE";; 6) set - "$PDEV1";; esac
 local DRVSAVE REMOVABLEDRVSAVE=0
 DRVSAVE="`echo -n "$*" | cut -f 1 -d ',' | sed -e 's/[0-9]*$//' -e 's/p$//'`" #ex: sda  110126 mmcblk0p1 becomes mmcblk0
 [ -f /sys/block/$DRVSAVE/removable ] && read REMOVABLEDRVSAVE </sys/block/$DRVSAVE/removable
 return $REMOVABLEDRVSAVE
}

_redefine12(){
 case $FPUPMODE in 11|12|13) return $FPUPMODE;; esac
 case $PMEDIA in *flash*) return 13;; esac
 _check_removable "$PUPSAVE"
 case $? in 1) [ "$PMEDIA" = usbhd ] || return 13;;esac
 return 12
}

__redefine12(){
 case $FPUPMODE in 11|12|13) return $FPUPMODE;; esac
 case $PMEDIA in *flash*) return 13;; esac
 DRVSAVE="`echo -n "$PUPSAVE" | cut -f 1 -d ',' | sed -e 's/[0-9]*$//' -e 's/p$//'`" #ex: sda  110126 mmcblk0p1 becomes mmcblk0
 [ -f /sys/block/$DRVSAVE/removable ] && read REMOVABLEDRVSAVE </sys/block/$DRVSAVE/removable
 case $REMOVABLEDRVSAVE in 1) [ "$PMEDIA" = usbhd ] || return 13;;esac
 return 12
}

__redefine12__(){
    case $FPUPMODE in 11|12|13) PUPMODE=$FPUPMODE;return 0;; esac
    case $PMEDIA in *flash*)    PUPMODE=13;       return 0;; esac
    DRVSAVE="`echo -n "$PUPSAVE" | cut -f 1 -d ',' | sed -e 's/[0-9]*$//' -e 's/p$//'`" #ex: sda  110126 mmcblk0p1 becomes mmcblk0
    [ -f /sys/block/$DRVSAVE/removable ] && read REMOVABLEDRVSAVE </sys/block/$DRVSAVE/removable
    case $REMOVABLEDRVSAVE in 1) [ "$PMEDIA" = usbhd ] || { PUPMODE=13;return 0; } ;;esac
    PUPMODE=12
}

case $PUPMODE in
 2)
   ;;
 3)
   ;;
 4) #so far have only got a ${DISTRO_FILE_PREFIX}-xxx.sfs. this is first boot or pfix=ram.
  PUPMODE=5 #`expr $PUPMODE + 1` #yes, want tmpfs top layer (PUPMODE=5).
  ;;
 12) #4=${DISTRO_FILE_PREFIX}-xxx.sfs found, 8=${DISTRO_FILE_PREFIX}save.2fs found.  total=12
  __old_redefine12__(){
  DRVSAVE="`echo -n "$PUPSAVE" | cut -b 1-3`"
  REMOVABLEDRVSAVE="`cat /sys/block/$DRVSAVE/removable`"
  [ "$REMOVABLEDRVSAVE" = "1" ] && PUPMODE=13 #`expr $PUPMODE + 1`
  [ "$PMEDIA" = "usbflash" ]    && PUPMODE=13 #v404 fix classmate, with internal usb flash.
  [ "$PMEDIA" = "ataflash" -o "$PMEDIA" = "ideflash" ] && PUPMODE=13 #w019 constrain writes to internal flash drv.
  [ "$FORCEPUPMODE" = 13 ] && PUPMODE=13
  [ "$FORCEPUPMODE" = 11 ] && PUPMODE=13
  }
   _redefine12
   PUPMODE=$?
   [ "$PUPMODE" ] || PUPMODE=13 #precaution
  ;;
 6) #4=${DISTRO_FILE_PREFIX}-xxx.sfs found, 2=full install of puppy in boot partition. total=6
  __old_check_removable__(){
  DRVSAVE="`echo -n "$PDEV1" | cut -b 1-3`"
  REMOVABLEDRVSAVE="`cat /sys/block/$DRVSAVE/removable`"
  [ "$REMOVABLEDRVSAVE" = "1" ] && PUPMODE=7 #`expr $PUPMODE + 1`
  }
  _check_removable "$PDEV1"; PUPMODE=$((PUPMODE + $?))
  #v3.96 Classmate laptop has internal usb flash, so really want the tmpfs layer...
  # puppyinstaller created 'pmedia=usbflash' for the extlinux full hd install...
  [ "$PMEDIA" = "usbflash" ] && PUPMODE=7
  ;;
 76|77) #v3.01 64+8+4 multisession cd.
  PUPMODE=77 #`expr $PUPMODE + 1` #yes, want tmpfs top layer.
  ;;
  *) [ "$FPUPMODE" ] && PUPMODE=$FPUPMODE || PUPMODE=5;;
esac


if [ $PDEV1 ];then
 APATTERN="^${PDEV1}|"
 DEV1FS="`echo "$PCPARTS0" | grep "$APATTERN" | cut -f 2 -d '|'`"
 #v2.20b if booted with PMEDIA=cd, refine it...
 if [ "$PMEDIA" = "cd" ];then
  case $PDEV1 in
   hd*) PMEDIA="idecd" ;; #v3.97
   scd*|sr*)
    PMEDIA="usbcd"
    if [ "`echo -n "$ATADRIVES" | grep "$PDEV1"`" != "" ];then
     if [ -e /proc/ide ];then #v3.97
      PMEDIA="satacd"
     else
      PMEDIA="atacd"
     fi
    fi
    ;;
  esac
 fi
fi

check_status 0
########################END FINDING PUPPY FILES############################
echo "FINALLY SET PUPMODE='$PUPMODE'"
##########################LOADING PUPPY FILES###########################
RAMSIZE=`free | grep 'Mem:' | tr -s ' ' | cut -f 3 -d ' '` #total physical ram (less shared video).
CRYPTO=""

#decide the mount-points...
#unionfs layers:            RW (top)      RO1             RO2              PUPMODE
#full install, flash drive: tmpfs         PDEV1                            3
#First boot (or pfix=ram):  tmpfs                         pup_xxx.sfs      5
#pup_save is a partition:   PDEV1                         pup_xxx.sfs      6
#ditto, but flash drive:    tmpfs         PDEV1           pup_xxx.sfs      7
#Normal running puppy:      pupsave.3fs                   pup_xxx.sfs      12
#ditto, but flash drive:    tmpfs         pupsave.3fs     pup_xxx.sfs      13
#Multisession cd/dvd:       tmpfs         folders(tmpfs2) pup_xxx.sfs      77
CREATETMPFS="";CREATEPDEV1="";CREATEPUPXXXSFS="";CREATEPUPSAVE2FS="";CREATEFOLDERS=""
case $PUPMODE in #w003 changed some save-layer to 'ro+wh' so that whiteouts files are recognised...
 2)  CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="/pup_ro1"
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="$CREATEPUPXXXSFS"
     CREATETMPFS="$CREATETMPFS";
     OLDFILESMNTPT="/pup_ro1";
     NEWFILESMNTPT="/pup_ro1";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_ro1=ro+wh"
     # new
     UMNTRO0="/pup_ro1=ro+wh:"
     # risky
     UPUP_SAVE="/pup_ro1=ro+wh"
     ;;
 3)  CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="/pup_ro1"
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="$CREATEPUPXXXSFS"
     CREATETMPFS="/pup_rw";
     OLDFILESMNTPT="/pup_ro1";
     NEWFILESMNTPT="/pup_ro1";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro1=ro+wh"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO0="/pup_ro1=ro+wh:"
     # risky
     UL_SAVE="/pup_ro1=ro+wh"
     UL_RW="/pup_rw=rw"
     ;;
 5)  CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="$CREATEPDEV1"
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="/pup_rw";
     OLDFILESMNTPT="";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_RW="/pup_rw=rw"
     ;;
 6)  CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="/pup_rw";
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="$CREATETMPFS";
     OLDFILESMNTPT="/pup_rw";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_RW="/pup_rw=rw"
     ;;
 7)  CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="/pup_ro1";
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="/pup_rw";
     OLDFILESMNTPT="/pup_ro1";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro1=ro+wh:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO0="/pup_ro1=ro+wh:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_SAVE="/pup_ro1=ro+wh"
     UL_RW="/pup_rw=rw"
     ;;
 12) CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="$CREATEPDEV1"
     CREATEPUPSAVE2FS="/pup_rw";
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="$CREATETMPFS";
     OLDFILESMNTPT="/pup_rw";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_RW="/pup_rw=rw"
     ;;
 13) CREATEFOLDERS="$CREATEFOLDERS"
     CREATEPDEV1="$CREATEPDEV1"
     CREATEPUPSAVE2FS="/pup_ro1";
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="/pup_rw";
     OLDFILESMNTPT="/pup_ro1";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro1=ro+wh:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO0="/pup_ro1=ro+wh:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_SAVE="/pup_ro1=ro+wh"
     UL_RW="/pup_rw=rw"
     ;;
 77) CREATEFOLDERS="/pup_ro1";
     CREATEPDEV1="$CREATEPDEV1"
     CREATEPUPSAVE2FS="$CREATEPUPSAVE2FS"
     CREATEPUPXXXSFS="/pup_ro2"
     CREATETMPFS="/pup_rw";
     OLDFILESMNTPT="/pup_ro1";
     NEWFILESMNTPT="/pup_ro2";
     #unionlayer /mountpoint=mountoptions
     # traditional
     UMNTMAIN="/pup_rw=rw:/pup_ro1=ro+wh:/pup_ro2=ro"
     # new
     UMNTRW="/pup_rw=rw:";
     UMNTRO0="/pup_ro1=ro+wh:";
     UMNTRO1="/pup_ro2=ro"
     # risky
     UL_SFS="/pup_ro2=ro"
     UL_SAVE="/pup_ro1=ro+wh"
     UL_RW="/pup_rw=rw"
     ;;
 *)  RDSH="yes";; #precaution.
esac

if [ "$CREATEPDEV1" != "" ];then
 [ "$DEV1FS" = "ext2" -o "$DEV1FS" = "ext3" -o "$DEV1FS" = "ext4" ] && echo "/dev/$PDEV1 $CREATEPDEV1 $DEV1FS defaults  1 1" >> /etc/fstab #v2.21 #2010-03 TazOC
 mount -t $DEV1FS /dev/$PDEV1 $CREATEPDEV1
 count_status $? mount PDEV1 CREATEPDEV1
 #save is not a ${DISTRO_FILE_PREFIX}save file, but a partition on a unionfs layer...
 if [ "$CREATEPDEV1" = "/pup_rw" -o "$CREATEPDEV1" = "/pup_ro1" ];then #v2.20b
  SMNTPT="$CREATEPDEV1"
  PUPSAVE="$PDEV1,$DEV1FS,/" #deliberately left last param as only /.
 fi
fi

if [ "$CREATEPUPSAVE2FS" != "" ];then
 PUPSAVEDEV="`echo -n "$PUPSAVE" | cut -f 1 -d ','`"
 PUPSAVEHOSTFS="`echo -n "$PUPSAVE" | cut -f 2 -d ','`" #2010-03 TazOC
 PUPSAVEFILE="`echo -n "$PUPSAVE" | cut -f 3 -d ','`"

 PUPSAVEFS="`echo $PUPSAVE | cut -f 3 -d ',' | cut -f 2- -d '.'`" #TazOC
 # TazOC precaution, in case name has >1 '.' e.g. spupsave.name.3fs
 while [ "`echo $PUPSAVEFS | grep '\.'`" ]; do
  PUPSAVEFS="`echo $PUPSAVEFS | cut -f 2- -d '.'`"
 done
 case $PUPSAVEFS in #TazOC support .2fs, .3fs, .4fs
  2fs)  PUPSAVEFS="ext2";;
  3fs)  PUPSAVEFS="ext3";;
  4fs)  PUPSAVEFS="ext4";;
 esac

 #normal ${DISTRO_FILE_PREFIX}save.2fs file. just mount it from where it is...
 echo -n "Loading personal file $PUPSAVEFILE ($PUPSAVEDEV)..." > /dev/console
 [ "$PUPSAVEHOSTFS" = "ext2" -o "$PUPSAVEHOSTFS" = "ext3" -o "$PUPSAVEHOSTFS" = "ext4" ] && echo "/dev/$PUPSAVEDEV /mnt/dev_save $PUPSAVEHOSTFS defaults  1 1" >> /etc/fstab #v2.21 #2010-03 TazOC
 #[ "$PUPSAVEHOSTFS" = "ext2" -o "$PUPSAVEHOSTFS" = "ext3" ] && fsck_func $PUPSAVEDEV $PUPSAVEHOSTFS #v3.01 # TazOC did this already ~line 457
 mnt_func $PUPSAVEHOSTFS /dev/$PUPSAVEDEV /mnt/dev_save noatime #2010-03 TazOC
 if [ $? -eq 0 ];then
  SMNTPT="/mnt/dev_save"
  #is the ${DISTRO_FILE_PREFIX}save encrypted?...
  if [ ! "`echo "$PUPSAVEFILE" | grep '_crypt'`" = "" ];then
   case $PUPSAVEFILE in
    *cryptx*) #see /etc/rc.d/rc.shutdown.
     CRYPTO='-E 1' #v2.16final '-e xor' --bug, loads xor.ko which is something else.
     #grep $Q cryptoloop /proc/crypto || modprobe cryptoloop
      if [ "`modinfo cryptoloop`" ]; then
       modprobe cryptoloop
      else
       echo "cryptoloop kernel module driver not found"
       echo "Going on and hoping for the best..."
       true # fake return value to get Puppy going - maybe compiled into the kernel..?
      fi
     ;;
    *)
     CRYPTO='-e aes'

     #modprobe cryptoloop
     #modprobe aes_generic #v407 aes name change.
     #modprobe aes         #for older kernel <2.6.25
     #modprobe crypto_blkcipher #v407 blkcipher name change.
     #modprobe blkcipher        #old kernel.
     #modprobe cbc

     for m in cryptoloop aes_generic aes crypto_blkcipher blkcipher cbc
     do
     #grep $Q "$m" /proc/crypto || modprobe $m
      mods=`find /lib/modules -name "${m}.ko*"`
      all_mods="${all_mods}$m='${mods}' "
      cm=$((cm+1))
     done
     for n in $all_mods; do
      case $n in
       *=\'\') not=$((not+1));;
       *) module=${n%%=*}
         modprobe $module
       ;;
      esac
     done
      if test $not = $cm; then
       echo "No crypt modules could be found in initrd."
       echo "Going on and hoping for the best..."
       true # fake return value to get Puppy going - maybe compiled into the kernel..?
      else
       true # fake return value to get Puppy going if not all were found....
      fi
      unset cm not m mods all_mods n
     ;;
   esac
  else true
  fi
  count_status $? crypt driver
  if [ "$CRYPTO" != "" ] ; then
   echo "" >/dev/console
   echo "Mounting encrypted $PUPSAVEFILE..." > /dev/console
   while true; do

    #v3.01 will take this out as a func later (similar code below)...
    #about to mount ${DISTRO_FILE_PREFIX}save.2fs, but before that check if need to resize it...
    if [ -f /mnt/dev_save/pupsaveresize.txt ];then #created by /usr/sbin/resizepfile.sh
     KILOBIG=`cat /mnt/dev_save/pupsaveresize.txt`
     rm -f /mnt/dev_save/pupsaveresize.txt
     echo > /dev/console
     echo -n "Increasing $PUPSAVEFILE by $KILOBIG Kbytes, please wait..." >/dev/console
     dd if=/dev/zero bs=1024 count=$KILOBIG >> /mnt/dev_save$PUPSAVEFILE
     count_status $? dd
     sync
     if [ "$CRYPTO" = "-e aes" ];then #v3.98
      echo "NOTICE: As you type your password nothing will be displayed on the" >/dev/console
      echo "screen for absolute security. Just type it in then press ENTER key..." >/dev/console
      echo -e "\\033[1;36m" >/dev/console #aqua-blue
      echo -n "Password: " >/dev/console
      echo -en "\\033[0;39m" >/dev/console
      read -s MYPASS #< /dev/console v403
      echo "$MYPASS" | losetup -p 0 -e aes /dev/loop1 /mnt/dev_save$PUPSAVEFILE
     else
      echo -e "\\033[1;36m" >/dev/console #aqua-blue
      echo -n "Password: " >/dev/console
      echo -en "\\033[0;39m" >/dev/console
      #losetup does not accept -p param for xor encryption... may not work...
      losetup $CRYPTO /dev/loop1 /mnt/dev_save$PUPSAVEFILE
     fi
     count_status $? losetup crypt
     e2fsck -y -f /dev/loop1 >>/tmp/chkret
     count_status $? fsck
     resize2fs -pf /dev/loop1 #no size, will fill all of file.
     count_status $? reszize
     sync
     #check_status 0 #note, e2fsck gives an error even though it works. v2.21 maybe okay now.
     echo -n "...continuing with loading $PUPSAVEFILE..." > /dev/console
    else
     echo -e "\\033[1;36m" >/dev/console #aqua-blue
     echo -n "Password: " >/dev/console
     echo -en "\\033[0;39m" >/dev/console
     if [ "$CRYPTO" = "-e aes" ];then #v3.98
      read -s MYPASS #< /dev/console v403
      echo "$MYPASS" | losetup -p 0 -e aes /dev/loop1 /mnt/dev_save$PUPSAVEFILE
     else
      #losetup does not accept -p param for xor encryption... may not work...
      losetup $CRYPTO /dev/loop1 /mnt/dev_save$PUPSAVEFILE
     fi
     count_status $? losetup crypt 2
    fi

    echo "/dev/loop1 $CREATEPUPSAVE2FS $PUPSAVEFS defaults  1 1" >> /etc/fstab #v2.21 # TazOC replaced ext2 with $PUPSAVEFS
    #fsck_func loop1 ext2 $PUPSAVEFILE #v3.01. no, removed, takes ages, and won't mount afterward.
    mount -t $PUPSAVEFS -o noatime,rw /dev/loop1 $CREATEPUPSAVE2FS # TazOC replaced ext2 with $PUPSAVEFS
    MNTSTAT=$?; count_status $MNTSTAT mount loop1
    if [ "$MNTSTAT" = "0" ] ; then
     echo -n "...successfully mounted" >/dev/console
     break
    else
     echo -en "\\033[1;31m" >/dev/console #31=red
     echo "Can't mount file, press ENTER key to try again, or" >/dev/console
     echo "any other char then ENTER for f.s. check then try again, or " > /dev/console
     echo -n "for developers type 'quit' to drop out to console: " > /dev/console
     echo -en "\\033[0;39m" >/dev/console
     read crypttryagain
     echo > /dev/console
     [ "$crypttryagain" = "quit" ] &&  exec /bin/sh >/dev/console 2>&1 #v3.98
     [ "$crypttryagain" != "" ] && { e2fsck -y -f /dev/loop1 >/dev/console; count_status $?; }
     losetup -d /dev/loop1
     count_status $? losetup -d loop1
    fi
   done
  else
   #about to mount ${DISTRO_FILE_PREFIX}save.2fs, but before that check if need to resize it...
   if [ -f /mnt/dev_save/pupsaveresize.txt ];then #created by /usr/sbin/resizepfile.sh
    KILOBIG=`cat /mnt/dev_save/pupsaveresize.txt`
    rm -f /mnt/dev_save/pupsaveresize.txt
    echo > /dev/console
    echo -n "Increasing $PUPSAVEFILE by $KILOBIG Kbytes, please wait..." >/dev/console
    dd if=/dev/zero bs=1024 count=$KILOBIG >> /mnt/dev_save$PUPSAVEFILE
    count_status $? dd
    sync
    e2fsck -y -f /mnt/dev_save$PUPSAVEFILE >>/tmp/chkret
    count_status $? fsck
    resize2fs -pf /mnt/dev_save$PUPSAVEFILE >>/tmp/chkret #no size, will fill all of file.
    count_status $? resize
    sync
    check_status $STATUS #0 #note, e2fsck gives an error even though it works. v2.21 maybe okay now.
    echo -n "...continuing with loading $PUPSAVEFILE..." > /dev/console
   fi
   losetup /dev/loop1 /mnt/dev_save${PUPSAVEFILE}
   count_status $? losetup loop1 PUPSAVEFILE
   echo "/dev/loop1 $CREATEPUPSAVE2FS $PUPSAVEFS defaults  1 1" >> /etc/fstab #v2.21 # TazOC replaced ext2 with $PUPSAVEFS
   fsck_func loop1 $PUPSAVEFS $PUPSAVEFILE #v3.01 # TazOC replaced ext2 with $PUPSAVEFS
   mount -t $PUPSAVEFS -o noatime /dev/loop1 $CREATEPUPSAVE2FS # TazOC replaced ext2 with $PUPSAVEFS
   if [ $? -ne 0 ];then
    e2fsck -y -f /dev/loop1 > /dev/console #-y answer yes to all repair questions.
    count_status $?
    resize2fs -pf /dev/loop1 >>/tmp/chkret # TazOC
    count_status $?
    mount -t $PUPSAVEFS -o noatime /dev/loop1 $CREATEPUPSAVE2FS # TazOC replaced ext2 with $PUPSAVEFS
   else true
   fi
   count_status $? mount loop1 CREATEPUPSAVE2FS
  fi
 fi
 count_status $? mount PUPSAVEDEV dev_save
 check_status $STATUS
fi

#there are technical problems with loading a swap partition/file before the union
#is created, so not doing it until rc.sysinit runs. however, if a tmpfs needs to be
#created here, set it's size in anticipation of a swap being loaded...
EXTRAALLOCK=0 ; PSWAPFILE=""
SWAPPART="`echo "$PCPARTSALL" | grep '|swap|' | head -n 1`"
[ "$SWAPPART" != "" ] && SWAPPARTSIZE=`echo -n "$SWAPPART" | cut -f 3 -d '|'`
#[ $SWAPPARTSIZE ] && EXTRAALLOCK=`expr $SWAPPARTSIZE \/ 2`
[ $SWAPPARTSIZE ] && EXTRAALLOCK=$((SWAPPARTSIZE/2))
if [ "$PDEV1" != "" -a $EXTRAALLOCK -eq 0 ];then
 APATTERN="^${PDEV1} "
 SWAPFILE="`grep "$APATTERN" /tmp/PUPPYFILES | tr ' ' '\n' | grep 'pupswap.swp' | head -n 1`"
 [ "$SWAPFILE" != "" ] && [ -f ${SMNTPT}${SWAPFILE} ] && SWAPFILESIZEBYTES=`stat -c %s ${SMNTPT}${SWAPFILE}`
 if [ $SWAPFILESIZEBYTES ];then
  #SWAPFILESIZE=`expr $SWAPFILESIZEBYTES \/ 2048` #use half.
  SWAPFILESIZE=$((SWAPFILESIZEBYTES/2048))
  #EXTRAALLOCK=`expr $EXTRAALLOCK + $SWAPFILESIZE`
  EXTRAALLOCK=$((EXTRAALLOCK + SWAPFILESIZE))
  PSWAPFILE="$PDEV1,$DEV1FS,$SWAPFILE"
 fi
fi

FREEK=0
if [ "$CREATETMPFS" != "" ];then
 #FREEK=`expr $RAMSIZE \/ 2` #half of physical.
 FREEK=$((RAMSIZE / 2)) #half of physical.
 #[ $PUPMODE -eq 77 ] && FREEK=`expr $FREEK - 50000` #need some slack.
 [ $PUPMODE -eq 77 ] && FREEK=$((FREEK - 50000)) #need some slack.
 #ALLOCK=`expr $FREEK + $EXTRAALLOCK`
 ALLOCK=$((FREEK + EXTRAALLOCK))
 mount -t tmpfs -o size=${ALLOCK}k pupramtmpfs $CREATETMPFS
else true
fi
count_status $? CREATETMPFS
#RW (top) layer now has a tmpfs, PDEV1 or ${DISTRO_FILE_PREFIX}save mounted on it. calc free space...
[ $FREEK -eq 0 ] && FREEK=`df | grep ' /pup_rw' | tr -s ' ' | cut -f 4 -d ' '`
[ ! $FREEK ] && FREEK=0

if [ "$CREATEFOLDERS" != "" ];then
 PUPSAVEDEV="`echo -n "$PUPSAVE" | cut -f 1 -d ','`"
 PUPSAVEHOSTFS="`echo -n "$PUPSAVE" | cut -f 2 -d ','`" #2010-03 TazOC
 PUPSAVEFILE="`echo -n "$PUPSAVE" | cut -f 3 -d ','`"
 mount -o noatime -t $PUPSAVEHOSTFS /dev/$PUPSAVEDEV /mnt/dev_ro1 #mnt the cd. #2010-03 TazOC
 count_status $?
 #create a tmpfs to load the folders...
 #ALLOCK=`expr $RAMSIZE \/ 2 - 50000` #allocate half of physical ram. + leave 50M slack.
 ALLOCK=$(((RAMSIZE / 2) - 50000)) #allocate half of physical ram. + leave 50M slack.
 mount -t tmpfs -o size=${ALLOCK}k pup77tmpfs $CREATEFOLDERS #/pup_ro1
 count_status $?
 #load the folders from the cd...
  ####START LOAD FOLDERS####
  CDMNTPT="/mnt/dev_ro1" #where the multisession cd is mounted.
  DESTDIR="$CREATEFOLDERS" #dest dir has a tmpfs mntd on it, into which to copy folders.
  BKFOLDERS="`ls -1 -r $CDMNTPT | grep '^20[0-9][0-9]'`"
  BKLASTFOLDER="`echo "$BKFOLDERS" | head -n 1`"
  #a boot option allows ignore last n sessions, also need to create a badlist...
  if [ "$PIGNORELAST" ];then
   BKBADLIST="`echo "$BKFOLDERS" | head -n ${PIGNORELAST}`"
   if [ -f $CDMNTPT/$BKLASTFOLDER/.badfolders ];then
    cp $CDMNTPT/$BKLASTFOLDER/.badfolders $DESTDIR/
    if [ ! $? -eq 0 ];then
     #fallback, in case last folder badly corrupted...
     BKPREVFOLDER="`echo "$BKFOLDERS" | head -n 2 | tail -n 1`"
     [ -f $CDMNTPT/$BKPREVFOLDER/.badfolders ] && cp $CDMNTPT/$BKPREVFOLDER/.badfolders $DESTDIR/
    fi
   fi
   echo "$BKBADLIST" >> $DESTDIR/.badfolders
   #note, rc.shutdown and savesession-dvd 'touch' this file so it will get saved.
   sync
  else
   [ -f $CDMNTPT/$BKLASTFOLDER/.badfolders ] && cp $CDMNTPT/$BKLASTFOLDER/.badfolders $DESTDIR/
  fi
  [ -f $DESTDIR/.badfolders ] && BKBADLIST="`cat $DESTDIR/.badfolders | tr "\n" " "`"
  BKFOLDERS="`echo -n "$BKFOLDERS" | tr "\n" " "`"
  for ONEFOLDER in $BKFOLDERS
  do
   if [ ! "`echo -n "$BKBADLIST" | grep "$ONEFOLDER"`" = "" ];then
    echo "Folder $ONEFOLDER marked bad." >/dev/console
    continue #ignore bad folder.
   fi
   echo -n "Loading folder $ONEFOLDER from CD/DVD..." >/dev/console
   #need to be careful not to overfill the ramdisk...
   FREERAMDISK=`df 2>/dev/null | grep "$DESTDIR" | head -n 1 | tr -s " " | cut -f 4 -d " "`
   SIZEFOLDER=`du -k -s ${CDMNTPT}/${ONEFOLDER} | cut -f 1`
   if [ -d ${CDMNTPT}/${ONEFOLDER}/archive ];then
    SIZEARCHIVE=`du -k -s ${CDMNTPT}/${ONEFOLDER}/archive | cut -f 1`
   else
    SIZEARCHIVE=0
   fi
   #SIZESOURCE=`expr $SIZEFOLDER - $SIZEARCHIVE`
    SIZESOURCE=$((SIZEFOLDER - SIZEARCHIVE))
   if [ $FREERAMDISK -gt $SIZESOURCE ];then
    #well, -u will only copy if files newer, so less stuff may get copied than calc'd above.
    #need to copy everything except archive folder...
    [ -d $CDMNTPT/$ONEFOLDER/bin ]  && cp -a -u $CDMNTPT/$ONEFOLDER/bin $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/sbin ] && cp -a -u $CDMNTPT/$ONEFOLDER/sbin $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/etc ]  && cp -a -u $CDMNTPT/$ONEFOLDER/etc $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/lib ]  && cp -a -u $CDMNTPT/$ONEFOLDER/lib $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/opt ]  && cp -a -u $CDMNTPT/$ONEFOLDER/opt $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/root ] && cp -a -u $CDMNTPT/$ONEFOLDER/root $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/usr ]  && cp -a -u $CDMNTPT/$ONEFOLDER/usr $DESTDIR/
    [ -d $CDMNTPT/$ONEFOLDER/dev ]  && cp -a -u $CDMNTPT/$ONEFOLDER/dev $DESTDIR/   #v411
    cp -a -u $CDMNTPT/$ONEFOLDER/*.sfs $DESTDIR/   #v3.97
    #delete deleted files (.wh.filename)...
    WHITEOUTS="`find $DESTDIR/ -xdev -type f -name .wh.* | grep -v '__dir_opaque'`"
    echo "$WHITEOUTS" |
    while read DELWHITE
    do
     DELFILE="`echo -n "$DELWHITE" | sed -e 's/\\.wh\\.//g'`"
     if [ -e "$DELFILE" ];then
      rm -rf "$DELFILE"
      rm -rf "$DELWHITE"
     fi
    done
    count_status $?
    check_status $STATUS #0 #display 'done' for each folder loaded.
   else
    echo -e "\\033[70G\\033[1;31mRAM full\\033[0;39m" >/dev/console #red text on column 70.
    break
   fi
  done
  sync
  ####END LOAD FOLDERS####
 umount /mnt/dev_ro1 #unmount the cd.
 count_status $?
fi #CREATEFOLDERS

OLDDISTRO_VERSION=$DISTRO_VERSION
[ -f $OLDFILESMNTPT/etc/puppyversion ] && OLDDISTRO_VERSION=`cat $OLDFILESMNTPT/etc/puppyversion` #old pre-w464 installation.
[ -f $OLDFILESMNTPT/etc/DISTRO_SPECS ] && OLDDISTRO_VERSION=`grep '^DISTRO_VERSION' $OLDFILESMNTPT/etc/DISTRO_SPECS | cut -f 2 -d '=' | cut -f 1 -d ' '` #w012 w478

#move modules to main f.s...
#(do this before loading ${DISTRO_FILE_PREFIX}rxxx.sfs, to free up ram space)...
REASON=''
if [ "$ZDRVINIT" = "yes" ];then
 #the entire kitchen sink of modules is in the initrd.
 ZDRV='' #/sbin/modprobe needs this.
 [ $DISTRO_VERSION -gt $OLDDISTRO_VERSION ] && REASON='upgrade'
 [ $PUPMODE -eq 5 ] && REASON='firstboot'
 #what if deleted modules due to lack space in ${DISTRO_FILE_PREFIX}save, but now more free space?... v4.01...
 [ ! -d /pup_rw/lib/modules/all-firmware ] && [ ! -d /pup_ro1/lib/modules/all-firmware ] && [ $FREEK -gt 24000 ] && REASON='restore'
 if [ "$REASON" != "" ];then
  [ -d /pup_rw/lib/modules ] && rm -rf /pup_rw/lib/modules
  [ -d /pup_ro1/lib/modules ] && rm -rf /pup_ro1/lib/modules
  mkdir -p /pup_rw/lib
  mv /lib/modules /pup_rw/lib/
  mkdir -p /pup_rw/initrd
  mount -t ramfs initrdramfs /pup_rw/initrd
  cp -af /DISTRO_SPECS /pup_rw/initrd/
  cp -af /init /pup_rw/initrd/
  sync
 fi
else
 #the initrd does have some modules, move them to the main layered f.s...
 #v4.02 moved this up. had it down after the the unionfs setup (just want it same place as the above code).
 [ ! -d /pup_rw/lib/modules/$KERNELVER/initrd ] && [ ! -d /pup_ro1/lib/modules/$KERNELVER/initrd ] && REASON="new"
 if [ "$REASON" != "" ];then
  mkdir -p /pup_rw/lib/modules/$KERNELVER #PUPMODE=5, this dir not exist.
  mv /lib/modules/$KERNELVER /pup_rw/lib/modules/$KERNELVER/initrd
  rm -f /pup_rw/lib/modules/$KERNELVER/initrd/modules.* && sync
  #note: /etc/rc.d/rc.sysinit will detect them and run depmod.
 else true
 fi
 #v3.91 a humongous initrd may have zdrv file...
 #( [ -f /${ZDRVSFS} ] && [ ! -f /pup_rw/${ZDRVSFS} ] && [ ! -f /pup_ro1/${ZDRVSFS} ] ) && { cp -a /${ZDRVSFS} /pup_rw/ || false; } || true
 if [ -f /${ZDRVSFS} ] && [ ! -f /pup_rw/${ZDRVSFS} ] && [ ! -f /pup_ro1/${ZDRVSFS} ]; then
  cp -a /${ZDRVSFS} /pup_rw/
 else true
 fi
fi
count_status $? ZDRVINIT
#v405 decide whether to copy sfs's to ram...
COPY2RAM=""
COPYMSG='copying to ram' #purple
#v4.00 lowered rom 230000 to 220000... v403 added PUPSFSDEVMNTPT test... v404 explicit PCOPY needed...
[ $PUPMODE -eq 5 ]  && PCOPY="yes" #well, override on first boot.
[ $PUPMODE -eq 77 ] && PCOPY="yes" #v406 multisession dvd.
#v404 absolutely must copy to ram, otherwise layerfs conflict...
[ $PUPMODE -eq 6 -o $PUPMODE -eq 7 ] && COPY2RAM="yes"
[ "$COPY2RAM" = "yes" ] && COPYMSG='forced copying to ram' #purple
#w482 lower this again, so multiession will work in 256MB system...
#[ $RAMSIZE -gt 260000 -a "$PCOPY" = "yes" ] && COPY2RAM="yes" #256MB system. note, only checking physical ram. w003 incr. from 220000.
#13 Feb 09 TazOC do this further down, checking whether LHP's larger main file will fit in RAM:
#[ $RAMSIZE -gt 220000 -a "$PCOPY" = "yes" ] && COPY2RAM="yes" #256MB system. note, only checking physical ram.

if [ "$CREATEPUPXXXSFS" != "" ];then
 #load ${DISTRO_FILE_PREFIX}-xxx.sfs...
 PUPSFSDEV="`echo -n "$PUPSFS" | cut -f 1 -d ','`"
 PUPSFSFS="`echo -n "$PUPSFS" | cut -f 2 -d ','`"
 PUPSFSFILE="`echo -n "$PUPSFS" | cut -f 3 -d ','`"
 basepupsfs="`basename $PUPSFSFILE`"

 #v406 copy ${DISTRO_FILE_PREFIX}rxxx.sfs to same place as ${DISTRO_FILE_PREFIX}save if fast-partition (in case not already)...
 COPYPUPSFS2DIR=""
 if [ "$CREATEPUPSAVE2FS" != "" ];then
  if [ -f /mnt/dev_save$PUPSAVEFILE ];then
   dirsavefile="`dirname $PUPSAVEFILE`"
   fPATTERN='^'"$PUPSAVEDEV"'|'
   if [ "`echo -n "$FASTPARTS0" | grep "$fPATTERN"`" != "" ];then
    #the ${DISTRO_FILE_PREFIX}save is on a fast media.
    if [ ! -f /mnt/dev_save${dirsavefile}/${basepupsfs} ];then
     COPYPUPSFS2DIR="/mnt/dev_save${dirsavefile}"
    fi
   fi
  fi
 fi

 echo -n "Loading the '${basepupsfs}' main file..." > /dev/console
 if [ "$PUPSFSDEV" = "rootfs" ];then #humongous initrd.
  PUPSFSDEVMNTPT="" #actually it's '/'.
 else
  PPATTERN="/dev/$PUPSFSDEV "
  PUPSFSDEVMNTPT="`mount | grep "$PPATTERN" | cut -f 3 -d ' '`"
  if [ "$PUPSFSDEVMNTPT" = "" ];then
   PUPSFSDEVMNTPT="/mnt/dev_sfs"
   #mnt_func $PUPSFSFS /dev/$PUPSFSDEV /mnt/dev_ro2 #-t $PUPSFSFS /dev/$PUPSFSDEV /mnt/dev_ro2
    mnt_func $PUPSFSFS /dev/$PUPSFSDEV $PUPSFSDEVMNTPT
   #PUPSFSDEVMNTPT="/mnt/dev_ro2"
   #UMOUNTME="/mnt/dev_ro2" #mark for unmounting.
   #UMOUNTME="$PUPSFSDEVMNTPT"
  else true
  fi
  count_status $? mount dev_save
  if [ "$COPYPUPSFS2DIR" ];then #v406 copy ${DISTRO_FILE_PREFIX}-xxx.sfs to same place as ${DISTRO_FILE_PREFIX}save...
   echo -e -n " \\033[1;35mcopying to ${PUPSAVEDEV}\\033[0;39m" > /dev/console #purple.
   cp -f ${PUPSFSDEVMNTPT}${PUPSFSFILE} ${COPYPUPSFS2DIR}/
   if [ $? -eq 0 ];then
    sync
    PUPSFSDEVMNTPT="$COPYPUPSFS2DIR"
    PUPSFS="${PUPSAVEDEV},${PUPSAVEHOSTFS},${PUPSFSFILE}" #2010-03 TazOC
    PUPSFSDEV="$PUPSAVEDEV"
    PUPSFSFS="$PUPSAVEHOSTFS" #2010-03 TazOC
   fi
   count_status $? copy pupsfs
  fi

 fi
 #12 Feb09 TazOC see note above and test whether a larger pup_xxx.sfs will fit in RAM
 #if there's heaps of ram, copy pup_xxx.sfs to a tmpfs...
 #[ "$PUPSFSDEVMNTPT" = "" ] && COPY2RAM="yes"
 #v405 fast media plus more than 256MB ram then definitely worth copying to ram...
 #[ "`echo -n "$FASTPARTS0" | grep "$PUPSFSDEV"`" != "" ] && [ $RAMSIZE -gt 280000 ] && COPY2RAM="yes" # TazOC 30 May09 moved this further down
 #12 Feb09 TazOC see note above
 SIZESFSK=`du -k ${PUPSFSDEVMNTPT}${PUPSFSFILE} | cut -f 1`
 SIZESFSK=`expr $SIZESFSK + 2000` # some slack space
 SIZESFSK=$((SIZESFSK + 2000)) #some slack.
 if [ "$SWAPPART" != "" ];then
   echo -n "  found swap..." >/dev/console
 #  SIZECOPYK=`expr $SIZESFSK + 12000` # some slack space, maybe zdrv etc.
   #SIZECOPYK=`expr $SIZESFSK + 4000` # TazOC lowered for 256M machines
    SIZECOPYK=$((SIZESFSK + 4000)) # TazOC lowered for 256M machines
 else
   echo -e "  ${cyan}swap not found${NC}" >/dev/console
   echo -en " ${cyan}Tip: You can create a ${bg_cyan}${white}linux-swap${NC}${cyan} partition with the utility GParted.${NC}" >/dev/console
   sleep 1
#   SIZECOPYK=`expr $SIZESFSK + 94000` # no swap, need more room for zdrv, X, WM etc.
   #SIZECOPYK=`expr $SIZESFSK + 82000` # TazOC lowered for 256M machines
   SIZECOPYK=$((SIZESFSK + 82000)) # TazOC lowered for 256M machines
 fi
 if [ "$PCOPY" = "yes" ] || [ "$COPY2RAM" = "yes" ] || [ "`echo -n "$FASTPARTS0" | grep "$PUPSFSDEV"`" != "" ];then # TazOC 30 May09 display sizes to compare
  echo "" >/dev/console
  echo -n " Size to copy: `expr $SIZECOPYK \/ 1024`M" >/dev/console
  echo -n " free RAM: `expr $RAMSIZE \/ 1024`M..." >/dev/console
 fi
 # TazOC 30 May09 If enough RAM and PCOPY, or enough RAM and fast media, then copy
 [ $RAMSIZE -gt $SIZECOPYK -a "$PCOPY" = "yes" ] || [ $RAMSIZE -gt $SIZECOPYK -a  "`echo -n "$FASTPARTS0" | grep "$PUPSFSDEV"`" != "" ] && COPY2RAM="yes"

 if [ "$COPY2RAM" = "yes" ];then
  SIZESFSK=`du -k ${PUPSFSDEVMNTPT}${PUPSFSFILE} | cut -f 1`
  SIZESFSK=`expr $SIZESFSK + 1000` #some slack.
  SIZESFSK=$((SIZESFSK + 1000)) #some slack.
  mount -t tmpfs -o size=${SIZESFSK}k pupsfstmpfs /mnt/tmpfs
  count_status $? mount pupsfstmpfs
  if [ "${PUPSFSDEVMNTPT}" = "" ];then #v403 humongous initrd.
    mv -f ${PUPSFSDEVMNTPT}${PUPSFSFILE} /mnt/tmpfs/
  else
   echo -e -n " \\033[1;35m${COPYMSG}\\033[0;39m" > /dev/console #purple.
   cp -af ${PUPSFSDEVMNTPT}${PUPSFSFILE} /mnt/tmpfs/ &
   # TazOC 1 June09 progress dots
   while [ "`pidof cp`" != "" ]; do sleep 2; echo -n "." >/dev/console; done
   true
  fi
  count_status $? copymessage
  sync
  SFSBASENAME="`basename $PUPSFSFILE`"
  losetup /dev/loop0 /mnt/tmpfs/${SFSBASENAME}
  count_status $?
  UMOUNTME="$PUPSFSDEVMNTPT"
#  [ "$UMOUNTME" != "" ] && umnt_func $UMOUNTME
 else
  losetup /dev/loop0 ${PUPSFSDEVMNTPT}${PUPSFSFILE}
  count_status $? losetup lo0
 fi
 mount -r -t squashfs -o noatime /dev/loop0 $CREATEPUPXXXSFS #usually /pup_ro2.
 #count_status $? mount lo0
 RV=$?
 [ $RV = 0 ] || unset UMOUNTME
 count_status $RV
fi

ZLAYER='' #v4.02
ZFACTOR='' #v426
#note, traditionally, loop2 kept free for scripts to use.
if [ "$ZDRVINIT" != "yes" ];then
 #v4.02 if ZDRV located, and mounted, put it into the unionfs...
 if [ "$ZDRV" != "" ];then
  ZDEV="`echo "$ZDRV" | cut -f 1 -d ','`"
  ZFS="`echo "$ZDRV" | cut -f 2 -d ','`"
  ZFILE="`echo "$ZDRV" | cut -f 3 -d ','`"
  MNT_ZFILE=""
  [ -f /mnt/dev_save${ZFILE} ] && MNT_ZFILE="dev_save"
  [ "$MNT_ZFILE" = "" ] && [ -f /mnt/dev_ro2${ZFILE} ] && MNT_ZFILE="dev_ro2"
  ZBASENAME="`basename $ZFILE`" #v426 moved up.
  if [ "$MNT_ZFILE" != "" ];then
   #w020 do not ever copy it to ram... w460 restore choice...
   if [ "$COPY2RAM" = "yes" ];then #256MB system. note, only checking physical ram.
    SIZEZK=`du -k /mnt/${MNT_ZFILE}${ZFILE} | cut -f 1`
    SIZEZK=`expr $SIZEZK + 1000` #some slack.
    SIZEZK=$((SIZEZK + 1000)) #some slack.
    mount -t tmpfs -o size=${SIZEZK}k pupzdrvtmpfs /mnt/tmpfs2
    count_status $?
    cp -af /mnt/${MNT_ZFILE}${ZFILE} /mnt/tmpfs2/
    count_status $?
    sync
    losetup /dev/loop3 /mnt/tmpfs2/${ZBASENAME}
    UMOUNTMEZ="$MNT_ZFILE"
   else
    losetup /dev/loop3 /mnt/${MNT_ZFILE}${ZFILE}
   fi
   count_status $?
   mount -r -t squashfs -o noatime /dev/loop3 /pup_z
   if [ $? -eq 0 ];then
    ZLAYER=':/pup_z=ro'
    UL_Z="/pup_z=ro"
    ZFACTOR="$ZBASENAME" #v426
   else
    unset UMOUNTMEZ
   fi
   count_status $?
  fi
 fi
fi


for oneUMOUNTME in "$UMOUNTMEZ" "$UMOUNTME"; do
test "$oneUMOUNTME" || continue
test "$oneUMOUNTME" = "/" && continue
test "$oneUMOUNTME" = "/mnt/dev_save" && continue #pupxxxsave-yyy.2fs partition
grep $Q " $oneUMOUNTME " /proc/mounts || continue
umnt_func $UMOUNTME
done

check_status $STATUS #$?
########################END LOADING PUPPY FILES########################


#/etc/PUPSTATE passes useful variables to the running puppy...
mkdir -p /pup_rw/etc/rc.d


rm -f /pup_rw/etc/rc.d/PUPSTATE
while :; do

 echo "PUPMODE=$PUPMODE"
 echo "PDEV1='$PDEV1'"
 echo "DEV1FS='$DEV1FS'"
 echo "PUPSFS='$PUPSFS'"
 echo "PUPSAVE='$PUPSAVE'"
 echo "PMEDIA='$PMEDIA'"
 if [ -e /proc/ide ];then
  echo "SATADRIVES='$ATADRIVES'"
 else
  echo '#v3.97: kernel with libata pata has both sata and pata drives in ATADRIVES...'
  echo "ATADRIVES='$ATADRIVES'"
 fi
 echo '#these directories are unionfs layers in /initrd...'
 echo "SAVE_LAYER='$OLDFILESMNTPT'"
 echo "PUP_LAYER='$NEWFILESMNTPT'"
 #if [ $SMNTPT ];then
  echo "#The partition that has the ${DISTRO_FILE_PREFIX}save file is mounted here..."
  echo "PUP_HOME='${SMNTPT}'"
  echo '#(in /initrd) ...note, /mnt/home is a link to it.'
 #fi
 echo '#this file has extra kernel drivers and firmware...'
 echo "ZDRV='$ZDRV'"  #v2.22
 echo '#complete set of modules in the initrd (moved to main f.s.)...'
 echo "ZDRVINIT='$ZDRVINIT'"  #v4.02
 echo "PSWAPFILE='$PSWAPFILE'"
 echo "PSAVEMARK='$PSAVEMARK'"

 #w481 record fast partititons, used by rc.shutdown...
 if [ "$FASTPARTS" = " " -o "$FASTPARTS" = "" ];then
  echo "FASTPARTS=''"
 else
  echo "FASTPARTS='$FASTPARTS'"
 fi

break
done >> /pup_rw/etc/rc.d/PUPSTATE 2>/dev/null

#older ${DISTRO_FILE_PREFIX}save.2fs <v2.16 will not have this file...
[ ! -f $OLDFILESMNTPT/etc/rc.d/BOOTCONFIG ] && touch $OLDFILESMNTPT/etc/rc.d/BOOTCONFIG
#note, OLDFILESMNTPT can also be "" so BOOTCONFIG needs to exist in initrd also.
. $OLDFILESMNTPT/etc/rc.d/BOOTCONFIG #can have EXTRASFSLIST variable.

######################SETUP UNIONFS LAYERED FILESYSTEM########################
echo -n "Setting up the layered filesystem..." > /dev/console #STEP FIVE
#are there any other sfs files to load at bottom layers?...
NEWUNIONRECORD=""
if [ "$PUPSAVE" != "" ];then
 if [ "$SMNTPT" != "" -o $PUPMODE -eq 77 ];then #v3.97
  SFSSDIR="$SMNTPT"
  [ $PUPMODE -eq 77 ] && SFSSDIR="$DESTDIR" #v3.97
  #find all the extra sfs files...
  touch /tmp/LOGONEBASES
  #v424 modified to only load selection made in BootManager...
  if [ "$EXTRASFSLIST" != "" ];then #in /etc/rc.d/BOOTCONFIG
   exPATTERN="^z|^pup_" #w478
   ls -1 $SFSSDIR/*.sfs |
   while read ONEEXTRA
   do
    #ONEBASE="`basename $ONEEXTRA`"
    ONEBASE="${ONEEXTRA##*/}"
    #exPATTERN="^z|^pup_" #w478
    [ "`echo "$ONEBASE" | grep -E "$exPATTERN"`" != "" ] && continue
    [ "`echo "$EXTRASFSLIST" | grep "$ONEBASE"`" != "" ] && echo "${ONEEXTRA}"
   done  >> /tmp/EXTRASFSS
  fi
  UMNTRO="" ; UL_ADD=""; EXTRASFSLIST=""
  if [ -f /tmp/EXTRASFSS ];then
   CNTLOOP=4
   echo >/dev/console;echo -en " ${green}Layering up to 40 SFS files from /mnt/home...${NC}" >/dev/console #TazOC
   for ONEEXTRA in `cat /tmp/EXTRASFSS`
   do
    #v423 need to reject wrong squashfs version... v424 no, don't bother...
    # TazOC yes, let's reject wrong squashfs version...
    [ "`disktype $ONEEXTRA | grep "$SFSSTR"`" = "" ] && continue
    #ONEBASE="`basename $ONEEXTRA`"
    ONEBASE="${ONEEXTRA##*/}"
    # TazOC - Barburo suggested to display when mounting extra SFS
    case $CNTLOOP in
    4|6|8|10|12|14|16|18|20|22|24|26|28|30|32|34|36|38|40|42)
     echo >/dev/console
    ;;
    esac

    echo -en "   ${dkgreen}`expr $CNTLOOP - 3` ${NC}${bg_green}${white} ${ONEBASE} ${NC}  " >/dev/console
    EXTRASFSLIST="${EXTRASFSLIST}${ONEBASE} " #construct list of actually used.
    losetup /dev/loop${CNTLOOP} $ONEEXTRA
    mount -r -t squashfs -o noatime /dev/loop${CNTLOOP} /pup_ro${CNTLOOP}
    [ $? -eq 0 ] && { UMNTRO="${UMNTRO}:/pup_ro${CNTLOOP}=ro"; UL_ADD="${UL_ADD}:/pup_ro${CNTLOOP}=ro"
    #CNTLOOP=`expr $CNTLOOP + 1`
    CNTLOOP=$((CNTLOOP + 1))
    } || losetup -d /dev/loop${CNTLOOP}
  #  [ $CNTLOOP -eq 10 ] && break
    [ $CNTLOOP -eq 44 ] && break # TazOC Supporting up to 40 extra SFS
    #...only support adding 3 extra .sfs files, as performance degrades as each layer added.
    #...v410 bugfix, change 6 to 7 so can have 3 sfs files.
    #...w015 change 7 to 10 so can have 6 sfs files.
   done
  fi
  #keep a record of different layer configurations...
  SAVEFILE="`echo -n "$PUPSAVE" | cut -f 3 -d ','`"
  SAVEFILENAMEONLY="`basename $SAVEFILE`"
  SFSFILE="`echo -n "$PUPSFS" | cut -f 3 -d ','`"
  SFSFILENAMEONLY="`basename $SFSFILE`"
  RECORDLIST="$SAVEFILENAMEONLY $SFSFILENAMEONLY $EXTRASFSLIST $ZFACTOR" #v426
  NEWUNIONRECORD="`echo "$RECORDLIST" | tr -s ' '  | sed -e 's/ $//'`"
 fi
fi

#update /etc/rc.d/BOOTCONFIG with latest unionfs layers configuration...
cat $OLDFILESMNTPT/etc/rc.d/BOOTCONFIG | grep -v '^PREVUNIONRECORD' | sed -e 's/^LASTUNIONRECORD/PREVUNIONRECORD/g' >/pup_rw/etc/rc.d/BOOTCONFIG
sync
echo "LASTUNIONRECORD='$NEWUNIONRECORD'" >> /pup_rw/etc/rc.d/BOOTCONFIG
[ "$LASTUNIONRECORD" = "$NEWUNIONRECORD" ] && NEWUNIONRECORD="" #used below.
#...if layers changed since last boot, code further down will do whiteout files purge.
#.../etc/rc.d/rc.update reads BOOTCONFIG, updates menu (etc) if layers changed.

#after switch_root, rc.sysinit calls rc.update, but need to do pre-cleaning...
if [ "$OLDFILESMNTPT" != "" ];then
 #an empty tmp is required for mounting a tmpfs onto later...
 rm -rf $OLDFILESMNTPT/tmp/*
 rm -rf $OLDFILESMNTPT/tmp/.[0-9a-zA-Z]*
 if [ ! -L $OLDFILESMNTPT/usr/X11R6 ];then #test if a symlink.
  #this is supposed to be a link to X11R7. <2.10 it won't be...
  if [ -d $OLDFILESMNTPT/usr/X11R6 ];then
   mkdir -p $OLDFILESMNTPT/usr/X11R7
   cp -af $OLDFILESMNTPT/usr/X11R6/* $OLDFILESMNTPT/usr/X11R7/
   rm -rf $OLDFILESMNTPT/usr/X11R6
  fi
  ln -snf X11R7 $OLDFILESMNTPT/usr/X11R6
 fi
 rm -rf $OLDFILESMNTPT/root/tmp
 rm -f $OLDFILESMNTPT/root/.wh.tmp
 NEWPVERSION=$DISTRO_VERSION
 if [ -f $OLDFILESMNTPT/etc/puppyversion ];then
  OLDPVERSION=`cat $OLDFILESMNTPT/etc/puppyversion` #old pre-w464 installation.
  rm -f $OLDFILESMNTPT/etc/puppyversion #no longer used.
 fi
 [ -f $OLDFILESMNTPT/etc/DISTRO_SPECS ] && OLDPVERSION=`grep '^DISTRO_VERSION' $OLDFILESMNTPT/etc/DISTRO_SPECS | cut -f 2 -d '=' | cut -f 1 -d ' '` #w478

 [ ! $OLDPVERSION ] && OLDPVERSION=$NEWPVERSION
 #[ "$PCLEAN" = "yes" ] && OLDPVERSION=`expr $NEWPVERSION - 1`
 [ "$PCLEAN" = "yes" ] && OLDPVERSION=$((NEWPVERSION - 1))
 #[ "$PPURGE" = "yes" ] && OLDPVERSION=`expr $NEWPVERSION - 1`
 [ "$PPURGE" = "yes" ] && OLDPVERSION=$((NEWPVERSION - 1))
 if [ $NEWPVERSION -gt $OLDPVERSION ];then
  echo -e "\\033[1;35m"  >/dev/console #35=purple.
  echo "Version update, restoring 'official' files, please wait..." >/dev/console
  echo -en "\\033[0;39m" >/dev/console
  echo "(with a slow CPU this may take sometime, please be patient)" >/dev/console
  #v2.16 do not overwrite rox desktop setup, as /etc/rc.d/rc.update now handles it...
  [ -f $OLDFILESMNTPT/root/Choices/ROX-Filer/PuppyPin ]  && touch $OLDFILESMNTPT/root/Choices/ROX-Filer/PuppyPin
  [ -f $OLDFILESMNTPT/root/Choices/ROX-Filer/globicons ] && touch $OLDFILESMNTPT/root/Choices/ROX-Filer/globicons
  mkdir $OLDFILESMNTPT/tmp/versioncleanup
  #make sure that the official boot scripts will be visible at top...
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.country
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.local0
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.modem
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.modules
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.modules2
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.network
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.shutdown
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.sysinit
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.update
  rm -f $OLDFILESMNTPT/etc/rc.d/rc.services #v405
  #i think if a file exists both in OLDFILESMNTPT and in NEWFILESMNTPT, remove
  #it from OLDFILESMNTPT (as OLDFILESMNTPT is upper layer and will hide the
  #'official' file. But, only do it if 'official' file has a newer modify date...
  cd $NEWFILESMNTPT
  #v2.12 this while-loop has become ultra-slow... seems upx compressed execs
  #responsible, recently upx-ed all the execs, now restore busybox, grep, cp.
  DOTCNT=0
  find ./ -noleaf -type f | sed -e 's/^\.//g' |
  while read ONENEW
  do
   #DOTCNT=`expr $DOTCNT + 1`
   DOTCNT=$((DOTCNT + 1))
   [ $DOTCNT -gt 100 ] && DOTCNT=0 #display a dot every time cnts to 100.
   [ $DOTCNT -eq 100 ] && echo -n '*' >/dev/console #v2.12
   #note, screens out spaces also...
   [ ! "`echo -n "$ONENEW" | grep -E '^/dev|^/tmp|^/proc| '`" = "" ] && continue
   ONEBASE="`basename $OLDFILESMNTPT$ONENEW`"

   OLDDIR="`dirname $OLDFILESMNTPT$ONENEW`"

   #a whiteout file 'on top' will hide the 'official' file...
   [ -f $OLDDIR/.wh.$ONEBASE ]     && rm -f $OLDDIR/.wh.$ONEBASE
   [ -f $OLDDIR/.wh.__dir_opaque ] && rm -f $OLDDIR/.wh.__dir_opaque #v424 not needed for aufs2
   #let's get paranoid and imagine upper-directories also wiped...
   while [ ! "$OLDDIR" = "/" ];do
    #OLDDIR="`dirname $OLDDIR`"
    OLDDIR="${OLDDIR%/*}"
    #UP1BASE="`basename $OLDDIR`"
    UP1BASE="${OLDDIR##*/}"
    [ -f $OLDDIR/.wh.$UP1BASE ]     && rm -f $OLDDIR/.wh.$UP1BASE
    [ -f $OLDDIR/.wh.__dir_opaque ] && rm -f $OLDDIR/.wh.__dir_opaque #v424 not needed for aufs2
   done
   #now check for 'old' files on top layer...
   if [ -f $OLDFILESMNTPT$ONENEW ];then
    #note, this is inaccurate due to local timezone not yet set...
    #i got this 'stat' off ibiblio, v3.3. i think older version than in main puppy f.s...
    MODIFOLD=`$PUPFILESDIR/bin/stat -c %Y $OLDFILESMNTPT$ONENEW`
    MODIFNEW=`$PUPFILESDIR/bin/stat -c %Y $NEWFILESMNTPT$ONENEW`
    #[ "$PPURGE" = "yes" ] && MODIFNEW=`expr $MODIFOLD + 1` #force overwrite all.
    [ "$PPURGE" = "yes" ] && MODIFNEW=$((MODIFOLD + 1)) #force overwrite all.
    if [ $MODIFNEW -ge $MODIFOLD ];then
     echo -n " $ONENEW " >/dev/console
     #ONEDIR="`dirname $ONENEW`"
     ONEDIR="${ONENEW%/*}"
     mkdir -p $OLDFILESMNTPT/tmp/versioncleanup$ONEDIR
     cp -af $OLDFILESMNTPT$ONENEW $OLDFILESMNTPT/tmp/versioncleanup$ONEDIR/
     rm -f $OLDFILESMNTPT$ONENEW
    fi
   fi
  done
  echo >/dev/console
  cd /
 fi
 #need to cleanup whiteout files if a new .sfs layer has been added...
 if [ "$NEWUNIONRECORD" != "" -o "$PPURGE" = "yes" ];then
  #find all .wh.__dir_opaque files at the OLDFILESMNTPT layer... v424 bugfixes...
  cd $OLDFILESMNTPT
  find ./ -noleaf -type f -name ".wh.*" | sed -e 's/^\.//g' |
  while read ONEOPAQUE #examples: /usr/src/.wh.__dir_opaque, /usr/src/.wh.bin
  do
   #ONEDIR="`dirname $ONEOPAQUE`" #ex: /usr/src
   ONEDIR="${ONEOPAQUE%/*}"       #ex: /usr/src
   #WHBASE="`basename $ONEOPAQUE`" #ex: .wh.bin
   WHBASE="${ONEOPAQUE##*/}"       #ex: .wh.bin
   if [ "$WHBASE" != ".wh.__dir_opaque" ];then #aufs2 always enter this condition...
    #example, .wh.bin alongside bin directory means it is deleted...
    ONEDEL="`echo -n "$WHBASE" | sed -e 's/^\\.wh\\.//g'`" #ex: bin
    ONEDIR="${ONEDIR}/${ONEDEL}" #ex: /usr/src/bin
    [ ! -e ".${ONEDIR}" ] && continue
   fi
   #if same dir exists lower layer, then wipe the opaque file...

    c=2
    maxLAYERS=9
    while :; do
     c=$((c+1))
     [ -d /pup_ro${c}${ONEDIR} ] && rm -f ${OLDFILESMNTPT}${ONEOPAQUE}
     [ $c -ge $maxLAYERS ]       && break
    done
    unset c
  done
  cd /
 fi
 if [ $NEWPVERSION -gt $OLDPVERSION ];then
  #echo -n "$OLDPVERSION" > $OLDFILESMNTPT/etc/puppyversion #v2.14 so rc.update will run.
  vPATTERN="s%^DISTRO_VERSION=.*%DISTRO_VERSION=${OLDPVERSION}%"
  sed -e "$vPATTERN" $OLDFILESMNTPT/etc/DISTRO_SPECS > /tmp/distro_specs_old
  cp -f /tmp/distro_specs_old $OLDFILESMNTPT/etc/DISTRO_SPECS #so rc.update will run.
  sync
  echo -e "\\033[1;35m"  >/dev/console #34=blue, 33=yellow, 32=green, 31=red, 35=purple, 36=aquablue, 38=black.
  [ "$PCLEAN" = "yes" ] && echo "This is a simulated version upgrade, which performs a file cleanup." >/dev/console
  [ "$PPURGE" = "yes" ] && echo "This is a radical file cleanup for broken systems, could alter some settings." >/dev/console
  echo "You are upgrading Puppy from version $OLDPVERSION to $NEWPVERSION." >/dev/console
  echo "Overwritten old files have been moved to /tmp/versioncleanup/" >/dev/console
  echo "After bootup please examine this directory (before shutdown) for anything" >/dev/console
  echo "that you might like to recover. Pausing 30 secs so you can read this msg..." >/dev/console
  echo -en "\\033[0;39m" >/dev/console
  sleep 30 #so can see above messages.
 fi
fi

#create the unionfs layered f.s.... ***THE BIG EVENT***

_old_mount_union(){
if [ "$LAYERFS" = "aufs" ];then

 mount -t aufs -o udba=reval,diropq=w,dirs=${UMNTMAIN}${ZLAYER}${UMNTRO} unionfs /pup_new
else #unionfs
 UMNTMAIN="`echo -n "$UMNTMAIN" | sed -e 's/+wh//g'`" #w003 'ro+wh' not accepted by unionfs, change back to 'ro'.
 echo "About to:mount -t unionfs -o dirs=${UMNTMAIN}${ZLAYER}${UMNTRO} unionfs /pup_new"
 mount -t unionfs -o dirs=${UMNTMAIN}${ZLAYER}${UMNTRO} unionfs /pup_new
fi
}

_new_mount_union(){
if [ "$LAYERFS" = "aufs" ];then
 echo "About to:mount -t aufs -o udba=reval,diropq=w,dirs=${UMNTRW}${UMNTRO0}${ALAYER}${YLAYER}${UMNTRO1}${ZLAYER}${UMNTRO} unionfs /pup_new"
 mount -t aufs -o udba=reval,diropq=w,dirs=${UMNTRW}${UMNTRO0}${ALAYER}${YLAYER}${UMNTRO1}${ZLAYER}${UMNTRO} unionfs /pup_new
else #unionfs
 UMNTRW="`echo -n "$UMNTRW" | sed -e 's/+wh//g'`" #w003 'ro+wh' not accepted by unionfs, change back to 'ro'.
 echo "About to:mount -t unionfs -o dirs=${UMNTRW}${UMNTRO0}${ALAYER}${YLAYER}${UMNTRO1}${ZLAYER}${UMNTRO} unionfs /pup_new"
 mount -t unionfs -o dirs=${UMNTRW}${UMNTRO0}${ALAYER}${YLAYER}${UMNTRO1}${ZLAYER}${UMNTRO} unionfs /pup_new
fi
}

_risky_mount_union(){
# REM: Order correctly the unionfs layers
#      First pup_rw, then on usb save_file, then optional additional modules
#      like devx, then optional zdrv, last lowest layer the puppy_main.sfs
# Foremost get rid of leading/trailing colons of UPUP_ADD
UL_ADD=`echo "$UL_ADD" | sed 's%^:*%%;s%:*$%%'`

for oneLAY in "$UL_RW" "$UL_SAVE" "$UL_ADD" "$UL_A" "$UL_Y" "$UL_Z" "$UL_SFS"
do
[ "$oneLAY" ] || continue
UNION_LAYERS="${UNION_LAYERS}${oneLAY}:"
done
UNION_LAYERS=`echo "$UNION_LAYERS" | sed 's%^:*%%;s%:*$%%'`
#UNION_LAYERS=`echo "$UNION_LAYERS" | sed 's%^:*%%;s%:*$%%' | tr -s ':'`

if [ "$LAYERFS" = "aufs" ];then
  echo "About to:mount -t aufs -o udba=reval,diropq=w,dirs=${UNION_LAYERS} unionfs /pup_new"
  mount -t aufs -o udba=reval,diropq=w,dirs=${UNION_LAYERS} unionfs /pup_new
else #unionfs
 UNION_LAYERS=`echo "$UNION_LAYERS" | sed -e 's/+wh//g'`
 echo "About to:mount -t unionfs -o dirs=${UNION_LAYERS} unionfs /pup_new"
 mount -t unionfs -o dirs=${UNION_LAYERS} unionfs /pup_new
fi
}

case $player in
[0-5]|old|traditional)
_old_mount_union
;;
risk*)
_risky_mount_union
;;
*)
_new_mount_union
;;
esac

check_status $? #END STEP FIVE
#######################END SETUP UNIONFS LAYERED FILESYSTEM###################

_fix_bin_sh(){
# fix /bin/sh symlink, since the devx may have it to /bin/dash
# and that shell may break scripts after switch_root
 if [ -L /pup_new/bin/sh ]; then
  case `readlink -f /pup_new/bin/sh` in
  */ash|*/bash) :
  ;;
  *) _say_shell_fix_message(){
     echo "/bin/sh in unionfs top layer is not symlink to ash or bash ."
     echo "If you intend using an other shell than these two,"
     echo "disable the call to this function _fix_bin_sh() in /init of initrd,"
     echo "or manually relink it in /sbin/init or /etc/rc.d/sysinit of the"
     echo "Puppy top layer (/initrd/pup_rw) ."
     }
     readlink -f /pup_new/bin/sh
     if   [ -x /pup_new/bin/bash ]; then
     ln -sf bash /pup_new/bin/sh && _say_shell_fix_message
     elif [ -x /pup_new/bin/ash ]; then
     ln -sf  ash /pup_new/bin/sh && _say_shell_fix_message
     else
      true
     fi
  ;;
  esac
 else true
 fi
}
_fix_bin_sh

#######################SETUP SWITCH TO MAIN FILESYSTEM#######################
#echo -n "Performing a 'switch_root' to the layered filesystem..." > /dev/console
echo -n "Preparing the 'switch_root' to the layered filesystem..." > /dev/console
#prepare everything for doing a switch_root...
#cpio archive does switch_root, lose the initial-ramfs, so move all mntd...
mkdir -p /pup_new/initrd
mount -t ramfs initrdramfs /pup_new/initrd

__make_folders__(){
maxLAYERS=43
while :; do
c=$((c+1))
#[ "$c" = $((maxLAYERS+1)) ] && break
[ -d /pup_new/initrd/pup_ro$c ] || mkdir -p /pup_new/initrd/pup_ro$c
[ "$c" -ge $maxLAYERS ] && break
done
unset c

for d in pup_rw pup_z mnt tmp; do
[ -d /pup_new/initrd/$d ] || mkdir -p /pup_new/initrd/$d; done

for d in data dev_ro1 dev_ro2 dev_save swap tmpfs tmpfs2 zdrv; do
[ -d /pup_new/initrd/$d ] || mkdir -p /pup_new/initrd/mnt/$d; done
unset d
}

for ONEMNT in `mount | cut -f 3 -d ' ' | grep -v 'pup_new' | grep '^/pup_'`
do
 [ -d /pup_new/initrd${ONEMNT} ] || mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done
for ONEMNT in `mount | cut -f 3 -d ' ' | grep '^/mnt/'`
do
 [ -d /pup_new/initrd${ONEMNT} ] || mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done

#v4.02 bring back, but allocate more space (/4 instead of /8)....
#v3.97 a problem can run out of /tmp space, remove...
#to minimise writes to pup_save and to speedup, tmpfs on /tmp...
if [ "$CREATETMPFS" != "/pup_rw" ];then #test if no tmpfs on unionfs top layer.
 ALLOCK=$(((RAMSIZE / 4) + EXTRAALLOCK))

 #v424 don't create tmpfs if have versioncleanup dir...
 #mount -t tmpfs -o size=${ALLOCK}k tmpfs /pup_new/tmp
 [ ! -e $OLDFILESMNTPT/tmp/versioncleanup ] && mount -t tmpfs -o size=${ALLOCK}k puptmpfs /pup_new/tmp

 __version_cleanup_fix1__(){
 #v412 bugfix, versioncleanup dir gets overwritten by this tmpfs on tmp...
 if [ -d $OLDFILESMNTPT/tmp/versioncleanup ];then
  cp -a $OLDFILESMNTPT/tmp/versioncleanup /pup_new/tmp/
  [ $? -ne 0 ] && rm -rf /pup_new/tmp/versioncleanup #precaution, if tmpfs gets full.
  rm -rf $OLDFILESMNTPT/tmp/versioncleanup
 fi
 }

 __make_var_tmpfs__(){
 #want var to be in the tmpfs...
 cp -a /pup_new/var /pup_new/tmp/
 rm -rf /pup_new/var #note, this creates a .wh.var whiteout file in pup_rw.
 ln -snf tmp/var /pup_new/var
 [ -d /pup_new/root/.thumbnails ] && rm -rf /pup_new/root/.thumbnails #image cache for rox.
 mkdir /pup_new/tmp/thumbnails
 ln -snf tmp/thumbnails /pup_new/root/.thumbnails
 }

fi

#PNOX is a boot param. /etc/profile prevents X from starting if this file exists...
[ "$PNOX" = "yes" ] || touch /pup_new/tmp/bootcnt.txt

cp -a /DISTRO_SPECS /pup_new/initrd/
[ -d /pup_new/initrd/tmp ] || mkdir -p /pup_new/initrd/tmp
cp -af /tmp/* /pup_new/initrd/tmp/ #keep any log files.

_cp_or_mount_dev(){
    mkdir -p /pup_new/dev || mkdir /pup_new/dev
    if grep $Q ' /dev ' /proc/mounts; then
     mkdir -p /pup_new/dev;
     #mount $VERB $VERB -o move /dev /pup_new/dev;
     mount -t devtmpfs devtmpfs /pup_new/dev
    else
     cp -a -u -f /dev/* /pup_new/dev/
    fi
}
_cp_or_mount_dev

#120215 if PLANG set here, carry it over...
if [ "$PLANG" ];then
 langPTN="s%^LANG=.*%LANG=${PLANG}%"
 sed -i -e "$langPTN" /pup_new/etc/profile
else
 true
fi

check_status $?

#RDSH is a boot param. exit to initial ramdisk shell...
if [ "$RDSH" = "yes" ];then
 echo > /dev/console
 echo "Dropped to initramfs shell. Type 'exec switch' to continue booting Puppy." > /dev/console
 exec /bin/sh >/dev/console 2>&1
fi

#v3.01 a bit untidy, but cd may still be mounted when it doesn't have to be...
case $PMEDIA in
 *cd)
  [ "$PDEV1" ] && umount /dev/$PDEV1 2>/dev/null #okay if it fails.
  ;;
esac

sync
#killall -USR1 hotplug2 #v423

echo -en "\\033[0;39m" >/dev/console

_unmount_pseudofs(){
umount "$*"/proc/bus/usb
umount "$*"/sys
umount "$*"/proc
}

_move_pseudofs(){
test "$*" || return 1
test "$*" = '.' && absP=`pwd` || absP="$*"
grep $Q ' /dev ' /proc/mounts && { grep $Q " $absP/dev " /proc/mounts && { umount /dev || true; } || { mkdir -p "$*"/dev; mount $VERB $VERB -o move /dev "$*"/dev; }; }

#grep ' /dev ' "$*"/proc/mounts && { mkdir -p "$*"/dev; mount $VERB $VERB -o move /dev "$*"/dev || echo "FAILURE moving /dev" >/dev/console; }

mkdir -p "$*"/sys || echo "FAILURE mkdir $*/sys" >/dev/console
mount $VERB $VERB -o move /sys "$*"/sys || echo "FAILURE moving /sys" >/dev/console
mkdir -p "$*"/proc || echo "FAILURE mkdir $*/proc" >/dev/console
mount $VERB $VERB -o move /proc "$*"/proc || echo "FAILURE moving /proc" >/dev/console
}


if [ "`grep '^/dev/root ' /proc/mounts`" = "" ]; then
echo -n "Performing a 'switch_root' to the layered filesystem..." > /dev/console
_unmount_pseudofs
#now using cpio archive for initramfs 'initial ramdisk'...
#exec switch_root -c /dev/console /pup_new /bin/busybox init 3
exec switch_root /pup_new /sbin/init
else
echo -n "Performing a 'pivot_root' to the layered filesystem..." > /dev/console
# assuming old-style
cd /pup_new        || echo "FAILURE cd /pup_new" >/dev/console
test -e bin/chroot || { cp -a ../bin/chroot bin/ || echo "FAILURE cp chroot" >/dev/console; }
_move_pseudofs '.'
mkdir -p oldstyle_initramdisk     || echo "FAILURE mkdir oldstyle_initramdisk" >/dev/console
pivot_root . oldstyle_initramdisk || echo "FAILURE pivot_root" >/dev/console

#mount | grep oldstyle_initramdisk | while read dev on mnt type fs mops n m;
#while read dev mnt fs mops n m
UNMOUNT_DIRS=`mount | grep oldstyle_initramdisk`
UNMOUNT_DIRS=`echo $UNMOUNT_DIRS |rev |sed 's% )%\n)%g'|rev` # reverse order
echo "$UNMOUNT_DIRS" | while read dev on mnt type fs mops n m;
 do
 sleep 1
 #echo "$mnt as $dev with $fs and $mops" >/dev/console
  case "$mnt" in
  *oldstyle_initramdisk*)
  echo "Unmounting $mnt" >/dev/console
  umount -lr "$mnt" #|| echo "<FAILURE> umounting $mnt" >/dev/console
  if test $? != 0; then

   oldPATH="$PATH"
   PATH="oldstyle_initramdisk/bin:oldstyle_initramdisk/sbin:$PATH"
   echo -e "\n\\033[0;33mFAILURE unmounting $mnt\\033[0;39m" >/dev/console
   mkdir oldstyle_initrd
   if [ $? = 0 ]; then
    cp -a oldstyle_initramdisk/bin oldstyle_initrd/bin
    cp -a oldstyle_initramdisk/sbin oldstyle_initrd/sbin
   else
    false
   fi
   if [ $? = 0 ]; then
    PATH="/oldstyle_initrd/bin:/oldstyle_initrd/sbin:$PATH"
    export PATH
   fi
   echo -en "\\033[0;33m]"
   dmesg | tail -n 7
   echo -en "\\033[0;39m]"
   echo -e "\\033[0;31mDropping out to console. Good Luck.......\\033[0;39m"
   exec chroot . /bin/sh </dev/console >/dev/console 2>&1

  fi

  ;;
  esac
 done
 #done<./proc/mounts

sleep 1
echo "About to chroot . /sbin/init" >/dev/console
exec chroot . /sbin/init
fi
###END###
