#!/bin/ash

MY_SELF=`realpath "$0"`
test "$0" = "$MY_SELF" && MY_SELF_MSG="$MY_SELF" || MY_SELF_MSG="$0 -> $MY_SELF"
ERR=/dev/null # /dev/stderr or errlogfile
OUT=/dev/null # /dev/stdout
ERROR=1
INFO=1
DEBUG=1
DEBUGX=1
VERSION=0.0 #2016-08-26
VERSION=0.5 #2016-08-27
TWO_DEBUG=1
TWO_VERSION=1
TWO_HELP=1
TWO_VERBOSE=1
test -f /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5

_exit()
{
local RV
test "$*" || { _err "Usage:_exit EXITCODE MESSAGE"; }
RV=$1
[ "${RV//[[:digit:]]/}" ] && { _err "\$1 must be a digit number."; RV=255; } || shift
echo "$*" >&2
case ${MY_SELF##*/} in
ash*|bash*|sh*) return $RV;; #likely sourced. sourced files crash scripts if exit.
*) exit $RV;;
esac
}

_err(){
test "$ERROR" || return 0
echo -e "$0:ERROR:$*"  >&2
}
_info(){
test "$INFO" || return 0
echo -e "$0:INFO:$*"  >&2
}
_debug(){
test "$DEBUG" || return 0
echo "$0:DEBUG:$*"  >&2
}
_debugx(){
test "$DEBUGX" || return 0
echo "$0:DEBUGX:$@"  >&2
}
_info "$*"
MAYBE_FILE=`echo -e "$*"`
MAYBE_DIR="$MAYBE_FILE"
_debug "MAYBE_FILE='$MAYBE_FILE'"
ORIG_PARAMS="$*"

_check_for_file_and_mountpoint(){
while :
do
if test -f "$FILE_MOUNT_LOOP"; then

[ "$maybe_dir" ]  && maybe_dir="${maybe_dir} ${*}"    || maybe_dir="$*"
[ "$maybe_dir2" ] && maybe_dir2="${maybe_dir2}  ${*}" || maybe_dir2="$*"
[ "$maybe_dir3" ] && maybe_dir3="${maybe_dir3}
${*}" || maybe_dir3="$*"

else

test -f "$*" && { FILE_MOUNT_LOOP="$*"; break; }
MAYBE_FILE=`echo -e "$*"`
test -f "$MAYBE_FILE" && { FILE_MOUNT_LOOP="$MAYBE_FILE"; break; }

[ "$maybe_file" ] && maybe_file="${maybe_file} ${*}" || maybe_file="$*"
test -f "$maybe_file" &&  { FILE_MOUNT_LOOP="$maybe_file"; break; }

[ "$maybe_file2" ] && maybe_file2="${maybe_file2}   ${*}" || maybe_file2="$*"
test -f "$maybe_file2" && { FILE_MOUNT_LOOP="$maybe_file2"; break; }

[ "$maybe_file3" ] && maybe_file3="${maybe_file3}
${*}" || maybe_file3="$*"
test -f "$maybe_file3" && { FILE_MOUNT_LOOP="$maybe_file3"; break; }
fi
break
done
}

_tell_help(){

MSG_HELP="$MY_SELF_MSG:
 Usage:
  ${0##*/} [ -h|-V|-v|-d ] <filename.ext> [ <mountpoint> ]
 Options:
 --help|-h)    say this message and exit.
 --version|-V) say version and exit.
 --verbose|-v) tell whats going on.
 --debug|-d)   print a lot of debugging.
"
[ "$*" ] && MSG_HELP="$MSG_HELP
$*"
gettext "$MSG_HELP"
}

_tell_version(){
gettext "$MY_SELF_MSG: $VERSION"
}
_check_params(){
PARAMS="$@"
while :
do
case $1 in
-*help|-*h)     _tell_help; exit $?;;
-*version|-*V)  _tell_version; exit $?;;
-*verbose|-*v)  VERB=-v;;
-*debug|-*d)    VERB=-v;DEBUG=$((DEBUG+1));;
*) _check_for_file_and_mountpoint "$1";;
esac
shift
[ "$1" ] || break
done
}

if test ! "$*"; then _tell_help; exit $?
elif test -f "$*"; then FILE_MOUNT_LOOP="$*"; set --
elif test -f "$MAYBE_FILE"; then FILE_MOUNT_LOOP="$MAYBE_FILE"; set --
elif test -d "$*"; then FILE_MOUNT_POINT="$*"; set --
elif test -d "$MAYBE_DIR"; then FILE_MOUNT_POINT="$MAYBE_DIR" ; set --
fi

test "$FILE_MOUNT_LOOP"    || _check_params "$@"

if ! test "$FILE_MOUNT_POINT"; then
test -d "$maybe_dir3" && FILE_MOUNT_POINT="$maybe_dir3" #use this only if exists
test -d "$maybe_dir2" && FILE_MOUNT_POINT="$maybe_dir2" #use this only if exists
test "$maybe_dir" && FILE_MOUNT_POINT="$maybe_dir" # this would convert tab and newline to space
fi
_debug "FILE_MOUNT_POINT='$FILE_MOUNT_POINT'"

[ "$FILE_MOUNT_LOOP" ]     && FILE_MOUNT_LOOP=`realpath "$FILE_MOUNT_LOOP"`
_debug "FILE_MOUNT_LOOP='$FILE_MOUNT_LOOP'"
#

# /mnt/home fix ?

_alias_default(){
alias rm="rm $VERB"
alias cp="cp $VERB"
alias mv="mv $VERB"
alias ln="ln $VERB"
alias mkdir="mkdir $VERB"
alias rmdir="rmdir $VERB"
alias chgrp="chgrp $VERB"
alias chmod="chmod $VERB"
alias chown="chown $VERB"
alias modprobe="modprobe $Q $VERB"
}
_alias_default

_losetup_a(){
# old losetup-FULL has no -a options,
# busybox since at least v1.14.4 prints all set up loop devices if no parameters given
(
for l in `ls /dev/loop[0-9]*`
do
losetup $l
done
) 2>>$ERR

(
for l in `ls /dev/loop/[0-9]*`
do
losetup $l
done
) 2>>$ERR
}

_ensure_loop_cont(){
    (
    usedLOOPS=`_losetup_a | wc -l`
    c=0
    while read loop; do
    NR=${loop##*/}
    NR=${NR##*loop}
    _debug c=$c NR=$NR
    while :; do
    test "$NR" = $c && break || { mknod /dev/loop$c b 7 $c; [ -d /dev/loop ] && ln -sf ../loop$c /dev/loop/$c; }
    c=$((c+1))
    _debugx c=$c NR=$NR
    test "$c" -le $usedLOOPS || break
    done
    c=$((c+1))
    test "$c" -le $usedLOOPS || break
    done << EoI
`ls -1d /dev/loop[0-9]* | sed 's!.*loop!!;s!/!!' | sort -n`
EoI
) 2>>$ERR
unset c NR
}
_ensure_loop_cont

_mk_free_loop()
{
    (
    usedLOOPS=`_losetup_a | wc -l`
    read NR <<EoI
`ls /dev/loop[0-9]* | wc -w`
EoI
    # REM : /dev/loop0 only would count as word '1', so need to reduce by one ..
    NR=$((NR-1))
    _debugx "NR=$NR"
    if test "$usedLOOPS" -ge $NR; then
    test -b /dev/loop$((NR+0)) || mknod /dev/loop$((NR+0)) b 7 $((NR+0))
    test -b /dev/loop$((NR+1)) || mknod /dev/loop$((NR+1)) b 7 $((NR+1))
    test -b /dev/loop$((NR+2)) || mknod /dev/loop$((NR+2)) b 7 $((NR+2))
    test -d /dev/loop && { ln -sf ../loop$((NR+0)) /dev/loop/$((NR+0)); ln -sf ../loop$((NR+1)) /dev/loop/$((NR+1)); ln -sf ../loop$((NR+2)) /dev/loop/$((NR+2)); }
    fi
    ) 2>>$ERR
unset NR usedLOOPS
}

_encrypted()
{
  #111110 handle encrypted save-files...
  CRYPTO=""; Err=0

     _init_crypt_save_file()
     {
      local fCRYPT=$1 Err=1
      test "$fCRYPT" || return 7

      freeLOOP="`losetup-FULL -f`" #next free loop device.
      test $? = 0 || return 8

      MYPASS="`pupdialog --title "$(gettext 'Enter Password')" --stdout --inputbox "$(gettext 'Password required to open') ${FILE_MOUNT_LOOP##*/} :" 0 0`"
      Err=$?

      _debugx "MYPASS='$MYPASS' fCRYPT=$fCRYPT"

      if [ $Err -eq 0 ];then
       echo "$MYPASS" | losetup-FULL $VERB -p 0 -e $fCRYPT $freeLOOP "$FILE_MOUNT_LOOP"
       #echo "$MYPASS" | /usr/local/sbin/losetup $VERB -p 0 $L_OP $freeLOOP "$FILE_MOUNT_LOOP"
       #echo "$MYPASS" | /sbin/losetup $VERB $VERB -p 0 $L_OP $freeLOOP "$FILE_MOUNT_LOOP"
# -N | --nohashpass        Do not hash the given password (Debian hashes)
# -k | --keybits <num>     specify number of bits in the hashed key given
#                          to the cipher.  Some ciphers support several key
#                          sizes and might be more efficient with a smaller
#                          key size.  Key sizes < 128 are generally not
#                          recommended
       Err=$?
      fi
      return $Err
     }

    case $FILE_MOUNT_LOOP  in

     *_cryptx*) #light encryption.
      CRYPTO='light'
      modprobe cryptoloop
      rxvt -geometry 25x3 -title "$(gettext 'Enter password')" -bg orange -e losetup-FULL -E 1 $freeLOOP
      #losetup-FULL -E 1 $freeLOOP $imgFile
      Err=$?
     ;;

     *_cryptanubis*|*_cryptan*) CRYPTO=anubis
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptarc4*|*_cryptarc*) CRYPTO=arc4 #does not mount
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_crypta*) #heavy encryption.
      CRYPTO='aes'

      for mod in cryptoloop aes_generic aes crypto_blkcipher blkcipher cbc
      do
      modprobe -l | grep $Q "/${mod}.ko$" || continue
      modprobe $mod
      done

# <linux/loop.h>
#/*
# * Loop filter types
# */

#define LO_CRYPT_NONE           0
#define LO_CRYPT_XOR            1
#define LO_CRYPT_DES            2
#define LO_CRYPT_FISH2          3    /* Twofish encryption */
#define LO_CRYPT_BLOW           4
#define LO_CRYPT_CAST128        5
#define LO_CRYPT_IDEA           6
#define LO_CRYPT_DUMMY          9
#define LO_CRYPT_SKIPJACK       10
#define LO_CRYPT_CRYPTOAPI      18
#define MAX_LO_CRYPT            20

      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptblowfish*|*_cryptbf*) CRYPTO=blowfish
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptcamellia*|*_cryptcam*) CRYPTO=camellia
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptcast6*|*_cryptcast*) CRYPTO=cast6
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptserpent*|*_cryptser*) CRYPTO=serpent
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_crypttwofish*|*_crypttf*) CRYPTO=twofish
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *) Err=9  #[ -b "$freeLOOP" ] && losetup $freeLOOP "$FILE_MOUNT_LOOP"; Err=$?
     ;;
    esac
   # [ -b "$freeLOOP" ] && losetup $freeLOOP "$FILE_MOUNT_LOOP"; Err=$?

return $Err
}

_mount_it(){

# /etc/fstab ...
test -f "$FILE_MOUNT_LOOP" || _exit 2 "'$ORIG_PARAMS' : No such file or directory"

 HAVE_FREE_LOOP=`losetup -f`
  if test "$HAVE_FREE_LOOP" ;then
   NR=${HAVE_FREE_LOOP##*/}
   NR=${NR##*loop}
   test -b "$HAVE_FREE_LOOP" || { rm -f $HAVE_FREE_LOOP; mknod "$HAVE_FREE_LOOP" b 7 $NR; }
  else
   _mk_free_loop
  fi

_encrypted
Err=$?
_debug Err=$Err
 #disktype "$FILE_MOUNT_LOOP" | grep $Q -iE 'file system|squashfs' || _exit 3 "File seems not to contain a filesystem.
 #Is it encrypted ?"

 # mount chokes today on missing -t FS_TYPE in case of ext2 fs,
 # but does not need -t FS_TYPE for squashfs.
 FS_TYPE=`guess_fstype "$FILE_MOUNT_LOOP"` || unset FS_TYPE
 test "$FS_TYPE" = 'unknown' && unset FS_TYPE #old guess_fstype does return 0 on unknown...
 #test "$FS_TYPE" && T_OP="-t $FS_TYPE"

 # encrypted files do not reveal anything for disktype, blkid, guess_fstype.
 # file command says for 'aes' : DBase 3 data file
 # mount-FULL is pretty good  at finding the correct f.s. , but tests all available
 # and testing them could cause kernel panics or taints in case of buggy drivers like LogFS
 # OK: [11885.733013] FAT-fs (loop22): invalid media value (0x06)
 # OK: [11885.733019] FAT-fs (loop22): Can't find a valid FAT filesystem
 # OK: [11885.738075] VFS: could not find a valid V7 on loop22.
 # [11885.750056] LogFS: Start mount 16
 # [11885.750207] LogFS: Start unmounting
 # [11885.750276] BUG: unable to handle kernel NULL pointer dereference at   (null)
 # [11885.750280] IP: [<c1c20a7e>] __mutex_lock_common+0x10a/0x28e
 # [11885.750287] *pdpt = 00000000271d2001 *pde = 0000000000000000
 # [11885.750290] Oops: 0002 [#23] SMP
 # [11885.750336] Pid: 9270, comm: mount-FULL Tainted: G      D      3.5.0-KRG-iCore2-smp-pae-srv1000gz #2 Dell Inc. OptiPlex 755                 /0GM819
 # [11885.750340] EIP: 0060:[<c1c20a7e>] EFLAGS: 00010086 CPU: 1
 # [11885.750356] Process mount-FULL (pid: 9270, ti=e72f2000 task=e732cb60 task.ti=e72f2000)
 # [11885.750379] Call Trace:
 # [11885.750385]  [<c12bdba5>] ? logfs_get_wblocks+0x2a/0x36

 test "$FS_TYPE" || {
 case `echo ${FILE_MOUNT_LOOP} | tr '[:upper:]' '[:lower:]'` in
 *.2fs*|*.ext2*)  FS_TYPE='ext2';;
 *.3fs*|*.ext3*)  FS_TYPE='ext3';;
 *.4fs*|*.ext4*)  FS_TYPE='ext4';;
 *.btr*|*.btrfs*) FS_TYPE='btrfs';;
 *.cramfs*)       FS_TYPE='cramfs';;
 *.f2f*)          FS_TYPE='f2fs';;
 *.fat*)          FS_TYPE='vfat';;
 *.hpfs*)         FS_TYPE='hpfs';;
 *.hfsplus*)      FS_TYPE='hfsplus';;
 *.hfs*)          FS_TYPE='hfs';;
 *.jfs*)          FS_TYPE='jfs';;
 *.mnx*|*.minix*) FS_TYPE='minix';;
 *.ntfs*)         FS_TYPE='ntfs-3g';;
 *.ofs*|*.ocfs2*) FS_TYPE='ocfs2';;
 *.rfs*|*.rfs3*)  FS_TYPE='reiserfs';;
 *.reiser4*)      FS_TYPE='reiser4';;
 *.sfs*|*.sqfs*|*.squashfs*) FS_TYPE='squashfs';;
 *.udf*)          FS_TYPE='udf';;
 *.ufs*)          FS_TYPE='ufs';;
 *.xfs*)          FS_TYPE='xfs';;
 *.iso*|*.cdfs*)  ###+++2013-03-02 Fatdog: fat16 first and iso9660 second
   TYPES=`disktype "$FILE_MOUNT_LOOP" |grep 'file system'`
   if [ "`echo "$TYPES" |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]' | grep -i 'UDF'`" ]; then
    FS_TYPE=udf
   else
    FS_TYPE=iso9660
   fi
  ;;
  *) ##+++2012-06-04
   FS_TYPE=`disktype "$FILE_MOUNT_LOOP" |grep 'file system' |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]'`
  ;;
  esac
 }

 _kernel_fs_support(){
     grep -v nodev /proc/filesystems | grep $Q "$*" && return 0
     ( modinfo "$*" && modprobe "$*" ) >>$OUT 2>>$ERR
 }
 test "$FS_TYPE" && _kernel_fs_support "$FS_TYPE" && T_OP="-t $FS_TYPE"

 mkdir -p "$FILE_MOUNT_POINT"
 #mount $T_OP -o loop "$FILE_MOUNT_LOOP" "$FILE_MOUNT_POINT"
 #Doing mount-FULL -o loop /mnt/sda3/tmp/test file with spaces.2fs /mnt/123 456
 #mount: you must specify the filesystem type
 #exit $?

 if test $Err = 0; then
 _info "About to mount $T_OP "$freeLOOP" "$FILE_MOUNT_POINT""
            /bin/mount $T_OP "$freeLOOP" "$FILE_MOUNT_POINT"

 elif test $Err = 9; then

 _info "About to mount $T_OP -o loop "$FILE_MOUNT_LOOP" "$FILE_MOUNT_POINT""
            /bin/mount $T_OP -o loop "$FILE_MOUNT_LOOP" "$FILE_MOUNT_POINT"

 elif test $Err = 8; then
 _err "No free loop device available"
 false
 elif test $Err = 7; then
 _err "Unknown encryption"
 false
 else
 _err "Unable to setup loop device"
 false
 fi

return $?
}

_convert_nl_tab_sp_esc()
{
xP=${*//\\/\\134} #bsl
xQ=${xP// /\\040}
xR=${xQ//	/\\011}  #TAB
xS="${xR//
/\\012}"
echo "$xS"
unset xP xQ xR xS
}

_format_grep_pattern(){
gP="$*"
_debugx "gP='$gP'"
for c in "\\\\" '$' '^' '*' '[' '.' # ']' "\\\\"
do
_debugx "c='$c'"
case "$c" in
'*'|'[') #echo have wildcard or square
gP=${gP//"$c"/\\$c};;
'\\')    #echo have backslash
gP=${gP//\\/\\\\};;
*) #gP=${gP//"$c"/\\\\"$c"};;
    gP=${gP//"$c"/\\"$c"};;
esac
_debugx "gP='$gP'"
done
_debug "gP='$gP'"
}

_check_dir_mounted(){

gP=`_convert_nl_tab_sp_esc "$FILE_MOUNT_POINT"`
_format_grep_pattern "$gP"
_debug "gP='$gP'"
cut -f2 -d' ' /proc/mounts | grep $Q "^${gP}$";
}

# REM: 2015-11-27 add sfs_load switch
_ask_to_run_sfs_load(){

 which sfs_load >>$OUT || return 1

test "$PUPMODE" || { [ -f /etc/rc.d/PUPSTATE ] && . /etc/rc.d/PUPSTATE || PUPMODE=2; }

case $PUPMODE in 2) return 1;; esac

 MSG_TEXT="This is a squashfs file.
Do you want to load it into the current running Puppy
as merged part of the Operating System ?
Most .sfs files are made to be loaded this way.

Or, it may be just a normal archive.sfs like any .iso file
or even a .sfs made for another linux and not for Puppy.
In that case you may want to mount it just simply
as any other partition mount.
"

GMSG_TEXT=`gettext "$MSG_TEXT"`
test "${GMSG_TEXT// /}" && MSG_TEXT=$GMSG_TEXT

BUTTON_LOD=`gettext 'OS Load'`
BUTTON_MNT=`gettext 'Just Mount'`
BUTTON_EXT=`gettext 'Quit'`

xmessage -buttons "$BUTTON_LOD:100,$BUTTON_MNT:101,$BUTTON_EXT:1" -bg "light blue" -title "filmnt" "$MSG_TEXT"
case $? in
100) return 0;;
101) return 1;;
1)   return 2;;
*)   return 3;;
esac
}

_ask_to_run_sfs_load
  case $? in 0) exec sfs_load "$imgFILE";;
  1) :;; 2) exit 0;; *) _warn "Unhandled return value from _ask_to_run_sfs_load";;
  esac

__exit(){
_get_yaf_args
case $2 in mount)
case $1 in
0) #$YAF $yafBG $yafFG $yafPL $yafFONT $yafEXTRA $yafTXT "Success. Click again to unmount.";;
	$YAF_CMD "Success. Click ${FILE_MOUNT_LOOP##*/} again to unmount." & true;;
*) #$YAF $yafBG $yafFG $yafPL $yafFONT $yafEXTRA $yafTXT "Failure. Error code $1 . Is it an unsupported .sfs version or compression ?";;
	$YAF_CMD "Failure. Error code $1 . Is it an unsupported .sfs version or compression ?" & false;;
esac
;;
umount)
case $1 in
0) #$YAF $yafBG $yafFG $yafPL $yafFONT $yafEXTRA $yafTXT "Successfully unmounted.";;
	$YAF_CMD "Successfully unmounted $FILE_MOUNT_POINT ." & true;;
*) #$YAF $yafBG $yafFG $yafPL $yafFONT $yafEXTRA $yafTXT "Failure unmounting. Error code $1 . Are apps like rxvterminal open therein ?";;
	$YAF_CMD "Failure unmounting. Error code $1 . Are apps like rxvterminal open therein ?" & false;;
esac
;;
esac
exit $1
}

if [ "$FILE_MOUNT_POINT" ]; then
 # toggle if already mounted

 if _check_dir_mounted; then
  rox -D "$FILE_MOUNT_POINT"
  /bin/umount -d "$FILE_MOUNT_POINT"
  __exit $? umount
 else
  _mount_it
 fi
 RV=$?

else

 FILE_MOUNT_POINT=/mnt/"${FILE_MOUNT_LOOP##*/}"
 if _check_dir_mounted; then
  rox -D "$FILE_MOUNT_POINT"
  /bin/umount -d "$FILE_MOUNT_POINT"
  __exit $? umount
 else
 _mount_it
 fi
 RV=$?

fi

_debug RV=$RV
if test "$RV" = 0; then
 :
 #[ -d "$FILE_MOUNT_POINT" ] && rox "$FILE_MOUNT_POINT"
else # clean up
 [ -d "$FILE_MOUNT_POINT" ] && rmdir "$FILE_MOUNT_POINT"
  if test "$freeLOOP"; then
   _losetup_a | grep $Q -w "^$freeLOOP" && losetup -d "$freeLOOP"
  fi
  if test "$FILE_MOUNT_LOOP"; then
   LOOP_ASS=`losetup -j "$FILE_MOUNT_LOOP"`
   for l in $LOOP_ASS; do
   test -b $l || continue
   losetup -d $l
   done
  fi
fi

__exit $RV mount

#TODO:
#/initrd/ support in use by puppy
#DONE:encryption support
#squashfs version support
#squashfs compression
#DONE:xmessages for success/failure
#DONE:dialog to load or mount
