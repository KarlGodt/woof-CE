#!/bin/bash
# echo $LINENO

# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_new2dir"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/usr/bin/new2dir"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#(c) Copyright Barry Kauler 2007
#Now LGPL 2007
#run like this: # new2dir make install
#creates a directory one or two levels higher with the name of the package
#but slightly modified. For example source package has dir 'abiword-0.5.6'
#inside this you do the usual 'configure', 'make', then 'new2dir make install'
#and 'abiword-0.5.6-i486' directory gets created, with all installed files
#in it.

VERSION='1.3-simple Puppy-4.3.1 KRG'
## TODO : More options , implement strip for rescue mode

ERRMSG="This script is used in the last step when installing a source
or binary package. For example:
# new2dir make install
Exiting script."

[ "$DEBUG" ] && echo $LINENO

_usage(){
    RV=0
    case $1 in [0-9]*) RV=$1; shift;; esac
    MSG="$0 [h d v V f r [m A C]]] make [opt] install
    f force : Timeout reduced from 10 to 1 second
              and answer questions automatically.

    h help   : Shows this usage.
    d debug  : turn on debug mode. Given twice 'set -x' .
    v verbose: Verbose mode.
    V version: Shows Version information.
    c clean  : Remove evtl. existing TAGETDIRS-i486, otherwise merge.

    Rescue Mode Options :
    r rescue : don't run make install but look for files modified less
               then $MMIN minutes ago and collect them.
               Also usefull to speed up large packages.
    M=# : in rescue mode specify the time (the needed minus needs to be omitted).
    A   : in rescue mode use access min rather than modify min .
    C   : in rescue mode use change min rather than modify min .

NOTE : THIS version does not support stripping in Resue Mode.
NOTE : THIS version does not give the option to split packages in Rescue Mode.

BUGS : Likely.
"
[ "$*" ] && MSG="$MSG
$*"
gettext "$MSG"
    exit $RV
}
#DBGecho $LINENO
if [ ! $1 ];then
 echo "$ERRMSG"
 exit 1
fi
#DBGecho $LINENO
T=10;RES=OFF;FIND_M=-mmin;MMIN=-5;ERR=/dev/null;OUT=/dev/null
#PRIVATEOPTS=`echo "$@" | sed 's/make.*instal[l\-a-zA-Z0-9]*//;s/-/ /g'`
MAKEOPTS=`echo "$@" |grep -oe 'make.*install[-""a-zA-Z0-9]*'`
[ "$MAKEOPTS" ] || MAKEOPTS='make install'
PRIVATEOPTS=`echo "$@" | sed "s|$MAKEOPTS||"`
PRIVATEOPTS=`echo "$PRIVATEOPTS" | sed 's|\(-\)\([[:alpha:]]\)|\2|g'` #+++2016-09-06 add -option possibility
PRIVATEOPTS=`echo "$PRIVATEOPTS" | sed -r 's|(.)|\1 |g'`              #+++2016-09-06
PRIVATEOPTS=`echo "$PRIVATEOPTS" |tr ' ' '\n' | sed -r 's,([^m=-[0-9]*]),\1 ,g;s| m = (- [[0-9] *])| m=\1|'| tr '\n' ' '`
echo "MAKEOPTS='$MAKEOPTS'"
echo "PRIVATEOPTS='$PRIVATEOPTS'"
for opt in $PRIVATEOPTS;do
echo -n "'$opt' "
case $opt in
f|F|force)T=1;FORCE=$((FORCE+1));;
r|R|rescue)RES=ON;;
m=[0-9]*|M=[0-9]*|m=-[0-9]*|M=-[0-9]*)MMIN="-${opt##*=}"; MMIN=`echo "$MMIN" | sed 's|^-*|-|'`
[ "${MMIN//[[:digit:]]/}" = '-' ] || { echo "Option '$opt' given but time not specified.";_usage 1; }
;;
A)FIND_M=-amin;;
C)FIND_M=-cmin;;
c)CLEAN=1;;
d|D) DEBUG=$((DEBUG+1)); [ "$DEBUG" -ge 2 ] && set -x;;
v)VERB=-v;L_VERB=--verbose;A_VERB=-verbose;ME_VERB=1;OUT=/dev/stdout;ERR=/dev/stderr;;
V)echo -e "\n$0: Version '$VERSION'
BUGS : likely
SPECIALS : options don't require '-' prefix
NOTE : No otions after make [make option(s)] install";exit 0;;
h|H)_usage 0;;
*)echo "opt='$opt'";_usage 1;;
esac;done
[ "$ME_VERB" ] && echo $LINENO  ##;exit

_add_verbosity_to_utils(){
alias cp="cp $VERB"
alias mv="mv $VERB"
alias rm="rm $VERB"
alias chgrp="chgrp $VERB"
alias chmod="chmod $VERB"
alias chown="chown $VERB"
alias mkdir="mkdir $VERB"
alias rmdir="rmdir $VERB"
}
_add_verbosity_to_utils

TTY=`tty` || _exit 2 "Need controlling terminal" # cp -i may need this

if test -f ./configure; then
#ac_default_prefix=/usr/local in configure shell script
DEFAULTPREFIX=`grep 'ac_default_prefix=' ./configure 2>>$ERR |cut -f2 -d'='`
PREFIX1='' #grep
fi

if test -f ./config.log; then
#config.log:ac_cv_host=i486-pc-linux-gnu
B_ARCHITECTURE=`grep 'ac_cv_build=' ./config.log 2>>$ERR |cut -f2 -d'='` # i486-pc-linux-gnu
H_ARCHITECTURE=`grep 'ac_cv_host='  ./config.log 2>>$ERR |cut -f2 -d'='`
T_ARCHITECTURE=

  ARCHITECTURE=`grep 'build_cpu='   ./config.log 2>>$ERR |cut -f2 -d"'"` # i486
fi
#config.status:S["host_cpu"]="i486"
#config.status:S["host"]="i486-pc-linux-gnu"
#config.status:S["build_cpu"]="i486"
#config.status:S["build"]="i486-pc-linux-gnu"
#config.status:S["build_alias"]="i486-pc-linux-gnu"

if test -f Makefile; then
MTUNE=`grep '\-mtune' Makefile 2>>$ERR`
MARCH=`grep '\-march' Makefile 2>>$ERR`
 MCPU=`grep '\-mcpu'  Makefile 2>>$ERR`
fi

if [ "$VERBOSE" ]; then
echo "
MTUNE='$MTUNE'
MARCH='$MARCH'
MCPU='$MCPU'
"
fi

[ "$ME_VERB" ] && echo $LINENO

_get_pkg_dir_(){
CURRDIR="`pwd`";BASE_NAME_PKG1="`basename $CURRDIR`"
UPONE=`dirname "$CURRDIR"`
PKGDIR1="../`basename "$CURRDIR"`";PKGDIR="$PKGDIR1"
xPKGDIR1=`basename "$CURRDIR"`;xPKGDIR="$xPKGDIR1"
MOVE_UP='../'
if [ "`echo "$PKGDIR1" | grep '[0-9]'`" = "" ];then
 MOVE_UP='../../'
 PKGDIR2="../../`basename "$UPONE"`";PKGDIR="$PKGDIR2"
 xPKGDIR2=`basename "$UPONE"`;xPKGDIR="$xPKGDIR2"
 BASE_NAME_PKG2="${PKGDIR2//\.\.\/\.\.\//}"
fi
}

_where_am_i(){

curDIR=`pwd`
#echo $curDIR >&2
(
rel='../'
 while :;
  do

  curDIR=`pwd`
  test "$curDIR" = '/' && return 2
  pkgDIR=$curDIR
  pkgNAME=`basename $pkgDIR`

  #echo $PWD >&2
  #echo $pkgNAME >&2
  case $pkgNAME in *-[0-9]*) break;; esac
   cd ..
   c=$((c+1))
   rel="../${rel}"
  test $c -ge 4 && break  # go 3? or 4? back
  done

 rpkgDIR="${rel}${pkgNAME}"
 #echo "rel='$rel'" >&2
 #test -d "$rpkgDIR" && echo "$rpkgNAME"
 #ls >&2
 test -d "$pkgDIR" && echo "$rpkgDIR"
 )

}

PKGDIR=`_where_am_i`
pkgNAME=`basename "$PKGDIR"`
xPKGDIR="$pkgNAME"

[ "$VEBOSE" ] && echo "Found myself in PKGDIR=$PKGDIR xPKGDIR=$xPKGDIR"
#exit

if [ "`echo "$PKGDIR" | grep '[0-9]'`" = "" ];then
 Pkg_VERSION=X.Y.Z
 TAR_PKG1=`find ../../ -maxdepth 3 -name "${BASE_NAME_PKG1}*.tar*" |head -n1`
 if [ "$BASE_NAME_PKG2" ];then
  TAR_PKG2=`find ../../ -maxdepth 3 -name "${BASE_NAME_PKG2}*.tar*" |head -n1`
 fi

 if [ "$TAR_PKG1" ];then
  Pkg_VERSION1="${TAR_PKG1//*${BASE_NAME_PKG1}/}";Pkg_VERSION1="${Pkg_VERSION1//\.tar*/}"
  Pkg_VERSION1="${Pkg_VERSION1/[-_]/}"
 fi
 [ "$Pkg_VERSION1" ] || Pkg_VERSION1=x.y.z
 if [ "$TAR_PKG2" ];then
  Pkg_VERSION2="${TAR_PKG2//*${BASE_NAME_PKG2}/}";Pkg_VERSION2="${Pkg_VERSION2//\.tar*/}"
  Pkg_VERSION2="${Pkg_VERSION2/[-_]/}"
 fi
 [ "$Pkg_VERSION2" ] || Pkg_VERSION2=X.Y.Z

 #if  [ "$Pkg_VERSION2" ];then
 #Pkg_VERSION="${Pkg_VERSION2/[-_]/}"
 #else
 #Pkg_VERSION="${Pkg_VERSION1/[-_]/}"
 #fi

echo
# echo "'$PKGDIR1' '$PKGDIR2' does not seem to be a package directory with version
echo "'$PKGDIR' or '$xPKGDIR' does not seem to be a package directory
with version number. Unfortunately, some source package tarballs expand
to a directory that does not have version number in it's name.
SeaMonkey is an example of this,
it expands to a directory named just 'mozilla' .
This script will create a package with the same name as the build directory
and it absolutely must have the version number in it which must commence
with a numeric digit. So, now should change the directory up and then it is
neccessary to rename the directory. For example, for SeaMonkey version 1.0.7
rename the directory from 'mozilla' to 'seamonkey-1.0.7' using the filemanager
or (mv 'mozilla' 'firefox-3.5.5') commandline.
[ In this case it would be (cd ../ && mv '${PKGDIR//\.\.\//}' '${PKGDIR//\.\.\//}-${Pkg_VERSION1}') ]"

#if [ "PKGDIR2" ];then
#echo "[ or cd ../../ && (mv '${PKGDIR2//\.\.\//}' '${PKGDIR2//\.\.\//}-${Pkg_VERSION2}') ]"
#fi

echo "
A dash '-' must be used to separate the package name from version.
A directory name like 'seamonkey-alpha1' is NOT allowed as the version
number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'.
Exiting script."
 #cd $MOVE_UP
 exit 1
fi

echo
echo -en "\\033[1;31mStep 1" #red
echo -e "\\033[0;39m"
echo "It seems that the package directory is '$PKGDIR'"
echo "If this is correct, just press ENTER key."
echo "Otherwise, type the correct directory with relative address."
if [ ! "$FORCE" ];then
echo " NOTE:"
echo " This script will create a package with the same name as the directory"
echo " and it absolutely must have the version number in it which must commence"
echo " with a numeric digit, and name and version number must be separated by"
echo " a dash '-', for example, 'seamonkey-1.0.7'."
echo " A directory name like 'seamonkey-alpha1' is NOT allowed as the version"
echo " number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'."
echo " If $PKGDIR is incorrect you must now exit with CTRL-C and close this"
echo " rxvt terminal window then rename the directory."
fi
echo -n "Type response now: "
read -t $T REPLY1
echo
[ ! "$REPLY1" = "" ] && PKGDIR="$REPLY1"
if [ ! -d "$PKGDIR" ];then
 echo "$PKGDIR seems not to exist, exiting script."
 exit 1
fi
echo "Okay, using PKGDIR='$PKGDIR' variable."

echo
echo -en "\\033[1;31mStep 2" #red
echo -e "\\033[0;39m"
echo "Puppy is designed to run on a i486 CPU upwards. Normally this means"
echo "that you have to specify 'build=i486-t2-linux-gnu' (sometimes host=)"
echo "Some packages do not have that configure option and compile for a"
echo "specific CPU regardless what is in your PC."
echo "If you have compiled for a i486, just press ENTER key."
echo "Otherwise, enter the CPU type, examples: i386 i486 i686 (the i is required)."
echo -n "Type response here "
read -t $T -p "found $ARCHITECTURE :" CPUTYPE CPUTYPE1

echo
_debug "CPUTYPE='$CPUTYPE' CPUTYPE1='$CPUTYPE1'"

if [ "$CPUTYPE" = "" ];then
if [ "$ARCHITECTURE" ];then
CPUTYPE="$ARCHITECTURE"
else
CPUTYPE=`uname -m`
fi;fi
[ "$CPUTYPE" ] || CPUTYPE="i486"

case $CPUTYPE in
i[0-9]86*|x86_64*|ia64*)
 true
;;
*)
 echo "$CPUTYPE seems not to be valid. Exiting."
 exit 1
;;
esac
echo "Okay, using $CPUTYPE"

#would like to create different targets for exe, doc, dev, nls components...
EXE_TARGETDIR="${PKGDIR}-${CPUTYPE}" #relative path.
EXE_PKGNAME=`basename "$EXE_TARGETDIR"`
    RELPATH=`dirname  "$EXE_TARGETDIR"`
    echo EXE_TARGETDIR=$EXE_TARGETDIR
echo EXE_PKGNAME=$EXE_PKGNAME
echo RELPATH=$RELPATH

#difficult task, separate package name from version part...
#not perfect, some start with non-numeric version info...
#xNAMEONLY=`echo -n "$xPKGDIR" | sed -e 's/[\-\_][0-9].*$//g'`
xNAMEONLY=`echo -n "$xPKGDIR" | sed -e 's/[-_][0-9].*$//g'`
#...if that fails, do it the old way...
[ "$xNAMEONLY" = "$xPKGDIR" ] && xNAMEONLY=`echo "$xPKGDIR" | cut -f 1 -d "-"`
NAMEONLY="${RELPATH}/${xNAMEONLY}"
#abasename=`basename ${PKGDIR}`
apattern="s/${xNAMEONLY}\\-//g"
VERONLY=`echo -n "$xPKGDIR" | sed -e "$apattern"`

echo NAMEONLY=$NAMEONLY
echo VERONLY=$VERONLY

EXE_TARGETDIR="${NAMEONLY}-${VERONLY}-${CPUTYPE}"
EXE_PKGNAME=`basename "$EXE_TARGETDIR"`
    RELPATH=`dirname  "$EXE_TARGETDIR"`
DOC_TARGETDIR="${NAMEONLY}_DOC-${VERONLY}-${CPUTYPE}"
DOC_PKGNAME=`basename "$DOC_TARGETDIR"`
DEV_TARGETDIR="${NAMEONLY}_DEV-${VERONLY}-${CPUTYPE}"
DEV_PKGNAME=`basename "$DEV_TARGETDIR"`
NLS_TARGETDIR="${NAMEONLY}_NLS-${VERONLY}-${CPUTYPE}"
NLS_PKGNAME=`basename "$NLS_TARGETDIR"`

echo EXE_TARGETDIR=$EXE_TARGETDIR
echo EXE_PKGNAME=$EXE_PKGNAME
echo RELPATH=$RELPATH

# in case of re-run, remove old directories
if [ "$CLEAN" ];then
rm -rf "$EXE_TARGETDIR" "$DOC_TARGETDIR" "$NLS_TARGETDIR" "$DEV_TARGETDIR"
fi

echo
echo -en "\\033[1;31mStep 3" #red
echo -e "\\033[0;39m"
if [ ! "$FORCE" ];then
echo "If you wish, you can split the final package up into separate"
echo "packages for the 'executables', 'documentation', 'development' and"
echo "'international' components."
echo "If the package has shared libraries, it is recommended to at least"
echo "create a seaparate 'development' package."
echo "The idea here is to 'trim the fat' as much as possible so that you only"
echo "have what is absolutely needed in the 'executables' PET package, but"
echo "the extra components can be installed if needed."
echo "WARNING: The automatic splitting performed by this script may not be"
echo "         perfect and you may have to modify the contents of the created"
echo "         separate directories before the final step of converting them"
echo "         to PET packages."
echo
fi
echo "Just press ENTER key only to create one package only."
echo "Or, type a number to choose which separate packages to create:"
echo " 1 Just one package (directory) only"
echo " 2 Create a separate 'development' package"
echo " 3 Create separate 'development', 'documentation', 'international' pkgs"
echo "Or, type a comma-separated list of the separate pkgs that you want to"
echo " create, using keywords 'exe', 'dev', 'doc', 'nls'."
echo " Example: exe,dev,doc  (in this example, nls component is left in the"
echo " main package, that is, the exe component)."
echo -n "Type response (just press ENTER if in doubt): "
read -t $T SPLITPETS

[ "$SPLITPETS" = "" ]  && SPLITPETS="exe"
[ "$SPLITPETS" = "1" ] && SPLITPETS="exe"
[ "$SPLITPETS" = "2" ] && SPLITPETS="exe,dev"
[ "$SPLITPETS" = "3" ] && SPLITPETS="exe,dev,doc,nls"
EXESPLIT="";DOCSPLIT="";DEVSPLIT="";NLSSPLIT=""
[ "`echo "$SPLITPETS" | grep -i 'exe'`" ] && EXESPLIT="yes"
[ "`echo "$SPLITPETS" | grep -i 'doc'`" ] && DOCSPLIT="yes"
[ "`echo "$SPLITPETS" | grep -i 'dev'`" ] && DEVSPLIT="yes"
[ "`echo "$SPLITPETS" | grep -i 'nls'`" ] && NLSSPLIT="yes"

[ "`echo "$SPLITPETS" | grep -i 'exe'`" ] && mkdir -p "$EXE_TARGETDIR"

# First the rescue part
if [ "$RES" = "ON" ];then
echo
echo -n "Finding '$FIND_M' '$MMIN' files in /usr "
U=`find /usr $FIND_M $MMIN`
echo -n "/lib "
L=`find /lib $FIND_M $MMIN`
echo -n "/bin "
B=`find /bin $FIND_M $MMIN`
echo -n "/sbin "
S=`find /sbin $FIND_M $MMIN`
echo "/etc"
if [ "`echo "EXE_TARGETDIR" | grep 'cups'`" ];then
E=`find /etc $FIND_M $MMIN |grep -v 'mtab'`
else
E=`find /etc $FIND_M $MMIN |grep -vE 'mtab|cups'`
fi

LIST="$U
$L
$B
$S
$E"

LIST=`echo "$LIST" |sort -u`

for i in $LIST;do
if [ -d "$i" ];then
mkdir -p "$EXE_TARGETDIR/$i"
else
#dn=`dirname $i`
dn="${i%/*}"
mkdir -p "$EXE_TARGETDIR"/"$dn"
cp -ai "$i" "$EXE_TARGETDIR"/"$dn"/     <$TTY
[ "$?" -eq '0' ] && echo "Found '$i' ."
fi;done

#find . -name "*.log" -exec cp   -ai --backup=numbered {} "$EXE_TARGETDIR" \;
echo "$LIST" >> /root/.packages/"${EXE_PKGNAME}".files
#mkdir -p "$EXE_TARGETDIR"/root/.packages/src/
#find . -name "*.log" -exec cp   -ai {} /root/.packages/src/"${EXE_PKGNAME}"-{} \;
mkdir -p "$EXE_TARGETDIR"/root/.packages/src/"${EXE_PKGNAME}"
echo "$LIST" >> "$EXE_TARGETDIR"/root/.packages/"${EXE_PKGNAME}".files
find . -type f -name "*.log*"   -exec cp -a --backup=numbered {} "$EXE_TARGETDIR"/root/.packages/src/"${EXE_PKGNAME}" \;
find . -type f -name "config.h" -exec cp -a --backup=numbered {} "$EXE_TARGETDIR"/root/.packages/src/"${EXE_PKGNAME}" \;
find "$EXE_TARGETDIR" -name "*.wh.*" -delete
exit "$?"
fi #REScue

[ "`echo "$SPLITPETS" | grep 'doc'`" ] && mkdir -p "$DOC_TARGETDIR"
[ "`echo "$SPLITPETS" | grep 'dev'`" ] && mkdir -p "$DEV_TARGETDIR"
[ "`echo "$SPLITPETS" | grep 'nls'`" ] && mkdir -p "$NLS_TARGETDIR"

echo
echo -en "\\033[1;31mStep 4" #red
echo -e "\\033[0;39m"
echo "The following line is about to be executed:"
echo "# installwatch -o /tmp/pkginstall.list ${MAKEOPTS}"
echo "...this logs all file activity to /tmp/pkginstall.list"
echo "This script will then determine all newly created directories"
echo "and files and create
'$EXE_TARGETDIR' with the new files"
echo "(and optionally
${DEV_TARGETDIR},
${DOC_TARGETDIR},
${NLS_TARGETDIR})."
echo -n "Press ENTER key to continue: "
read -t $T goforit

installwatch -o /tmp/pkginstall.list ${MAKEOPTS}

_sync

echo
echo -en "\\033[1;31mStep 5" #red
echo -e "\\033[0;39m"
echo "Getting and formatting installwatch information .."

#create list of installed files...
#v2.17 bug, if sometimes logs files in the pkg installing from, have added
# filter out $UPONE...
# BUGPATTERN='&'"$UPONE"
# no, just filter out /mnt and /initrd...
echo "Checking for 'success' ..."
cat /tmp/pkginstall.list | grep '#success$' | tr -s '\t' | tr '&' ' ' | tr '\t' '&' | grep '^[345]&open&' | grep --extended-regexp -v '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc' | grep -E -v '&/initrd|&/mnt/' | cut -f 3 -d '&' > ${RELPATH}/${EXE_PKGNAME}.files
#...list will only have created files, not created directories, so an empty
#   directory won't get recorded.
_sync
#pick up created symlinks...
echo "Checking for 'symlink' ..."
cat /tmp/pkginstall.list | grep '#success$' | tr -s '\t' | tr '&' ' ' | tr '\t' '&' | grep '^0&symlink&' | grep -E -v '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc' | grep -E -v '&/initrd|&/mnt/' | cut -f 4 -d '&' >> ${RELPATH}/${EXE_PKGNAME}.files

#bad if we miss out installing an empty directory...
echo "Checking for 'mkdir' ..."
cat /tmp/pkginstall.list | grep '#success$' | tr -s '\t' | tr '&' ' ' | tr '\t' '&' | grep '^0&mkdir&' | grep -E -v '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc' | grep -E -v '&/initrd|&/mnt/' | cut -f 3 -d '&' | sed -e 's/^\/\//\//g' > /tmp/${EXE_PKGNAME}.dirs

_sync
#problem if there is a post-install script that moves or renames a file...
echo "Checking for 'rename' ..."
#cat /tmp/pkginstall.list | grep '#success$' | tr -s '\t' | tr '&' ' ' | tr '\t' '&' | grep '^0&rename&' | grep -E -v '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc' | grep -E -v '&/initrd|&/mnt/' | cut -f 3,4 -d '&' | tr '\n' ' ' > /tmp/${EXE_PKGNAME}.moved.files
cat /tmp/pkginstall.list | grep '#success$' | tr -s '\t' | tr '&' ' ' | tr '\t' '&' | grep '^0&rename&' | grep -E -v '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc' | grep -E -v '&/initrd|&/mnt/' | cut -f 3,4 -d '&' > /tmp/${EXE_PKGNAME}.moved.files

_sync

_ignore_home_files(){
echo "Checking for '$PWD' files ..."
grep_PWD=`echo "$PWD" |sed 's,\([[:punct:]]\),\\\\\1,g'`
echo -e "\e[1;36m$grep_PWD\e[0;39m"
cat ${RELPATH}/${EXE_PKGNAME}.files | grep -v "$grep_PWD" >/tmp/${EXE_PKGNAME}.files
[ "$ME_VERB" ] && mv ${RELPATH}/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files.old
#/bin/cp --remove-destination /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
}
_ignore_home_files

_sort_unique_files(){
sort -u /tmp/${EXE_PKGNAME}.files        >${RELPATH}/${EXE_PKGNAME}.files
sort -u /tmp/${EXE_PKGNAME}.dirs         >/tmp/${EXE_PKGNAME}.dirs.s
sort -u /tmp/${EXE_PKGNAME}.moved.files  >/tmp/${EXE_PKGNAME}.moved.files.s
_sync
mv /tmp/${EXE_PKGNAME}.dirs.s        /tmp/${EXE_PKGNAME}.dirs
mv /tmp/${EXE_PKGNAME}.moved.files.s /tmp/${EXE_PKGNAME}.moved.files
_sync
}
_sort_unique_files

_filter_renamed_files(){
#find out if any installed file got moved/renamed...
#example:
#/root/COMPILE/Gpart/gpart-0.1h/_install/sbin/st8ycUJA
#/root/COMPILE/Gpart/gpart-0.1h/_install/sbin/gpart

 _alter_files_file(){
  #old BK way, heavy on cpu on large sources, that install a lot of data files
  grep -v "$oneORIG" ${RELPATH}/${EXE_PKGNAME}.files > /tmp/${EXE_PKGNAME}.files
  echo "$oneNEW" >> /tmp/${EXE_PKGNAME}.files
  _sync
  mv -f /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
 }

 _build_list(){
  oneORIG="$oneORIG
`echo -n "$oneMOVED" | cut -f 1 -d '&'`"
  oneNEW="$oneNEW
`echo -n "$oneMOVED" | cut -f 2 -d '&'`"
  [ "$ME_VERB" ] && echo "orig:'$oneORIG' new:'$oneNEW'"
 }

#echo "Fixing 'moved' files ..."
#if [ -s /tmp/${EXE_PKGNAME}.moved.files ];then
[ -s /tmp/${EXE_PKGNAME}.moved.files ] || return 0
echo "Fixing 'moved' files ..."
 for oneMOVED in `cat /tmp/${EXE_PKGNAME}.moved.files`
 do

#  oneORIG="$oneORIG
#`echo -n "$oneMOVED" | cut -f 1 -d '&'`"
#  oneNEW="$oneNEW
#`echo -n "$oneMOVED" | cut -f 2 -d '&'`"
#  [ "$ME_VERB" ] && echo "orig:'$oneORIG' new:'$oneNEW'"

##  #oneORIG=`echo -n "$oneMOVED" | cut -f 1 -d '&'`
##  #oneNEW=`echo -n "$oneMOVED" | cut -f 2 -d '&'`
##  #grep -v "$oneORIG" ${RELPATH}/${EXE_PKGNAME}.files > /tmp/${EXE_PKGNAME}.files
##  #echo "$oneNEW" >> /tmp/${EXE_PKGNAME}.files
##  #_sync
##  #mv -f /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
##  _alter_files_file

  _build_list
 done
##fi

[ "$ME_VERB" ] && echo "orig:
'$ONEORIG'

new:
'$ONENEW'"

#fixfilelistfunc() uses ${RELPATH}/${EXE_PKGNAME}.files...
echo "$oneORIG" |sed '/^$/d' >  /tmp/${EXE_PKGNAME}.orig.files
echo "$oneNEW"  |sed '/^$/d' >  /tmp/${EXE_PKGNAME}.new.files

grep -v -f /tmp/${EXE_PKGNAME}.orig.files ${RELPATH}/${EXE_PKGNAME}.files >/tmp/${EXE_PKGNAME}.files

cat /tmp/${EXE_PKGNAME}.new.files  >> /tmp/${EXE_PKGNAME}.files
/bin/cp $VERB -a --remove-destination /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
#fi
}
_filter_renamed_files

_ignore_home_files(){
# sometimes files get in as '/root/$pkgname/...'
# probably because install first moves files to .lib/libxyz.so.0.1.2T
# do not need them, so filter them out
echo "Checking for '$PWD' files ..."
grep_PWD=`echo "$PWD" |sed 's,\([[:punct:]]\),\\\\\1,g'`
echo -e "\e[1;36m$grep_PWD\e[0;39m"
cat ${RELPATH}/${EXE_PKGNAME}.files | grep -v "$grep_PWD" >/tmp/${EXE_PKGNAME}.files
[ "$ME_VERB" ] && mv --backup=numbered ${RELPATH}/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files.old
/bin/cp $VERB --remove-destination /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
_sync
}
_ignore_home_files

#echo
#echo -en "\\033[1;31mStep 5" #red
#echo -e "\\033[0;39m"

_sort_unique_files2(){
#fixfilelistfunc() uses this...
#cat ${RELPATH}/${EXE_PKGNAME}.files |sort -u >/tmp/${EXE_PKGNAME}.files
sort -u ${RELPATH}/${EXE_PKGNAME}.files >/tmp/${EXE_PKGNAME}.files
/bin/cp $VERB --remove-destination /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
}
_sort_unique_files2

fixfilelistfunc() {
 #$1 is file to remove, as doesn't exist since cp returned non-zero.
 [ "$1" ] || return 2
 echo " ...${1} has been deleted."
 grep -v "$1" /tmp/${EXE_PKGNAME}.files   > /tmp/${EXE_PKGNAME}.files.tmp
 mv -f        /tmp/${EXE_PKGNAME}.files.tmp /tmp/${EXE_PKGNAME}.files
}
#...a post-install script could delete files, which fixfilelistfunc fixes.

echo
echo -en "\\033[1;31mStep 6" #red
echo -e "\\033[0;39m"

#cat ${RELPATH}/${EXE_PKGNAME}.files |
while read oneFILE
do
 ONEBASE=`basename "$oneFILE"`
 ONEPATH=`dirname  "$oneFILE"`
 echo "Processing ${oneFILE}"
 #strip the file...
 if [ ! -h "$oneFILE" ];then #make sure it isn't a symlink
  if [ ! "`echo "$oneFILE" |grep -E '\.dvi$|\.gs$|\.html$|\.pdf$|\.ps$|\.txt$|\.xml$|\.cfg$|\.conf$|\.mo$|\.po$|\.h$|\.hpp$|\.c$|\.cc$|\.cpp$|\.bmp$|\.gif$|\.jpg$|\.png$|\.tif$|\.xbm$|\.xpm$|\.a$|\.la$|\.pc$|/man/.*\.[0-9x]+$|\.menu$|\.desktop$|\.pl$|\.py$|\.sh$|\.bz2$|\.gz$|\.lzma$|\.lzo$|\.xz$|\.Z$|\.au$|\.flv$|\.mp[0-9]$|\.ogg$|\.raw$|\.wav$'`" ];then #file is heavy on cpu
  echo -e '\033[1;35m'"Testing for stripping '$oneFILE'"'\033[0;39m'
  [ "`echo "$FILE_oneFILE" | grep 'LSB' | grep 'shared object'`" ] && strip $VERB --strip-debug "$oneFILE"
  [ "`echo "$FILE_oneFILE" | grep 'ELF' | grep 'executable'`" ] && strip $VERB --strip-unneeded "$oneFILE"
  fi
 fi
 _sync

 if [ "$NLSSPLIT" = "yes" ];then
  #find out if this is an international language file...
  if [ ! "`echo -n "$oneFILE" | grep -E '/locale/|/nls/|/i18n/'`" = "" ];then
   mkdir -p "${NLS_TARGETDIR}/${ONEPATH}"
   /bin/cp $VERB -a --remove-destination "$oneFILE" "${NLS_TARGETDIR}/${ONEPATH}/"
   [ $? -ne 0 ] && fixfilelistfunc $oneFILE
   continue
  fi
 fi

 if [ "$DOCSPLIT" = "yes" ];then
  #find out if this is a documentation file...
  if [ ! "`echo -n "$oneFILE" | grep -E '/man/|/doc/|/docs/|/info/|/gtk-doc/|/faq/|/manual/|/examples/|/help/|/htdocs/'`" = "" ];then
   mkdir -p "${DOC_TARGETDIR}/${ONEPATH}"
   /bin/cp $VERB -a --remove-destination "$oneFILE" "${DOC_TARGETDIR}/${ONEPATH}/"
   [ $? -ne 0 ] && fixfilelistfunc $oneFILE
   continue
  fi
 fi

 if [ "$DEVSPLIT" = "yes" ];then
  #find out if this is development file...
  if [ ! "`echo -n "$oneFILE" | grep -E '/include/|/pkgconfig/|/aclocal|/cvs/|/svn/'`" = "" ];then
   mkdir -p "${DEV_TARGETDIR}/${ONEPATH}"
   /bin/cp $VERB -a --remove-destination "$oneFILE" "${DEV_TARGETDIR}/${ONEPATH}/"
   [ $? -ne 0 ] && fixfilelistfunc $oneFILE
   continue
  fi
  #find *.so symlink files...
  if [ -h "$oneFILE" ];then #-h tests for symlink
   if [ ! "`echo -n "$oneFILE" | grep '\.so$'`" = "" ];then
    mkdir -p "${DEV_TARGETDIR}/${ONEPATH}"
    /bin/cp $VERB -a --remove-destination "$oneFILE" "${DEV_TARGETDIR}/${ONEPATH}/"
    [ $? -ne 0 ] && fixfilelistfunc $oneFILE
    continue
   fi
  fi
  #find various config files...
  if [ ! "`echo -n "$ONEBASE" | grep -E '\-config$|config.sh$|Conf.sh$'`" = "" ];then
    mkdir -p "${DEV_TARGETDIR}/${ONEPATH}"
    /bin/cp $VERB -a --remove-destination "$oneFILE" "${DEV_TARGETDIR}/${ONEPATH}/"
    [ $? -ne 0 ] && fixfilelistfunc $oneFILE
    continue
  fi
  #all .a and .la files... and any stray .m4 files...
  if [ ! "`echo -n "$ONEBASE" | grep -E '\.a$|\.la$|\.m4$'`" = "" ];then
    mkdir -p "${DEV_TARGETDIR}/${ONEPATH}"
    /bin/cp $VERB -a --remove-destination "$oneFILE" "${DEV_TARGETDIR}/${ONEPATH}/"
    [ $? -ne 0 ] && fixfilelistfunc $oneFILE
    continue
  fi
 fi

 #anything left over goes into the main 'executable' package...
 if [ "$EXESPLIT" = "yes" ];then
  mkdir -p "${EXE_TARGETDIR}/${ONEPATH}"
  /bin/cp $VERB -a --remove-destination "$oneFILE" "${EXE_TARGETDIR}/${ONEPATH}/"
  [ $? -ne 0 ] && fixfilelistfunc $oneFILE
  #fix for empty directories...
  cat /tmp/${EXE_PKGNAME}.dirs |
  while read ANEWDIR
  do
   [ "`ls -A $ANEWDIR`" ] || mkdir -p ${EXE_TARGETDIR}${ANEWDIR}
  done
 fi
#done
done<${RELPATH}/${EXE_PKGNAME}.files
_sync

#fixed fileslist file now overwrites the former .files file
if [ "$DEBUG" ]; then
cat /tmp/${EXE_PKGNAME}.files >>${RELPATH}/${EXE_PKGNAME}.files
else
cp   -af /tmp/${EXE_PKGNAME}.files ${RELPATH}/${EXE_PKGNAME}.files
fi

# cp   log files into pkg -- probably into _DEV pkg? ..
find -type f -name "*.log*"   -exec cp -a --backup=numbered {} "${EXE_TARGETDIR}/" \;  ##KRG 2011-12-18
find -type f -name "config.h" -exec cp -a --backup=numbered {} "${EXE_TARGETDIR}/" \;  ##KRG 2012-07-18

#add a pkgname file to /root/.packages since it is installed now
if [ "$DEBUG" ]; then
cat /tmp/${EXE_PKGNAME}.files >>/root/.packages/${EXE_PKGNAME}.files
else
cp -af /tmp/${EXE_PKGNAME}.files /root/.packages
fi

# add a source directory to /root/.packages ..
mkdir -p /root/.packages/src/${EXE_PKGNAME}
# and copy log files into it
#find -name "*.log" -exec cp {} /root/.packages/src/${EXE_PKGNAME}-{} \;
find -type f -name "*.log*"   -exec cp -a --backup=numbered {} /root/.packages/src/${EXE_PKGNAME} \;
find -type f -name "config.h" -exec cp -a --backup=numbered {} /root/.packages/src/${EXE_PKGNAME} \;

# delete whiteout files by aufs driver
find "$EXE_TARGETDIR" -name "*.wh.*" -delete
[ -d "$DEV_TARGETDIR" ] && find "$DEV_TARGETDIR" -name "*.wh.*" -delete
[ -d "$DOC_TARGETDIR" ] && find "$DOC_TARGETDIR" -name "*.wh.*" -delete
[ -d "$NLS_TARGETDIR" ] && find "$NLS_TARGETDIR" -name "*.wh.*" -delete

#check if EXE_TARGETDIR has content ..
[ "`ls -1A "$EXE_TARGETDIR"`" ] || { echo "Hmmm... '$EXE_TARGETDIR' is not populated";exit 1; }

# remove unpopulated _DEV _DOC _NLS directories ...
[ -d "$DEV_TARGETDIR" ] && { [ "`ls -1A "$DEV_TARGETDIR"`" ] || rmdir "$DEV_TARGETDIR"; }
[ -d "$DOC_TARGETDIR" ] && { [ "`ls -1A "$DOC_TARGETDIR"`" ] || rmdir "$DOC_TARGETDIR"; }
[ -d "$NLS_TARGETDIR" ] && { [ "`ls -1A "$NLS_TARGETDIR"`" ] || rmdir "$NLS_TARGETDIR"; }

echo
echo -en "\\033[1;31mFinished" #red
echo -e "\\033[0;39m"
echo "$EXE_TARGETDIR should be now fully populated."
[ -d "$DEV_TARGETDIR" ] && echo "$DEV_TARGETDIR has also been populated."
[ -d "$DOC_TARGETDIR" ] && echo "$DOC_TARGETDIR has also been populated."
[ -d "$NLS_TARGETDIR" ] && echo "$NLS_TARGETDIR has also been populated."
echo "${RELPATH}/${EXE_PKGNAME}.files has a list of the installed files."
echo "You might want to go into it and trim the fat or whatever,"
echo "but basically it is now ready to be converted to a PET"
echo "package. Just do this:"
echo "# cd ${RELPATH}"
echo "# dir2pet $EXE_PKGNAME"

echo
echo "Press ENTER only to exit this script."
echo "Or, if you want the convenience, the 'dir2pet' script can be launched"
echo "right now -- press any character on the keyboard then ENTER."
echo -n "Type response here: "
read -t $T nextphase
[ "$nextphase" ] || { echo;exit $?; }

cd ${RELPATH}
if [ -d ${xNAMEONLY}-${VERONLY}-${CPUTYPE} ];then
 dir2pet ${xNAMEONLY}-${VERONLY}-${CPUTYPE}
 echo -n "${xNAMEONLY}-${VERONLY}-${CPUTYPE}.pet created. Press ENTER to continue: "
 read domore
fi

if [ -d ${xNAMEONLY}_DEV-${VERONLY}-${CPUTYPE} ];then
 dir2pet ${xNAMEONLY}_DEV-${VERONLY}-${CPUTYPE}
 echo -n "${xNAMEONLY}_DEV-${VERONLY}-${CPUTYPE}.pet created. Press ENTER to continue: "
 read domore
fi

if [ -d ${xNAMEONLY}_DOC-${VERONLY}-${CPUTYPE} ];then
 dir2pet ${xNAMEONLY}_DOC-${VERONLY}-${CPUTYPE}
 echo -n "${xNAMEONLY}_DOC-${VERONLY}-${CPUTYPE}.pet created. Press ENTER to continue: "
 read domore
fi

if [ -d ${xNAMEONLY}_NLS-${VERONLY}-${CPUTYPE} ];then
 dir2pet ${xNAMEONLY}_NLS-${VERONLY}-${CPUTYPE}
 echo -n "${xNAMEONLY}_NLS-${VERONLY}-${CPUTYPE}.pet created. Press ENTER to continue: "
 read domore
fi

echo "All done."

###END###
