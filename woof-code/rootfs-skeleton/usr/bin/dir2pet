#!/bin/ash
#
# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_dir2pet"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Create a .pet pkg of a directory"

MY_SELF="/usr/bin/dir2pet"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#Barry Kauler (c) Copyight 2007,2009 www.puppylinux.com
#2007 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
# This script will create a PET package.
# Just create a directory with the name of the package, for example 'abiword-0.5.6'
# and put what you want in it.
# It should have abiword-0.5.6/usr/share/applications/abiword.desktop if the
# application requires a menu entry, but if there isn't one this script will ask
# some simple questions and create one.
# This script will also create abiword-0.5.6/pet.specs, which has
# some information useful to the Puppy Package Manager.
#w476, w478 fixes to work with petspec.
#w482 if preexisting pet.specs, read fields from it.


########################################################################
#
# ADDS/CHANGES by Karl Godt :
#
# TOTAL TODO
#
# /dev/sda1:
# UUID="0C18A53918A52326"
# /dev/sda7:
# UUID="2dfe19a9-7a5c-48aa-9e81-3758c67b12f6"
# /dev/sda9:
# UUID="e29717d3-b775-4dc8-9643-42a862f2b34f"
# /dev/sda2:
# LABEL="2nd"
# UUID="a4f28ea3-eede-49f8-93ca-dbeefe8f72fa"
# /dev/sda10:
# UUID="193a7e6b-8626-493e-8b77-940211a8fc9d"
# /dev/sda6:
# LABEL="1stLogicalPartit"
# UUID="8efb5611-ffb4-41ca-b8ef-8e64769ce9ef"
# /dev/sda3:
# LABEL="3rd"
# UUID="f711a43e-c5dc-4f92-84dc-6824feeb690c"
# /dev/sda11:
# LABEL="store"
# UUID="51600f00-d3cc-4fba-ba77-c34b0c94502c"
# /dev/sda8:
# UUID="7b5cd9dd-54c7-4d03-af79-566588111fcb"
# /dev/sda5:
# LABEL="1stSWAP"
# DISTRO_VERSION=430·#481·#416·#218·#478······#####change·this·as·required#####
# DISTRO_BINARY_COMPAT="puppy"·#"ubuntu"·#"puppy"·#####change·this·as·required#####
# case·$DISTRO_BINARY_COMPAT·in
# ubuntu)
# DISTRO_NAME="Jaunty·Puppy"
# DISTRO_FILE_PREFIX="upup"
# DISTRO_COMPAT_VERSION="jaunty"
# ;;
# debian)
# DISTRO_NAME="Lenny·Puppy"
# DISTRO_FILE_PREFIX="dpup"
# DISTRO_COMPAT_VERSION="lenny"
# ;;
# slackware)
# DISTRO_NAME="Slack·Puppy"
# DISTRO_FILE_PREFIX="spup"
# DISTRO_COMPAT_VERSION="12.2"
# ;;
# arch)
# DISTRO_NAME="Arch·Puppy"
# DISTRO_FILE_PREFIX="apup"
# DISTRO_COMPAT_VERSION="200904"
# ;;
# t2)
# DISTRO_NAME="T2·Puppy"
# DISTRO_FILE_PREFIX="tpup"
# DISTRO_COMPAT_VERSION="puppy5"
# ;;
# puppy)·#built·entirely·from·Puppy·v2.x·or·v3.x·or·4.x·pet·pkgs.
# DISTRO_NAME="Puppy"
# DISTRO_FILE_PREFIX="pup"·#"ppa"·#"ppa4"·#"pup2"··#pup4··###CHANGE·AS·REQUIRED,·recommend·limit·four·characters###
# DISTRO_COMPAT_VERSION="4"·#"2"··#4·····###CHANGE·AS·REQUIRED,·recommend·single·digit·5,·4,·3,·or·2###
# ;;
# esac
# PUPMODE=2
# KERNVER=2.6.30.9-i586-dpup005-Celeron2G
# SATADRIVES='·sda'
# USB_SATAD=''
# PUP_HOME='/'
# PDEV1='sda2'
# Linux·puppypc·2.6.30.9-i586-dpup005-Celeron2G·#6·SMP·Sat·Jan·15·13:35:51·GMT-8·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xorg
# $LANG=de_DE@euro
# today=Sa·21.·Apr·19:35:49·GMT+1·2012
#
#
#
#
#
########################################################################

OUT=/dev/null;ERR=$OUT
[ "$FORCE" ]   && { echo "FORCE given : '$FORCE'";FORCE=1; }
[ "$VERBOSE" ] && { echo "VERBOSE given : '$VERBOSE'";VERBOSE=-v;L_VERBOSE=--verbose;OUT=/dev/stdout;ERR=/dev/stderr; }
[ "$DEBUG" ]   && { echo "DEBUG given : '$DEBUG'";DEBUG=1;set -x; }

_usage (){
    echo "
$0 [-h|-d|-v] [-g|-b|-l|-L|-s|-S|-X|-x] DIR_NAME/
    -h) help: show this usage
    -f) force : answer all questions with 'yes'
    -g) gzip (default) '`which gzip`'
    -b) bzip2          '`which bzip2`'
    -l) lzop           '`which lzop`'
    -L) lzma           '`which lzma`'
    -s) squashfs3 gz   '`which mksquashfs3`'
    -S) squashfs4 gz   '`which mksquashfs4`'
    -X) squashfs4 xz   '`which mksquashfs4`'
    -x) xz             '`which xz`'
    -Z) compress       '`which compress||tar --help |grep -w '\-Z'|awk '{print $1 $2}'`'
    -z) zip            '`which zip`'
    Script to create a .pet with the above compressions.
    Without option given,defaults to the old and proven gzip
    compression.
    -d) debug through 'set -x'
    -v) verbose output and options to binaries
    "
    exit $1
}
#OUTPUT=/dev/null;ERR=/dev/null
while getopts fgbhlLsSXxZzdv opt;do
case $opt in
g) COMPRESS_BIN='gzip'; OPT='-g';EXT='gz'; petEXT='pet';;
b) COMPRESS_BIN='bzip2';OPT='-b';EXT='bz2';petEXT='b2pet';;
f) FORCE=1;TOUT='-t 1';;
h) _usage 0;;
l) COMPRESS_BIN='lzop';OPT='-l';EXT='lzo'; petEXT='lopet';;
L) COMPRESS_BIN='lzma';OPT='-L';EXT='lzma';petEXT='lapet';;
s) COMPRESS_BIN='mksquashfs3';OPT='-s';EXT='sfs3';petEXT='s3pet';;
S) COMPRESS_BIN='mksquashfs4';OPT='-S';EXT='sfs4';petEXT='s4pet';;
X) COMPRESS_BIN='mksquashfs4';OPT='-X';EXT='sfs4x';COMPRESS_OPT='xz';petEXT='s4xpet';;
x) COMPRESS_BIN='xz'; OPT='-x';EXT='xz'; petEXT='xzpet';;
z) COMPRESS_BIN='zip';OPT='-z';EXT='zip';petEXT='zipet';;
Z) COMPRESS_BIN='compress';OPT='-Z';EXT='Z';petEXT='Zpet'
if [ ! "`which $COMPRESS_BIN`" ];then
COMPRESS_BIN='tar'
[ "`$COMPRESS_BIN --help |grep -w '\-Z'`" ] || COMPRESS_BIN='';fi
;;
d) set -x;DEBUG=1;;
v) VERBOSE='-v';L_VERBOSE='--verbose';OUT=/dev/stdout;ERR=/dev/stderr;;
*) _usage 1;;
esac;done

[ "$COMPRESS_BIN" ]         || { COMPRESS_BIN='gzip';EXT='gz';petEXT='pet'; }
[ "`which $COMPRESS_BIN`" ] || { echo "'$COMPRESS_BIN' apparenty not installed (in the PATH)";exit 1; }

#[ "$2" ] && shift
#for i in `seq 2 1 $#`;do shift;done
while [ "$2" ];do shift;done #leave only the last argument

if [ ! "$*" ];then
 echo "It is required to invoke this script like this:
# dir2pet abiword-0.5.6
where abiword-0.5.6 is a directory in the same directory
in which this terminal window is open. 'abiword-0.5.6' is
just an example, and contains subdirectories and files
that will become the PET package."
 exit 1
fi

[ -d "$*" ] || { echo "$* must be a directory"; exit 1; }

aDIR="$*"

#split aDIR path/filename into components...
basPKG=`basename "$aDIR"`
 dirPKG=`dirname  "$aDIR"`
[ "$dirPKG" = "/" ] && dirPKG=""

#w482 directory may already have a pet.specs, reuse it...
nameONLY=""
PUPMENUDESCR=""
PUPOFFICIALDEPS=""
PUPCATEGORY=""

if [ -f "${aDIR}"/pet.specs ];then
 #new: pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|
 #optionally on the end: compileddistro|compiledrelease|repo| (fields 11,12,13)
 PETSPECS=`cat "${aDIR}"/pet.specs | head -n 1`
 DB_pkgname=`echo "$PETSPECS" | cut -f 1 -d '|'`
 DB_nameonly=`echo "$PETSPECS" | cut -f 2 -d '|'`
 nameONLY="$DB_nameonly"
 DB_version=`echo "$PETSPECS" | cut -f 3 -d '|'`
 DB_pkgrelease=`echo "$PETSPECS" | cut -f 4 -d '|'`
 DB_category=`echo "$PETSPECS" | cut -f 5 -d '|'`
 PUPCATEGORY="$DB_category"
 DB_size=`echo "$PETSPECS" | cut -f 6 -d '|'`
 DB_path=`echo "$PETSPECS" | cut -f 7 -d '|'`
 DB_fullfilename=`echo "$PETSPECS" | cut -f 8 -d '|'`
 DB_dependencies=`echo "$PETSPECS" | cut -f 9 -d '|'`
 PUPOFFICIALDEPS="$DB_dependencies"
 DB_description=`echo "$PETSPECS" | cut -f 10 -d '|'`
 PUPMENUDESCR="$DB_description"
 DB_compileddistro=`echo "$PETSPECS" | cut -f 11 -d '|'`
 DB_compiledrelease=`echo "$PETSPECS" | cut -f 12 -d '|'`
 DB_repo=`echo "$PETSPECS" | cut -f 13 -d '|'`
fi

#difficult task, separate package name from version part...
#not perfect, some start with non-numeric version info...
[ "$nameONLY" = "" ] && nameONLY=`echo "$basPKG" | sed -e 's/\-[0-9].*$//g'`
#...if that fails, do it the old way...
[ "$nameONLY" = "$basPKG" ] && nameONLY=`echo "$basPKG" | cut -f 1 -d "-"`

[ "$DEBUG" ] || clear
echo "Welcome to the 'dir2pet' script."
if [ ! "$FORCE" ];then
cat >&1 <<EoI
This will convert a directory into a PET package. Example, you have a
directory named 'abiword-0.5.6' and inside that you place whatever is
needed for the package, for example usr/local/bin/abiword (the executable)
and usr/share/applications/abiword.desktop (the XDG menu file).
Whatever the packages needs, though don't worry if there is no .desktop
file as this script will ask some simple questions and optionally create
one. The package only needs a .desktop file if a menu entry is to be
created, and also a 16x16 pixel icon is required for the menu.
It is preferred that the icon be an xpm image and the default location
for these is at /usr/local/lib/X11/mini-icons/, but it can be anywhere.

The directory $basPKG must separate name of the package and
version number with a dash. Ex: abiword-0.5.6

The package may optionally have post-install and post-remove scripts,
named 'pinstall.sh' and 'puninstall.sh' placed at the top directory.
 (to create official PETs for the Unleashed suite, see its README file
 for more information how to create these scripts properly)
EoI
fi
echo
echo "If any of the above needs to be further sorted out, you can quit this"
echo "script right now by pressing CTRL-C, otherwise just press ENTER."
echo -n "Press ENTER key to continue: "
read $TOUT goforit

[ -f /etc/xdg/menus/hierarchy ] && . /etc/xdg/menus/hierarchy #has PUPHIERARCHY variable.

DESKTOPFILE=""
aDESKTOPFILE=`find "$aDIR" -type f -name \*.desktop`
[ "$aDESKTOPFILE" ] && DESKTOPFILE="yes"

echo
echo -e "\\033[1;31mStep 1""\\033[0;39m"

if [ "$DESKTOPFILE" = "" ];then
 echo "Currently there is no .desktop file (they are usually at usr/share/applications"

 if [ ! "$FORCE" ];then
 echo "or usr/local/share/applications), so perhaps this package is not supposed to
have a menu entry? You can optionally create one though...
If you know that the ${basPKG} application does not require
a menu entry, press the ENTER key only.
If a menu entry is required, type any printable character then ENTER."
 fi

 echo "(if in doubt, just press ENTER key)"
 echo -n "Type a printable character or just ENTER key: "
 read $TOUT YESMENU

 [ "$YESMENU" ] || DESKTOPFILE="ignore"

else #w476
cat >&1 <<EoI
A .desktop file was found here:
$aDESKTOPFILE
So this application will have a menu entry.
If you want to change the .desktop file in any way, open it in a text editor
right now, before proceeding and make any changes you want.
In particular, check that the icon exists, and that 'Category' entry fits
into Puppy's menu hierarchy (see file /etc/xdg/menus/hierarchy).
After satisfying yourself that the .desktop file is ok, press the ENTER key
to continue this script.
Or, type 'ignore' to build pet pkg as if there is no .desktop file.
Or, type 'new' if you would like this script to ask a series of
EoI
 echo -n "questions and rebuild the .desktop file from scratch: "
 read $TOUT newMENU

 [ "$newMENU" = "ignore" ] && DESKTOPFILE="ignore" #w478
 if [ "$newMENU" = "new" ];then
  for oneDESKTOP in $aDESKTOPFILE
  do
   deskBAS=`basename "$oneDESKTOP" .desktop`
   deskDIR=`dirname  "$oneDESKTOP"`
   echo "Moving ${deskDIR}/${deskBAS}.desktop to /tmp"
   mv $VERB -f "${deskDIR}"/"${deskBAS}".desktop /tmp/
  done
  DESKTOPFILE=""
 fi
fi

PUPAPPLICATION=""
PUPEXECUTABLE=""
PUPICON16=""

_get_old_menu_entries(){
if [ "$DESKTOPFILE" = "yes" ];then #w476
 #get some info out of it...
 FIRSTDESKTOPFILE=`echo "$aDESKTOPFILE" | head -n 1`
 [ -f "$FIRSTDESKTOPFILE" ] || return 1
   PUPCATEGORY=`grep '^Categories=' "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
 PUPEXECUTABLE=`grep '^Exec='       "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
     PUPICON16=`grep '^Icon='       "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
  PUPMENUDESCR=`grep '^Comment='    "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
 [ "$PUPMENUDESCR" ] || PUPMENUDESCR=`grep '^Name='        "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
 [ "$PUPMENUDESCR" ] || PUPMENUDESCR=`grep '^GenericName=' "$FIRSTDESKTOPFILE" | cut -f 2 -d '='`
fi
}
_get_old_menu_entries

if [ "$DESKTOPFILE" = "" ];then
 echo
 echo -en "\\033[1;31mStep 1B""\\033[0;39m"

 if [ ! "$FORCE" ];then
 echo "Please type the category in which you want the application
to create a window manager menu entry. The official Puppy
has a menu hierarchy as follows:
('X-' categories are unofficial, Puppy-specific)
$PUPHIERARCHY
"
 fi

 echo -n "Type one word from the CATEGORIES column: "
 read $TOUT PUPCATEGORY

 echo
 echo -e "\\033[1;31mStep 1C""\\033[0;39m"
 echo "Please enter the name of the executable. If it is in the"

 if [ ! "$FORCE" ];then
cat >&1 <<EoI
executable-search-path, namely /bin, /sbin, /usr/bin,
/usr/sbin, /root/my-applications/bin or /usr/local/bin,
then you only need to enter the name of the executable
not the path. Example: mtpaint
 (of course, if you need to specify the path here, it is
 the path AFTER the package is installed)

EoI
 fi

 echo -n "Enter [path]executable: "
 read $TOUT PUPEXECUTABLE

 echo
 echo -e "\\033[1;31mStep 1D""\\033[0;39m"
 echo "Please enter the name of the icon that is to be used in"

 if [ ! "$FORCE" ];then
cat >&1 <<EoI
the window manager menu entry. This must be a 16x16 pixel
.xpm file (.png okay but not suitable all window managers).
If this icon is located at /usr/local/lib/X11/mini-icons
then there is no need to specify the path.
If the icon is located elsewhere then the full path must
be provided. An example: the package gfnrename-0.4 installs
a 16x16 icon at /usr/local/gfnrename-0.4/icon.xpm
(of course, if you need to specify the path here, it is
 the path AFTER the package is installed)
IT MUST BE A 16x16 PIXEL ICON, NO BIGGER!

EoI
 fi

 echo -n "Please type [path]icon: "
 read $TOUT PUPICON16

 echo
 echo -e "\\033[1;31mStep 1E""\\033[0;39m"
 echo "Please enter the name of the application, as you wish it to"

 if [ ! "$FORCE" ];then
 echo "appear in the menu. It will be the first word in the menu entry."
 echo "Example: Abiword"
 echo
 fi

 echo -n "Type application name: "
 read $TOUT PUPAPPLICATION
fi

if [ "$PUPMENUDESCR" = "" ];then #w476
 echo
 echo -e "\\033[1;31mDescription""\\033[0;39m"
 echo "Please enter a description of 1-3 words."

 if [ ! "$FORCE" ];then
 if [ "$DESKTOPFILE" = "" ];then
  echo "This must be extremely short. as it will appear in the window"
  echo "manager menu entry immediately after the application name."
 fi

 echo "This may be used for various purposes,"
 echo "such by PETget for package management purposes."
 echo "Example for Abiword: powerful wordprocessor"
 echo
 fi

 echo -n "Type the VERY SHORT description (without quotes): "
 read $TOUT PUPMENUDESCR
#else
# echo "A description of the package has been extracted:"
# echo " '${PUPMENUDESCR}'"
# echo "This will be placed in the package database entry. Press ENTER if ok,"
# echo -n "or type an alternative very short description: "
# read NEWDESCR
# if [ "$NEWDESCR" != "" ];then
#  PUPMENUDESCR="$NEWDESCR"
# fi
fi

echo

#if pkg is a split-off, already has a known dependency...
depBASE="";DEPNOTE=""
case "$nameONLY" in
*_DEV*) depBASE="+`echo "$nameONLY" | sed -e 's/_DEV//g'`";;
*_DOC*) depBASE="+`echo "$nameONLY" | sed -e 's/_DOC//g'`";;
*_NLS*) depBASE="+`echo "$nameONLY" | sed -e 's/_NLS//g'`";;
esac

if [ "$depBASE" ];then
 DEPNOTE="NOTE5: It is strongly suggested that you at least enter ${depBASE}
       the main package
"
fi

if [ "$PUPOFFICIALDEPS" = "" ];then
 echo
 echo -e "\\033[1;31mDependencies""\\033[0;39m"
 echo "Please enter a dependency-list for the PET package that is now being"

 if [ ! "$FORCE" ];then
cat >&1 <<EoI
created. Packages already built-in to Puppy do not need to be
explicitly named as dependencies (except a cut-down barebones version
of Puppy may not have all of these built in, so you may have to
think of the worst-case situation).
How to enter this dependency-list is shown by an example: the package
'pupdvdtool-0.5b' has the following dependency list:
+vamps,+vobcopy,+ffmpeg,+dvdauthor,+gtkdialog3
Each package name is preceded by a '+' and delimited by a ','.
NOTE1: that 'gtkdialog3' requires the GTK libraries, but it is not
       necessary to specify sub-dependencies, as if 'gtkdialog3'
       needs to be installed it has its own dependency list.
NOTE2: You can lookup the dependency-list of each package in the
       /root/.packages/Packages-* database files
NOTE3: it is not required to specify package version numbers,
       VERSION NUMBERS NOT YET SUPPORTED BY PACKAGE MANAGER
NOTE4: If you don't know what to specify, just press ENTER key
       (the package manager will still do some basic dependency checking)
EoI
 fi
 echo "$DEPNOTE"
 echo -n "Type dependency-list: "
 read $TOUT PUPOFFICIALDEPS
fi

echo
echo -e "\\033[1;31mGUI window""\\033[0;39m"

#create tarball...
if [ "$FORCE" ];then
rm $VERB -f "$dirPKG"/"${basPKG}".tar
rm $VERB -f "$dirPKG"/"${basPKG}".tar.gz
rm $VERB -f "$dirPKG"/"${basPKG}".pet
fi

if [ "$DESKTOPFILE" = "" ];then
 mkdir -p "$dirPKG"/"$basPKG"/usr/share/applications
 (
 echo '[Desktop Entry]'
 echo 'Encoding=UTF-8'
 echo "Name=${PUPAPPLICATION} ${PUPMENUDESCR}"
 echo "Icon=${PUPICON16}"
 echo "Comment=${PUPAPPLICATION} ${PUPMENUDESCR}"
 echo "Exec=${PUPEXECUTABLE}"
 echo "Terminal=false"
 echo "Type=Application"
 echo "Categories=${PUPCATEGORY}"
 echo "GenericName=${PUPAPPLICATION} ${PUPMENUDESCR}"
 ) > "$dirPKG"/"$basPKG"/usr/share/applications/"${nameONLY}".desktop

 echo
 echo "File $dirPKG/$basPKG/usr/share/applications/${nameONLY}.desktop created."
 echo
fi

echo "Press ENTER key to bring up a GUI window that will help you to create"
echo "a database entry for the package. This will be shown in a text editor"
echo "for saving somewhere, also written to file 'pet.specs' inside the pkg."
echo -n "Press ENTER: "
read $TOUT enternow

SIZEK=`du -s -k $dirPKG/$basPKG | cut -f 1` #w476

[ "${PUPCATEGORY}" ] || PUPCATEGORY="EMPTY"
#if PUPCATEGORY is in format 'entry1;entry2;' extract only 'entry2'...
xPUPCATEGORY=`echo -n "$PUPCATEGORY" | tr ';' ' ' | tr -s ' ' | sed -e 's% $%%' | rev | cut -f 1 -d ' ' | rev`
TOPCAT=`echo "$PUPHIERARCHY" | grep "$xPUPCATEGORY" | cut -f 1 -d ' ' | head -n 1`
[ "${TOPCAT}" ] || TOPCAT="EMPTY"

[ "${PUPOFFICIALDEPS}" ] || PUPOFFICIALDEPS="EMPTY"
[ "${PUPMENUDESCR}" ]    || PUPMENUDESCR="EMPTY"
FORCE=$FORCE DEBUG=$DEBUG VERBOSE=$VERBOSE petspec "${nameONLY}" "${TOPCAT}" "${PUPOFFICIALDEPS}" "${PUPMENUDESCR}" "$basPKG" "$SIZEK"

cat /tmp/petspec_db_entry | tail -n 1 > "$dirPKG"/"$basPKG"/pet.specs

test -s "$dirPKG"/"$basPKG"/pet.specs || exit 15

echo
echo "Creating package..."
STATUS=0
tar -c -f "$dirPKG"/"${basPKG}".tar "$dirPKG"/"$basPKG"
STATUS=$((STATUS+$?))
_sync

#gzip $dirPKG/${basPKG}.tar
$COMPRESS_BIN "$dirPKG"/"${basPKG}".tar
STATUS=$((STATUS+$?))

#rmdir $dirPKG/$basPKG
#TARBALL="$dirPKG/${basPKG}.tar.gz"
TARBALL="$dirPKG/${basPKG}.tar.${EXT}"

test -s "$TARBALL" || exit 16
_sync

echo
echo "File $TARBALL created. Now converting to .pet..."
FULLSIZE=`stat -c %s "${TARBALL}"`
STATUS=$((STATUS+$?))
MD5SUM=`md5sum "$TARBALL" | cut -f 1 -d ' '`
STATUS=$((STATUS+$?))
echo -n "$MD5SUM" >> "$TARBALL"
_sync
mv -f "$TARBALL" "$dirPKG"/"${basPKG}"."${petEXT}"
STATUS=$((STATUS+$?))
_sync

test -s "$dirPKG"/"${basPKG}"."${petEXT}" || exit 17

echo
echo "${basPKG}.${petEXT} has been created."
echo
echo "If you look in ${basPKG} you should see the new '.specs' file."
if [ "$DESKTOPFILE" = "" ];then
 echo "And in $basPKG/usr/share/applications/ the new '.desktop' file."
fi
echo "Directory $basPKG is now configured correctly as a PET package
and in future you do not need to go through this script again.
You could manually edit the files if required, and create another
.pet package just by doing this:
# tar -c -f ${basPKG}.tar ${basPKG}/
# $COMPRESS_BIN ${basPKG}.tar
# tgz2pet $OPT ${basPKG}.tar.${EXT}
"
echo "dir2pet finished."
exit $STATUS
###END###
