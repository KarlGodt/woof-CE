#!/bin/bash
# ash has no select buildin

# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_new2dir"
_VERSION_=1.98   #2016-09-01 general overhaul
_VERSION_=1.99   #2016-09-02 general overhaul
_VERSION_=1.99.1 #2016-09-02 bugfixe
_VERSION_=1.99.2 #2016-09-04 speedup moved.files processing, cleanup
_VERSION_=1.99.3 #2016-09-04 add dry run option -n, add confirmation dialog for pkg name and version
_VERSION_=1.99.4 #2016-09-15 bugfix STATUS not getting returnvalue but +1; simplify some code
_VERSION_=1.99.5 #2016-09-16 wrap more code into functions

_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/usr/bin/new2dir"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#(c) Copyright Barry Kauler 2007
#Now LGPL 2007
# Run like this: # new2dir make install
# Creates a directory one or two levels higher with the name of the package
# but slightly modified. For example source package has dir 'abiword-0.5.6'
# inside this you do the usual 'configure', 'make', then 'new2dir make install'
# and 'abiword-0.5.6-i486' directory gets created, with all installed files
# in it.

_info "\$0='$0' \$@='$@'"
TTY=`tty` # in case of interactive needs to read input from controlling terminal.

findTIME=-mmin  #default find option -mmin -amin -cmin to new2dir -r option
mMIN='-2'       #default value to findTIME option, -2 means last two minutes

whatSTRIP='ALL' #NONE: do not strip files
                #INSTALLED: strip installed files but do not strip files in the pkg folder(s)
                #ALL: Puppy default to strip installed files and copy them into the pkg folder(s)

tmpDIR=/tmp
pkgLIST_FILE=pkginstall.list

[ "$OUT" ] || OUT=/dev/null
[ "$ERR" ] || ERR=/dev/null
#BB='busybox ' # enable to use busybox applets

Version='1.8.2-getopts Macpup Foxy 3 Puppy-Linux-430/2 KRG'

echo "$0 : $Version"
echo 'This is an alpha snapshot
and most likely not bugfree
'

_usage(){
    msgHELP="
${0} make install
${0##*/} [-new2dir_opt1 -option2 ..] make [make_opts] install[-doc|.man]

    Script to list installed files by 'make install' using
    'installwatch/checkinstall pkg' and to copy these files into a
    seperate directory to easily be packaged further.
    Also strips binaries automatically and libraries to reduce size.

    Script specific options :
    -c) forcibly delete already existing destination pkg directory(s);
        default is to rename to pkgname-date.
    -d) say other than verbose. given twice 'set -x' .
    -f) answer all dialog questions automatically:yes,cpu-type,
        split-level(-f default = 3); includes -k .
    -h) show this usage.
    -i) interactive modes for binaries used by this script.
    -I/path/to/bin/installwatch) if installwatch script to use
        to monitor make install is installed not first in the PATH .
    -k) keep binaries and libraries unstripped.
    -K) strip only installed bins and libs.
    -l) run with logsave -a $tmpDIR/new2dir.log .
    -m) Menu for selecting various used executables.
    -n) short dry-run option that for now exits before
        installwatch make install in non-rescue mode.
    -M #) set the mMIN level for the find command in -r mode below;
        default is -2 (means to look for modified files not
        older than the last two minutes).
    -A #) switch to AMIN instead of mMIN for above
    -C #) switch to CMIN instead of mMIN for above
            (cmake source seems to need this if run a second time)
    -r) rescue mode if installwatch does not work.
    -u) update already existing _DESTDIR s , do not delete _DESTIR s.
    -v) give verbose output.
    -V) show version information.

    For make specific options, see 'man make|make --help' .
"
gettext "$msgHELP"
    exit $1
}

if [ ! "$*" ];then
 echo "This script is used in the last step when installing a source"
 echo "or binary package. For example:"
 echo "# new2dir make install"
 echo "Exiting script."
 exit 140
fi

INFO=1
DEBUG=1
DEBUGX=1
MAKE=`echo "$@" | ${BB}grep -owe 'make.*instal[-_a-z0-9A-Z\.]\+'`
_info "MAKE='$MAKE'"
[ "$MAKE" ] || MAKE='make install'
_info "MAKE='$MAKE'"
NEW2DIRPARAMS=`echo "$@" |${BB}sed "s#$MAKE##"`
_info "NEW2DIRPARAMS='$NEW2DIRPARAMS'"
[ "`echo "$NEW2DIRPARAMS" |${BB}grep help`" ] && _usage 1  ##+++2012-07-07

while getopts VcdfhiI:kKlmnM:A:C:rvu opt;do
case $opt in
c) cleanUP='y';;
d) OUT=/dev/stderr; ERR=/dev/stderr
   me_DEBUG=1; me_DEBUG=$((me_DEBUG+1)); [ "$me_DEBUG" -ge 2 ] && set -x;
   ;;
f) timeOUT='-t 1';forceIT=$((forceIT+1));;
h) _usage 0;;
i) [ -c "$TTY" ] || _exit 2 "$opt needs controlling terminal"; iNTERACTIVE='-i';lINTERACTIVE='--interactive';;
I) INSTALL_WATCH_EXE="$OPTARG";;
k) whatSTRIP='NONE';;
K) whatSTRIP='INSTALLED';;
l)
NEW2DIRPARAMS=`echo "$NEW2DIRPARAMS" | sed 's/l//g'`  ##+++2012 added g global in case accid. more than one 'l'
exec logsave $VERB -a "$tmpDIR"/new2dir.log "$0" "$NEW2DIRPARAMS" "$MAKE"
;;
m) showMENUS=1;;
n) dryRUN=1;;
M) mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;  ##+++2012-07-07 check ~bug if -A -f
A) findTIME=-amin;mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;
C) findTIME=-cmin;mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;##+-+2012-07-07 BUG had A)
r) RESC='YES';;
u) upDATE=1;;
v) OUT=/dev/stdout;ERR=/dev/stderr;
   VERB='-v';lVERBOSE='--verbose';al_VERBOSE='-verbose';
   me_VERBOSE=1;
   VERBOSE=$((VERBOSE+1)); [ "$VERBOSE" -ge 2 ] && set -v
 ;;
V) echo -e "\n$0 : Version '$Version'\n";exit 0;;
*) _usage 1;;
esac;done

_debug "\$@='$@'"
MAKE=`echo "$@" | ${BB}grep -owe 'make.*instal[-_a-z0-9A-Z\.]\+'`
[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"
[ "$MAKE" ] || MAKE='NONE' ##+++2012-04-03
[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"
NEW2DIRPARAMS=`echo "$@" |${BB}sed "s#$MAKE##"`
[ "$me_VERBOSE" ] && echo "NEW2DIRPARAMS='$NEW2DIRPARAMS'"

_do_menu(){
if [ "$showMENUS" ];then   #busybox ash has no select function
for dir in `echo $PATH |tr ":" " "`;do
INS_WS="$INS_WS `${BB}find $dir -maxdepth 1 -type f \( -name "installwatch[-_]*" -o -name "checkinstall[-_]*" \)`"
done
echo
echo "Select the installwatch executable :"  #busybox ash has no select function
select INSTALL_WATCH_EXE in $INS_WS;do echo $INSTALL_WATCH_EXE;break;done
[ "$INS_WS" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/installwatch -a ! -L /bin/installwatch ] && { echo "'/bin/installwatch' is not a link ";exit 1; }
${BB}rm $VERB -f /bin/installwatch;${BB}ln $VERB -s $INSTALL_WATCH_EXE /bin/installwatch
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/installwatch

for dir in `echo $PATH |tr ":" " "`;do
LIB_TOOLS="$LIB_TOOLS `${BB}find $dir -maxdepth 1 -type f -name "libtool[-_]*"`"
done
echo "Select the libtool executable :"
select LIBTOOL_EXE in $LIB_TOOLS;do echo $LIBTOOL_EXE;break;done
[ "$LIBTOOL_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/libtool -a ! -L /bin/libtool ] && { echo "'/bin/libtool' is not a link ";exit 1; }
${BB}rm $VERB -f /bin/libtool;${BB}ln $VERB -s $LIBTOOL_EXE /bin/libtool
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/libtool

for dir in `echo $PATH |tr ":" " "`;do
MAKE_S="$MAKE_S `${BB}find $dir -maxdepth 1 -type f -name "make[-_][0-9]*"`"
done
echo "Select the make executable :"
select MAKE_EXE in $MAKE_S;do echo $MAKE_EXE;break;done
[ "$MAKE_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /usr/bin/make -a ! -L /usr/bin/make ] && { echo "'/usr/bin/make' is not a link ";exit 1; }
${BB}rm $VERB -f /usr/bin/make;${BB}ln $VERB -s $MAKE_EXE /usr/bin/make
[ "$me_VERBOSE" ] && ${BB}ls -l /usr/bin/make
#MAKE=`echo "$MAKE" |sed "s|^make |$MAKE_EXE |"`
#[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"

for dir in `echo $PATH |tr ":" " "`;do
INSTALL_S="$INSTALL_S `${BB}find $dir -maxdepth 1 \( -type f -o -type l \) -name "install[-_][bB0-9]*"`"
done
echo "Select the install executable :"
select INSTALL_EXE in $INSTALL_S;do echo $INSTALL_EXE;break;done
[ "$INSTALL_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/install -a ! -L /bin/install ] && { echo "'/bin/install' is not a link ";exit 1; }
if [ -e /bin/install -a "`file /bin/install | ${BB}grep busybox`" ];then
${BB}mv $VERB    /bin/install /bin/install-busybox;fi
${BB}rm $VERB -f /bin/install;${BB}ln $VERB -s $INSTALL_EXE /bin/install
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/install

fi #showMENUS
}
_do_menu

curDIR=`pwd`
[ "$me_VERBOSE" ] && echo "curDIR='$curDIR'"

#pkgDIR="../`${BB}basename "$curDIR"`"
bpkgDIR=`${BB}basename "$curDIR"`
 pkgDIR="../$bpkgDIR"

#if make one level deep >
if [ ! "`echo "$bpkgDIR" | ${BB}grep '[0-9]'`" ];then
 upONE=`${BB}dirname "$curDIR"`
 #pkgDIR="../../`${BB}basename "$upONE"`"
 bpkgDIR=`${BB}basename "$upONE"`
  pkgDIR="../../$bpkgDIR"
fi

_pkg_version_check(){
case $pkgDIR in *[0-9]*) return 0;; esac
cat >&1 <<EoI
$pkgDIR does not seem to be the package directory with version
number. Unfortunately, some source package tarballs expand to a
directory that does not have version number in it's name. SeaMonkey
is an example of this, it expands to a directory named just 'mozilla'.
This script will create a package with the same name as the directory
and it absolutely must have the version number in it which must commence
with a numeric digit. So, you must now close this rxvt terminal window
then rename the directory. For example, for SeaMonkey version 1.0.7
rename the directory from 'mozilla' to 'seamonkey-1.0.7'
A dash '-' must be used to separate the package name from version.
A directory name like 'seamonkey-alpha1' is NOT allowed as the version
number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'.
Exiting script.
EoI
 exit 1
}
_pkg_version_check

_step_one(){
echo
echo -e "\\033[1;31mStep 1""\\033[0;39m" #red
read $timeOUT -n1 -p "Press any key for step 1" STEP_1_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
It seems that the package directory is '$pkgDIR'
If this is correct, just press ENTER key.
Otherwise, type the correct directory with relative address.
 NOTE:
 This script will create a package with the same name as the directory
 and it absolutely must have the version number in it which must commence
 with a numeric digit, and name and version number must be separated by
 a dash '-', for example, 'seamonkey-1.0.7'.
 A directory name like 'seamonkey-alpha1' is NOT allowed as the version
number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'.
EoI
fi
echo " If $pkgDIR is incorrect you must now exit with CTRL-C and close this"
echo " rxvt terminal window then rename the directory."
read $timeOUT -e -p "Type response now: " REPLY1
[ "$REPLY1" ] && pkgDIR="$REPLY1"
if [ ! -d "$pkgDIR" ];then
 echo
 echo "$pkgDIR does not exist, exiting script."
 exit 1
fi
echo "Okay, using $pkgDIR"
}
_step_one

_step_two(){
echo
echo -e "\\033[1;31mStep 2""\\033[0;39m" #red
read $timeOUT -n1 -p "Press any key for step 2" STEP_2_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
Puppy is designed to run on a i486 CPU upwards. Normally this means
that you have to specify 'build=i486-t2-linux-gnu' (sometimes host=)
Some packages do not have that configure option and compile for a
specific CPU regardless what is in your PC.
Otherwise, enter the CPU type, examples: i386 i486 i686 (the i is required).
If you leave empty the cpu type will be looked for in 'config.log' file.
If not found defaults to 'i486' .
EoI
fi
echo "If not found and if run with '-f' option , guessed by 'uname -m' ."
echo -n "Type response here: "
read $timeOUT -e cpuTYPE
if [ ! "$cpuTYPE" ];then
if [ -f config.log ];then
BuildCPU=`${BB}grep '^build_cpu='.*'' config.log | tail -n1 | cut -f 2 -d "'"`
 HostCPU=`${BB}grep '^host_cpu='.*''  config.log | tail -n1 | cut -f 2 -d "'"`
if [ "$HostCPU" != "$BuildCPU" ];then
echo "NOTICE build_cpu='$BuildCPU' NOT host_cpu='$HostCPU'"
fi
cpuTYPE="$BuildCPU"
fi
if [ ! "$cpuTYPE" ];then
if [ ! "$timeOUT" ];then
cpuTYPE="i486"
else
cpuTYPE=`${BB}uname -m`
fi
else
echo "Found '$cpuTYPE'";fi;fi
#config.log >
#build='i686-pc-linux-gnu'
#build_alias=''
#build_cpu='i686'
#build_os='linux-gnu'
#build_vendor='pc'
#datadir='${prefix}/share'
#exec_prefix='${prefix}'
#host='i686-pc-linux-gnu'
#host_alias=''
#host_cpu='i386'
#host_os='linux-gnu'
#host_vendor='pc'
##bash-3.2# grep 'i[0-9]' Makefile >
#build_triplet = i686-pc-linux-gnu
#host_triplet = i686-pc-linux-gnu
#build = i686-pc-linux-gnu
#build_cpu = i686
#host = i686-pc-linux-gnu
#host_cpu = i386

#if [ ! "`echo -n "$cpuTYPE" | ${BB}grep '^[a-zA-Z]'`" ];then
case $cpuTYPE in

x86_64-*kfreebsd*-gnu | x86_64-*linux* ) ;;
powerpc64le-* | powerpc64-* | ppc*-*linux* | powerpc*-*linux* ) ;;
s390x-*linux* | s390*-*tpf* ) ;;
sparc64-*linux* | sparc*-*-solaris* ) ;;
i?86-*-solaris* )  ;;
*-*-irix6* )       ;;
ia64-*-hpux* | x86_64-*-* ) ;;
aix* ) ;;
cygwin* | mingw* | pw32* | cegcc* ) ;;
hpux* )       ;;
osf* )        ;;
solaris* )    ;;
sco3.2v5* )   ;;
sysv4.2uw2* ) ;;
sysv5* | sco5v6* | unixware* | OpenUNIX* ) ;;
sysv4 )    ;;
darwin* )  ;;
openbsd* ) ;;
i?86 | x86_64 | ppc | ppc64 ) ;;
arm*-*-* ) ;;
i386? | pe-arm-wince | pe-x86-64 ) ;;
pe-arm-.*little ) ;;
m88k* )   ;;
netbsd* ) ;;
sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX* ) ;;
vxworks* ) ;;
hppa*64* ) ;;

*)
 echo "$cpuTYPE probably not valid. Exiting."
 exit 3
;;
esac
echo "Okay, using $cpuTYPE"
}
_step_two

_get_pkg_version(){
#would like to create different targets for exe, doc, dev, nls components...
#exeTARGETDIR="${pkgDIR}-${cpuTYPE}" #relative path.
#exePKGNAME=`${BB}basename "$exeTARGETDIR"`
   relPATH=`${BB}dirname  "$pkgDIR"`

#_debugx "exeTARGETDIR='$exeTARGETDIR'"
#_debugx "exePKGNAME='$exePKGNAME'"
_debugx "relPATH='$relPATH'"

#difficult task, separate package name from version part...
#not perfect, some start with non-numeric version info...
nameONLY=`echo "$bpkgDIR" |${BB}sed -e 's/[-_][0-9\.]*$//g'`
_debugx " bpkgDIR='$bpkgDIR'"
_debugx "nameONLY='$nameONLY'"

#...if that fails, try this
[ "$nameONLY" = "$bpkgDIR" ] && {
    nameONLY=`echo "$bpkgDIR" |${BB}rev`;
    nameONLY="${nameONLY#*[-_]}";
    nameONLY=`echo "$nameONLY" |${BB}rev`;
}

#_debugx "nameONLY='$nameONLY'"
#nameONLY="${relPATH}/${nameONLY}"
_debugx "nameONLY='$nameONLY'"

#abasename=`basename ${pkgDIR}`
#apattern="s/${xnameONLY}[\\-\\_]//g" ##does not work today 2016-09-04 bash
aPattern="s%${nameONLY}[-_]%%g"
_debugx "aPattern='$aPattern'"
verONLY=`echo "$bpkgDIR" |${BB}sed -e "$aPattern"`
_debugx "verONLY='$verONLY'"

if [ "$verONLY" = "$bpkgDIR" ];then
verONLY=`echo "$bpkgDIR" |${BB}sed 's,[[:alpha:]],,g;s,^\-*,,'`
_debug "verONLY='$verONLY'"
fi

_no_orig(){ # debian source
verONLY="${verONLY//.orig/}"
}

_info "verONLY='$verONLY'"

exeTARGETDIR="${nameONLY}-${verONLY}-${cpuTYPE}"
exePKGNAME=`${BB}basename "$exeTARGETDIR"`
docTARGETDIR="${nameONLY}_DOC-${verONLY}-${cpuTYPE}"
docPKGNAME=`${BB}basename "$docTARGETDIR"`
devTARGETDIR="${nameONLY}_DEV-${verONLY}-${cpuTYPE}"
devPKGNAME=`${BB}basename "$devTARGETDIR"`
nlsTARGETDIR="${nameONLY}_NLS-${verONLY}-${cpuTYPE}"
nlsPKGNAME=`${BB}basename "$nlsTARGETDIR"`

_debug "exeTARGETDIR=$exeTARGETDIR"
_debug "docTARGETDIR=$docTARGETDIR"
_debug "devTARGETDIR=$devTARGETDIR"
_debug "nlsTARGETDIR=$nlsTARGETDIR"

_debug "exePKGNAME=$exePKGNAME"
_debug "docPKGNAME=$docPKGNAME"
_debug "devPKGNAME=$devPKGNAME"
_debug "nlsPKGNAME=$nlsPKGNAME"
}
_get_pkg_version

_confirm_pkgname_version(){
test "$forceIT" && return 0
cat >&1 <<EoI
So, i have split the package name and version into
nameONLY=$nameONLY
and
verONLY=$verONLY
variables.
If one or both of these seem to be incorrect, you have now
the possibillity to change one or both of these.
Just hit enter if it is OK.
EoI
read $timeOUT -e -p "New name    for $nameONLY : " newNAMEONLY
[ "$newNAMEONLY" ] && nameONLY="$newNAMEONLY"
read $timeOUT -e -p "New version for $verONLY  : " newVERONLY
[ "$newVERONLY" ] && verONLY="$newVERONLY"
}
_confirm_pkgname_version

_get_target_dirs(){
_debugx "nameONLY='$nameONLY'"
rnameONLY="${relPATH}/${nameONLY}"
_debugx "nameONLY='$nameONLY'"

exeTARGETDIR="${rnameONLY}-${verONLY}-${cpuTYPE}"
exePKGNAME=`${BB}basename "$exeTARGETDIR"`
docTARGETDIR="${rnameONLY}_DOC-${verONLY}-${cpuTYPE}"
docPKGNAME=`${BB}basename "$docTARGETDIR"`
devTARGETDIR="${rnameONLY}_DEV-${verONLY}-${cpuTYPE}"
devPKGNAME=`${BB}basename "$devTARGETDIR"`
nlsTARGETDIR="${rnameONLY}_NLS-${verONLY}-${cpuTYPE}"
nlsPKGNAME=`${BB}basename "$nlsTARGETDIR"`

_debug "exeTARGETDIR=$exeTARGETDIR"
_debug "docTARGETDIR=$docTARGETDIR"
_debug "devTARGETDIR=$devTARGETDIR"
_debug "nlsTARGETDIR=$nlsTARGETDIR"

_debug "exePKGNAME=$exePKGNAME"
_debug "docPKGNAME=$docPKGNAME"
_debug "devPKGNAME=$devPKGNAME"
_debug "nlsPKGNAME=$nlsPKGNAME"

#[ "$dryRUN" ] && exit # -n option
}
_get_target_dirs

_step_three(){
echo
echo -e "\\033[1;31mStep 3""\\033[0;39m"  #red
read $timeOUT -n1 -p "Press any key for step 3" STEP_3_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
If you wish, you can split the final package up into separate
packages for the 'executables', 'documentation', 'development' and
'international' components.
If the package has shared libraries, it is recommended to at least
create a seaparate 'development' package.
The idea here is to 'trim the fat' as much as possible so that you only
have what is absolutely needed in the 'executables' PET package, but
the extra components can be installed if needed.
WARNING: The automatic splitting performed by this script may not be
         perfect and you may have to modify the contents of the created
         separate directories before the final step of converting them
         to PET packages.

Just press ENTER key only to create one package only.
Or, type a number to choose which separate packages to create:
 1 Just one package (directory) only
 2 Create a separate 'development' package
 3 Create separate 'development', 'documentation', 'international' pkgs
Or, type a comma-separated list of the separate pkgs that you want to
create, using these keywords: 'exe', 'dev', 'doc', 'nls'.
EoI
fi
echo " Example: exe,dev,doc  (in this example, nls component is left in the"
echo " main package, that is, the exe component)."
echo -n "Type response (just press ENTER if in doubt): "
read $timeOUT -e splitPETS
echo

[ "$timeOUT" ] && splitPETS=3
}
_step_three

_get_splits(){
case $splitPETS in
1|'') splitPETS="exe";;
2)    splitPETS="exe,dev";;
3|*)  splitPETS="exe,dev,doc,nls";;
esac

unset exeSPLIT docSPLIT devSPLIT nlsSPLIT
case $splitPETS in *exe*) exeSPLIT="yes";; esac
case $splitPETS in *doc*) docSPLIT="yes";; esac
case $splitPETS in *dev*) devSPLIT="yes";; esac
case $splitPETS in *nls*) nlsSPLIT="yes";; esac

echo "Will create $splitPETS packages"
echo
}
_get_splits

_rm_empty_pkg_dirs(){
[ "$dryRUN" ] && return 0
${BB}rmdir $VERB -f "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
}
_rm_recursive_pkg_dirs(){
[ "$dryRUN" ] && return 0
${BB}rm $VERB -rf "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
}

_backup_old_pkg_dirs(){
[ "$dryRUN" ] && return 0
curDATE=`${BB}date +%F-%T`
 for d in "$exeTARGETDIR" "$docTARGETDIR" "$devTARGETDIR" "$nlsTARGETDIR"
 do
 [ -d "$d" ] && ${BB}mv $VERB "$d" "$d"-"$curDATE"
 done
}

_prepare_pkd_dirs(){
[ "$dryRUN" ] && return 0
if [ ! "$cleanUP" -a "$upDATE" = "" ];then  ##+++2012-07-08 added upDATE support 2012-09-29 changed -o to -a
 _backup_old_pkg_dirs
elif [ "$upDATE" ];then : #true, do nothing
else
 #${BB}rm $VERB -rf "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
 _rm_recursive_pkg_dirs
fi
}
_prepare_pkd_dirs #probably should be run after installwatch make install

_make_pkg_dirs(){
[ "$dryRUN" ] && return 0
case $splitPETS in *exe*) mkdir $VERB -p "$exeTARGETDIR";; esac
case $splitPETS in *doc*) mkdir $VERB -p "$docTARGETDIR";; esac
case $splitPETS in *dev*) mkdir $VERB -p "$devTARGETDIR";; esac
case $splitPETS in *nls*) mkdir $VERB -p "$nlsTARGETDIR";; esac
}
_make_pkg_dirs # TODO: Probably should be run after installwatch make install

__strip_func(){ #normal mode
#strip the file...
 [ -L "$*" ] && return 0 #make sure it isn't a symlink
 _debug "$*"
  elf_TYPE=`file "$*" | grep -Ew 'ELF|LSB'`

  case $elf_TYPE in
  *ELF*shared*object*) strip $VERB --strip-debug    "$*";;
  *ELF*executable*)    strip $VERB --strip-unneeded "$*";;
  esac
  RV=$?
 pidof sync >>$OUT || sync
return $RV
}

strip_func(){
#strip the file...
 [ -L "$*" ] && return 0
 _debug "$*"
  elf_FILE=`file "$*" | ${BB}grep -Ew 'ELF|LSB'`

  case $elf_FILE in
   *shared*object*)
      if [ "$dryRUN" ]; then
       echo "Would have strip --strip-debug '$*'"
      else
       [ "$VERBOSE" ] && ls -ls "$*"
       strip $VERB --strip-debug    "$*"
       [ "$VERBOSE" ] && ls -ls "$*"
      fi
      ;;
   *executable*)
      if [ "$dryRUN" ]; then
       echo "Would have strip --strip-unneeded '$*'"
      else
       [ "$VERBOSE" ] && ls -ls "$*"
       strip $VERB --strip-unneeded "$*"
       [ "$VERBOSE" ] && ls -ls "$*"
      fi
      ;;
  esac
  RV=$?
 pidof sync >>$OUT || sync
return $RV
}

__strip_it(){
# TODO: implement shopt -s -u nocasematch
#[ "`echo "$*" | ${BB}grep '\.[[:alnum:]]*$' | ${BB}grep -vE '\.so$|\.so\.[\.0-9]*$'`" ] && { [ "$me_VERBOSE" ] && echo "'$*' not considered stripable";return 0; }
case $* in */data/*|*.3gp|*.a|*.abw|*.au|*.deb|*.bmp|*.bz2|*.cfg|*.conf|*.config|*.css|*.dat|*.db|*.doc*|*.dtd|*.flv|*.gif|*.gs|*.gz|*.*htm*|*.ini|*.jar|*.js|*.log|*.lua|*.lz*|*.m4|*.map|*.mht|*.mid*|*.mo|*.mod|*.mp[0-9]|*.pbm|*.php|*.png|*.pnm|*.po|*.jp2|*.jpg|*.jpeg|*.odt|*.ogg|*.pdf|*.pl|*.pm|*.ps|*.py|*.raw|*.rdf|*.rpm|*.rtf|*.ru|*.sh|*.sql|*.sqlite|*.svg|*.swf|*.tar|*.tcl|*.tif*|*.txt|*.wav|*.web[mp]|*.xbm|*.xhtm*|*.xml|*.xpm|*.xz|*.Z|*.zip)
 [ "$me_VERBOSE" ] && echo "'$*' not considered stripable"
 return 0;;
*) :;;
esac
strip_func "$@"
}

strip_it(){
[ "$*" ] || return 2
bn=${*##*/}
case $bn in
*.o|*.so|*.so.[0-9]*|*.bin|*.exe)
strip_func "$@"; return $?
;;
[[:alnum:][:punct:]].*) return 0;;
esac
strip_func "$@"
}

copy_files(){
STATUS=0
echo "Processing ${1}"
#[ "$dryRUN" ] && return 0
if [ -f "$1" ];then
    if [ "$noSTRIP" ]; then :
    else
    [ "$whatSTRIP" = 'ALL' ] && { strip_it "$1"; STATUS=$((STATUS+$?)); }
    fi
if [ "$dryRUN" ]; then
echo "Would have created directory '${2}${1%/*}'"
echo "Would have copied file '${1}' as '${2}${1}'"
STATUS=0
else
${BB}mkdir $VERB -p "${2}${1%/*}"
/bin/cp -a $VERB $backUP $iNTERACTIVE "${1}" "${2}${1}" <$TTY
STATUS=$((STATUS+$?))
fi
   if [ "$noSTRIP" ]; then :
   else
[ "$whatSTRIP" = 'INSTALLED' ] && { strip_it "$1"; STATUS=$((STATUS+$?)); }
   fi

   if [ ! -L "$1" ]; then
   if [ "$dryRUN" ]; then
   ${BB}md5sum "$1"
   else
   ${BB}md5sum "$1" >>"${2//\.\.\//}".md5
   ${BB}md5sum "${2}${1}" >>"${2}"/files.md5
   fi
   fi
elif [ -L "$1" -a ! -d "$1" ];then
 RL=`${BB}readlink    "$1"`
RLF=`${BB}readlink -f "$1"`
RLE=`${BB}readlink -e "$1"`
RLM=`${BB}readlink -m "$1"`
RLS="$RL
$RPF
$RPE
$RLM"
RLS=`echo "$RLS" | ${BB}sort -u`

while read -r link; do
[ "$link" ] || continue
if [ "$dryRUN" ]; then
echo "Would have created directory '${2}${1%/*}'"
echo "Would have copied link '${link}' as '${2}${link}'"
STATUS=0
else
${BB}mkdir $VERB -p "${2}${1%/*}"
/bin/cp -a $VERB $backUP $iNTERACTIVE "${link}" "${2}${link}" <$TTY
STATUS=$((STATUS+$?))
fi
done <<EoI
$(echo "$RLS")
EoI
elif [ -d "$1" -a ! -L "$1" ]; then
 if [ "$dryRUN" ]; then
  echo "Would have created directory '${2}${1}'"
 else
  ${BB}mkdir $VERB -p "${2}${1}"
 fi
fi
unset noSTRIP link
return $STATUS
}

_remove_whiteouts(){
#[ "$dryRUN" ] && return 0
for d in "${exeTARGETDIR}" "${devTARGETDIR}" "${docTARGETDIR}" "${nlsTARGETDIR}"
do [ -d "$d" ] || continue
if [ "$dryRUN" ]; then
foundWH=`find "${d}" -name "*.wh.*"`
test "$foundWH" && echo "Found these whiteouts:
$foundWH" || echo "No whiteouts found in $d ."
else
find "${d}" -name "*.wh.*" -delete
fi
done
}

_rescue_mode_search(){
echo "
searching for modified files '$findTIME' '$mMIN' .."
echo -n "In /usr .. "
time F=`${BB}find /usr $findTIME $mMIN`
echo -n "   /etc .. "
if [ ! "`echo "$exeTARGETDIR" | ${BB}grep 'cups'`" ];then
time E=`${BB}find /etc $findTIME $mMIN | ${BB}grep -vi 'cups'`  #certs file gets updated apparently by cupsd
else
time E=`${BB}find /etc $findTIME $mMIN`
fi
echo -n "   /sbin .. "
time S=`${BB}find /sbin $findTIME $mMIN`
echo -n "   /bin .. "
time B=`${BB}find /bin $findTIME $mMIN`
echo -n "   /lib .. "
time L=`${BB}find /lib $findTIME $mMIN`
echo -n "   /var .. "
time V=`${BB}find /var $findTIME $mMIN -iname "*$nameONLY*"`  ###+2013-03-15 Typo was "*xnameONLY*"
echo -n "   /opt .. "
time O=`${BB}find /opt $findTIME $mMIN`
echo

foundFILES="$F
$E
$S
$B
$L
$O
$V"
foundFILES=`echo "$foundFILES" |${BB}sort`
}

_rescue_mode(){

_rescue_mode_search

_rescue_mode_get_files(){
###---2013-03-15 for filename with spaces
while read -r oneFILE
do
[ "$oneFILE" ] || continue
oneFILE=`realpath "$oneFILE"`
[ "$oneFILE" ] || continue
_info "$oneFILE"

#dn="${i%/*}"

case $oneFILE in
*.a|*.la|*.h|*.hpp|*.h++|*.m4|*.pc|*-config|*config.sh|*Conf*.sh|*/aclocal/*|*/automake/*|*/cvs/*|*/svn/*|*/git/*|*/intltool/*|*/libtool/*)
#${BB}mkdir $VERB -p "${devTARGETDIR}${dn}"
noSTRIP=Y copy_files "$oneFILE" "${devTARGETDIR}"
;;
###+++2013-03-15 added noSTRIP FLAG
*/doc/*|*/man/*|*/docs/*|*/info/*|*/gtk-doc/*|*/faq/*|*/manual/*|*/examples/*|*/help/*|*/htdocs/*)
#${BB}mkdir $VERB -p "${docTARGETDIR}${dn}"
noSTRIP=Y copy_files "$oneFILE" "${docTARGETDIR}"
;;
*/locale/*|*/i18n/*|*/nls/*)
#${BB}mkdir $VERB -p "${nlsTARGETDIR}${dn}"
noSTRIP=Y copy_files "$oneFILE" "${nlsTARGETDIR}"
;;
*)
#${BB}mkdir $VERB -p "${exeTARGETDIR}${dn}"
copy_files "$oneFILE" "${exeTARGETDIR}"
;;
esac

done <<EoI
$(echo "$foundFILES")
EoI

###+++2013-03-15 for filename with spaces
echo "DONE cp files."
}
_rescue_mode_get_files

_save_log_files(){
#[ "$dryRUN" ] && return 0
logFILES=`find -type f \( -name "*.log" -o -name "*.err" -o -name "config.h" -o -iname "makefile.*" -not -name "*.in" -not -name "*.am" \) | sort | tac`
while read -r oneFILE
do
[ "$oneFILE" ] || continue
if [ "$dryRUN" ]; then
echo "Would have copied '$oneFILE' '${exeTARGETDIR}/${oneFILE##*/}'"
else
/bin/cp $VERB $iNTERACTIVE -a --backup=numbered "$oneFILE" "${exeTARGETDIR}"/"${oneFILE##*/}" <$TTY
fi
done << EoI
`echo "$logFILES"`
EoI

echo "DONE cp log files."
echo "$C"      >"${relPATH}"/"${exePKGNAME}".files
echo "$C" >"$HOME"/.packages/"${exePKGNAME}".files
}
_save_log_files

_remove_whiteouts

( _rm_empty_pkg_dirs ) 2>>$ERR

return $STATUS
}

if [ "$RESC" = 'YES' ];then
##rescue mode
_rescue_mode
exit $?

else
# Puppy default to use installwatch

fixfilelistfunc() {
 #$1 is file to remove, as doesn't exist.
 echo " NOTICE: ${*} seems to have been deleted."
 ${BB}grep -v "$*" "$tmpDIR"/"${exePKGNAME}".files  >> "$tmpDIR"/"${exePKGNAME}".files.tmp
 ${BB}mv $VERB -f  "$tmpDIR"/"${exePKGNAME}".files.tmp "$tmpDIR"/"${exePKGNAME}".files
}

__installwatch(){
export LD_PRELOAD=/usr/lib/installwatch.so
export INSTALLWATCHFILE="$tmpDIR"/"$pkgLIST_FILE"
make install
}

_installwatch(){

for p in "$@"; do
case $p in
-o) shift; INSTALLWATCHFILE="$1";;
*) makePARAMS="$p";;
esac
shift
done

set - "$makePARAMS"
[ "$me_DEBUG" ] && [ "$me_DEBUG" -ge 2 ] && set -x
[ "$VERBOSE" ]  && [ "$VERBOSE" -ge 2 ]  && set -v
unset makePARAMS

export LD_PRELOAD=/usr/lib/installwatch.so
export INSTALLWATCHFILE
 "$@"
}

_prepare_installwatch(){
if [ ! "$INSTALL_WATCH_EXE" ];then
 INSTALL_WATCH_EXE='installwatch'
 [ "`which $INSTALL_WATCH_EXE`" ] || { echo -e "\\033[1;31m'$INSTALL_WATCH_EXE' seems not to be installed \(correctly?\)\\033[0;39m";exit 1; }
fi
}
_prepare_installwatch

_step_four(){
echo
echo -e "\\033[1;31mStep 4""\\033[0;39m"
read $timeOUT -n1 -p "Press any key for step 4" STEP_4_KEY
echo
echo "The following line is about to be executed:"
echo "# $INSTALL_WATCH_EXE -o $tmpDIR/$pkgLIST_FILE $MAKE"

if [ ! "$forceIT" ];then
echo "...this logs all file activity to $tmpDIR/$pkgLIST_FILE"
echo "This script will then determine all newly created directories"
echo "and files and create '$exeTARGETDIR' with the new files."
echo "\(and optionally ${devTARGETDIR}, ${docTARGETDIR}, ${nlsTARGETDIR}\)"
#fi

echo -n "Press ENTER key to continue: "
read $timeOUT goforit
echo
fi
}
_step_four

_run_installwatch_make_install(){
[ -z "$INSTALL_WATCH_EXE" ] && { echo "installwatch not installed?"; ${BB}sleep 2s;_usage 1; }

${BB}rm $VERB -f "$tmpDIR"/"$pkgLIST_FILE"
${BB}sleep 2s;pidof sync >>$OUT || { ${BB}sync; sleep 2; }

[ "$DEBUG" ] || DEBUG=1 # MAKE variable
_debug "MAKE='$MAKE'"
set - $MAKE
[ "$me_DEBUG" ] && [ "$me_DEBUG" -ge 2 ] && set -x
[ "$VERBOSE" ]  && [ "$VERBOSE" -ge 2 ]  && set -v
unset MAKE    # MAKE seems to be a global variable recognized by make ..
_debug "\$*='$*'"

#unset aNEWDIR B backUP C cleanUP cpuTYPE curDIR curDATE devSPLIT devTARGETDIR docSPLIT docTARGETDIR DO_SHIFT
#unset E ERR exeSPLIT exePKGNAME exeTARGETDIR F FILE_FILE FILE_TYPE forceIT findTIME H HAVE_F HOME
#unset INSTALL_EXE INSTALL_S INSTALL_WATCH_EXE INS_WS iNTERACTIVE L LIBTOOL_EXE LIB_TOOLS
#unset MAKE MAKE_EXE MAKE_S showMENUS me_VERBOSE mMIN nameONLY NEW nlsSPLIT nlsTARGETDIR noSTRIP
#unset oneBASE oneFILE oneMOVED oneNEW oneORIG OPTARG OUT OUTPUT
#unset PATH pkgDIR REPLY RESC RL RLM RLS RPE RPF S splitPETS timeOUT
#unset upDATE upONE V VERB VERBOSE verONLY whatSTRIP _COMMENT_ _TITLE_

[ "$me_VERBOSE" ] && echo -e "\nRunning '$INSTALL_WATCH_EXE' ... $@"
[ "$dryRUN" ] && exit 0  #for now

$INSTALL_WATCH_EXE \
 -o "$tmpDIR"/"$pkgLIST_FILE" \
 "${@}"

#installwatch -o "$tmpDIR"/"$pkgLIST_FILE" ${@}
#logsave -v "$tmpDIR"/pkginstall.logsave.list ${@}

[ $? = 0 ] || { _rm_empty_pkg_dirs; _exit 3 "
$@ apparently did not finish correctly.
"; }

pidof sync >>$OUT || ${BB}sync
}
_run_installwatch_make_install

_fix_pkglist_files(){
echo
echo -n fixing file lists ...
${BB}touch $VERB "$tmpDIR"/"$pkgLIST_FILE"
#create list of installed files...
#v2.17 bug, if sometimes logs files in the pkg installing from, have added
# filter out $upONE...
# BUGPATTERN='&'"$upONE"
# no, just filter out /mnt and /initrd...

grep '#success$' "$tmpDIR"/"$pkgLIST_FILE" | tr -s '\t' | tr '&' ' ' | tr '\t' '&' >"$tmpDIR"/"$pkgLIST_FILE".success
mv $VERB -f "$tmpDIR"/"$pkgLIST_FILE".success "$tmpDIR"/"$pkgLIST_FILE"
#echo -n " 1"
grep -Ev '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc|&/initrd|&/mnt/'  "$tmpDIR"/"$pkgLIST_FILE" >"$tmpDIR"/"$pkgLIST_FILE".success
mv $VERB -f "$tmpDIR"/"$pkgLIST_FILE".success "$tmpDIR"/"$pkgLIST_FILE"
#echo -n " 2"
grep -E '^[345]&open&' "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3 -d '&'             > "${relPATH}"/"${exePKGNAME}".files
#echo -n " 3"
grep -E '^0&symlink&'  "$tmpDIR"/"$pkgLIST_FILE" | cut -f 4 -d '&'            >> "${relPATH}"/"${exePKGNAME}".files
#echo -n " 4"
grep -E '^0&mkdir&'    "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3 -d '&' | tr -s '/' > "$tmpDIR"/"${exePKGNAME}".dirs
#echo -n " 5"
#grep -E '^0&rename&'   "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3,4 -d '&' | tr '\n' ' '  > "$tmpDIR"/"${exePKGNAME}".moved.files
grep -E '^0&rename&'   "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3,4 -d '&'           > "$tmpDIR"/"${exePKGNAME}".moved.files
#echo -n " 6"

#find out if any installed file got moved/renamed...
if [ -s "$tmpDIR"/"${exePKGNAME}".moved.files ];then
#echo -n " 61"
sort -u     "$tmpDIR"/"${exePKGNAME}".moved.files       >"$tmpDIR"/"${exePKGNAME}".moved.files.sorted
mv $VERB -f "$tmpDIR"/"${exePKGNAME}".moved.files.sorted "$tmpDIR"/"${exePKGNAME}".moved.files
#echo -n " 62"
fi
#echo -n " 7"
if [ -s "$tmpDIR"/"${exePKGNAME}".moved.files ];then
#echo -n " 71"
__fix_moved_files(){
 #for oneMOVED in `cat "$tmpDIR"/"${exePKGNAME}".moved.files`
 while read -r oneMOVED
 do
 [ "$oneMOVED" ] || continue
 _debugx "$oneMOVED"
  oneORIG=`echo "$oneMOVED" | cut -f 1 -d '&'`
   oneNEW=`echo "$oneMOVED" | cut -f 2 -d '&'`
  ${BB}grep -v "$oneORIG" "${relPATH}"/"${exePKGNAME}".files > "$tmpDIR"/"${exePKGNAME}".files
  echo "$oneNEW" >> "$tmpDIR"/"${exePKGNAME}".files
  pidof sync >>$OUT || sync
  mv $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
 done <"$tmpDIR"/"${exePKGNAME}".moved.files
}

 oldMOVED=`cut -f1 -d'&'  "$tmpDIR"/"${exePKGNAME}".moved.files`
 oldMOVED=`echo "$oldMOVED" | sed '/^$/d'`
 newMOVED=`cut -f2 -d'&'  "$tmpDIR"/"${exePKGNAME}".moved.files`
 newMOVED=`echo "$newMOVED" | sed '/^$/d'`

 [ "$oldMOVED" ] && /bin/grep -v "$oldMOVED" "${relPATH}"/"${exePKGNAME}".files > "$tmpDIR"/"${exePKGNAME}".files
 [ "$newMOVED" ] && echo "$newMOVED" >> "$tmpDIR"/"${exePKGNAME}".files
 cp $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
 echo " Done."
#echo -n " 72"
else
 echo " Not needed."
fi
#echo -n " 8"

sort -u  "${relPATH}"/"${exePKGNAME}".files >   "$tmpDIR"/"${exePKGNAME}".files
mv $VERB -f "$tmpDIR"/"${exePKGNAME}".files  "${relPATH}"/"${exePKGNAME}".files
#echo -n " 9"
pidof sync >>$OUT || sync

#echo
#echo -e "\\033[1;31mStep 5""\\033[0;39m"

#fixfilelistfunc() uses this...
#cp $VERB -af "${relPATH}"/"${exePKGNAME}".files "$tmpDIR"/"${exePKGNAME}".files
#...a post-install script could delete files, which fixfilelistfunc fixes.
##+++2012-04-30
sort -u  "${relPATH}"/"${exePKGNAME}".files >  "$tmpDIR"/"${exePKGNAME}".files
pidof sync >>$OUT || sync
cp $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
##+++2012-04-30

#TODOS :
# correct permissions for created directories
# put similar code into functions
pidof sync >>$OUT || sync
}
_fix_pkglist_files

_md5sum(){
[ -e "$*" ]  || return 1
${BB}md5sum "$*"
}

_step_five(){
echo
echo -e "\\033[1;31mStep 5""\\033[0;39m"

touch $VERB "${relPATH}"/"${exePKGNAME}".files "$tmpDIR"/"${exePKGNAME}".dirs
echo
while read -r oneFILE
do

 [ "$oneFILE" ] || continue
 oneFILE=`realpath "$oneFILE"`
 [ "$oneFILE" ] || continue

 oneBASE="${oneFILE##*/}"
 onePATH="${oneFILE%/*}"
 echo "Processing ${oneFILE}"

 #[ "$whatSTRIP" = 'ALL' ] && strip_func "$oneFILE"
  [ "$whatSTRIP" = 'ALL' ] && strip_it "$oneFILE"

 if [ "$nlsSPLIT" = "yes" ];then
  #find out if this is an international language file...
  case "$oneFILE" in */locale/*|*/nls/*|*/i18n/*)
   mkdir -p "${nlsTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${nlsTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${nlsTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${nlsTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${nlsTARGETDIR}"/files.md5
   _md5sum "${nlsTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${nlsTARGETDIR}"/files.md5
   [ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac
 fi

 if [ "$docSPLIT" = "yes" ];then
  #find out if this is a documentation file...
  case "$oneFILE" in */man/*|*/doc/*|*/docs/*|*/info/*|*/gtk-doc/*|*/faq/*|*/manual/*|*/examples/*|*/help/*|*/htdocs/*)
   mkdir -p "${docTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${docTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${docTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${docTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${docTARGETDIR}"/files.md5
   _md5sum "${docTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${docTARGETDIR}"/files.md5
   #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac
 fi

 if [ "$devSPLIT" = "yes" ];then
  #find out if this is development file...
  case "$oneFILE" in */include/*|*/pkgconfig/*|*/aclocal/*|*/automake/*|*/cvs/*|*/svn/*|*/git/*|*/intltool/*|*/libtool/*)
   mkdir -p "${devTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
   _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
   #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac

  #find *.so symlink files...
  if [ -h "$oneFILE" ];then #-h tests for symlink
   case "$oneFILE" in *.so)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #_md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    #_md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
   ;; esac
  fi

  #find various config files...
  case "$oneBASE" in *-config|*config.sh|*Conf.sh)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
  ;; esac

  #all .a and .la files... and any stray .m4 files...
  case "$oneBASE" in *.a|*.la|*.m4)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
  ;; esac
 fi #dev

 #anything left over goes into the main 'executable' package...
 if [ "$exeSPLIT" = "yes" ];then
  mkdir -p "${exeTARGETDIR}"/"${onePATH}"
  cp $VERB -af "$oneFILE" "${exeTARGETDIR}"/"${onePATH}"/ 2>>$OUT
  [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
  #[ -e "${exeTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
  #${BB}md5sum "${exeTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${exeTARGETDIR}"/files.md5
  _md5sum "${exeTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${exeTARGETDIR}"/files.md5
  [ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
  #[ -e "$oneFILE" ] && \
  #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
  _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5

  #fix for empty directories - for example /var/lib/pkgname ...
  #TODO: set correct permissions ..
  #cat "$tmpDIR"/"${exePKGNAME}".dirs |
  while read -r aNEWDIR
  do
   [ "$aNEWDIR" ] || continue
   [ -d "${exeTARGETDIR}${aNEWDIR}" ] || mkdir -p "${exeTARGETDIR}${aNEWDIR}"
  done <"$tmpDIR"/"${exePKGNAME}".dirs
 fi

done <"${relPATH}"/"${exePKGNAME}".files

echo

pidof sync >>$OUT || sync
}
_step_five

_copy_files_list(){
for d in "${relPATH}"  "/root/.packages" "${exeTARGETDIR}"
do [ -d "$d" ] || continue
cp $VERB -af "$tmpDIR"/"${exePKGNAME}".files "$d"/
done
}
_copy_files_list

fi ##rescue or default mode
####========================


_add_log_files(){
DEBUG=1
_debug Adding config log files to pkg...

logFILES=`find -type f \( -name "*.log" -o -name "*.err" -o -name "config.h" -o -iname "makefile.*" -not -name "*.in" -not -name "*.am" \) | sort | tac`
while read -r oneFILE
do
[ "$oneFILE" ] || continue
/bin/cp $VERB $iNTERACTIVE -a --backup=numbered "$oneFILE" "${exeTARGETDIR}"/ <$TTY
done << EoI
`echo "$logFILES"`
EoI
_debug DONE
DEBUG=
}
_add_log_files

_remove_whiteouts(){
##remove any whiteout files
for d in "${exeTARGETDIR}" "${nlsTARGETDIR}" "${docTARGETDIR}" "${devTARGETDIR}"
do [ -d "$d" ] || continue
find "${d}" -name "*.wh.*" -exec rm $VERB -f {} \;
done
}
_remove_whiteouts

_remove_unused_dirs(){
for d in "$exeTARGETDIR" "$devTARGETDIR" "$docTARGETDIR" "$nlsTARGETDIR"
do [ -d "$d" ] || continue
[ "`find "$d" -type f`" ] && echo "$d should now be populated." || rm $VERB -rf "$d"
done
}
_remove_unused_dirs

echo
echo -e "\\033[1;31mFinished""\\033[0;39m"

_step_six(){
echo
echo -e "\\033[1;31mStep 6""\\033[0;39m"

cat >&1 <<EoI
${relPATH}/${exePKGNAME}.files has a list of the installed files.

You might want to go into it and trim the fat or whatever,
but basically it is now ready to be converted to a PET
package. Just do this:
# cd ${relPATH}
# dir2pet $exePKGNAME

Press ENTER to exit this script.
Or, if you want the convenience, the 'dir2pet' script can be launched
right now -- press any character on the keyboard then ENTER.
EoI

echo -n "Type response here: "
read $timeOUT nextphase
[ "$nextphase" ] || { [ "$forceIT" ] && [ "$forceIT" -ge 2 ] && nextphase=y; }
if [ ! "$nextphase" ];then
echo -e "\n\nFinished.\nAll done in `pwd`?"
exit 0
fi
}
_step_six

_create_pets(){
cd "${relPATH}" || _exit 5 "Could not change into $relPATH"

for pKg in "" _DEV _DOC _NLS
do
     [ -d "${nameONLY}${pKg}-${verONLY}-${cpuTYPE}" ] || continue
 dir2pet2 "${nameONLY}${pKg}-${verONLY}-${cpuTYPE}"   || break
 echo -n "${nameONLY}${pKg}-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
read domore <$TTY
done
}
_create_pets

__make_exe_pet(){
if  [ -d "${xnameONLY}-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
__make_dev_pet(){
if  [ -d "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
__make_doc_pet(){
if  [ -d "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
__make_nls_pet(){
if  [ -d "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}

echo "Finished. All done?"

###END###
