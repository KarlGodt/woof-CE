#!/bin/bash
# ash has no select buildin

# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_new2dir"
_VERSION_=1.98   #2016-09-01 general overhaul
_VERSION_=1.99   #2016-09-02 general overhaul
_VERSION_=1.99.1 #2016-09-02 bugfixe
_VERSION_=1.99.2 #2016-09-04 speedup moved.files processing, cleanup
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/usr/bin/new2dir"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#(c) Copyright Barry Kauler 2007
#Now LGPL 2007
# Run like this: # new2dir make install
# Creates a directory one or two levels higher with the name of the package
# but slightly modified. For example source package has dir 'abiword-0.5.6'
# inside this you do the usual 'configure', 'make', then 'new2dir make install'
# and 'abiword-0.5.6-i486' directory gets created, with all installed files
# in it.

_info "\$0='$0' \$@='$@'"
TTY=`tty` # in case of interactive needs to read input from controlling terminal.

findTIME=-mmin  #default find option -mmin -amin -cmin to new2dir -r option
mMIN='-2'       #default value to findTIME option, -2 means last two minutes

whatSTRIP='ALL' #NONE: do not strip files
                #INSTALLED: strip installed files but do not strip files in the pkg folder(s)
                #ALL: Puppy default to strip installed files and copy them into the pkg folder(s)

tmpDIR=/tmp
pkgLIST_FILE=pkginstall.list

[ "$OUT" ] || OUT=/dev/null
[ "$ERR" ] || ERR=/dev/null
#BB='busybox ' # enable to use busybox applets

Version='1.7-getopts Macpup Foxy 3 Puppy-Linux-430/2 KRG'

echo "$0 : $Version"
echo 'This is an alpha snapshot
and most likely not bugfree
'

_usage(){
    echo "
$0 [-new2dir_option1 -option2 ..] make [make_options] install[-doc|-etc..]

    Script to list installed files by 'make install' using
    'installwatch/checkinstall pkg' and to copy these files into a
    seperate directory to easily be packaged further .
    Also strips binaries automatically and libraries to reduce size .

    Script specific options :
    -c) forcibly delete already existing destination pkg directory(s);
        default is to rename to pkgname-date.
    -d) debug by '' .
    -f) answer all dialog questions automatically:yes,cpu-type,
        split-level(-f default = 3); includes -k .
    -h) show this usage .
    -V) show version information .
    -i) interactive modes for binaries used by this script .
    -I/path/to/bin/installwatch) if installwatch script to use
        to monitor make install is installed not first in the PATH .
    -k) keep binaries and libraries unstripped .
    -K) strip only installed bins and libs .
    -l) run with logsave -a $tmpDIR/new2dir.log .
    -u) update already existing _DESTDIR s , do not delete _DESTIR s .
    -m) Menu for selecting various used executables .
    -M #) set the mMIN level for the find command in -r mode below;
        default is -2 (means to look for modified files not
        older than the last two minutes) .
    -A #) switch to AMIN instead of mMIN for above
    -C #) switch to CMIN instead of mMIN for above
            (cmake source seems to need this if run a second time)
    -r) rescue mode if installwatch does not work .
    -v) give verbose output by '2>/dev/stderr' .

    For make specific options, see 'man make|make --help' .
    "
    exit $1
}

if [ ! "$*" ];then
 echo "This script is used in the last step when installing a source"
 echo "or binary package. For example:"
 echo "# new2dir make install"
 echo "Exiting script."
 exit 140
fi

INFO=1
DEBUG=1
DEBUGX=1
MAKE=`echo "$@" | ${BB}grep -owe 'make.*instal[-_a-z0-9A-Z\.]\+'`
_info "MAKE='$MAKE'"
[ "$MAKE" ] || MAKE='make install'
_info "MAKE='$MAKE'"
NEW2DIRPARAMS=`echo "$@" |${BB}sed "s#$MAKE##"`
_info "NEW2DIRPARAMS='$NEW2DIRPARAMS'"
[ "`echo "$NEW2DIRPARAMS" |${BB}grep help`" ] && _usage 1  ##+++2012-07-07

while getopts VcdfhiI:kKlmM:A:C:rvu opt;do
case $opt in
c) cleanUP='y';;
d) set -x; me_DEBUG=1;;
f) timeOUT='-t 1';forceIT=$((forceIT+1));;
h) _usage 0;;
i) [ -c "$TTY" ] || _exit 2 "$opt needs controlling terminal"; iNTERACTIVE='-i';lINTERACTIVE='--interactive';;
I) INSTALL_WATCH_EXE="$OPTARG";;
k) whatSTRIP='NONE';;
K) whatSTRIP='INSTALLED';;
l)
NEW2DIRPARAMS=`echo "$NEW2DIRPARAMS" | sed 's/l//g'`  ##+++2012 added g global in case accid. more than one 'l'
exec logsave $VERB -a "$tmpDIR"/new2dir.log "$0" "$NEW2DIRPARAMS" "$MAKE"
;;
m) showMENUS=1;;
M) mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;  ##+++2012-07-07 check ~bug if -A -f
A) findTIME=-amin;mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;
C) findTIME=-cmin;mMIN=$OPTARG;echo "$mMIN" | ${BB}grep '[0-9]' || _usage 1;;##+-+2012-07-07 BUG had A)
r) RESC='YES';;
v) OUT=/dev/stdout;ERR=/dev/stderr;VERB='-v';lVERBOSE='--verbose';al_VERBOSE='-verbose';me_VERBOSE=1;;
u) upDATE=1;;
V) echo -e "\n$0 : Version '$Version'\n";exit 0;;
*) _usage 1;;
esac;done

_debug "\$@='$@'"
MAKE=`echo "$@" | ${BB}grep -owe 'make.*instal[-_a-z0-9A-Z\.]\+'`
[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"
[ "$MAKE" ] || MAKE='NONE' ##+++2012-04-03
[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"
NEW2DIRPARAMS=`echo "$@" |${BB}sed "s#$MAKE##"`
[ "$me_VERBOSE" ] && echo "NEW2DIRPARAMS='$NEW2DIRPARAMS'"

curDIR=`pwd`
[ "$me_VERBOSE" ] && echo "CURRENTDIR='$curDIR'"

upONE=`${BB}dirname "$curDIR"`
pkgDIR="../`${BB}basename "$curDIR"`"
xpkgDIR=`${BB}basename "$curDIR"`
#if make one level deep >
if [ ! "`echo "$pkgDIR" | ${BB}grep '[0-9]'`" ];then
 pkgDIR="../../`${BB}basename "$upONE"`"
 xpkgDIR=`${BB}basename "$upONE"`
fi

_do_menu(){
if [ "$showMENUS" ];then   #busybox ash has no select function
for dir in `echo $PATH |tr ":" " "`;do
INS_WS="$INS_WS `${BB}find $dir -maxdepth 1 -type f \( -name "installwatch[-_]*" -o -name "checkinstall[-_]*" \)`"
done
echo
echo "Select the installwatch executable :"  #busybox ash has no select function
select INSTALL_WATCH_EXE in $INS_WS;do echo $INSTALL_WATCH_EXE;break;done
[ "$INS_WS" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/installwatch -a ! -L /bin/installwatch ] && { echo "'/bin/installwatch' is not a link ";exit 1; }
${BB}rm $VERB -f /bin/installwatch;${BB}ln $VERB -s $INSTALL_WATCH_EXE /bin/installwatch
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/installwatch

for dir in `echo $PATH |tr ":" " "`;do
LIB_TOOLS="$LIB_TOOLS `${BB}find $dir -maxdepth 1 -type f -name "libtool[-_]*"`"
done
echo "Select the libtool executable :"
select LIBTOOL_EXE in $LIB_TOOLS;do echo $LIBTOOL_EXE;break;done
[ "$LIBTOOL_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/libtool -a ! -L /bin/libtool ] && { echo "'/bin/libtool' is not a link ";exit 1; }
${BB}rm $VERB -f /bin/libtool;${BB}ln $VERB -s $LIBTOOL_EXE /bin/libtool
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/libtool

for dir in `echo $PATH |tr ":" " "`;do
MAKE_S="$MAKE_S `${BB}find $dir -maxdepth 1 -type f -name "make[-_][0-9]*"`"
done
echo "Select the make executable :"
select MAKE_EXE in $MAKE_S;do echo $MAKE_EXE;break;done
[ "$MAKE_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /usr/bin/make -a ! -L /usr/bin/make ] && { echo "'/usr/bin/make' is not a link ";exit 1; }
${BB}rm $VERB -f /usr/bin/make;${BB}ln $VERB -s $MAKE_EXE /usr/bin/make
[ "$me_VERBOSE" ] && ${BB}ls -l /usr/bin/make
#MAKE=`echo "$MAKE" |sed "s|^make |$MAKE_EXE |"`
#[ "$me_VERBOSE" ] && echo "MAKE='$MAKE'"

for dir in `echo $PATH |tr ":" " "`;do
INSTALL_S="$INSTALL_S `${BB}find $dir -maxdepth 1 \( -type f -o -type l \) -name "install[-_][bB0-9]*"`"
done
echo "Select the install executable :"
select INSTALL_EXE in $INSTALL_S;do echo $INSTALL_EXE;break;done
[ "$INSTALL_EXE" ] || { echo "Nothing available selected ";exit 0; }
[ -e /bin/install -a ! -L /bin/install ] && { echo "'/bin/install' is not a link ";exit 1; }
if [ -e /bin/install -a "`file /bin/install | ${BB}grep busybox`" ];then
${BB}mv $VERB    /bin/install /bin/install-busybox;fi
${BB}rm $VERB -f /bin/install;${BB}ln $VERB -s $INSTALL_EXE /bin/install
[ "$me_VERBOSE" ] && ${BB}ls -l /bin/install

fi #showMENUS
}
_do_menu

_pkg_version_check(){
case $pkgDIR in *[0-9]*) return 0;; esac
cat >&1 <<EoI
$pkgDIR does not seem to be the package directory with version
number. Unfortunately, some source package tarballs expand to a
directory that does not have version number in it's name. SeaMonkey
is an example of this, it expands to a directory named just 'mozilla'.
This script will create a package with the same name as the directory
and it absolutely must have the version number in it which must commence
with a numeric digit. So, you must now close this rxvt terminal window
then rename the directory. For example, for SeaMonkey version 1.0.7
rename the directory from 'mozilla' to 'seamonkey-1.0.7'
A dash '-' must be used to separate the package name from version.
A directory name like 'seamonkey-alpha1' is NOT allowed as the version
number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'.
Exiting script.
EoI
 exit 1
}
_pkg_version_check

fixfilelistfunc() {
 #$1 is file to remove, as doesn't exist.
 echo " ...${*} has been deleted."
 ${BB}grep -v "$*" "$tmpDIR"/"${exePKGNAME}".files  >> "$tmpDIR"/"${exePKGNAME}".files.tmp
 ${BB}mv $VERB -f  "$tmpDIR"/"${exePKGNAME}".files.tmp "$tmpDIR"/"${exePKGNAME}".files
}

echo
echo -e "\\033[1;31mStep 1""\\033[0;39m" #red
read $timeOUT -n1 -p "Press any key for step 1" STEP_1_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
It seems that the package directory is '$pkgDIR'
If this is correct, just press ENTER key.
Otherwise, type the correct directory with relative address.
 NOTE:
 This script will create a package with the same name as the directory
 and it absolutely must have the version number in it which must commence
 with a numeric digit, and name and version number must be separated by
 a dash '-', for example, 'seamonkey-1.0.7'.
 A directory name like 'seamonkey-alpha1' is NOT allowed as the version
number must start with a numeric digit, example 'seamonkey-1.0.7alpha1'.
EoI
fi
echo " If $pkgDIR is incorrect you must now exit with CTRL-C and close this"
echo " rxvt terminal window then rename the directory."
read $timeOUT -p "Type response now: " REPLY1
[ "$REPLY1" ] && pkgDIR="$REPLY1"
if [ ! -d "$pkgDIR" ];then
 echo
 echo "$pkgDIR does not exist, exiting script."
 exit 1
fi
echo "Okay, using $pkgDIR"

echo
echo -e "\\033[1;31mStep 2""\\033[0;39m" #red
read $timeOUT -n1 -p "Press any key for step 2" STEP_2_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
Puppy is designed to run on a i486 CPU upwards. Normally this means
that you have to specify 'build=i486-t2-linux-gnu' (sometimes host=)
Some packages do not have that configure option and compile for a
specific CPU regardless what is in your PC.
Otherwise, enter the CPU type, examples: i386 i486 i686 (the i is required).
If you leave empty the cpu type will be looked for in 'config.log' file.
If not found defaults to 'i486' .
EoI
fi
echo "If not found and if run with '-f' option , guessed by 'uname -m' ."
echo -n "Type response here: "
read $timeOUT cpuTYPE
if [ ! "$cpuTYPE" ];then
if [ -f config.log ];then
BuildCPU=`${BB}grep '^build_cpu='.*'' config.log | tail -n1 | cut -f 2 -d "'"`
 HostCPU=`${BB}grep '^host_cpu='.*''  config.log | tail -n1 | cut -f 2 -d "'"`
if [ "$HostCPU" != "$BuildCPU" ];then
echo "NOTICE build_cpu='$BuildCPU' NOT host_cpu='$HostCPU'"
fi
cpuTYPE="$BuildCPU"
fi
if [ ! "$cpuTYPE" ];then
if [ ! "$timeOUT" ];then
cpuTYPE="i486"
else
cpuTYPE=`${BB}uname -m`
fi
else
echo "Found '$cpuTYPE'";fi;fi
#config.log >
#build='i686-pc-linux-gnu'
#build_alias=''
#build_cpu='i686'
#build_os='linux-gnu'
#build_vendor='pc'
#datadir='${prefix}/share'
#exec_prefix='${prefix}'
#host='i686-pc-linux-gnu'
#host_alias=''
#host_cpu='i386'
#host_os='linux-gnu'
#host_vendor='pc'
##bash-3.2# grep 'i[0-9]' Makefile >
#build_triplet = i686-pc-linux-gnu
#host_triplet = i686-pc-linux-gnu
#build = i686-pc-linux-gnu
#build_cpu = i686
#host = i686-pc-linux-gnu
#host_cpu = i386

#if [ ! "`echo -n "$cpuTYPE" | ${BB}grep '^[a-zA-Z]'`" ];then
case $cpuTYPE in

x86_64-*kfreebsd*-gnu | x86_64-*linux* ) ;;
powerpc64le-* | powerpc64-* | ppc*-*linux* | powerpc*-*linux* ) ;;
s390x-*linux* | s390*-*tpf* ) ;;
sparc64-*linux* | sparc*-*-solaris* ) ;;
i?86-*-solaris* )  ;;
*-*-irix6* )       ;;
ia64-*-hpux* | x86_64-*-* ) ;;
aix* ) ;;
cygwin* | mingw* | pw32* | cegcc* ) ;;
hpux* )       ;;
osf* )        ;;
solaris* )    ;;
sco3.2v5* )   ;;
sysv4.2uw2* ) ;;
sysv5* | sco5v6* | unixware* | OpenUNIX* ) ;;
sysv4 )    ;;
darwin* )  ;;
openbsd* ) ;;
i?86 | x86_64 | ppc | ppc64 ) ;;
arm*-*-* ) ;;
i386? | pe-arm-wince | pe-x86-64 ) ;;
pe-arm-.*little ) ;;
m88k* )   ;;
netbsd* ) ;;
sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX* ) ;;
vxworks* ) ;;
hppa*64* ) ;;

*)
 echo "$cpuTYPE probably not valid. Exiting."
 exit 3
;;
esac
echo "Okay, using $cpuTYPE"

#would like to create different targets for exe, doc, dev, nls components...
exeTARGETDIR="${pkgDIR}-${cpuTYPE}" #relative path.
exePKGNAME=`${BB}basename "$exeTARGETDIR"`
   relPATH=`${BB}dirname  "$exeTARGETDIR"`

_debug "exeTARGETDIR='$exeTARGETDIR'"
_debug "exePKGNAME='$exePKGNAME'"
_debug "relPATH='$relPATH'"

#difficult task, separate package name from version part...
#not perfect, some start with non-numeric version info...
xnameONLY=`echo "$xpkgDIR" |${BB}sed -e 's/[\-\_][0-9].*$//g'`
_debugx "xnameONLY='$xnameONLY'"
_debugx "  xpkgDIR='$xpkgDIR'"

#...if that fails, do it the old way...
#[ "$xnameONLY" = "$xpkgDIR" ] && xnameONLY=`echo "$xpkgDIR" | cut -f 1 -d "-"`
#[ "$xnameONLY" = "$xpkgDIR" ] && xnameONLY=`echo "$xpkgDIR" | sed 's,[\-\_].*,,'`
#[ "$xnameONLY" = "$xpkgDIR" ] && xnameONLY=`echo "$xpkgDIR" | sed 's,[-_].*,,'`
#[ "$xnameONLY" = "$xpkgDIR" ] && xnameONLY=`echo "$xpkgDIR" | rev |cut -f 2- -d '[-_]' |rev`

[ "$xnameONLY" = "$xpkgDIR" ] && {
    xnameONLY=`echo "$xpkgDIR" |${BB}rev`;
    xnameONLY="${xnameONLY#*[-_]}";
    xnameONLY=`echo "$xnameONLY" |${BB}rev`;
}

_debugx "xnameONLY='$xnameONLY'"
nameONLY="${relPATH}/${xnameONLY}"
_debugx "nameONLY='$nameONLY'"

#abasename=`basename ${pkgDIR}`
#apattern="s/${xnameONLY}[\\-\\_]//g" ##does not work today 2016-09-04 bash
aPattern="s/${xnameONLY}[-_]//g"
_debugx "aPattern='$aPattern'"
verONLY=`echo "$xpkgDIR" |${BB}sed -e "$aPattern"`
_debugx "verONLY='$verONLY'"

if [ "$verONLY" = "$xpkgDIR" ];then
verONLY=`echo "$xpkgDIR" |${BB}sed 's,[[:alpha:]],,g;s,^\-*,,'`
_debug "verONLY='$verONLY'"
fi

_no_orig(){ # debian source
verONLY="${verONLY//.orig/}"
}

_info "verONLY='$verONLY'"

exeTARGETDIR="${nameONLY}-${verONLY}-${cpuTYPE}"
exePKGNAME=`${BB}basename "$exeTARGETDIR"`
docTARGETDIR="${nameONLY}_DOC-${verONLY}-${cpuTYPE}"
docPKGNAME=`${BB}basename "$docTARGETDIR"`
devTARGETDIR="${nameONLY}_DEV-${verONLY}-${cpuTYPE}"
devPKGNAME=`${BB}basename "$devTARGETDIR"`
nlsTARGETDIR="${nameONLY}_NLS-${verONLY}-${cpuTYPE}"
nlsPKGNAME=`${BB}basename "$nlsTARGETDIR"`

_debug "exeTARGETDIR=$exeTARGETDIR"
_debug "exePKGNAME=$exePKGNAME"
_debug "docTARGETDIR=$docTARGETDIR"
_debug "docPKGNAME=$docPKGNAME"
_debug "devTARGETDIR=$devTARGETDIR"
_debug "devPKGNAME=$devPKGNAME"
_debug "nlsTARGETDIR=$nlsTARGETDIR"
_debug "nlsPKGNAME=$nlsPKGNAME"

#exit

__cleanup(){
if [ "$cleanUP" -a ! "$upDATE" ];then
${BB}rm $VERB -rf "$exeTARGETDIR"*
${BB}rm $VERB -rf "$docTARGETDIR"*
${BB}rm $VERB -rf "$devTARGETDIR"*
${BB}rm $VERB -rf "$nlsTARGETDIR"*
fi
}

echo
echo -e "\\033[1;31mStep 3""\\033[0;39m"  #red
read $timeOUT -n1 -p "Press any key for step 3" STEP_3_KEY
echo
if [ ! "$forceIT" ];then
cat >&1 <<EoI
If you wish, you can split the final package up into separate
packages for the 'executables', 'documentation', 'development' and
'international' components.
If the package has shared libraries, it is recommended to at least
create a seaparate 'development' package.
The idea here is to 'trim the fat' as much as possible so that you only
have what is absolutely needed in the 'executables' PET package, but
the extra components can be installed if needed.
WARNING: The automatic splitting performed by this script may not be
         perfect and you may have to modify the contents of the created
         separate directories before the final step of converting them
         to PET packages.

Just press ENTER key only to create one package only.
Or, type a number to choose which separate packages to create:
 1 Just one package (directory) only
 2 Create a separate 'development' package
 3 Create separate 'development', 'documentation', 'international' pkgs
Or, type a comma-separated list of the separate pkgs that you want to
create, using these keywords: 'exe', 'dev', 'doc', 'nls'.
EoI
fi
echo " Example: exe,dev,doc  (in this example, nls component is left in the"
echo " main package, that is, the exe component)."
echo -n "Type response (just press ENTER if in doubt): "
read $timeOUT splitPETS
echo

[ "$timeOUT" ] && splitPETS=3

case $splitPETS in
1|'') splitPETS="exe";;
2)    splitPETS="exe,dev";;
3|*)  splitPETS="exe,dev,doc,nls";;
esac

unset exeSPLIT docSPLIT devSPLIT nlsSPLIT
case $splitPETS in *exe*) exeSPLIT="yes";; esac
case $splitPETS in *doc*) docSPLIT="yes";; esac
case $splitPETS in *dev*) devSPLIT="yes";; esac
case $splitPETS in *nls*) nlsSPLIT="yes";; esac

echo "Will create $splitPETS packages"
echo

_rm_empty_pkg_dirs(){
${BB}rmdir $VERB -f "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
}
_rm_recursive_pkg_dirs(){
${BB}rm $VERB -rf "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
}
_backup_old_pkg_dirs(){
curDATE=`${BB}date +%F-%T`
 for d in "$exeTARGETDIR" "$docTARGETDIR" "$devTARGETDIR" "$nlsTARGETDIR"
 do
 [ -d "$d" ] && ${BB}mv $VERB "$d" "$d"-"$curDATE"
 done
}

_prepare_pkd_dirs(){
if [ ! "$cleanUP" -a "$upDATE" = "" ];then  ##+++2012-07-08 added upDATE support 2012-09-29 changed -o to -a
 _backup_old_pkg_dirs
elif [ "$upDATE" ];then : #true, do nothing
else
 #${BB}rm $VERB -rf "$exeTARGETDIR"* "$docTARGETDIR"* "$devTARGETDIR"* "$nlsTARGETDIR"*
 _rm_recursive_pkg_dirs
fi
}
_prepare_pkd_dirs #probably should be run after installwatch make install

_make_pkg_dirs(){
case $splitPETS in *exe*) mkdir $VERB -p "$exeTARGETDIR";; esac
case $splitPETS in *doc*) mkdir $VERB -p "$docTARGETDIR";; esac
case $splitPETS in *dev*) mkdir $VERB -p "$devTARGETDIR";; esac
case $splitPETS in *nls*) mkdir $VERB -p "$nlsTARGETDIR";; esac
}
_make_pkg_dirs #probably should be run after installwatch make install

#function
strip_func(){
#strip the file...
 [ -L "$*" ] && return 0
 _debug "$*"
  elf_FILE=`file "$*" | ${BB}grep -E 'ELF|LSB'`

  case $elf_FILE in
   *shared*object*) strip $VERB --strip-debug    "$*";;
   *executable*)    strip $VERB --strip-unneeded "$*";;
  esac
  RV=$?
 pidof sync >>$OUT || sync
return $RV
}
#function
strip_it(){
#[ "`echo "$*" | ${BB}grep '\.[[:alnum:]]*$' | ${BB}grep -vE '\.so$|\.so\.[\.0-9]*$'`" ] && { [ "$me_VERBOSE" ] && echo "'$*' not considered stripable";return 0; }
case $* in */data/*|*.au|*.bmp|*.flv|*.gif|*.gs|*.*htm*|*.map|*.mp[0-9]|*.pbm|*.png|*.pnm|*.jpg|*.jpeg|*.pdf|*.tiff|*.txt|*.wav|*.xbm|*.xpm)
 [ "$me_VERBOSE" ] && echo "'$*' not considered stripable"
 return 0;;
*) :;;
esac
strip_func "$@"
}
#function

strip_func(){ #normal mode
#strip the file...
 [ -L "$*" ] && return 0 #make sure it isn't a symlink
 _debug "$*"
  elf_TYPE=`file "$*" | grep -Ew 'ELF|LSB'`
  case $elf_TYPE in
  *ELF*shared*object*) strip $VERB --strip-debug "$*";;
  *ELF*executable*)    strip $VERB --strip-unneeded "$*";;
  esac
  RV=$?
 pidof sync >>$OUT || sync
return $RV
}

#function
copy_files(){
STATUS=0
echo "Processing ${1}"
if [ -f "$1" ];then
    if [ "$noSTRIP" ]; then :
    else
    [ "$whatSTRIP" = 'ALL' ] && { strip_it "$1"; STATUS=$((STATUS+1)); }
    fi
/bin/cp -a $VERB $backUP $iNTERACTIVE "${1}" "${2}${1}" <$TTY
STATUS=$((STATUS+1))
   if [ "$noSTRIP" ]; then :
   else
[ "$whatSTRIP" = 'INSTALLED' ] && { strip_it "$1"; STATUS=$((STATUS+1)); }
   fi
   if [ ! -L "$1" ]; then
   ${BB}md5sum "$1" >>"${2//\.\.\//}".md5
   ${BB}md5sum "${2}${1}" >>"${2}"/files.md5
   fi
elif [ -L "$1" -a ! -d "$1" ];then
 RL=`${BB}readlink    "$1"`
RLF=`${BB}readlink -f "$1"`
RLE=`${BB}readlink -e "$1"`
RLM=`${BB}readlink -m "$1"`
RLS="$RL
$RPF
$RPE
$RLM"
RLS=`echo "$RLS" | ${BB}sort -u`

while read -r link; do
[ "$link" ] || continue
/bin/cp -a $VERB $backUP $iNTERACTIVE "${link}" "${2}${link}" <$TTY
STATUS=$((STATUS+1))
done <<EoI
$(echo "$RLS")
EoI

fi
unset noSTRIP link
return $STATUS
}

_rescue_mode_search(){
echo "
searching for modified files '$findTIME' '$mMIN' .."
echo -n "In /usr .. "
time F=`${BB}find /usr $findTIME $mMIN`
echo -n "   /etc .. "
if [ ! "`echo "$exeTARGETDIR" | ${BB}grep 'cups'`" ];then
time E=`${BB}find /etc $findTIME $mMIN | ${BB}grep -vi 'cups'`  #certs file gets updated apparently by cupsd
else
time E=`${BB}find /etc $findTIME $mMIN`
fi
echo -n "   /sbin .. "
time S=`${BB}find /sbin $findTIME $mMIN`
echo -n "   /bin .. "
time B=`${BB}find /bin $findTIME $mMIN`
echo -n "   /lib .. "
time L=`${BB}find /lib $findTIME $mMIN`
echo -n "   /var .. "
time V=`${BB}find /var $findTIME $mMIN -iname "*$xnameONLY*"`  ###+2013-03-15 Typo was "*xnameONLY*"
echo

C="$F
$E
$S
$B
$L
$V"
C=`echo "$C" |${BB}sort`

###---2013-03-15 for filename with spaces
while read -r i
do
[ "$i" ] || continue
_info "$i"

dn="${i%/*}"

case $i in
*.la|*.a|*.h|*.hpp|*.h++|*.m4|*.pc|*-config|*config.sh|*Conf*.sh|*/aclocal/*|*/automake/*|*/cvs/*|*/svn/*|*/git/*|*/intltool/*|*/libtool/*)
${BB}mkdir $VERB -p "${devTARGETDIR}${dn}"
noSTRIP=Y copy_files "$i" "${devTARGETDIR}"
;;
###+++2013-03-15 added noSTRIP FLAG
*/doc/*|*/man/*|*/docs/*|*/info/*|*/gtk-doc/*|*/faq/*|*/manual/*|*/examples/*|*/help/*|*/htdocs/*)
${BB}mkdir $VERB -p "${docTARGETDIR}${dn}"
noSTRIP=Y copy_files "$i" "${docTARGETDIR}"
;;
*/locale/*|*/i18n/*|*/nls/*)
${BB}mkdir $VERB -p "${nlsTARGETDIR}${dn}"
noSTRIP=Y copy_files "$i" "${nlsTARGETDIR}"
;;
*)
${BB}mkdir $VERB -p "${exeTARGETDIR}${dn}"
copy_files "$i" "${exeTARGETDIR}"
;;
esac

done <<EoI
$(echo "$C")
EoI

###+++2013-03-15 for filename with spaces
echo "DONE cp files."

logFILES=`find -type f \( -name "*.log" -o -name "*.err" -o -name "config.h" -o -iname "makefile.*" -not -name "*.in" -not -name "*.am" \) | sort | tac`
while read -r oneFILE
do
[ "$oneFILE" ] || continue
/bin/cp $VERB $iNTERACTIVE -a --backup=numbered "$oneFILE" "${exeTARGETDIR}"/"${oneFILE##*/}" <$TTY
done << EoI
`echo "$logFILES"`
EoI


echo "DONE cp log files."
echo "$C"      >"${relPATH}"/"${exePKGNAME}".files
echo "$C" >"$HOME"/.packages/"${exePKGNAME}".files

_remove_whiteouts(){
for d in "${exeTARGETDIR}" "${devTARGETDIR}" "${docTARGETDIR}" "${nlsTARGETDIR}"
do [ -d "$d" ] || continue
find "${d}" -name "*.wh.*" -delete
done
}
_remove_whiteouts

(
#${BB}rmdir $VERB "${devTARGETDIR}"* "${docTARGETDIR}"* "${nlsTARGETDIR}"*
_rm_empty_pkg_dirs
) 2>>$ERR

return $STATUS
}

if [ "$RESC" = 'YES' ];then
##rescue mode
_rescue_mode_search
exit $?

else
# Puppy default to use installwatch


__installwatch(){
export LD_PRELOAD=/usr/lib/installwatch.so
export INSTALLWATCHFILE="$tmpDIR"/"$pkgLIST_FILE"
make install
}

_installwatch(){

for p in "$@"; do
case $p in
-o) shift; INSTALLWATCHFILE="$1";;
*) makePARAMS="$p";;
esac
shift
done

set - "$makePARAMS"
[ "$me_DEBUG" ]   && set -x
unset makePARAMS

export LD_PRELOAD=/usr/lib/installwatch.so
export INSTALLWATCHFILE
 "$@"
}

if [ ! "$INSTALL_WATCH_EXE" ];then
 INSTALL_WATCH_EXE='installwatch'
 [ "`which $INSTALL_WATCH_EXE`" ] || { echo -e "\\033[1;31m'$INSTALL_WATCH_EXE' seems not to be installed \(correctly?\)\\033[0;39m";exit 1; }
fi

echo
echo -e "\\033[1;31mStep 4""\\033[0;39m"
read $timeOUT -n1 -p "Press any key for step 4" STEP_4_KEY
echo
echo "The following line is about to be executed:"
echo "# $INSTALL_WATCH_EXE -o $tmpDIR/$pkgLIST_FILE $MAKE"

if [ ! "$forceIT" ];then
echo "...this logs all file activity to $tmpDIR/$pkgLIST_FILE"
echo "This script will then determine all newly created directories"
echo "and files and create '$exeTARGETDIR' with the new files."
echo "\(and optionally ${devTARGETDIR}, ${docTARGETDIR}, ${nlsTARGETDIR}\)"
#fi

echo -n "Press ENTER key to continue: "
read $timeOUT goforit
echo
fi

[ -z "$INSTALL_WATCH_EXE" ] && { echo "installwatch not installed?"; ${BB}sleep 2s;_usage 1; }

${BB}rm $VERB -f "$tmpDIR"/"$pkgLIST_FILE"
${BB}sleep 2s;pidof sync >>$OUT || { ${BB}sync; sleep 2; }

DEBUG=1
_debug "MAKE='$MAKE'"
set - $MAKE
[ "$me_DEBUG" ]   && set -x
unset MAKE    # MAKE seems to be a global variable recognized by make ..
_debug "\$*='$*'"

#unset aNEWDIR B backUP C cleanUP cpuTYPE curDIR curDATE devSPLIT devTARGETDIR docSPLIT docTARGETDIR DO_SHIFT
#unset E ERR exeSPLIT exePKGNAME exeTARGETDIR F FILE_FILE FILE_TYPE forceIT findTIME H HAVE_F HOME
#unset INSTALL_EXE INSTALL_S INSTALL_WATCH_EXE INS_WS iNTERACTIVE L LIBTOOL_EXE LIB_TOOLS
#unset MAKE MAKE_EXE MAKE_S showMENUS me_VERBOSE mMIN nameONLY NEW nlsSPLIT nlsTARGETDIR noSTRIP
#unset oneBASE oneFILE oneMOVED oneNEW oneORIG OPTARG OUT OUTPUT
#unset PATH pkgDIR REPLY RESC RL RLM RLS RPE RPF S splitPETS timeOUT
#unset upDATE upONE V VERB VERBOSE verONLY whatSTRIP _COMMENT_ _TITLE_

[ "$me_VERBOSE" ] && echo -e "\nRunning '$INSTALL_WATCH_EXE' ... $@"

$INSTALL_WATCH_EXE \
 -o "$tmpDIR"/"$pkgLIST_FILE" \
 "${@}"

#installwatch -o "$tmpDIR"/"$pkgLIST_FILE" ${@}
#logsave -v "$tmpDIR"/pkginstall.logsave.list ${@}

[ $? = 0 ] || { _rm_empty_pkg_dirs; _exit 3 "
$@ apparently did not finish correctly.
"; }

pidof sync >>$OUT || ${BB}sync

echo
echo -n fixing file lists ...
${BB}touch $VERB "$tmpDIR"/"$pkgLIST_FILE"
#create list of installed files...
#v2.17 bug, if sometimes logs files in the pkg installing from, have added
# filter out $upONE...
# BUGPATTERN='&'"$upONE"
# no, just filter out /mnt and /initrd...

grep '#success$' "$tmpDIR"/"$pkgLIST_FILE" | tr -s '\t' | tr '&' ' ' | tr '\t' '&' >"$tmpDIR"/"$pkgLIST_FILE".success
mv $VERB -f "$tmpDIR"/"$pkgLIST_FILE".success "$tmpDIR"/"$pkgLIST_FILE"
#echo -n " 1"
grep -Ev '&/dev/tty&|&/dev/null&|&/root/\.packages/|&/tmp/|&/root/\.icewm/|&/proc/|&/sys/|DotPupTmpDir|/\.myownmenuerc|&/initrd|&/mnt/'  "$tmpDIR"/"$pkgLIST_FILE" >"$tmpDIR"/"$pkgLIST_FILE".success
mv $VERB -f "$tmpDIR"/"$pkgLIST_FILE".success "$tmpDIR"/"$pkgLIST_FILE"
#echo -n " 2"
grep -E '^[345]&open&' "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3 -d '&'             > "${relPATH}"/"${exePKGNAME}".files
#echo -n " 3"
grep -E '^0&symlink&'  "$tmpDIR"/"$pkgLIST_FILE" | cut -f 4 -d '&'            >> "${relPATH}"/"${exePKGNAME}".files
#echo -n " 4"
grep -E '^0&mkdir&'    "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3 -d '&' | tr -s '/' > "$tmpDIR"/"${exePKGNAME}".dirs
#echo -n " 5"
#grep -E '^0&rename&'   "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3,4 -d '&' | tr '\n' ' '  > "$tmpDIR"/"${exePKGNAME}".moved.files
grep -E '^0&rename&'   "$tmpDIR"/"$pkgLIST_FILE" | cut -f 3,4 -d '&'           > "$tmpDIR"/"${exePKGNAME}".moved.files
#echo -n " 6"

#find out if any installed file got moved/renamed...
if [ -s "$tmpDIR"/"${exePKGNAME}".moved.files ];then
#echo -n " 61"
sort -u     "$tmpDIR"/"${exePKGNAME}".moved.files       >"$tmpDIR"/"${exePKGNAME}".moved.files.sorted
mv $VERB -f "$tmpDIR"/"${exePKGNAME}".moved.files.sorted "$tmpDIR"/"${exePKGNAME}".moved.files
#echo -n " 62"
fi
#echo -n " 7"
if [ -s "$tmpDIR"/"${exePKGNAME}".moved.files ];then
#echo -n " 71"
__fix_moved_files(){
 #for oneMOVED in `cat "$tmpDIR"/"${exePKGNAME}".moved.files`
 while read -r oneMOVED
 do
 [ "$oneMOVED" ] || continue
 _debugx "$oneMOVED"
  oneORIG=`echo "$oneMOVED" | cut -f 1 -d '&'`
   oneNEW=`echo "$oneMOVED" | cut -f 2 -d '&'`
  ${BB}grep -v "$oneORIG" "${relPATH}"/"${exePKGNAME}".files > "$tmpDIR"/"${exePKGNAME}".files
  echo "$oneNEW" >> "$tmpDIR"/"${exePKGNAME}".files
  pidof sync >>$OUT || sync
  mv $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
 done <"$tmpDIR"/"${exePKGNAME}".moved.files
}

 oldMOVED=`cut -f1 -d'&'  "$tmpDIR"/"${exePKGNAME}".moved.files`
 oldMOVED=`echo "$oldMOVED" | sed '/^$/d'`
 newMOVED=`cut -f2 -d'&'  "$tmpDIR"/"${exePKGNAME}".moved.files`
 newMOVED=`echo "$newMOVED" | sed '/^$/d'`

 [ "$oldMOVED" ] && /bin/grep -v "$oldMOVED" "${relPATH}"/"${exePKGNAME}".files > "$tmpDIR"/"${exePKGNAME}".files
 [ "$newMOVED" ] && echo "$newMOVED" >> "$tmpDIR"/"${exePKGNAME}".files
 cp $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
 echo " Done."
#echo -n " 72"
else
 echo " Not needed."
fi
#echo -n " 8"

sort -u  "${relPATH}"/"${exePKGNAME}".files >   "$tmpDIR"/"${exePKGNAME}".files
mv $VERB -f "$tmpDIR"/"${exePKGNAME}".files  "${relPATH}"/"${exePKGNAME}".files
#echo -n " 9"
pidof sync >>$OUT || sync

#echo
#echo -e "\\033[1;31mStep 5""\\033[0;39m"

#fixfilelistfunc() uses this...
#cp $VERB -af "${relPATH}"/"${exePKGNAME}".files "$tmpDIR"/"${exePKGNAME}".files
#...a post-install script could delete files, which fixfilelistfunc fixes.
##+++2012-04-30
sort -u  "${relPATH}"/"${exePKGNAME}".files >  "$tmpDIR"/"${exePKGNAME}".files
pidof sync >>$OUT || sync
cp $VERB -f "$tmpDIR"/"${exePKGNAME}".files "${relPATH}"/"${exePKGNAME}".files
##+++2012-04-30

#TODOS :
# correct permissions for created directories
# put similar code into functions

_md5sum(){
[ -e "$*" ]  || return 1
${BB}md5sum "$*"
}

pidof sync >>$OUT || sync

echo
echo -e "\\033[1;31mStep 5""\\033[0;39m"

touch $VERB "${relPATH}"/"${exePKGNAME}".files "$tmpDIR"/"${exePKGNAME}".dirs
echo
while read -r oneFILE
do

 [ "$oneFILE" ] || continue
 oneBASE="${oneFILE##*/}"
 onePATH="${oneFILE%/*}"
 echo "Processing ${oneFILE}"

 [ "$whatSTRIP" = 'ALL' ] && strip_func "$oneFILE"

 if [ "$nlsSPLIT" = "yes" ];then
  #find out if this is an international language file...
  case "$oneFILE" in */locale/*|*/nls/*|*/i18n/*)
   mkdir -p "${nlsTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${nlsTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${nlsTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${nlsTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${nlsTARGETDIR}"/files.md5
   _md5sum "${nlsTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${nlsTARGETDIR}"/files.md5
   [ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac
 fi

 if [ "$docSPLIT" = "yes" ];then
  #find out if this is a documentation file...
  case "$oneFILE" in */man/*|*/doc/*|*/docs/*|*/info/*|*/gtk-doc/*|*/faq/*|*/manual/*|*/examples/*|*/help/*|*/htdocs/*)
   mkdir -p "${docTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${docTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${docTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${docTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${docTARGETDIR}"/files.md5
   _md5sum "${docTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${docTARGETDIR}"/files.md5
   #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac
 fi

 if [ "$devSPLIT" = "yes" ];then
  #find out if this is development file...
  case "$oneFILE" in */include/*|*/pkgconfig/*|*/aclocal/*|*/automake/*|*/cvs/*|*/svn/*|*/git/*|*/intltool/*|*/libtool/*)
   mkdir -p "${devTARGETDIR}"/"${onePATH}"
   cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
   [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
   #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
   #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
   _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
   #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
   #[ -e "$oneFILE" ] && \
   #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
   continue
  ;; esac

  #find *.so symlink files...
  if [ -h "$oneFILE" ];then #-h tests for symlink
   case "$oneFILE" in *.so)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #_md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    #_md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
   ;; esac
  fi

  #find various config files...
  case "$oneBASE" in *-config|*config.sh|*Conf.sh)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
  ;; esac

  #all .a and .la files... and any stray .m4 files...
  case "$oneBASE" in *.a|*.la|*.m4)
    mkdir -p "${devTARGETDIR}"/"${onePATH}"
    cp $VERB -af "$oneFILE" "${devTARGETDIR}"/"${onePATH}"/ 2>>$OUT
    [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
    #[ -e "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
    #${BB}md5sum "${devTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    _md5sum "${devTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${devTARGETDIR}"/files.md5
    #[ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
    #[ -e "$oneFILE" ] && \
    #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
    continue
  ;; esac
 fi #dev

 #anything left over goes into the main 'executable' package...
 if [ "$exeSPLIT" = "yes" ];then
  mkdir -p "${exeTARGETDIR}"/"${onePATH}"
  cp $VERB -af "$oneFILE" "${exeTARGETDIR}"/"${onePATH}"/ 2>>$OUT
  [ $? -ne 0 ] && fixfilelistfunc "$oneFILE"
  #[ -e "${exeTARGETDIR}"/"${onePATH}"/"${oneBASE}" ] && \
  #${BB}md5sum "${exeTARGETDIR}"/"${onePATH}"/"${oneBASE}" >>"${exeTARGETDIR}"/files.md5
  _md5sum "${exeTARGETDIR}""${onePATH}"/"${oneBASE}" >>"${exeTARGETDIR}"/files.md5
  [ "$whatSTRIP" = 'INSTALLED' ] && strip_func "$oneFILE"
  #[ -e "$oneFILE" ] && \
  #${BB}md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5
  _md5sum "$oneFILE" >>"${exePKGNAME//\.\.\//}".md5

  #fix for empty directories - for example /var/lib/pkgname ...
  #TODO: set correct permissions ..
  #cat "$tmpDIR"/"${exePKGNAME}".dirs |
  while read -r aNEWDIR
  do
   [ "$aNEWDIR" ] || continue
   [ -d "${exeTARGETDIR}${aNEWDIR}" ] || mkdir -p "${exeTARGETDIR}${aNEWDIR}"
  done <"$tmpDIR"/"${exePKGNAME}".dirs
 fi

done <"${relPATH}"/"${exePKGNAME}".files

echo

pidof sync >>$OUT || sync

_copy_files_list(){
for d in "${relPATH}"  "/root/.packages" "${exeTARGETDIR}"
do [ -d "$d" ] || continue
cp $VERB -af "$tmpDIR"/"${exePKGNAME}".files "$d"/
done
}
_copy_files_list

fi ##rescue or default mode
####========================

DEBUG=1
_debug Adding config log files to pkg...

logFILES=`find -type f \( -name "*.log" -o -name "*.err" -o -name "config.h" -o -iname "makefile.*" -not -name "*.in" -not -name "*.am" \) | sort | tac`
while read -r oneFILE
do
[ "$oneFILE" ] || continue
/bin/cp $VERB $iNTERACTIVE -a --backup=numbered "$oneFILE" "${exeTARGETDIR}"/ <$TTY
done << EoI
`echo "$logFILES"`
EoI
_debug DONE
DEBUG=

_remove_whiteouts(){
##remove any whiteout files
for d in "${exeTARGETDIR}" "${nlsTARGETDIR}" "${docTARGETDIR}" "${devTARGETDIR}"
do [ -d "$d" ] || continue
find "${d}" -name "*.wh.*" -exec rm $VERB -f {} \;
done
}
_remove_whiteouts

echo
echo -e "\\033[1;31mFinished""\\033[0;39m"

_remove_unused_dirs(){
for d in "$exeTARGETDIR" "$devTARGETDIR" "$docTARGETDIR" "$nlsTARGETDIR"
do [ -d "$d" ] || continue
[ "`find "$d" -type f`" ] && echo "$d should now be populated." || rm $VERB -rf "$d"
done
}
_remove_unused_dirs

cat >&1 <<EoI
${relPATH}/${exePKGNAME}.files has a list of the installed files.

You might want to go into it and trim the fat or whatever,
but basically it is now ready to be converted to a PET
package. Just do this:
# cd ${relPATH}
# dir2pet $exePKGNAME

Press ENTER to exit this script.
Or, if you want the convenience, the 'dir2pet' script can be launched
right now -- press any character on the keyboard then ENTER.
EoI

echo -n "Type response here: "
read $timeOUT nextphase
[ "$nextphase" ] || { [ "$forceIT" ] && [ "$forceIT" -ge 2 ] && nextphase=y; }
if [ ! "$nextphase" ];then
echo -e "\n\nFinished.\nAll done in `pwd`?"
exit 0
fi

cd "${relPATH}" || _exit 5 "Could not change into $relPATH"

for pKg in "" _DEV _DOC _NLS
do
     [ -d "${xnameONLY}${pKg}-${verONLY}-${cpuTYPE}" ] || continue
 dir2pet2 "${xnameONLY}${pKg}-${verONLY}-${cpuTYPE}"   || break
 echo -n "${xnameONLY}${pKg}-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
read domore <$TTY
done

__make_exe_pet(){
if  [ -d "${xnameONLY}-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
__make_dev_pet(){
if  [ -d "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_DEV-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
__make_doc_pet(){
if  [ -d "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_DOC-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}
_make_nls_pet(){
if  [ -d "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}" ];then
 dir2pet "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}"
 if test $? = 0; then
  echo -n "${xnameONLY}_NLS-${verONLY}-${cpuTYPE}.pet created. Press ENTER to continue: "
  read domore
 else
  exit 4
 fi
fi
}

echo "Finished. All done?"

###END###
