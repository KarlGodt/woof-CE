#!/bin/bash
# ROX app.: Click image files to mount & unmount.
# by: Terry Becker  aka: SunBurnt
# File types = ".2fs, .3fs, .sfs, .iso, & old  ext2 initrd.gz".



#************
#KRG

OUT=/dev/null;ERR=$OUT
[ "$DEBUG" ] && { OUT=/dev/stdout;ERR=/dev/stderr; }
[ "$DEBUG" = 2 ] && set -x

Version=1.1-KRG-MacPup_O2

usage(){
MSG="
$0 [ help | version ]
"
echo "$MSG
$2"
exit $1
}
[ "`echo "$1" | grep -wEi "help|\-h"`" ] && usage 0
[ "`echo "$1" | grep -wEi "version|\-V"`" ] && { echo "$0: $Version";exit 0; }

trap "exit" HUP INT QUIT ABRT KILL TERM

#KRG
#************


#v423 detect wrong squashfs version 3.x or 4.x.
#v424 advise of sfs-version-converter.

# KRG code clean up, resurrect initrd check and mount if disktype can get a fs inside
# KRG some sanity checks, usage and options, UDF support for .iso, simple GUI for mount flavours
# KRG better error message for wrong squashfs, .squashfs and .sqfs extensions
# TODO much, kernel 3.x, support more filesystems, port npierce improvements, port encryption mounting

Version='1.1-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'

usage (){
MSG="
$0 [-h -V -l ] FILENAME.sfs

-h) show this usage message
-V) emitt version information
-l) log to /tmp/filemnt.log
-d) debug with 'set -x'
-v) verbose output
"
echo "$MSG"
[ "$DISPLAY" ] && xmessage -bg green3 "$MSG"
exit $1
}

OUT=/dev/null;ERR=/dev/null
while getopts lhV opt;do
case $opt in
h) usage 0;;
V) echo -e "\n$0 : Version '$Version'\n";exit 0;;
l) exec 1>>/tmp/filemnt.log 2>&1;;
d) DEBUG=1;set -x;;
v) VERBOSE=1;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;OUT=/dev/stdout;ERR=/dev/stderr;;
*) :;;
esac;done

#v423...
KERNELVER=`uname -r`
KERNEL_MAJOR=`echo -n "$KERNELVER" | cut -f 1 -d '.'`
KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-'`
SFSSTR='squashfs, version 4'
if [ "$KERNEL_MAJOR" -lt 3 ] ; then
[ $KERNELSUBVER -lt 29 ] && SFSSTR='squashfs, version 3'
fi

 ImgFile="$1"
 echo "ImgFile='$ImgFile'"
 if [ -z "$ImgFile" ];then echo "Need parameter or filename. Try -h for little more info.";exit 1 ;fi
 [ -f "$ImgFile" ] || { echo "'$ImgFile' seems not to exist (in $PWD)";exit 1; }
 #if [ "`basename "$ImgFile"`" = 'initrd' ] ;then gzip -9 $ImgFile;ImgFile="${ImgFile}.gz";WoExt=Y;fi #2012-06-02

 if [ "`dirname "$ImgFile"`" = '\.' ] ;then  #2012-06-02
  ImgFile=`pwd``echo "$ImgFile" |sed 's/^\.//'` #2012-06-02
 fi

 MntPt='/mnt/'`echo "$ImgFile" |sed "s#^\.##g" |sed "s#/#+#g"`
 ##NEW##
 MntPt='/mnt/'`basename "$ImgFile"`.$$
 MntPtBASE="${MntPt%%\.*}"
 ##NEW##

ImgFileBASE=`basename "$ImgFile"` #BK

if [ ! -d "$MntPt" ] ;then #! -d MntPt

check_already_mounted_func(){

  #BK check if already mounted elsewhere...
  for ONELOOP in `mount | grep ^[\'\"/]*dev/loop | cut -f 1 -d ' ' | tr '\n' ' '`
  do

   echo "ONELOOP='$ONELOOP'" #DEBUG
   ONELOOP=`echo "$ONELOOP" |sed s,^[\"\'],,| sed s,[\"\']$,,`

   MNTDIMG=`losetup-FULL "$ONELOOP" | cut -f 2 -d '(' | cut -f 1 -d ')'`
   IMGBASE=`basename "$MNTDIMG"`

    echo "IMGBASE='$IMGBASE' ImgFileBASE='$ImgFileBASE'" #DEBUG
    #not perfect, but paths may be symlinks...

    if [ "$IMGBASE" = "$ImgFileBASE" ];then #MOUNTED ELSEWHERE # if [ "$MNTDIMG" = "$ImgFile" ];then

     if [ -n "$DISPLAY" ] ; then #DISPLAY
xmessage -buttons "Quit:190,ROX-Filer:191,console:192,Unmount:193,Unmount all $IMGBASE:194,Mount another time:199" "$ImgFile
is already mounted and in-use by Puppy .
Do you want to unmount it or mount it to another mount point ?"
RETVAL=$?
if [ "$RETVAL" = "190" ] ; then #BUTTONS
     exit 0

 elif [ "$RETVAL" = "191" ] ; then #BUTTONS
     MntPt=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
     rox "$MntPt"
     exit $?

 elif [ "$RETVAL" = "192" ] ; then #BUTTONS
     MntPt=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
     cd "$MntPt"
     pwd
     rxvt &
     exit $?

 elif [ "$RETVAL" = "193" ] ; then #BUTTONS
       UNMOUNT='yes'
       MntPt=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
       return 0

 elif [ "$RETVAL" = "194" ] ; then #BUTTONS
       UNMOUNT='yes'
       MntPt=`busybox mount | grep "$IMGBASE" | cut -f 3 -d ' '`
       echo 1 "$MntPt"
       MntPt2=`echo "$MntPt" | sed "1 d"`
       echo 2 "$MntPt2"
       for i in $MntPt2 ; do
       GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       echo "$GREP"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       echo "$LOOPD"
       USEapps=`fuser -c $LOOPD`
       echo 3 "$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
       echo 4 "$USEapps"
       for j in $USEapps ; do
       echo "$i: $j"
       kill -1 $j
       done
       [ -n "$DISPLAY" ] && rox -D "$i"
       umount "$i"
       sleep 2
       rmdir "$i"
       done
       MntPt=`busybox mount | grep "$IMGBASE" | cut -f 3 -d ' '`
       return 0

else #BUTTONS
     MOUNT='again'
     return 0
fi #BUTTONS

fi #DISPLAY
fi #MOUNTED ELSEWHERE
done

}
check_already_mounted_func

fi #! -d MntPt

if [ -z "$UNMOUNT" ] ; then #UNMOUNT

  Ext=`echo "$ImgFile" |sed 's/^.*\.//'`    # get file type from extention
  if [ "$Ext" = '2fs' ] ;then #Ext
   Type='ext2'
  elif [ "$Ext" = '3fs' ] ;then #Ext
   Type='ext3'
  elif [ "$Ext" = '4fs' ] ;then  #Ext #v423 planning for the future!
   Type='ext4'
  elif [ "$Ext" = 'sfs' -o "$Ext" = 'squashfs' -o "$Ext" = 'sqfs' ] ;then #Ext
   Type='squashfs'
  elif [ "$Ext" = 'iso' ] ;then #Ext
   Type=`disktype "$ImgFile" | grep -m1 'file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
   [ "$Type" ] || Type='iso9660'  #fallback
  elif [ "$ImgFileBASE" = 'initrd.gz' -o "$ImgFileBASE" = 'initrd' ] ;then
   if [ "$ImgFileBASE" = 'initrd.gz' ];then
    gunzip "$ImgFile"               # handle gzip image file
    ImgFile=`echo "$ImgFile" |sed 's/.gz$//'`
   fi
   Type=`disktype "$ImgFile" | grep -m1 'file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
   if [ ! "$Type" ];then #! TYPE
    [ "$DISPLAY" ] && xmessage -bg red "Sorry, no file system inside initrd." &
    echo "Sorry, no file system inside initrd."
    if [ "$ImgFileBASE" = 'initrd.gz' ];then
     gzip -9 "$ImgFile"
    fi
    exit 1
   fi #! TYPE
  fi #Ext

  #v423 detect wrong squashfs version...
  if [ "$Type" = "squashfs" ];then #squashfs
   DISK_TYPE=`disktype "${ImgFile}" 2>&1`
    if [ "`echo "$DISK_TYPE" | grep -i permission`" ];then #DISK_TYPE
     xmessage -bg red2 "CHECK Permissions :
`ls -l $ImgFile`
"
     exit 1

    elif [ ! "`echo "$DISK_TYPE" | grep "$SFSSTR"`" ];then #DISK_TYPE
     if [ $KERNELSUBVER -gt 28 ];then #KERNEL 2.6.29+
      [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This is an older version 3.x squashfs file, not usable.
All Linux kernels 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
     else #KERNEL 2.6.29-
      [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This is a newer version 4.x squashfs file, not usable.
All Linux kernels 2.6.28 or earlier require version 3.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
     fi #KERNEL 2.6.28/29
     exit $?
    fi #DISK_TYPE
  fi #squashfs

 #check if loopdevice available :

# if [ "`losetup -a |wc -l`" -ge 8 ];then #loopdevice count
# xmessage -bg red3 "Sorry, all loopdevices in use.
#Please unmount some and try again."

# else #loopdevice count

  LAST_LOOP=`losetup -a |cut -f1 -d: |grep -o -e '[0-9]*' | sort -n |tail -n1`
  NEW_LOOP=$((LAST_LOOP+1))
  if [ ! -b /dev/loop$NEW_LOOP ] ; then
  mknod /dev/loop$NEW_LOOP b 7 $NEW_LOOP
  fi

  echo "$0:mount: $ImgFile"
  mkdir -p "$MntPt" ##2012-06-02
  mount -t $Type -o loop "$ImgFile" "$MntPt" ##2012-06-02
  Err=$?
  sleep 2s
  if [ "$Err" -eq 0 ] || [ -n "`mount | grep "$MntPt"`" ];then #MOUNT OK
   if [ -n "$DISPLAY" ] ; then #DISPLAY
    rox -d "$MntPt" # mount good, run rox filer
    yaf-splash -timeout 6 -font "8x16" -outline 0 -margin 4 -bg green -text "SUCCESS! Click $ImgFileBASE icon again to unmount it" & #BK
   fi #DISPLAY
  fi #MOUNT OK

 if [ "$Err" -gt 0 ] ;then  #MOUNT FAIL     # ERROR: mount/unmount
  [ -n "$DISPLAY" ] && xmessage -bg red -title "ERROR... mounting $MntPt returned $Err"

  grepP=`echo "$MntPt" |sed 's|\([[:punct:]]\)|\\\\\1|g'`
  [ -d "$MntPt" -a "`busybox mount | grep "$grepP"`" = "" ] && rmdir "$MntPt"

 fi #MOUNT FAIL

#fi  #loopdevice count

else #UNMOUNT               ### file's mounted, unmount it

   [ -n "$DISPLAY" ] && rox -D "$MntPt" #BK

       GREP=`echo "$MntPt" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       echo 1 "$GREP"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       echo 2 "$LOOPD"
       USEapps=`fuser -c $LOOPD`
       echo 3 "$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g;s/[[:punct:]]//g'`
       echo 4 "$USEapps"
       for j in $USEapps ; do
       echo -n "$j "
       kill -1 $j
       done

  sleep 2s
  umount "$MntPt" ##2012-06-02
  Err=$?
  sleep 2s
  [ -n "$DISPLAY" ] && yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg orange -text "Unmounting $ImgFileBASE" #BK

  echo "$0: umount: $ImgFile"
  grepP=`echo "$MntPt" |sed 's|\([[:punct:]]\)|\\\\\1|g'`
  [ -d "$MntPt" -a "`busybox mount | grep "$grepP"`" = "" ] && rmdir "$MntPt"

 if [ "$Err" -gt 0 ] ;then  #UMOUNT FAIL # ERROR: mount/unmount
  [ -n "$DISPLAY" ] && xmessage -bg red -title "ERROR..." "Returned $Err ... unmounting $MntPt"
 fi #UMOUNT FAIL

fi #UNMOUNT


exit $Err

