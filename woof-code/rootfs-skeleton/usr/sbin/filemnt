#!/bin/bash
##############  ROX app.: Click image files to mount & unmount. by: Terry Becker        aka: SunBurnt
##############  File types = ".2fs, .3fs, .sfs, .iso, & initrd.gz".
#v423 detect wrong squashfs version 3.x or 4.x.
#v424 advise of sfs-version-converter.
#100606 have backported squashfs4 to kernel 2.6.27.47.
########################################################################
#
# CHANGES by Karl Reimer Godt
# 01.0 : added xmessage dialog if already mounted to choose actions :
#        Quit,ROX-Filer,console,Unmount,Unmountall,MountAnotherTime
# 02.0 : position of removal of $MntPt changed in code
# 03.0 : doubble quoted all $file_toMOUNT AND $MntPt in case of spaces
#
# /dev/sda5:
# LABEL="MacPup430_F3"
# UUID="07443de5-1fab-4656-a3ab-7b1c14ccc8c8"
# TYPE="ext3"
# DISTRO_VERSION=430·#481·#416·#218·#478······#####change·this·as·required#####
# DISTRO_BINARY_COMPAT="puppy"·#"ubuntu"·#"puppy"·#####change·this·as·required#####
# case·$DISTRO_BINARY_COMPAT·in
# ubuntu)
# DISTRO_NAME="Jaunty·Puppy"
# DISTRO_FILE_PREFIX="upup"
# DISTRO_COMPAT_VERSION="jaunty"
# ;;
# debian)
# DISTRO_NAME="Lenny·Puppy"
# DISTRO_FILE_PREFIX="dpup"
# DISTRO_COMPAT_VERSION="lenny"
# ;;
# slackware)
# DISTRO_NAME="Slack·Puppy"
# DISTRO_FILE_PREFIX="spup"
# DISTRO_COMPAT_VERSION="12.2"
# ;;
# arch)
# DISTRO_NAME="Arch·Puppy"
# DISTRO_FILE_PREFIX="apup"
# DISTRO_COMPAT_VERSION="200904"
# ;;
# t2)
# DISTRO_NAME="T2·Puppy"
# DISTRO_FILE_PREFIX="tpup"
# DISTRO_COMPAT_VERSION="puppy5"
# ;;
# puppy)·#built·entirely·from·Puppy·v2.x·or·v3.x·or·4.x·pet·pkgs.
# DISTRO_NAME="Puppy"
# DISTRO_FILE_PREFIX="pup"·#"ppa"·#"ppa4"·#"pup2"··#pup4··###CHANGE·AS·REQUIRED,·recommend·limit·four·characters###
# DISTRO_COMPAT_VERSION="4"·#"2"··#4·····###CHANGE·AS·REQUIRED,·recommend·single·digit·5,·4,·3,·or·2###
# ;;
# esac
# PUPMODE=2
# KERNVER=2.6.30.7-KRG-i586
# ATADRIVES='·sda'
# USB_SATAD=''
# PUP_HOME='/'
# Linux·puppypc·2.6.30.7-KRG-i586·#2·SMP·Tue·Jan·4·15:42:45·CET·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xvesa_stripped_upx9
# $LANG=en_US
# today=Thu·Oct·27·11:44:41·CEST·2011
# TODO1 : cleanup my code
# TODO2 : cleanup original code
# TODO3 : observe fuser -c and fuser -m
# TODO4 : Kernel 3.x.x ready # 2013-12-04 done.
# TODO5 : create grepPatternMntPt
# TODO6 : both fuser parts into one func
# TODO7 : adopt the code from npierce
#
########################################################################


exec 1>>/tmp/filemnt.log 2>&1
echo
echo '----------------------------------------------------------------------'

test -f /etc/rc.d/f4puppy5 && source /etc/rc.d/f4puppy5

QUIET=-q
INFO=1
DEBUG=1
test "$DEBUG" && QUIET='';

_kernel_version3 || {
#v423...
KERNELVER="`uname -r`"
SFSSTR='squashfs, version 3'
squashXZ=NOT
#KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-'`
     K_VERSION=`uname -r | { IFS='.-_' read kversion localversion;echo $kversion; }` ##code from /usr/sbin/laptop_mode, Maintainer: Bart Samwel (bart@samwel.tk)
  K_PATCHLEVEL=`uname -r | { IFS='.-_' read kversion patchlevel localversion;echo $patchlevel; }`
    K_SUBLEVEL=`uname -r | { IFS='.-_' read kversion pathlevel sublevel localversion;echo $sublevel; }`
K_EXTRAVERSION=`uname -r | { IFS='.-_' read kversion pathlevel sublevel extraversion localversion;echo $extraversion; }`

[ "$K_EXTRAVERSION" ] || K_EXTRAVERSION=0
[ "${K_EXTRAVERSION//[[:digit:]._-]/}" ] && K_EXTRAVERSION=0

case $K_VERSION in
3) SFSSTR='squashfs, version 4';;
2)
        case $K_PATCHLEVEL in
        6)
                case $K_SUBLEVEL in
                29|30|31|32|33|34|35|36|37) SFSSTR='squashfs, version 4';;
                38|39) SFSSTR='squashfs, version 4';squashXZ=YES;;
                27)
                    case $K_EXTRAVERSION in
                    46) SFSSTR='squashfs, version 4';;
                    esac
                ;;
                *) :;;
                esac;;
        0|1|2|3|4|5) _warn "sfs version :Kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        *) _warn "sfs version :Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        esac;;
*) _warn "sfs version :Unhandled kernel version '$K_VERSION' .";;
esac

#[ "$KERNELSUBVER" -gt 28 ] && SFSSTR='squashfs, version 4'
}
_debug "SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"

file_toMOUNT="$@"
_debug "file_toMOUNT='$file_toMOUNT'"
if [ -z "$file_toMOUNT" ]; then _exit 1 "Need file-name" ;fi #1
test  -f "$file_toMOUNT" || _exit 1 "Not a regular file"

if [ "`basename "$file_toMOUNT"`" = 'initrd' ] ;then gzip -9 "$file_toMOUNT" ;fi # 11
if [ "`basename "$file_toMOUNT"`" = 'initrd.gz' ] ;then gunzip -9 "$file_toMOUNT" ;fi # 111  ##+2011_10_27 changed gzip to gunzip


if [ "`dirname "$file_toMOUNT"`" = '\.' ] ;then # 2
      file_toMOUNT="`pwd``echo "$file_toMOUNT" |sed 's/^\.//'`"
fi # 2

file_toMOUNTdevINODE=`stat -L -c "%d_%i" "$file_toMOUNT"` || _exit 2 "Problems with stat" #120220
_debug "file_toMOUNTdevINODE='$file_toMOUNTdevINODE'"

#MntPt='/mnt/'`echo "$imgFile" |sed "s#^\.##g" |sed "s#/#+#g"`
MntPt='/mnt/'`basename "$file_toMOUNT"`.$$  ##KRG my change
grepPatternMntPt=`echo "$MntPt" | sed 's#\([[:punct:]]\)#\\\1#g'`
grepPatternImgFile=`echo "$imgFile" | sed 's#\([[:punct:]]\)#\\\1#g'`

file_toMOUNTbase="`basename "$file_toMOUNT"`" #BK  ##only for yaf/xmessage message not too long

if [ ! -d "$MntPt" ] ;then # 5

_show_mount_menu()
{
     if [ -n "$DISPLAY" ] ; then #66
xmessage -buttons "Quit:190,ROX-Filer:191,console:192,Unmount:193,Unmount all $imgBASE:194,Mount another time:199" "$file_toMOUNT
is already mounted and in-use by Puppy .
Do you want to unmount it or mount it to another mount point ?"
RETVAL=$?
if [ "$RETVAL" = "190" ] ; then #666  ##Quit
     exit 0

elif [ "$RETVAL" = "191" ] ; then #666  ##ROX-Filer
       #MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       #rox "$MntPt"
       rox -x "$mountpoint" -x "${mountpoint%/*}" -d "$mountpoint"
       exit $?

elif [ "$RETVAL" = "192" ] ; then #666  ##console
       #MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       #cd "$MntPt"
       cd "$mountpoint"
       pwd
       rxvt &
       exit $?

elif [ "$RETVAL" = "193" ] ; then #666  ##umount
       UNMOUNT='yes'
       #MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       MntPt="$mountpoint"
       return

elif [ "$RETVAL" = "194" ] ; then #666  ##umount ALL $IMGBASE
       UNMOUNT='yes'
       #MntPt=`busybox mount | grep "$imgBASE" | cut -f 3 -d ' '`
       #MntPts=`grep -w "${mountpoint##*/}" /proc/mounts | cut -f2 -d' '`
       MntPts=`grep -w "${fileNAME##*/}" /proc/mounts | cut -f2 -d' '`
       _debug "MntPts='$MntPts'"
       MntPts2=`echo "$MntPts" | sed "1 d"` ##only umount all others except one
       _debug "MntPts2='$MntPts2'"
       for i in $MntPts2 ; do
       GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "GREP='$GREP'"
       LOOPD=$(busybox mount | grep -m1 "$GREP" | cut -f 1 -d ' ')
       _debug "LOOPD='$LOOPD'"
       #USEapps=`fuser -c $LOOPD`     ##---2011-10-27
       USEapps=`fuser -m "$i"`   ##+++2011-10-27
       _debug "USEapps='$USEapps'"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
       _info "USEapps='$USEapps'"
       for j in $USEapps ; do
       echo $j
       kill -1 $j
       done
       [ -n "$DISPLAY" ] && rox -D $i
       /bin/umount $i
       #test $? = 0 && { sleep 2s; test -d "$i" && rmdir $i; }
       done
       #MntPt=`grep "$mountpoint" /proc/mounts | cut -f 2 -d ' '`
       MntPt=`grep -m1 "${fileNAME##*/}" /proc/mounts | cut -f 2 -d ' '`
       return

else #666
     MOUNT='again'
     return
fi   ###666
else ##66      ##+++2011-10-27 to fix call from without X running
UNMOUNT='yes'  ##+++2011-10-27
fi ##66
}


check_already_mounted_func(){

  #BK check if already mounted elsewhere...
  for oneLOOP in `grep '^/dev/loop' /proc/mounts | cut -f 1 -d ' '`
  do

   mntdIMG="`losetup-FULL $oneLOOP | cut -f 2 -d '(' | cut -f 1 -d ')'`"
   imgBASE="`basename "$mntdIMG"`"

    #echo "IMGBASE=$IMGBASE imgFileBASE=$imgFileBASE" #TEST
    #not perfect, but paths may be symlinks...

    if [ "$imgBASE" = "$file_toMOUNTbase" ];then #if [ "$MNTDIMG" = "$imgFile" ];then #6

     if [ -n "$DISPLAY" ] ; then #66
xmessage -buttons "Quit:190,ROX-Filer:191,console:192,Unmount:193,Unmount all $imgBASE:194,Mount another time:199" "$file_toMOUNT
is already mounted and in-use by Puppy .
Do you want to unmount it or mount it to another mount point ?"
RETVAL=$?
if [ "$RETVAL" = "190" ] ; then #666  ##Quit
     exit 0

elif [ "$RETVAL" = "191" ] ; then #666  ##ROX-Filer
       MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       rox "$MntPt"
       exit $?

elif [ "$RETVAL" = "192" ] ; then #666  ##console
       MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       cd "$MntPt"
       pwd
       rxvt &
       exit $?

elif [ "$RETVAL" = "193" ] ; then #666  ##umount
       UNMOUNT='yes'
       MntPt=`busybox mount | grep "$imgBASE" | head -n 1 | cut -f 3 -d ' '`
       return

elif [ "$RETVAL" = "194" ] ; then #666  ##umount ALL $IMGBASE
       UNMOUNT='yes'
       MntPt=`busybox mount | grep "$imgBASE" | cut -f 3 -d ' '`
       _debug "MntPt='$MntPt'"
       MntPt2=`echo "$MntPt" | sed "1 d"` ##only umount all others except one
       _debug "MntPt2='$MntPt2'"
       for i in $MntPt2 ; do
       GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "GREP='$GREP'"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "LOOPD='$LOOPD'"
       #USEapps=`fuser -c $LOOPD`     ##---2011-10-27
       USEapps=`fuser -m "$i"`   ##+++2011-10-27
       _debug "USEapps='$USEapps'"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
       _info "USEapps='$USEapps'"
       for j in $USEapps ; do
       echo $j
       kill -1 $j
       done
       [ -n "$DISPLAY" ] && rox -D $i
       /bin/umount $i
       #test $? = 0 && { sleep 2s; test -d "$i" && rmdir $i; }
       done
       MntPt=`busybox mount | grep "$imgBASE" | cut -f 3 -d ' '`
       return

else #666
     MOUNT='again'
     return
fi   ###666
else ##66      ##+++2011-10-27 to fix call from without X running
UNMOUNT='yes'  ##+++2011-10-27
fi ##66
fi #6
done

}

check_already_mounted_func2()
{
while read device mountpoint fstype rest
do
test "$device" || continue
case $device in
/dev/loop*) fileNAME=`busybox losetup $device | awk '{print $3}'`
            _debug "fileNAME='$fileNAME'"
            test -e "$fileNAME" && { imgDEV_INODE=`stat -L -c "%d_%i" "$fileNAME"`
            _debug "imgDEV_INODE='$imgDEV_INODE'"
            test "$imgDEV_INODE" = "$file_toMOUNTdevINODE" && {
#xmessage -bg '#FF8080' "$(eval_gettext "Sorry \$file_toMOUNT is already mounted and in-use by Puppy
#on \$mountpoint from \$fileNAME")"
#            exit 3;
            _show_mount_menu
            break
} ; }
;;
*) continue;;
esac

done</proc/mounts
}
check_already_mounted_func2

fi # 5

if [ -z "$UNMOUNT" ] ; then #55 == yes || [ -n "$MOUNT" ] == again

_guess_file_fstype()
{
  Type=`guess_fstype "$file_toMOUNT"`
  if test -z "$Type" -o "$Type" = 'unknown'; then
   Ext=`echo "$file_toMOUNT" |sed 's/^.*\.//'`        # get file type from extention
   if [ "$Ext" = '2fs' ] ;then #7
    Type='ext2'
   elif [ "$Ext" = '3fs' ] ;then
    Type='ext3'
   elif [ "$Ext" = '4fs' ] ;then #v423 planning for the future!
    Type='ext4'
   elif [ "$Ext" = 'sfs' -o "$Ext" = 'sqfs' -o "$Ext" = 'squashfs' ] ;then
    Type='squashfs'
   elif [ "$Ext" = 'iso' ] ;then
    Type='iso9660'
   # BK
   #elif [ "$imgFile" = 'initrd.gz' ] ;then
   # Type='ext2'
   # gunzip $imgFile                             # handle gzip image file
   # imgFile="echo "$imgFile" |sed 's/.gz$//'"
   fi #7
  fi
  #v423 detect wrong squashfs version...
  if [ "$Type" = "squashfs" ];then #8

   diskTYPE_OUT=`disktype "${file_toMOUNT}" 2>&1`
   test "`echo "$diskTYPE_OUT" | grep 'Input/output error'`" && { [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "ERROR : The
${file_toMOUNT##*/} may be corrupted.
Cannot mount it currently."; ##exit 1
   } || {

   if [ "`disktype "${file_toMOUNT}" | grep "$SFSSTR"`" = "" ];then #8.1

    if [ $SFSMAJOR -eq 4 ] ;then #8.1.1 #100606
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This is likely an older version 3.x squashfs file, not usable.
All Linux kernels 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    else #8.1.1
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This is likely a newer version 4.x squashfs file, not usable.
All Linux kernels 2.6.28 or earlier require version 3.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    fi #8.1.1
    exit 1
   fi #8.1
   }
  fi #8
}
_guess_file_fstype

_mk_free_loop_device()
{
  test -c /dev/loop-control || mknod /dev/loop-control c 10 237
  FREE_LOOP=`losetup -f`
  [ "$FREE_LOOP" ] || {
        _info "No free loop devices available.. Attempt to create one.."
        LOOPS_ALL=`ls -1 /dev/loop* |sed 's%[^[:digit:]]%%g' | sort -n`
        LOOP_LAST=`echo "$LOOPS_ALL" | tail -n1`
        LOOP_NEW=$(( $LOOP_LAST + 1 ))
        mknod /dev/loop$LOOP_NEW b 7 $LOOP_NEW
        test $? = 0 && _notice "Created /dev/loop$LOOP_NEW" || _warn "Could not create /dev/loop$LOOP_NEW"
 }
}
_mk_free_loop_device

_encrypted()
{
  #111110 handle encrypted save-files...
  CRYPTO=""; Err=0
  DEVLOOP="`losetup-FULL -f`" #next free loop device.
  case $Type in
   ext2|ext3|ext4)
    case "$file_toMOUNTbase" in
     *_cryptx*) #light encryption.
      CRYPTO='light'
      modprobe $VERB cryptoloop
      rxvt -geometry 25x3 -title "$(gettext 'Enter password')" -bg orange -e losetup-FULL -E 1 $DEVLOOP "$file_toMOUNT"
      #losetup-FULL -E 1 $DEVLOOP $imgFile
      Err=$?
     ;;
     *_crypt*) #heavy encryption.
      CRYPTO='heavy'
      for mod in cryptoloop aes_generic aes crypto_blkcipher blkcipher cbc
      do
      modprobe -l | grep $QUIET "/${mod}.ko$" || continue
      modprobe $VERB $mod
      done
      #modprobe cryptoloop
      #modprobe aes_generic 2>/dev/null #v407 aes name change.
      #modprobe aes 2>/dev/null #for older kernel <2.6.25
      #modprobe crypto_blkcipher 2>/dev/null #v407 blkcipher name change.
      #modprobe blkcipher 2>/dev/null #old kernel.
      #modprobe cbc
      MYPASS="`pupdialog --title "$(gettext 'Enter Password')" --stdout --inputbox "$(gettext 'Password required to open') ${file_toMOUNTbase}:" 0 0`"
      Err=$?
      if [ $Err -eq 0 ];then
       echo "$MYPASS" | losetup-FULL -p 0 -e aes $DEVLOOP "$file_toMOUNT"
       Err=$?
      fi
     ;;
    esac
   ;;
  esac
}
_encrypted

_mount_loop_file()
{
  echo -e "\n$0 : Mount: $file_toMOUNT\n"
  #mkdir -p "$MntPt"
  echo '-------------'
  freeLOOP=`losetup -f`
  losetup $freeLOOP "$file_toMOUNT"

 if [ "$CRYPTO" ];then
   [ $Err -eq 0 ] && { /bin/mount -t $Type $DEVLOOP "$MntPt"; Err=$?; }

  else #normal, no encryption... 130204 mavrothal: fix spaces in imgFile...

  #/bin/mount -t $Type -o loop "$file_toMOUNT" "$MntPt"
  /bin/mount -t $Type -o loop $freeLOOP "$MntPt"
  Err=$?     ##+++2011_10_27

fi

  echo '-------------'
  if [ $Err -eq 0 ] || [ -n "`grep " $MntPt " /proc/mounts`" ]; then #9
   if [ -n "$DISPLAY" ]; then #99
   # rox -d "$MntPt" # mount good, run rox filer #done by /bin/mount
    yaf-splash -timeout 4 -font "8x16" -outline 0 -margin 4 -bg green -text "SUCCESS! Click $file_toMOUNTBASE icon again to unmount it" & #BK
   fi #99
  fi #9
}
_mount_loop_file

 else #55       [ -n "$UNMOUNT" ]                                       ### file's mounted, unmount it

_unmount_loop()
{
    [ -n "$DISPLAY" ] && yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg orange -text "Unmounting $file_toMOUNTbase" & #BK

       GREP=`echo "$MntPt" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "GREP='$GREP'"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "LOOPD='$LOOPD'"
       #USEapps=`fuser -c $LOOPD`   ##---2011-10-27
       USEapps=`fuser -m "$MntPt"`  ##+++2011-10-27
       _debug "USEapps='$USEapps'"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g;s/[[:punct:]]//g'`
       _info "USEapps='$USEapps'"
       for j in $USEapps ; do
       echo $j
       kill -1 $j
       done

  sleep 1s
  echo '------------'
  /bin/umount "$MntPt"
  Err=$?
  sleep 1s  ##+++2011-10-27
  echo -e "\n$0 UnMount: $file_toMOUNT\n"
  echo '------------'

}
_unmount_loop
 fi #55

 if [ "$Err" -gt 0 ] ;then                      # ERROR: mount/unmount # 9999
  [ -n "$DISPLAY" ] && xmessage -bg red -title "ERROR..." "Returned <$Err> ... mounting or unmounting $MntPt"
  #[ -d "$MntPt" ] && [ -z "`ls "$MntPt" 2>/dev/null`" ] && rmdir "$MntPt"  ##+++2011_10_27
 fi # 9999



