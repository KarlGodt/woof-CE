#!/bin/ash
#
# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_filemnt"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/usr/sbin/filemnt"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
# ROX app.: Click image files to mount & unmount.
# by: Terry Becker  aka: SunBurnt
# File types = ".2fs, .3fs, .sfs, .iso, & old  ext2 initrd.gz".

trap "exit" HUP INT QUIT ABRT KILL TERM

#v423 detect wrong squashfs version 3.x or 4.x.
#v424 advise of sfs-version-converter.

# KRG code clean up, resurrect initrd check and mount if disktype can get a fs inside
# KRG some sanity checks, usage and options, UDF support for .iso, simple GUI for mount flavours
# KRG better error message for wrong squashfs, .squashfs and .sqfs extensions
# TODO much, kernel 3.x, support more filesystems, port npierce improvements, port encryption mounting

. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS

Version='1.1-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'
Version='1.2-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'  ## Added lots of remarks
                                                          ## reordere the code a little (sleep, rmdir mountPT, yaf-splash, few if)
Version='1.3-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'  ## Create MOUNT_EXE and UMOUNT_EXE variables
                                                          ## and some functions to let mount.sh handle
                                                          ##  creation and deletion of mountpoint directories
                                                          ##  and close/open ROX-Filer windows
Version='1.4-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'  ## 3 BUGFIXES :
                                                          ##  -false added to losetup -f test return value
                                                          ##  -use imageFILEBASE instead oneIMGBASE in check_already_mounted_func
                                                          ##   because losetup -j could override testing all loop devices
                                                          ##  -typos in comments and debug output
                                                          ## 3 functions added :
                                                          ##  _losetup : switch to correct losetup usage
                                                          ##  _test_bb_version : helper for losetup
                                                          ##  _fuser : switch to correct fuser usage

Version='1.5-getopts Macpup_Opera_2-Puppy_Linux_431 KRG'  ## Add sfs_load interface

usage (){
MSG="
$0 [-h -V -l ] FILENAME.EXT

-h) show this usage message
-V) emitt version information
-l) log to /tmp/filemnt.log
-d) debug with 'set -x'
-v) verbose output
"
echo "$MSG"
[ "$DISPLAY" ] && xmessage -bg green3 "$MSG"
exit $1
}

OUT=/dev/null;ERR=/dev/null
while getopts lhVdv opt;do
case $opt in
h) usage 0;;
V) echo -e "\n$0 : Version '$Version'\n";exit 0;;
l) exec 1>>/tmp/filemnt.log 2>&1;;
d) DEBUG=1;set -x;;
v) VERBOSE=1;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;OUT=/dev/stdout;ERR=/dev/stderr;;
*) :;;
esac;done

_ask_to_load(){
if [ "`which sfs_load`" ]; then
case $PUPMODE in

''|2|3) :;;
*)
  case "$imageFILEBASE" in
  *.sfs)
    LOAD_MSG=`gettext "Do you want insert/load/integrate the
$imageFILEBASE into the current running
$DISTRO_NAME $DISTRO_VERSION ?
Or do you just want to mount it to look inside ?
"`
    INSERT_B=`gettext 'Insert'`
    MOUNT_B=`gettext 'Mount'`
    xmessage -buttons "$INSERT_B:100,$MOUNT_B:101" "$LOAD_MSG"
    case $? in
    100) exec sfs_load "$@";;
    101) :;;
    *) exit 0;;
    esac
  ;;
  esac
;;
esac

fi
}


# REM: Need to know about the kernel version
#     because since around kernel 2.6.29
#     squashfs version became version 4.x
#     Older squashfs version was 3.x
#     and introduced around kernel version 2.4.20

# REM: Since the kernel version and squashfs version
#      are used in other scripts ( bootmanager ),
#      I use a function from f4puppy5 .
_kernel_version4

_kernel_version_filemnt(){
#v423...
KERNELVER=`uname -r`
KERNEL_MAJOR=`echo -n "$KERNELVER" | cut -f 1 -d '.'`
KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-'`
SFSSTR='squashfs, version 4'
if [ "$KERNEL_MAJOR" -lt 3 ] ; then
[ $KERNELSUBVER -lt 29 ] && SFSSTR='squashfs, version 3'
fi
}

# REM: INFO, DEBUG, DEBUGX unset by default in f4puppy5
INFO=1
DEBUG=1
DEBUGX=1

# REM: Some more global variables
#      MOUNT_EXE : either /bin/mount, busybox mount, mount-FULL .
#       Since it does not need to update any partition icons,
#       would not need to use mount script.
#       mount script could manage ROX-Filer windows,
#       mkdir mountpoint directory
#      UMOUNT_EXE : either /bin/umount. busybox umount, umount-FULL
#       umount script coulfd take care of file-system users,
#        ROX-Filer windows and rmdir mountpoint directory
MOUNT_EXE='busybox mount'
UMOUNT_EXE='busybox umount'

# REM: kill file-system users reported by fuser tool
#      unset it in case of mount.sh (interferes with function
#      _close_rox_window)
KILL_FS_USERS='YES'
case $UMOUNT_EXE in
/bin/umount) KILL_FS_USERS='NO';;
esac

# REM: Need to find out fuser version, older fuser supported -c option
#      which was usually more correct
FUSER_BIN=`which fuser`
 if [ "$FUSER_BIN" ]; then
  case `realpath "$FUSER_BIN"` in
  *busybox*) versFUSER=new;;
  *)
    #FUSER_VERS=`$FUSER_BIN --version 2>&1 | head -n1`
    FUSER_VERS=`$FUSER_BIN -V 2>&1 | head -n1`
    FUSER_VERS=`echo "$FUSER_VERS" | grep -o '[[:digit:][:punct:]]\+$'`
   case $FUSER_VERS in
   22*) versFUSER=new;; #MacPup529 has 22.15, MacPup Opera2 upgraded to 22.5
   *)   versFUSER=old;;
   esac
   ;;
  esac
 else
  FUSER_BIN=:
 fi

_debug "FUSER_BIN=$FUSER_BIN versFUSER=$versFUSER FUSER_VERS=$FUSER_VERS"

_fuser(){
local GREP LOOPD MNTD

case "$@" in
/dev/loop*)
        GREP=`echo "$@" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
        _debug "GREP='$GREP'" >&2
        MNTD=$(busybox mount | grep "^$GREP" | cut -f 3 -d ' ')
        _debug "MNTD='$MNTD'" >&2
        LOOPD="$@"
;;
*)
        GREP=`echo "$@" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
        _debug "GREP='$GREP'" >&2
        LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
        _debug "LOOPD='$LOOPD'" >&2
        MNTD="$@"
;;
esac

case $versFUSER in
new) $FUSER_BIN -m "$MNTD";;
old) $FUSER_BIN -c "$LOOPD";;
*)   $FUSER_BIN -m "$MNTD";;
esac
return $?
}

# REM: Handle losetup-FULL versions
versLOSETUP_FULL=new
LOSETUP_FULL=`which losetup-FULL`
if test "$LOSETUP_FULL"; then
# REM: losetup-FULL has no --version option
 LOSETUP_FULL_VERS=`losetup-FULL 2>>$ERR`
 if [ $? = 0 ]; then
 versLOSETUP_FULL=old
 else
  LOSETUP_FULL_VERS=`losetup-FULL -a 2>>$ERR`
  if [ $? = 0 ]; then
  versLOSETUP_FULL=new
  else
  versLOSETUP_FULL=very_old
  fi
 fi
else LOSETUP_FULL=:
fi


# REM: Handle losetup versions
versLOSETUP=busybox_new
LOSETUP=`which losetup`
# REM: Also Busybox losetup
BB_VERS=`busybox | head -n1`

_test_bb_version(){
           case $BB_VERS in
           '')           return 1   ;;
           *v0.*)        return 1   ;;
           *v1.[0-9].*)  return 1   ;;
           *v1.1[0-9].*) return 1   ;;
           *v1.2[0-1].*) return 1   ;;
           *v1.2[2-9].*) return 0   ;;
           *)            return 0   ;;
           esac
}

if test "$LOSETUP"; then
case "`realpath $LOSETUP`" in
*busybox*) #BB_VERS=`busybox | head -n1`
           #case $BB_VERS in
           #'') :;;
           #*v0.*)        versLOSETUP=busybox_old;;
           #*v1.[0-9].*)  versLOSETUP=busybox_old;;
           #*v1.1[0-9].*) versLOSETUP=busybox_old;;
           #*v1.2[2-9].*) versLOSETUP=busybox_new;;
           #*)            versLOSETUP=busybox_new;;
           #esac
           _test_bb_version && versLOSETUP=busybox_new || versLOSETUP=busybox_old
;;
*)
 versLOSETUP=new
 LOSETUP_VERS=`losetup-FULL 2>>$ERR`
 if [ $? = 0 ]; then
 versLOSETUP=old
 else
  LOSETUP_VERS=`losetup-FULL -a 2>>$ERR`
  if [ $? = 0 ]; then
  versLOSETUP=new
  else
  versLOSETUP=very_old
  fi
 fi
;;
esac

else LOSETUP=:
fi

_losetup(){

local loparam=$1
shift

case $loparam in
'')
    case "$versLOSETUP_FULL" in
    busybox_new) busybox losetup -a && return $?;;
    busybox_old) busybox losetup && return $?;;
    very_new)    losetup-FULL -a && return $?;;
    new)         losetup-FULL -a && return $?;;
    old)      _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;return;;
    very_old) _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;return;;
    *)        _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;return;;
    esac

    case "$versLOSETUP" in
    busybox_new) busybox losetup -a;;
    busybox_old) busybox losetup;;
    very_new)    losetup -a;;
    new)         losetup -a;;
    old)      _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;;
    very_old) _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;;
    *)        _test_bb_version && busybox losetup -a "$@" || busybox losetup "$@" ;;
    esac

;;
-a)
    case "$versLOSETUP_FULL" in
    busybox_new)  busybox losetup $loparam "$@" && return $?;;
    busybox_old)  busybox losetup "$@" && return $?;;
    very_new)     losetup-FULL $loparam "$@" && return $?;;
    new)          losetup-FULL $loparam "$@" && return $?;;
    old)          losetup-FULL $loparam "$@" && return $?;;
    very_old)     losetup-FULL $loparam "$@" && return $?;;
    *)        _test_bb_version && busybox losetup $loparam "$@" || busybox losetup "$@" ;return ;;
    esac

    case "$versLOSETUP" in
    busybox_new) busybox losetup $loparam "$@";;
    busybox_old) busybox losetup "$@";;
    very_new)    losetup $loparam "$@";;
    new)         losetup $loparam "$@";;
    old)      _test_bb_version && busybox losetup $loparam "$@" || busybox losetup "$@" ;;
    very_old) _test_bb_version && busybox losetup $loparam "$@" || busybox losetup "$@" ;;
    *)        _test_bb_version && busybox losetup $loparam "$@" || busybox losetup "$@" ;;
    esac

;;
-j)
    case "$versLOSETUP_FULL" in
    busybox_new) _warn "-j option may not be supported by busybox losetup" >>$ERR; losetup $loparam "$@" && return $?;;
    busybox_old) _warn "-j option not supported by busybox losetup"        >>$ERR; losetup $loparam "$@" && return $?;;
    very_new) losetup-FULL $loparam "$@" && return $?;;
    new)      losetup-FULL $loparam "$@" && return $?;;
    old)      _warn "-j option may not be supported by losetup-FULL" >>$ERR; losetup $loparam "$@" && return $?;;
    very_old) _warn "-j option not supported by losetup-FULL"        >>$ERR; losetup $loparam "$@" && return $?;;
    *)       losetup-FULL $loparam "$@" && return $?;;
    esac

    case "$versLOSETUP" in
    busybox_new) busybox losetup $loparam "$@" ;;
    busybox_old) busybox losetup $loparam "$@" ;;
    very_new)            losetup $loparam "$@" ;;
    new)                 losetup $loparam "$@" ;;
    old)                 losetup $loparam "$@" ;;
    very_old)            losetup $loparam "$@";;
    *)                   losetup $loparam "$@";;
    esac

;;
*)
    case "$versLOSETUP_FULL" in
    busybox_new) busybox losetup $loparam "$@" && return $?;;
    busybox_old) busybox losetup $loparam "$@" && return $?;;
    very_new)       losetup-FULL $loparam "$@" && return $?;;
    new)            losetup-FULL $loparam "$@" && return $?;;
    old)            losetup-FULL $loparam "$@" && return $?;;
    very_old)       losetup-FULL $loparam "$@" && return $?;;
    *)              losetup-FULL $loparam "$@" && return $?;;
    esac

    case "$versLOSETUP" in
    busybox_new) busybox losetup $loparam "$@";;
    busybox_old) busybox losetup $loparam "$@";;
    very_new)            losetup $loparam "$@";;
    new)                 losetup $loparam "$@";;
    old)                 losetup $loparam "$@";;
    very_old)            losetup $loparam "$@";;
    *)                   losetup $loparam "$@";;
    esac
;;
esac

}

# REM: mount.sh should take care of ROX-Filer windows
_open_rox_window(){
[ "$*" ]       || return 1
[ "$DISPLAY" ] || return 0
case $MOUNT_EXE in
/bin/mount) return 0;;
esac
rox -d "$@"
return $?
}
_close_rox_window(){
[ "$*" ]       || return 1
[ "$DISPLAY" ] || return 0
case $UMOUNT_EXE in
/bin/umount) return 0;;
esac
rox -D "$@"
return $?
}
# REM: mount.sh should take care of creating mountpoint directory
_create_mountpoint(){
[ "$*" ] || return 1
case $MOUNT_EXE in
/bin/mount) return 0;;
esac
mkdir $VERB -p "$@"
return $?
}
# REM: mount.sh should take care of removing mountpoint directory
_remove_mountpoint(){
sleep 2
[ -d "$@" ]             || { _return 0 "$@ is not a directory"; return $?; }
mountpoint $Q "$@"      && { _return 1 "$@ is recognized as mountpoint"; return $?; }
[ "`ls -A "$@"`" ]      && { _return 1 "$@ has content"; return $?; }

if [ "$UNMOUNT" ]; then
 case $UMOUNT_EXE in
 /bin/umount) return 0;;
 esac
else
 case $MOUNT_EXE in
 /bin/mount) return 0;;
 esac
fi
rmdir $VERB "$@"
return $?
}



# REM: Main parameter to this script is a filename .
#      Absolute path preferred
 imageFILE="$1"
 _info "imageFILE='$imageFILE'"
 if [ -z "$imageFILE" ];then echo "Need parameter or filename. Try -h for little more info.";exit 1 ;fi
 [ -f "$imageFILE" ] || { echo "'$imageFILE' seems not to exist (in $PWD)";exit 1; }
 #if [ "`basename "$imageFILE"`" = 'initrd' ] ;then gzip -9 $imageFILE;imageFILE="${imageFILE}.gz";WoExt=Y;fi #2012-06-02

# REM: But if not absolute /path/to/filename,
#      add pwd to it to make it absolute
#      insead could use realpath or readlink -f|-e for this...
 if [ "`dirname "$imageFILE"`" = '\.' ] ;then  #2012-06-02
  imageFILE=`pwd``echo "$imageFILE" |sed 's/^\.//'` #2012-06-02
 fi

# REM: Need a mountpoint directory name
 mountPT='/mnt/'`echo "$imageFILE" |sed "s#^\.##g" |sed "s#/#+#g"`
 _debug "old mountpoint would be: '$mountPT'"
 ##NEW##
 mountPT='/mnt/'`basename "$imageFILE"`.$$
 _info "new mountpoint is '$mountPT'"
 mountPTBASE="${mountPT%%\.*}"
 _debug "mountPTBASE='$mountPTBASE'"
 ##NEW##

# REM: imageFILEBASE is used to compare if that file is already
#      mounted with another loop device further down
imageFILEBASE=`basename "$imageFILE"` #BK

# REM: If sfs_load found in PATH, ask if to run it
_ask_to_load "$@"

# REM: Crude logic if the mountpoint is not a directory
#      Todo test -e beforehand ...
#if [ ! -d "$mountPT" ] ;then #! -d mountPT

check_already_mounted_func(){

  #BK check if already mounted elsewhere...
  # REM: Had mount quoting output like lspci -m
  for oneLOOP in `mount | grep ^[\'\"/]\\\+dev/loop | cut -f 1 -d ' '`
  do

   _debug "oneLOOP='$oneLOOP'" #DEBUG

   # REM: Care for the quoted output and get rid of enclosing quotes
   oneLOOP=`echo "$oneLOOP" |sed s,^[\"\'],,| sed s,[\"\']$,,`

   if test -f /sys/block/${oneLOOP##*/}/loop/backing_file; then
    read oneMNTDIMG </sys/block/${oneLOOP##*/}/loop/backing_file
   else
   # REM: Don't know why we use losetup-FULL for this,
   #      busybox losetup does it right too and without enclosing parenthesis ...
   #oneMNTDIMG=`losetup-FULL "$oneLOOP" | cut -f 2 -d '(' | cut -f 1 -d ')'`
   oneMNTDIMG=`_losetup "$oneLOOP" | cut -f 2 -d '(' | cut -f 1 -d ')'`
   fi
   _debug "oneMNTDIMG='$oneMNTDIMG'"

   # REM: A loop mount could be loaded into the current frugal OS
   #      or be just mounted.
   #     If it is loaded, add some extra message
   unset ANDINUSEBYPUPPY
   case "$oneMNTDIMG" in
   /initrd/*) ANDINUSEBYPUPPY='and in use by Puppy';;
   esac

   # REM: Now compare both base names ...
   oneIMGBASE=`basename "$oneMNTDIMG"`

    _debug "oneIMGBASE='$oneIMGBASE' imageFILEBASE='$imageFILEBASE'" #DEBUG
    #not perfect, but paths may be symlinks...

    case $oneMNTDIMG in
    *\*) _warn "truncated output by losetup"
        lengthONEMNTDIMG=`echo "$oneMNTDIMG" | wc -L`
        _notice "'$oneMNTDIMG' is '$lengthONEMNTDIMG' characters or more"
        :
        ;;
    esac

   # REM: Use losetup -j additionally
   #ass_imageFILE=`losetup-FULL -j "$imageFILE" 2>>$ERR`
   ass_imageFILE=`_losetup -j "$imageFILE" 2>>$ERR`
   _debug "ass_imageFILE='$ass_imageFILE'"
   case "$ass_imageFILE" in
   /dev/loop*) :;;
   *) unset ass_imageFILE;;
   esac


    if [ "$ass_imageFILE" ] || [ "$oneIMGBASE" = "$imageFILEBASE" ];then #MOUNTED ELSEWHERE # if [ "$MNTDIMG" = "$imageFILE" ];then

     if [ -n "$DISPLAY" ] ; then #DISPLAY
#xmessage -buttons "Quit:190,ROX-Filer:191,console:192,Unmount:193,Unmount all $oneIMGBASE:194,Mount another time:199" "$imageFILE
xmessage -buttons "Quit:190,ROX-Filer:191,console:192,Unmount:193,Unmount all $imageFILEBASE:194,Mount another time:199" "$imageFILE
is already mounted $ANDINUSEBYPUPPY .
Do you want to unmount it or mount it to another mount point ?"
RETVAL=$?
if [ "$RETVAL" = "190" ] ; then #BUTTONS
     exit 0

 elif [ "$RETVAL" = "191" ] ; then #BUTTONS
     #mountPT=`busybox mount | grep "$oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
     mountPT=`busybox mount | grep "$imageFILEBASE" | head -n 1 | cut -f 3 -d ' '`
     _debug "ROX-Filer: mountPT='$mountPT'"
     rox "$mountPT"
     exit $?

 elif [ "$RETVAL" = "192" ] ; then #BUTTONS
     #mountPT=`busybox mount | grep "$oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
     mountPT=`busybox mount | grep "$imageFILEBASE" | head -n 1 | cut -f 3 -d ' '`
     cd "$mountPT"
     _info "`pwd`"
     rxvt &
     exit $?

 elif [ "$RETVAL" = "193" ] ; then #BUTTONS
       UNMOUNT='yes'
       #mountPT=`busybox mount | grep "$oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
       mountPT=`busybox mount | grep "$imageFILEBASE" | tail -n 1 | cut -f 3 -d ' '`
       _debug "mountPT='$mountPT'"
       return 0

 elif [ "$RETVAL" = "194" ] ; then #BUTTONS
       UNMOUNT='yes'
       #mountPT=`busybox mount | grep "$oneIMGBASE" | cut -f 3 -d ' '`
       mountPT=`busybox mount | grep "$imageFILEBASE" | cut -f 3 -d ' '`
       _debug "mountPT='$mountPT'"
       mountPT2=`echo "$mountPT" | sed "1 d" | tac`
       _debug "mountPT2='$mountPT2'"

       for i in $mountPT2 ; do

       # REM: make killing optional
       if [ "$KILL_FS_USERS" = "YES" ]; then
       # REM: Close ROX-Filer windows before they are detected by fuser
       #       kill window pid would kill ROX-Filer completely (black pinboard)
       [ "$DISPLAY" ] && rox -D "$i"
       #_close_rox_window "$i"
       # GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       # _debug "$GREP"
       # LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       # _debug "$LOOPD"
       # USEapps=`_command fuser -c $LOOPD`
       # _debugx "_command fuser -c $LOOPD claims these pids: '$USEapps'"
       USEapps=`_fuser "$i"`
       _debugx "_fuser \"$i\" claims these pids: '$USEapps'"
        USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
        _debug "USEapps='$USEapps'"
         for j in $USEapps ; do
         _debugx "$i: $j"
         case $j in 1|$$) continue;; esac
         kill -1 $j
         #kill -0 $j
         done
        fi

       _debug "'$i'"
       #[ -n "$DISPLAY" ] && rox -D "$i"
       $UMOUNT_EXE -d "$i"
       [ "$?" = 0 ] || continue
       #  REM: Refresh rox
       #[ "$DISPLAY" ] && rox -x "${mountPT%/*}"
       #sleep 2
       #rmdir "$i"
       _remove_mountpoint "$i"
       done

       #mountPT=`busybox mount | grep "$oneIMGBASE" | cut -f 3 -d ' '`
       mountPT=`busybox mount | grep "$imageFILEBASE" | cut -f 3 -d ' '`
       _debug "mountPT='$mountPT'"
       return 0

 else #BUTTONS 199
     # REM: If mount on another mountpoint
     #       mount-FULL uses a new available loop device,
     #       busybox mount fails because it uses the same loop device for the imgFILE
     #       busybox mount would need losetup /dev/loopY imgFILE beforehand
     MOUNT='again'
     return 0
 fi #BUTTONS

else
  # REM: DISPLAY unset so assuming tty terminal
  #      No select right now
  #      Unmount it
  UNMOUNT='yes'
fi #DISPLAY

else
# REM: not mounted elsewhere, so continue
: continue
fi #MOUNTED ELSEWHERE

done

}

unset UNMOUNT
[ -d "$mountPT" ] || check_already_mounted_func

#fi #! -d mountPT

# REM: Simple UNMOUNT variable: If not set to anything
#      start mount procedure
if [ -z "$UNMOUNT" ] ; then #UNMOUNT

  _get_extension(){
  # REM: Probaly a good idea to pass file-system-type to mount
  #      The code now uses extension MIME-Type (noted in /usr/share/mime/globs) .
  #      TODO: Better use disktype first and if that fails fall back using
  #       extension or mount without passing -t option to let mount guess f.s.-type...
  #     TODO2 : Better use case instead if test

  Ext=`echo "$imageFILE" |sed 's/^.*\.//'`    # get file type from extention
  if [ "$Ext" = '2fs' ] ;then #Ext
   Type='ext2'
  elif [ "$Ext" = '3fs' ] ;then #Ext
   Type='ext3'
  elif [ "$Ext" = '4fs' ] ;then  #Ext #v423 planning for the future!
   Type='ext4'
  elif [ "$Ext" = 'sfs' -o "$Ext" = 'squashfs' -o "$Ext" = 'sqfs' ] ;then #Ext
   Type='squashfs'
  elif [ "$Ext" = 'iso' ] ;then #Ext
   #Type=`disktype "$imageFILE" | grep -m1 'file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
    Type=`disktype "$imageFILE" | grep -m1 -E '^[^[:blank:]]+ file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
   [ "$Type" ] || Type='iso9660'  #fallback

__say_some_weird_iso_fs__(){
cat >&1 <<EoI
--- /mnt/sda2/Suse/openSUSE-12.3-Rescue-CD-x86_64.iso
Regular file, size 560 MiB (587202560 bytes)
DOS/MBR partition map
Partition 1: 4 MiB (4194304 bytes, 8192 sectors from 404)
  Type 0xEF (EFI System (FAT))
  FAT12 file system (hints score 5 of 5)
    Volume size 3.977 MiB (4169728 bytes, 2036 clusters of 2 KiB)
    Volume name "BOOT"
Partition 2: 555.8 MiB (582801408 bytes, 1138284 sectors from 8596, bootable)
  Type 0x83 (Linux)
  ISO9660 file system
    Volume name "openSUSE 12.3 Live"
    Publisher   "SUSE LINUX GmbH"
    Preparer    "KIWI - http://opensuse.github.com/kiwi"
    Application "0xc1d28df8"
    Data size 555.2 MiB (582123520 bytes, 284240 blocks of 2 KiB)
    El Torito boot record, catalog at 2150
      Bootable non-emulated image, starts at 4300, preloads 2 KiB
        Platform 0x00 (x86), System Type 0x00 (Empty)
      Bootable non-emulated image, starts at 101, preloads 512 bytes
        Platform 0x00 (x86), System Type 0x00 (Empty)
        FAT12 file system (hints score 5 of 5)
          Volume size 3.977 MiB (4169728 bytes, 2036 clusters of 2 KiB)
          Volume name "BOOT"
      Bootable non-emulated image, starts at 101, preloads 4 MiB (4194304 bytes)
        Platform 0x00 (x86), System Type 0x00 (Empty)
        FAT12 file system (hints score 5 of 5)
          Volume size 3.977 MiB (4169728 bytes, 2036 clusters of 2 KiB)
          Volume name "BOOT"
    Joliet extension, volume name "openSUSE 12.3 Li"
ISO9660 file system
  Volume name "openSUSE 12.3 Live"
  Publisher   "SUSE LINUX GmbH"
  Preparer    "KIWI - http://opensuse.github.com/kiwi"
  Application "0xc1d28df8"
  Data size 559.4 MiB (586524672 bytes, 286389 blocks of 2 KiB)
  El Torito boot record, catalog at 20
    Bootable non-emulated image, starts at 4300, preloads 2 KiB
      Platform 0x00 (x86), System Type 0x00 (Empty)
      ISOLINUX boot loader
    Bootable non-emulated image, starts at 101, preloads 512 bytes
      Platform 0xEF (EFI), System Type 0x00 (Empty)
      FAT12 file system (hints score 5 of 5)
        Volume size 3.977 MiB (4169728 bytes, 2036 clusters of 2 KiB)
        Volume name "BOOT"
  Joliet extension, volume name "openSUSE 12.3 Li"
EoI
}


  #===== INITRD CODE =====#
  # REM: Older initrds were a simple ext2 fs container that needed root=/dev/ram0
  #      kernel parameter. init is /sbin/init in such containers.
  #      With cpio archive support init is on rootfs-top :
  #      TODO : handle other copressions ...
  elif [ "$imageFILEBASE" = 'initrd.gz' -o "$imageFILEBASE" = 'initrd' ] ;then

   # REM: gunzip removes the .gz extension
   if [ "$imageFILEBASE" = 'initrd.gz' ];then
    gunzip "$imageFILE"               # handle gzip image file
    imageFILE=`echo "$imageFILE" |sed 's/.gz$//'`
   fi

   # REM : Do not attempt to mount it if no f.s. inside (cpio archive)
   Type=`disktype "$imageFILE" | grep -m1 'file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
   if [ ! "$Type" ];then #! TYPE
    [ "$DISPLAY" ] && xmessage -bg red "Sorry, no file system inside initrd." &
    echo "Sorry, no file system inside initrd."
    # REM: For now gzip it back again.
    #      Todo: Could unpack it ...
    if [ "$imageFILEBASE" = 'initrd' ];then
     gzip -9 "$imageFILE"
    fi
    exit 1
   fi #! TYPE
   #===== INITRD CODE =====#


  else
   # REM: No extension nor some initrd*
   #      Ex: openSUSE-10.3-read-only.i686-2.0
   #            Regular file, size 659.1 MiB (691138560 bytes)
   #            Linux squashfs, version 3.0, little-endian
   #            Compressed size 659.1 MiB (691138172 bytes)
   #            Block size 64 KiB

   Type=`disktype "$imageFILE" | grep -iE 'file system|Linux squashfs,' |tr '[[:upper:]]' '[[:lower:]]'`
    case $Type in
    *squashfs*) Type=squashfs;;
    *) Type=${Type%% *};;  ## TODO
    esac

  fi #Ext
  } ##_get_extension(){ #END

  case $imageFILE in
  *.2fs|*.ext2)  Type=ext2;;
  *.3fs|*.ext3)  Type=ext3;;
  *.4fs|*.ext4)  Type=ext4;;
  *.btr|*.btrfs) Type=btrfs;;
  *.hfs)         Type=hfs;;
  *.hfsp|*.hfp|*.hfs+|*.hf+) Type=hfsp;;
  *.jfs)         Type=jfs;;
  *.ofs|*.ocfs2) Type=ocfs2;;
  *.rfs|*.reiser|*.reiserfs) Type=reiserfs;;
  *.rf4|*.reiser4|*.reiserfs4) Type=reiser4;;
  *.sfs|*.sqfs|*.squashfs)   Type=squashfs;;
  *.xfs)         Type=xfs;;
  *.iso|*.ISO)
     Type=`disktype "$imageFILE" | grep -m1 -E '^[^[:blank:]]+ file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
     [ "$Type" ] || Type=iso9660
     ;;
  *initrd*.gz|*initrd)
     gunzip "$imageFILE"               # handle gzip image file
     test $? = 0 && imageFILE=`echo "$imageFILE" |sed 's/.gz$//'`
     # REM : Do not attempt to mount it if no f.s. inside (cpio archive)
     Type=`disktype "$imageFILE" | grep -m1 'file system' |awk '{print $1}' |tr '[[:upper:]]' '[[:lower:]]'`
     if [ ! "$Type" ];then #! TYPE
      [ "$DISPLAY" ] && xmessage -bg red "Sorry, no file system inside initrd." &
      echo "Sorry, no file system inside initrd."
      # REM: For now gzip it back again.
      #      Todo: Could unpack it ...
      if [ "$imageFILEBASE" = 'initrd' ];then
      gzip -9 "$imageFILE"
      fi
      exit 1
     fi #! TYPE
    ;;
    *)
    # REM: No extension nor some initrd*
    #      Ex: openSUSE-10.3-read-only.i686-2.0
    #            Regular file, size 659.1 MiB (691138560 bytes)
    #            Linux squashfs, version 3.0, little-endian
    #            Compressed size 659.1 MiB (691138172 bytes)
    #            Block size 64 KiB

   Type=`disktype "$imageFILE" | grep -iE 'file system|Linux squashfs,' |tr '[[:upper:]]' '[[:lower:]]'`
    case $Type in
    *squashfs*) Type=squashfs;;
    *) Type=${Type%% *};;  ## TODO
    esac
   ;;
   esac

 # REM: Say something...
 if [ "$Type" ]; then
 _notice "Detected Type='$Type'"
 else
 _warn "Could not detect f.s. Type='$Type'"
 fi

  #v423 detect wrong squashfs version...
  if [ "$Type" = "squashfs" ];then #squashfs
  _info "Is squashfs"
   DISK_TYPE=`disktype "${imageFILE}" 2>&1`
    if [ "`echo "$DISK_TYPE" | grep -i permission`" ];then #DISK_TYPE
     xmessage -bg red2 "CHECK Permissions :
`ls -l $imageFILE`
"
     exit 1

    elif [ ! "`echo "$DISK_TYPE" | grep "$SFSSTR"`" ];then #DISK_TYPE
    case $KERNEL_RELEASE in
     [0-2].*)
     if [ $KERNELSUBVER -gt 28 ];then #KERNEL 2.6.29+
      [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This seems to be an older version 3.x squashfs file, not usable.
All Linux kernels 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
     else #KERNEL 2.6.29-
      [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This seems to be a newer version 4.x squashfs file, not usable.
All Linux kernels 2.6.28 or earlier require version 3.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
     fi #KERNEL 2.6.28/29
     ;;
     *) [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This seems to be an older version 3.x squashfs file, not usable.
All Linux kernels 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
     ;;
    esac
     exit $?
    fi #DISK_TYPE
  else
  _info "Not squashfs"
  fi #squashfs

 # REM: Older kernels before 3.1 need check if loopdevice available :

 # REM: just could tell user that it is not possible to mount more than Y loop devices ...
  # if [ "`losetup -a |wc -l`" -ge 8 ];then #loopdevice count
   # xmessage -bg red3 "Sorry, all loopdevices in use.
   #Please unmount some and try again."

  # else #loopdevice count

  #LAST_LOOP=`(losetup -a || losetup) 2>/dev/null`
  LAST_LOOP=`_losetup`
  LAST_LOOP=`echo "$LAST_LOOP" |cut -f1 -d: |grep -o -e '[0-9]\+' | sort -n |tail -n1`
  if [ "$LAST_LOOP" -a ! "${LAST_LOOP//[[:digit:]]/}" ]; then
  NEW_LOOP=$((LAST_LOOP+1))
  if [ ! -b /dev/loop$NEW_LOOP ] ; then
  mknod /dev/loop$NEW_LOOP b 7 $NEW_LOOP
  fi
  fi
  _info "about to $MOUNT_EXE '$imageFILE' on '$mountPT'"
  #mkdir -p "$mountPT" ##2012-06-02
  _create_mountpoint "$mountPT"

  # REM: Type or not Type ...
  # REM: If mount on another mountpoint
  #       mount-FULL uses a new available loop device,
  #       busybox mount fails because it uses the same loop device for the imgFILE
  #       busybox mount would need losetup /dev/loop imgFILE beforehand
  case $MOUNT_EXE in
  *mount-FULL*)
  if [ "$Type" ]; then
   $MOUNT_EXE -t $Type -o loop "$imageFILE" "$mountPT" ##2012-06-02
  else
   $MOUNT_EXE -o loop "$imageFILE" "$mountPT" ##2014-12-01
  fi
  Err=$?  # if should pass error code of last commands here ...
  ;;
  *)
    #newLOOP=`losetup -f`
    newLOOP=`_losetup -f`
    _debug "newLOOP='$newLOOP'"
    if [ -b "$newLOOP" ]; then
    #losetup $newLOOP "$imageFILE"
    _losetup $newLOOP "$imageFILE"
    else false
    fi
    if [ $? = 0 ]; then
    _notice "about to $MOUNT_EXE '$newLOOP' on '$mountPT'"
   if [ "$Type" ]; then
    $MOUNT_EXE -t $Type -o loop "$newLOOP" "$mountPT" ##2012-06-02
   else
    $MOUNT_EXE -o loop "$newLOOP" "$mountPT" ##2014-12-01
   fi
    Err=$?
    else  # REM: fallback though should error 255 ...
   if [ "$Type" ]; then
    $MOUNT_EXE -t $Type -o loop "$imageFILE" "$mountPT" ##2012-06-02
   else
    $MOUNT_EXE -o loop "$imageFILE" "$mountPT" ##2014-12-01
   fi
    Err=$?   # if should pass error code of last commands here ..
    fi

  ;;
  esac

  # REM: If error code 0 reported or mountPT in mount output, pop up a message
  if [ "$Err" -eq 0 ] || [ -n "`mount | grep "$mountPT"`" ];then #MOUNT OK
   if [ -n "$DISPLAY" ] ; then #DISPLAY
    #rox -d "$mountPT" # mount good, run rox filer
    _open_rox_window "$mountPT"
    yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg green -text "SUCCESS! Click $imageFILEBASE icon again to unmount it" & #BK
   fi #DISPLAY
  fi #MOUNT OK

 # REM: Some sleep neccessary because rmdir might fail if too
 #      soon after mount/umount finished - especially on SMP systems
 #sleep 2s

 if [ "$Err" -gt 0 ] ;then  #MOUNT FAIL     # ERROR: mount/unmount
  [ -n "$DISPLAY" ] && xmessage -bg red -title "ERROR..." "mounting '$mountPT' returned '$Err'"

  # REM: check to remove created directory
  #      grep needs some backslash escaping unfortunately (\+, \? expression - see man grep)
  #      So simply escape all :punct: -- should work
  #grepP=`echo "$mountPT" |sed 's|\([[:punct:]]\)|\\\\\1|g'`
  #[ -d "$mountPT" -a "`busybox mount | grep "$grepP"`" = "" ] && rmdir "$mountPT"
  _remove_mountpoint "$mountPT"
 fi #MOUNT FAIL

#fi  #loopdevice count

else #UNMOUNT               ### file's mounted, unmount it
INFO=1
DEBUG=1
DEBUGX=1

   [ -n "$DISPLAY" ] && yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg orange -text "Unmounting  $imageFILEBASE" & #BK

   # REM: Close ROX-Filer windows to avoid unmount failure
   #      because the window keeps the mountpoint busy
   _close_rox_window "$mountPT"

     # REM: Some crude code to kill f.s users ...
     # REM: Make it optional
     if [ "$KILL_FS_USERS" = "YES" ]; then
       [ -n "$DISPLAY" ] && rox -D "$mountPT" #BK

       #GREP=`echo "$mountPT" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       #_debug "$GREP"
       #LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       #_debug "$LOOPD"
       #USEapps=`_command fuser -c $LOOPD`
       #_debugx "_command fuser -c claims these pids '$USEapps' are using '$LOOPD'"
       USEapps=`_fuser "$mountPT"`
       _debugx "_fuser \"$mountPT\" claims these pids: '$USEapps'"
       # REM: Want numbers only ...
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g;s/[[:punct:]]//g'`
       _debug "f.s users: $USEapps"
       for j in $USEapps ; do
       _debugx "$j "
       case $j in 1|$$) continue;; esac
       kill -1 $j
       #kill -0 $j
       done

      # REM: Some sleep here beforehand of umount to let dust settle
      sleep 2s
     fi

  _info "$UMOUNT_EXE: $imageFILE"
  $UMOUNT_EXE -d "$mountPT" ##2012-06-02
  Err=$?

 # REM: Error handling...
 if [ "$Err" -gt 0 ] ;then  #UMOUNT FAIL # ERROR: mount/unmount
  [ -n "$DISPLAY" ] && xmessage -bg red -title "ERROR..." "Returned '$Err' ... unmounting '$mountPT'"
 fi #UMOUNT FAIL


  # REM: remove mountPT directory if not anymore in mount output
  # REM: Some sleep again beforehand...
  #sleep 2s
  #grepP=`echo "$mountPT" |sed 's|\([[:punct:]]\)|\\\\\1|g'`
  #[ -d "$mountPT" -a "`busybox mount | grep "$grepP"`" = "" ] && rmdir "$mountPT"
  _remove_mountpoint "$mountPT"

fi #UNMOUNT


exit $Err

### END ###
