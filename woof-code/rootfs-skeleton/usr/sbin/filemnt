#!/bin/ash
# ROX App.: Click image files to mount & unmount. by: Terry Becker    aka: SunBurnt
# File types = ".2fs, .3fs, .sfs, .iso, & initrd.gz".
#v423 detect wrong squashfs version 3.x or 4.x.
#v424 advise of sfs-version-converter.

###KRG Fr 31. Aug 23:34:58 GMT+1 2012

Version='2.3.1-getopts Macpup_Foxy_3-Puppy-Linux-430/2 KRG'
test -f /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5
test "$PUPMODE" || . /etc/rc.d/PUPSTATE # PUPMODE needed by _ask_to_run_sfs_load

xmTITLE="PuppyFileMount"

usage(){
MSG="
$0 [-V|-v|-d|-h|-l] FILENAME.sfs
Script to mount and unmount
loop image, iso and squashfs files
[ by simple left click ] .

-V) show version
-v) verbose
-d) debug
-h) show this usage
-l) log to /tmp/filemnt.log
"
echo "$MSG"
[ "$DISPLAY" ] && xmessage -bg lightgreen -title "$xmTITLE" "$MSG"
exit $1
}
case $@ in
*-help|*-"help "*|*-help) usage 0;;
*-version) echo -e "\n$0: Version '$Version'\n";exit 0;;
esac
OUT=/dev/null;ERR=$OUT
while getopts Vvdhl opt;do
case $opt in
V) echo -e "\n$0: Version '$Version'\n";exit 0;;
v) VERBOSE=1;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;ERR=/dev/stderr;OUT=/dev/stdout;shift;;
d) DEBUG=1;set -x;shift;;
h) usage 0;;
l) shift;exec 1>>/tmp/filemnt.log 2>&1;;
*) :;;
esac;done


_kernel_version5 ## f4puppy5

# REM: Variables
MOUNT_DIR=/mnt  # parent dir there where files should be mounted

DEBUG=1
DEBUGX=1

_notice "PWD='$PWD'"
_notice "pwd='`pwd`'"

if test -f "$*"; then
   imgFILE="$@"
   _debug "$*:Is file"  ##DEBUG
   set --
else
   _debug "$*:Is NOT file"  ##DEBUG
# REM: Filter filename parameter from other possible
#       parameters (--help,.. etc)

while [ $# != 0 ]; do
 _debugx "\$1='$1'"

 [ -f "$1" ] && imgFILE="$1"

 #this is for space only
 maybe_file="${maybe_file}$1 ";
 [ -f "$maybe_file" ] && imgFILE="$maybe_file"

 #this is for tab only
  maybe_file2=`echo -e ${maybe_file}${1}\t`;
 [ -f "$maybe_file2" ] && imgFILE="$maybe_file2"

 #this is for newline only
  maybe_file3=`echo -e ${maybe_file}${1}\n`;
 [ -f "$maybe_file3" ] && imgFILE="$maybe_file3"

 #missing combinations of space,tab and newline .. GRR...
 shift
 [ "$imgFILE" ] && break

 sleep 0.1
done

posPARAMS="$*"
set - $posPARAMS

fi

_info "$*:imgFILE='$imgFILE'"  ##DEBUG

test "$imgFILE" || _exit 3 "Need existing filename ..."

# REM: Need to handle relative path
#      regular readlink -e should print absolute path if file exists
#      regular readlink -f should print absolute path if parent directory of directory or file exists
#       ( if I understand "-f, --canonicalize
#              canonicalize  by  following  every symlink in every component of
#              the given name recursively; all  but  the  last  component  must
#              exist" correctly
#      busybox readlink has no -e option
#                       but a  -f option that works as -e
#imgFILE=`readlink -f "$imgFILE"`
imgFILE=`realpath "$imgFILE"`
_debug "imgFILE='$imgFILE'"
# REM: Sanity checks
 case "$imgFILE" in
 ./*|../*)
     dn_imgFILE=${imgFILE%/*}
     [ "$dn_imgFILE" = '.' ] && dn_imgFILE=''
     bn_imgFILE=${imgFILE##*/}
     imgFILE=`pwd`/"$dn_imgFILE"/"$bn_imgFILE"
     ;;
 */*)
     dn_imgFILE=${imgFILE%/*}
     bn_imgFILE=${imgFILE##*/}
     ;;
  *)
     dn_imgFILE=`pwd`
     bn_imgFILE="$imgFILE"
     ;;
 esac
_debug "imgFILE='$imgFILE'"
# REM: Sanity checks
#test -e "$imgFILE" || imgFILE=`pwd`/"$bn_imgFILE"
test -f  "$imgFILE" || imgFILE=`pwd`/"$bn_imgFILE"
#test -e "$imgFILE" || _exit 4 "Error while testing for existence of '$imgFILE'"
test -f "$imgFILE" || _exit 4 "Error while testing as regular file of '$imgFILE'"

_debugx "dn_imgFILE='$dn_imgFILE'"  ##DEBUG
_debugx "bn_imgFILE='$bn_imgFILE'"  ##DEBUG

# REM: 2015-11-27 add sfs_load switch
_ask_to_run_sfs_load(){

 which sfs_load >>$OUT || return 1

case $PUPMODE in 2) return 1;; esac

 MSG_TEXT="This is a squashfs file.
Do you want to load it into the current running Puppy
as merged part of the Operating System ?
Most .sfs files are made to be loaded this way.

Or, it may be just a normal archive.sfs like any .iso file
or even a .sfs made for another linux and not for Puppy.
In that case you may want to mount it just simply
as any other partition mount.
"

GMSG_TEXT=`gettext "$MSG_TEXT"`
test "${GMSG_TEXT// /}" && MSG_TEXT=$GMSG_TEXT

BUTTON_LOD=`gettext 'OS Load'`
BUTTON_MNT=`gettext 'Just Mount'`
BUTTON_EXT=`gettext 'Quit'`

xmessage -buttons "$BUTTON_LOD:100,$BUTTON_MNT:101,$BUTTON_EXT:1" -bg "light blue" -title "filmnt" "$MSG_TEXT"
case $? in
100) return 0;;
101) return 1;;
1)   return 2;;
*)   return 3;;
esac
}

# REM: Try to handle initrd files.
#      These may be compressed.
#      As of 2010 and later, Puppy Linux initrd are cpio archives.
#      Before, they seem to have been ext2 file-system files.

# REM: First some functions...

_change_into_dir_where_initrd_is(){
 parentDIR="${imgFILE%/*}"
 cd "$parentDIR" || _exit 5 "Could not change into '$parentDIR'"
 return $?
}

_make_backup_of_initrd(){
test -e "$*" || return 6
test -e "$*".bak && mv $VERB -f "$*".bak "$*".bak.old
cp $VERB -a "$*" "$*".bak
return $?
}

_make_backup_of_initrd_dir_tree(){
test -e "$*".bak && mv $VERB -f "$*".bak "$*".bak.old
test -e "$*" && mv $VERB -f "$*" "$*".bak
}

_create_and_change_into_initrd_dir_tree(){
test -e "$*" && rm -rf "$*"
mkdir $VERB -p "$*"
cd "$*" || _exit 7 "Could nor change into directory `pwd`/./initrd-tree"
}

_where_am_i(){
case `pwd` in
*${*}) :;;
*) return 8;;
esac
return 0
}

_unpack_initrd_cpio(){
_info "_unpack_initrd_cpio:$*" ##DEBUG
COMPRESS="$1"
case $COMPRESS in
gz)   dec_cat=zcat;;
bz2)  dec_cat=bzcat;;
lzo)  dec_cat=lzcat;;
lzma) dec_cat=lzmacat;;
xz)   dec_cat=xzcat;;
no)   dec_cat=cat;;
*)    echo "Unhandled compression '$COMPRESS'"
      return 10;;
esac

shift
_debug "$*"  ##DEBUG
test -e "$*" || return 8
which $dec_cat >>$OUT || return 9
$dec_cat "$*" | cpio -i -d
return $?
}

_is_initrd_cpio(){
 disktype "$imgFILE" | grep $Q -i 'cpio' && return 0
 return 1
}

_is_initrd_fs(){
 disktype "$imgFILE" | grep $Q -i 'File system' && return 0
 return 1
}

# REM: Variables
INTRD_DIR_TREE="initrd-tree" # name of the initrd_dir_tree to extract files from initrd

_prepare(){
# REM: Prepare the working directory
_change_into_dir_where_initrd_is
_make_backup_of_initrd "$imgFILE"
_make_backup_of_initrd_dir_tree "$INTRD_DIR_TREE"
_create_and_change_into_initrd_dir_tree "$INTRD_DIR_TREE"
_where_am_i || _exit 9 "Something feels wrong in this directory '`pwd`'"
}


case "${imgFILE##*/}" in
*initrd*)


# REM: Define compression from extension
case "$imgFILE" in
*initrd*.gz)   COMPRESS=gz;;
*initrd*.bz2)  COMPRESS=bz2;;
*initrd*.lzo)  COMPRESS=lzo;;
*initrd*.lza|*initrd*.lzm|*initrd*.lzma|*initrd*.lz)  COMPRESS=lzma;;
*initrd*.xz)   COMPRESS=xz;;
*initrd*)      COMPRESS=no;;
*) _err "Unhandled extension of '$bn_imgFILE'";;
esac


# REM: Is initrd a file-system
#      or cpio archive
if  _is_initrd_cpio; then
 _prepare
 _unpack_initrd_cpio "$COMPRESS" "$imgFILE"
 [ $? = 0 ] || { echo "something went wrong ..."; false; }
   exit $?

elif _is_initrd_fs; then
    _info "$imgFILE seems to contain a file system"  ##DEBUG
    # REM: further down it will be mounted


else
_err "Unhandled file type for '$imgFILE' - neither cpio or file-system"
exit 2
fi


;;
*.sfs)
 case $PUPMODE in 2|3) :;;
 *)
   if [ "`which load_sfs`" ]; then

       LOAD_MSG=`gettext "Do you want insert / load / integrate the
$bn_imgFILE into the current running
$DISTRO_NAME $DISTRO_VERSION ?
Or do you just want to mount it to look inside ?
"`
    INSERT_B=`gettext 'Insert'`
    MOUNT_B=`gettext 'Mount'`
    xmessage -buttons "$INSERT_B:100,$MOUNT_B:101" "$LOAD_MSG"
    case $? in
    100) exec sfs_load "$@";;
    101) :;;
    *) exit 0;;
    esac


   fi
 ;;
 esac
;;
esac

_debug "5 mntPT='$mntPT'"  ##DEBUG
#+++2016-02-16 Add mountpoint parameter support
_debug "positional parameters:$*"
case "$*" in ${imgFILE#*/mnt/home}|${bn_imgFILE#./}|$imgFILE|$bn_imgFILE) :;;
*)
_debug "6 mntPT='$mntPT'"  ##DEBUG
#test "$2" && mntPT="$2" #always quote it
##test "$1" && mntPT="$1" #always quote it
#shift
test "$*" && mntPT="$*" #always quote it
;;
esac

_debug "7 mntPT='$mntPT'"  ##DEBUG
test "$mntPT" || mntPT="${MOUNT_DIR}/$bn_imgFILE"
_debug "7 mntPT='$mntPT'"  ##DEBUG
test -e "$mntPT" && mntPT="${MOUNT_DIR}/$bn_imgFILE"
_debug "8 mntPT='$mntPT'"  ##DEBUG

grepPatternMntPt=`echo "$mntPT" | sed 's#\([[:punct:]]\)#\\\1#g'`
grepPatternImgFile=`echo "$imgFILE" | sed 's#\([[:punct:]]\)#\\\1#g'`

_create_new_folder_name(){
    _debug "_create_new_folder_name:$*"
    test "$*" || return 2
    test -d "$*" || { mkdir -p "$*" && return 0; }
c=
while read path_to_folder
do
_debug "_create_new_folder_name:$path_to_folder"  ##DEBUG
c=$((c+1))
test -e "${path_to_folder%.[0-9]}".$c && continue
mntPT="${path_to_folder%.[0-9]}".$c
break
done << EoI
`ls -1dv "$*"*`
EoI
}

_xmessage_menu(){

xmessage -buttons "

Just
Quit
-->:190,

Open ROX-
Filer window
-->:191,

Open
console
-->:192,

Just Unmount
$IMGBASE
-->:193,

Unmount all
$IMGBASE
-->:194,

Mount an-
other time
-->:199
" -title "$xmTITLE" "$imgFILE
is already mounted $IN_USE_BY_PUPPY .
Do you want to unmount it
or mount it to another mount point ?"

RETVAL=$?

}

_xdialog_menu(){

Xdialog\
    -title "xmTITLE"\
    -stdout\
    -no-cancel\
    -menu\
    "$imgFILE
is already mounted $IN_USE_BY_PUPPY .
$cmMSG
Do you want to unmount it
or mount it on $mpMSG ?"\
    400x280 6\
    "Quit" "do nothing - just leave"\
    "ROX" "open ROX-Filer window"\
    "Console" "open rxvt console window"\
    "unmount" "just unmount $bn_imgFILE"\
    "Unmount all" "unmount all $bn_imgFILE"\
    "mount again" "mount $bn_imgFILE again"\
    >/tmp/filemnt_dialog.out

[ $? = 0 ] || exit 0
read RETVAL </tmp/filemnt_dialog.out
case "$RETVAL" in
Quit)          RETVAL=190;;
ROX)           RETVAL=191;;
Console)       RETVAL=192;;
unmount)       RETVAL=193;;
Unmount*all)   RETVAL=194;;
mount*again)   RETVAL=199;;
esac

}

_get_real_backing_file(){

  test "$*" || return 3
  oneLOOP_="$*"
  test -b "$oneLOOP_" || return 4
  _debug "_get_real_backing_file oneLOOP_='$oneLOOP_'"

  #PROBLEM:
  # kernel 2.6.37.4 writes such after mount into backing_file ..:
  #/usr/sbin/filemnt:DEBUG:\nmount: 'ext2' '/dev/loop0' '/mnt/test.2fs'\n
  #FS_TYPE='Ext2'
  #mount-FULL normal='0'
  #if #8 else '-t ext2 -o loop /dev/loop0 /mnt/test.2fs' ''
  #mount-FULL normal='0'
  #final RETVAL='0'

  #bash-3.2# losetup -a
  # /dev/loop/0: [c0010300]:2324803 (/tmp/test.2fs)
  # /dev/loop/1: [0005]:699 (/dev/loop0)
  # file /dev/loop/0
  # /dev/loop/0: symbolic link to `../loop0'
  # file /dev/loop/1
  # /dev/loop/1: symbolic link to `../loop1'
  #mount-FULL --version
  # mount (util-linux 2.13-pre7)
  #busybox | head -n2
  # BusyBox v1.18.3 (2011-05-01 19:45:13 CEST) multi-call binary.
  #grep /dev/loop /proc/mounts
  #/dev/loop1 /mnt/test.2fs ext2 rw,relatime,errors=continue 0 0

  # mount-FULL works correctly from the cmdline:
  # mkdir /mnt/test.2fs
  # mount-FULL -o loop ./test.2fs /mnt/test.2fs
  # losetup -a
  #  /dev/loop/0: [c0010300]:2324803 (./test.2fs)
  # grep /dev/loop /proc/mounts
  #  /dev/loop0 /mnt/test.2fs ext2 rw,relatime,errors=continue 0 0

  #bash-3.2# umount-FULL /mnt/test.2fs
  #bash-3.2# grep /dev/loop /proc/mounts
  #bash-3.2# losetup -a
  # /dev/loop/0: [c0010300]:2324803 (./test.2fs)

  # found error: -t TYPE -o loop /dev/loopY MNTPT was -o loop too much

  # REM: Now try to get the basename of the file associated with oneLOOP
   unset oneIMG_FILE_ LOSETUP_OUT_ oneMOUNTPOINT_ eoneMOUNTPOINT_ IMGBASE_
   if test -f /sys/block/${oneLOOP_##*/}/loop/backing_file; then
    read oneIMG_FILE_ </sys/block/${oneLOOP_##*/}/loop/backing_file
    _debug "_get_real_backing_file oneIMG_FILE_='$oneIMG_FILE_'"
   fi
   case $oneIMG_FILE_ in /dev/loop*) unset oneIMG_FILE_;; esac

   if [ -f "$oneIMG_FILE_" ]; then :
   else
    #oneIMG_FILE_=`losetup-FULL "$oneLOOP_" | cut -f 2 -d '(' | cut -f 1 -d ')'`
    LOSETUP_OUT_=`losetup "$oneLOOP_" | tail -n1`
    _debug "_get_real_backing_file LOSETUP_OUT_='$LOSETUP_OUT_'"
    set - $LOSETUP_OUT_
    shift #$1
    shift #$2
    oneIMG_FILE_="$@"
    oneIMG_FILE_=`echo "$oneIMG_FILE_" | sed 's%^(%%;s%)$%%'`
    case $oneIMG_FILE_ in
    /dev/loop*)
    NR=${oneIMG_FILE_##*/}
    NR=${NR##*loop}
    _debug "_get_real_backing_file NR='$NR'"
    oneIMG_FILE_=`losetup "$oneIMG_FILE_" | grep -Ew "^/dev/loop$NR|^/dev/loop/$NR" | cut -f 2 -d '(' | cut -f 1 -d ')'`
    ;;
    esac
    _debug "_get_real_backing_file oneIMG_FILE_='$oneIMG_FILE_'"
    #TODO 64 chars
    #bash-3.2# losetup-FULL /dev/loop1
    #/dev/loop1: [0700]:2579 (/mnt/xubuntu-11.10-desktop-i386.iso.29782/casper/filesystem.sq*)
                            # 123456789012345678901234567890123456789012345678901234567890123
    case $oneIMG_FILE_ in
    *\*) _warn "truncated output by losetup"
        length_oneIMG_FILE_=`echo "$oneIMG_FILE_" | wc -L`
        _notice "'$oneMNTDIMG' is '$length_oneIMG_FILE_' characters or more"
        :
        ;;
    esac
   fi

   # REM: A loop mount could be loaded into the current frugal OS
   #       or be just mounted.
   #      The initrd mounts on /mnt but switch_root
   #       changes the mountpoint to /initrd/mnt in /proc/mounts,
   #       but the losetup output stays as it was
   oneMOUNTPOINT_=`grep -w "^$oneLOOP_" /proc/mounts | cut -f2 -d' '`
   oneMOUNTPOINT_=`echo -e "$oneMOUNTPOINT_"`
   case $oneMOUNTPOINT_ in
   /initrd/*) oneIMG_FILE_="/initrd$oneIMG_FILE_";;
   esac

    IMGBASE_=`basename "$oneIMG_FILE_"`
    _debug "_get_real_backing_file IMGBASE_='$IMGBASE_'"
test "$IMGBASE_"
}

_check_already_mounted(){

  #BK check if already mounted elsewhere...
  for oneLOOP in `grep '^/dev/loop' /proc/mounts | cut -f 1 -d ' '`
  do

  __get_real_backing_file(){
   # REM: Now try to get the basename of the file associated with oneLOOP
   if test -f /sys/block/${oneLOOP##*/}/loop/backing_file; then
    read oneIMG_FILE </sys/block/${oneLOOP##*/}/loop/backing_file
   else
    oneIMG_FILE=`losetup-FULL "$oneLOOP" | cut -f 2 -d '(' | cut -f 1 -d ')'`
    #TODO 64 chars
    #bash-3.2# losetup-FULL /dev/loop1
    #/dev/loop1: [0700]:2579 (/mnt/xubuntu-11.10-desktop-i386.iso.29782/casper/filesystem.sq*)
                            # 123456789012345678901234567890123456789012345678901234567890123
    case $oneIMG_FILE in
    *\*) _warn "truncated output by losetup"
        length_oneIMG_FILE=`echo "$oneIMG_FILE" | wc -L`
        _notice "'$oneMNTDIMG' is '$length_oneIMG_FILE' characters or more"
        :
        ;;
    esac
   fi

   # REM: A loop mount could be loaded into the current frugal OS
   #       or be just mounted.
   #      The initrd mounts on /mnt but switch_root
   #       changes the mountpoint to /initrd/mnt in /proc/mounts,
   #       but the losetup output stays as it was
   oneMOUNTPOINT=`grep -w "^$oneLOOP" /proc/mounts | cut -f2 -d' '`
   oneMOUNTPOINT=`echo -e "$oneMOUNTPOINT"`
   case $oneMOUNTPOINT in
   /initrd/*) oneIMG_FILE="/initrd$oneIMG_FILE";;
   esac

    IMGBASE=`basename "$oneIMG_FILE"`
  }
   _get_real_backing_file "$oneLOOP" || : #TODO Error handling
   IMGBASE=$IMGBASE_

    _debug "IMGBASE='$IMGBASE' bn_imgFILE='$bn_imgFILE'" #TEST
    #not perfect, but paths may be symlinks...

    if [ "$IMGBASE" = "$bn_imgFILE" ];then #if [ "$MNTDIMG" = "$imgFILE" ];then #6

     # If frugal install check if it is in use
     IN_USE_BY_PUPPY=
     case "$IMG_MTP" in
     */pup_ro[0-9]*) IN_USE_BY_PUPPY="and in use by Puppy" ;;
     esac

     # REM : Try to tell the current mountpoint
     test "$curr_mntPT" && cmMSG="on $curr_mntPT"
     test "$mntPT"      && mpMSG="on $mntPT" || mpMSG="another mount point"

     if [ -n "$DISPLAY" ] ; then #66

   if which Xdialog >>$OUT; then _xdialog_menu
 elif which xmessage>>$OUT; then _xmessage_menu
 else RETVAL=193
   fi

  if [ "$RETVAL" = "190" ] ; then #666  ## Quit
     exit $?

  elif [ "$RETVAL" = "191" ] ; then #666  ## open a ROX-Filer window
       mntPT=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
       test -d "$mntPT" || {
       #+++2016-02-16 using losetup
       _LOSETUP_=`losetup || losetup -a` 2>>$ERR
       dev_node_=`echo "$_LOSETUP_" | grep "$IMGBASE" | tail -n1 | awk -F'[ :]' '{print $1}'`
       test "$dev_node_" && mntPT=`grep -w "^$dev_node_" /proc/mounts | tail -n1 |cut -f2 -d' '`
       }
       mntPT=`echo -e "$mntPT"`
       test -d "$mntPT" && rox "$mntPT"
       exit $?

  elif [ "$RETVAL" = "192" ] ; then #666  ## console
       mntPT=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
       test -d "$mntPT" || {
       #+++2016-02-16 using losetup
       _LOSETUP_=`losetup || losetup -a` 2>>$ERR
       dev_node_=`echo "$_LOSETUP_" | grep "$IMGBASE" | tail -n1 | awk -F'[ :]' '{print $1}'`
       test "$dev_node_" && mntPT=`grep -w "^$dev_node_" /proc/mounts | tail -n1 |cut -f2 -d' '`
       }
       mntPT=`echo -e "$mntPT"`
       test -d "$mntPT" && {
       cd "$mntPT"
       _debug "pwd='`pwd`'"
       rxvt &
       }
       exit $?

  elif [ "$RETVAL" = "193" ] ; then #666  ## umount
       UNMOUNT='yes'
       #test "$mntPT" || mntPT=`busybox mount | grep "$IMGBASE" | head -n 1 | cut -f 3 -d ' '`
       mntPT=`busybox mount | grep "$IMGBASE" | tail -n 1 | cut -f 3 -d ' '`
       _debug "193:$mntPT"
       test -d "$mntPT" || {
       #+++2016-02-16 using losetup
       _LOSETUP_=`losetup || losetup -a` 2>>$ERR
       dev_node_=`echo "$_LOSETUP_" | grep "$IMGBASE" | tail -n1 | awk -F'[ :]' '{print $1}'`
       test "$dev_node_" && mntPT=`grep -w "^$dev_node_" /proc/mounts | tail -n1 |cut -f2 -d' '`
       }
       _debug "193:$mntPT"
       test -d "$mntPT" || {
	   _LOSETUP_=`losetup || losetup -a` 2>>$ERR
	   dev_node_=`echo "$_LOSETUP_" | grep "$IMGBASE" | tail -n1 | awk -F'[ :]' '{print $1}'`
	   devNR=${dev_node_##*/} #/dev/loop/0
       devNR=${devNR##*loop}  #/dev/loop0
       real_loop=`echo "$_LOSETUP_" | grep -E "[ (]/dev/loop$devNR[)]$|[ (]/dev/loop/$devNR[)]$" | cut -f1 -d':'`
       _debug "193:real_loop=$real_loop"
       devNR=${real_loop##*/} #/dev/loop/0
       devNR=${devNR##*loop}  #/dev/loop0
       _debug "193:devNR=$devNR"
       mntpt=`grep -Ew "^/dev/loop$devNR|^/dev/loop/$devNR" /proc/mounts | cut -f2 -d' '`
       _debug "193:mntpt=$mntpt"
	   }
       mntPT=`echo -e "$mntPT"`
       test -d "$mntPT"
       return $?

  elif [ "$RETVAL" = "194" ] ; then #666  ## umount ALL $IMGBASE
       UNMOUNT='yes'
       _debug "194:IMGBASE=$IMGBASE"
       #mntPT=`cut -f2 -d' ' /proc/mounts | grep "${IMGBASE}[\.0-9]*$"`
       #mntPTS=`cut -f2 -d' ' /proc/mounts | grep "${IMGBASE}"`
       gPATTERN=`_convert_nl_tab_sp "$IMGBASE"`
       mntPTS=`cut -f2 -d' ' /proc/mounts | grep "$gPATTERN"`
       _debug "194:mntPTS=$mntPTS"
       test "$mntPTS" || {
       _LOSETUP_=`losetup || losetup -a` 2>>$ERR
       loops=`echo "$_LOSETUP_" | grep "$IMGBASE" | awk -F'[ :]' '{print $1}'`
       for l in $loops; do
       devNR=${l##*/}        #/dev/loop/0
       devNR=${devNR##*loop} #/dev/loop0
       real_loop=`echo "$_LOSETUP_" | grep -E "[ (]/dev/loop$devNR[)]$|[ (]/dev/loop/$devNR[)]$" | cut -f1 -d':'`
       _debug "194:real_loop=$real_loop"
       devNR=${real_loop##*/} #/dev/loop/0
       devNR=${devNR##*loop}  #/dev/loop0
       _debug "194:devNR=$devNR"
       mntpt=`grep -Ew "^/dev/loop$devNR|^/dev/loop/$devNR" /proc/mounts | cut -f2 -d' '`
       _debug "194:mntpt=$mntpt"
       #mntpt=`echo -e "$mntpt"` #not allowed for next for loop needs cons filenames without space
       mntPTS="$mntpt
$mntPTS"
       _debug "194:mntPTS=$mntPTS"
       done
       }

       MntPtS=`echo "$mntPTS" | sed "1 d"` ## only umount all others except one
       _debug "194:MntPtS=$MntPtS"

       for i in $MntPtS ; do
       _debug "194:i=$i"
       i=`echo -e "$i"`
       test "$i"    || continue
       test -d "$i" || continue
       GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "194:GREP='$GREP'"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "194:LOOPD='$LOOPD'"
       #USEapps=`fuser -c $LOOPD`     ##---2011-10-27
       USEapps=`fuser -m "$i"`        ##+++2011-10-27
       _notice "194:fuser:$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
       _debugx "194:fuser:$USEapps"

       # REM: kill signal - use your preferred signal
       #      Supported signals are listed by 'help trap'
       SIG=2
       for j in $USEapps ; do
       _debugx "fuser claims PID '$j' is using '$i'"
       #kill -$SIG $j
       done

       [ -n "$DISPLAY" ] && rox -D "$i"
       /bin/umount "$i"
       #sleep 2
       #rmdir "$i"
       done

       _debug "194:IMGBASE=$IMGBASE"
       #mntPT=`cut -f2 -d' ' /proc/mounts | grep "${IMGBASE}"`
       gPATTERN=`_convert_nl_tab_sp "$IMGBASE"`
       mntPT=`cut -f2 -d' ' /proc/mounts | grep "$gPATTERN"`
       _debug "194:$mntPT"
       test -d "$mntPT" || {
       #+++2016-02-16 using losetup
       _debug "194:losetup OR losetup -a"
       _LOSETUP_=`losetup || losetup -a` 2>>$ERR
       _debug "194:losetup OR losetup -a"
       dev_node_=`echo "$_LOSETUP_" | grep "$IMGBASE" | tail -n1 | awk -F'[ :]' '{print $1}'`
       _debug "194:dev_node_=$dev_node_"
       devNR=${dev_node_##*/}
       devNR=${devNR##*loop}
       _debug "194:devNR=$devNR"
       test "$dev_node_" && {
           mntPT=`grep -Ew "^/dev/loop$devNR|^/dev/loop/$devNR" /proc/mounts | tail -n1 |cut -f2 -d' '`
           _debug "194:$mntPT"
       }
       mntPT=`echo -e "$mntPT"`
       if test "$mntPT" ; then :
       else
       real_loop=`echo "$_LOSETUP_" | grep -E "[ (]/dev/loop$devNR[)]$|[ (]/dev/loop/$devNR[)]$" | cut -f1 -d':'`
       _debug "194:real_loop=$real_loop"
       devNR=${real_loop##*/}
       devNR=${devNR##*loop}
       _debug "194:devNR=$devNR"
       mntPT=`grep -Ew "^/dev/loop$devNR|^/dev/loop/$devNR" /proc/mounts | tail -n1 |cut -f2 -d' '`
       _debug "194:$mntPT"
       fi
    }
       _debug "194:$mntPT"
       mntPT=`echo -e "$mntPT"`
       _debug "194:$mntPT"
       [ -d "$mntPT" ]
       return $?

  else   #666
     MOUNT='again'
     return 0
  fi   ###666

 else ##66
 # REM: Without X, no sophisticated GUI - just unmount
 UNMOUNT='yes'  ##+++2011-10-27
 # REM: END DISPLAY test
 fi ##66

else : # do nothing
# REM: END basename comparisons of files printed by losetup and imgFILE
fi #6

# REM: check /dev/loop in proc/mounts
done

}

_check_already_mounted || _exit 4 "TODO:_check_already_mounted returned '$?'"

# REM: UNMOUNT is not set until it gets set by GUI or automatically if no DISPLAY
if [ -z "$UNMOUNT" ] ; then
 # REM: mount imgFILE

  # REM: Do not use a Ext variable, case is better
  # get file type from extension
  #Ext=`echo "$imgFILE" |sed 's/^.*\.//'`
  #Ext=${imgFILE##*.}

 case "$imgFILE" in
 *.2fs|*.ext2|*.ext2fs.img) Type=ext2;;
 *.3fs|*.ext3|*.ext3fs.img) Type=ext3;;
 *.4fs|*.ext4|*.ext4fs.img) Type=ext4;;
 *.btr|*.btrfs|*.btrfs.img) Type=btrfs;;
 *.jfs|*.jfs.img)           Type=jfs;;
 *.mnx|*.minix|*.minix.img) Type=minix;;
 *.ofs|*.ocfs2|*.ocfs2.img) Type=ocfs2;;
 *.rfs|*.rfs3|*.rfs.img)    Type=reiserfs;;
 *.sfs|*.sqfs|*.squashfs|*.squashfs.img) Type=squashfs;;
 *.xfs|*.xfs.img)           Type=xfs;;
 *.iso|*.ISO|*.Iso)
   #Fatdog fat16 first and iso9660 second  ###+++2013-03-02
   TYPES=`disktype "$imgFILE" |grep 'file system'`
   if [ "`echo "$TYPES" |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]' | grep -i 'UDF'`" ]; then
    Type=udf
   else
    Type=iso9660
   fi
  ;;
  *)
   Type=`disktype "$imgFILE" |grep 'file system' |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]'` ##+++2012-06-04 udf or iso9660
   #Type='iso9660' ##---2012-06-04
   # BK
   #elif [ "$imgFILE" = 'initrd.gz' ] ;then
   # Type='ext2'
   # gunzip $imgFILE             # handle gzip image file
   # imgFILE="echo "$imgFILE" |sed 's/.gz$//'"
  ;;
  esac

  #v423 detect wrong squashfs version...
  if [ "$Type" = "squashfs" ];then
   DISK_TYPE=`disktype "${imgFILE}"`
   _debug $DISK_TYPE

   # use unsquashfs -s
   # v3
   FILE_HEADER3=`unsquashfs3 -s "${imgFILE}" 2>&1`
   _debug $FILE_HEADER3
   case "$FILE_HEADER3" in
    *Filesystem*on*is*\(4:0\),*which*is*a*later*filesystem*version*than*I*support!*)
     IS_SQUASH=YES
     IS_SQUASH3=MAYBE
     IS_SQUASH4=YES
     ;;
   esac
   # v4
   FILE_HEADER4=`unsquashfs4 -s "${imgFILE}" 2>&1`
   _debug $FILE_HEADER4
   case "$FILE_HEADER4" in
    *Found*a*valid*SQUASHFS*4:0*superblock*on*.*)
     IS_SQUASH=YES
     IS_SQUASH3=
     IS_SQUASH4=YES
     ;;
   esac

   _debugx IS_SQUASH=$IS_SQUASH IS_SQUASH3=$IS_SQUASH3 IS_SQUASH4=$IS_SQUASH4

   # maybe it is not a squashfs file
   test "$IS_SQUASH" = YES -o "`echo "$DISK_TYPE" | grep -i squash`" || {
    MSG_ERR_NO_SQUASH=`gettext "Could not confirm being a squashfs file"`
    _warning "$MSG_ERR_NO_SQUASH"
    xmessage -bg red "$MSG_ERR_NO_SQUASH"
    exit 4
   }

   if [ "`echo "${DISK_TYPE}" | grep "$SFSSTR"`" = "" ];then
    xmessage -bg orange1 "$DISK_TYPE"
    if [ $K_VERSION = 2 -a $KERNELSUBVER -gt 28 ] || [ $K_VERSION -gt 2 ];then
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This may be an older version 3.x squashfs file, not usable.
All Linux kernels around 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    else
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This may be a newer version 4.x squashfs file, not usable.
All Linux kernels around 2.6.28 or earlier require version 3.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    fi
    _err "Wrong squashfs version"
    exit 0
   fi

  _ask_to_run_sfs_load
  case $? in 0) exec sfs_load "$imgFILE";;
  1) :;; 2) exit 0;; *) _warn "Unhandled return value from _ask_to_run_sfs_load";;
  esac

  fi

  # REM: Older pups need to mknod a /dev/loop
  #      Since kernel 3.1 they are automatically created by the kernel
  _ensure_loop_cont
  _mk_free_loop  # see f4puppy5

  # REM: if choosen mount again
  [ "$MOUNT" = 'again' ] && _create_new_folder_name "$mntPT"
  _debug "mntPT='$mntPT'"  ##DEBUG
  mkdir -p "$mntPT"    ## mount.sh should do this

_encrypted()
{
  #111110 handle encrypted save-files...
  CRYPTO=""; Err=0
  freeLOOP="`losetup-FULL -f`" #next free loop device.
  test $? = 0 || return 1

#  bash-3.2# modprobe $VERB -l | grep crypt
#kernel/drivers/staging/rtl8192e/rtllib_crypt_wep.ko
#kernel/drivers/staging/rtl8192e/rtllib_crypt_tkip.ko
#kernel/drivers/staging/rtl8192e/rtllib_crypt_ccmp.ko
#kernel/drivers/crypto/padlock-sha.ko
#kernel/drivers/crypto/geode-aes.ko
#kernel/drivers/crypto/padlock-aes.ko
#kernel/security/keys/encrypted-keys/encrypted-keys.ko
#kernel/net/wireless/lib80211_crypt_ccmp.ko
#kernel/net/wireless/lib80211_crypt_wep.ko
#kernel/net/wireless/lib80211_crypt_tkip.ko
#kernel/crypto/ccm.ko
#kernel/crypto/xcbc.ko
#kernel/crypto/fcrypt.ko
#kernel/crypto/rmd320.ko
#kernel/crypto/cts.ko
#kernel/crypto/serpent_generic.ko
#kernel/crypto/sha256_generic.ko
#kernel/crypto/ctr.ko
#kernel/crypto/ghash-generic.ko
#kernel/crypto/arc4.ko
#kernel/crypto/async_tx/raid6test.ko
#kernel/crypto/tgr192.ko
#kernel/crypto/camellia_generic.ko
#kernel/crypto/crypto_null.ko
#kernel/crypto/gf128mul.ko
#kernel/crypto/cast6.ko
#kernel/crypto/khazad.ko
#kernel/crypto/zlib.ko
#kernel/crypto/crypto_user.ko
#kernel/crypto/rmd160.ko
#kernel/crypto/blowfish_generic.ko
#kernel/crypto/rmd256.ko
#kernel/crypto/cast5.ko
#kernel/crypto/gcm.ko
#kernel/crypto/sha512_generic.ko
#kernel/crypto/algif_skcipher.ko
#kernel/crypto/rmd128.ko
#kernel/crypto/seed.ko
#kernel/crypto/wp512.ko
#kernel/crypto/xts.ko
#kernel/crypto/md4.ko
#kernel/crypto/twofish_generic.ko
#kernel/crypto/blowfish_common.ko
#kernel/crypto/vmac.ko
#kernel/crypto/salsa20_generic.ko
#kernel/crypto/pcrypt.ko
#kernel/crypto/lrw.ko
#kernel/crypto/aes_generic.ko
#kernel/crypto/anubis.ko
#kernel/crypto/tea.ko
#kernel/crypto/twofish_common.ko
#kernel/crypto/michael_mic.ko
#kernel/crypto/ansi_cprng.ko
#kernel/crypto/ecb.ko
#kernel/crypto/pcbc.ko
#kernel/crypto/af_alg.ko
#kernel/crypto/cryptd.ko
#kernel/crypto/seqiv.ko
#kernel/crypto/tcrypt.ko
#kernel/crypto/algif_hash.ko
#kernel/fs/ecryptfs/ecryptfs.ko
#kernel/arch/x86/crypto/crc32c-intel.ko
#kernel/arch/x86/crypto/serpent-sse2-i586.ko
#kernel/arch/x86/crypto/aes-i586.ko
#kernel/arch/x86/crypto/twofish-i586.ko
#kernel/arch/x86/crypto/aesni-intel.ko
#kernel/arch/x86/crypto/salsa20-i586.ko

     _init_crypt_save_file(){
      local fCRYPT=$1 Err=1
      test "$fCRYPT" || return 1

      MYPASS="`pupdialog --title "$(gettext 'Enter Password')" --stdout --inputbox "$(gettext 'Password required to open') ${bn_imgFILE}:" 0 0`"
      Err=$?

      if [ $Err -eq 0 ];then
       echo "$MYPASS" | losetup-FULL -p 0 -e $fCRYPT $freeLOOP "$imgFILE"
       Err=$?
      fi
      return $Err
     }

  case $Type in
   ext2|ext3|ext4|btrfs|jfs|ocfs2|reiserfs|xfs)
    case "$bn_imgFILE" in

     *_cryptx*) #light encryption.
      CRYPTO='light'
      modprobe $Q $VERB cryptoloop
      rxvt -geometry 25x3 -title "$(gettext 'Enter password')" -bg orange -e losetup-FULL -E 1 $freeLOOP "$imgFILE"
      #losetup-FULL -E 1 $freeLOOP $imgFile
      Err=$?
     ;;

     *_crypta*) #heavy encryption.
      CRYPTO='aes'

      for mod in cryptoloop aes_generic aes crypto_blkcipher blkcipher cbc
      do
      modprobe $Q $VERB -l | grep $Q "/${mod}.ko$" || continue
      modprobe $Q $VERB $mod
      done

      #modprobe $VERB cryptoloop
      #modprobe $VERB aes_generic 2>$ERR #v407 aes name change.
      #modprobe $VERB aes 2>$ERR #for older kernel <2.6.25
      #modprobe $VERB crypto_blkcipher 2>$ERR #v407 blkcipher name change.
      #modprobe $VERB blkcipher 2>$ERR #old kernel.
      #modprobe $VERB cbc

# <linux/loop.h>
#/*
# * Loop filter types
# */

#define LO_CRYPT_NONE           0
#define LO_CRYPT_XOR            1
#define LO_CRYPT_DES            2
#define LO_CRYPT_FISH2          3    /* Twofish encryption */
#define LO_CRYPT_BLOW           4
#define LO_CRYPT_CAST128        5
#define LO_CRYPT_IDEA           6
#define LO_CRYPT_DUMMY          9
#define LO_CRYPT_SKIPJACK       10
#define LO_CRYPT_CRYPTOAPI      18
#define MAX_LO_CRYPT            20


      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptblowfish*|*_cryptbf*) CRYPTO=blowfish
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_crypttwofish*|*_crypttf*) CRYPTO=twofish
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptarc4*|*_cryptarc*) CRYPTO=arc4
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptanubis*|*_cryptan*) CRYPTO=anubis
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptserpent*|*_crypts*) CRYPTO=serpent
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *_cryptcamellia*|*_cryptc*) CRYPTO=camellia
      _init_crypt_save_file $CRYPTO; Err=$?
     ;;

     *) [ -b "$freeLOOP" ] && losetup $freeLOOP "$imgFILE"; Err=$?
     ;;
    esac
    ;;
   *) [ -b "$freeLOOP" ] && losetup $freeLOOP "$imgFILE"; Err=$?
   ;;
  esac

return $Err
}

mkdir $VERB -p "$mntPT" # mount.sh should do this
_encrypted && {
  # REM: New problem in case of additional mount 2014-11-27,
  #      mount complains that /dev/loop is in use - don't know why ...
  #freeLOOP=`losetup -f`
  #[ -b "$freeLOOP" ] && losetup $freeLOOP "$imgFILE" && {

  _debug "\nmount: '$Type' '$freeLOOP' '$mntPT'\n"
   /bin/mount $VERB -t $Type -o loop "$freeLOOP" "$mntPT"
  # /bin/mount $VERB -t $Type "$freeLOOP" "$mntPT"
   Err=$?
  } || {

  #__old_mount_code_that_worked_flawless_until_today__(){  #mount.sh uses busybox mount
  _debug "\nmount: '$Type' '$imgFILE' '$mntPT'\n"
  /bin/mount $VERB -t $Type -o loop "$imgFILE" "$mntPT";
   Err=$?
  # }                                                      #busybox mount does not automatically assign
  #__old_mount_code_that_worked_flawless_until_today__     #a loop device, whereas mount-FULL does.
  }

  if [ "$Err" -eq 0 ]; then
   if [ -n "$DISPLAY" ] ; then #99
    yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg green -text "SUCCESS! Click $imgFileBASE icon again to unmount it" & #BK
   fi
  elif [ -n "`mount | grep "$mntPT"`" ];then
   :
  else
   : sleep 2s
   losetup -d $freeLOOP
   #: [ -d "$mntPT" ] && { [ -z "`ls -A "$mntPT" 2>/dev/null`" ] && rmdir "$mntPT"; }
  fi


 else
 # REM: unmount imgFILE using mntPT
   [ -n "$DISPLAY" ] && {
    #:rox -D "$mntPT"
    yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg orange -text "Unmounting $bn_imgFILE" &
   }
       GREP=`echo "$mntPT" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "unmount:$GREP"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "unmount:$LOOPD"
       #USEapps=`fuser -c $LOOPD`   ##---2011-10-27
       USEapps=`fuser -m "$mntPT"`  ##---2011-10-27
       _notice "unmount:fuser:$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g;s/[[:punct:]]//g'`
       _debugx "unmount:fuser:$USEapps"

       # REM: kill signal - use your preferred signal
       #      Supported signals are listed by 'help trap'
       SIG=2
       for j in $USEapps; do
       _debugx "fuser claims PID '$j' is using '$mntPT'"
       #kill -$SIG $j
       done

  #_debug "\nUnMount: '$imgFILE'\n"
  _debug "\nUnMount: '$mntPT'\n"
  /bin/umount "$mntPT"
  Err=$?
  # REM: If mount-FULL uses increasing loopdevices on mntPT,
  #      check if mntPT still mounted, if not,
  #      free loopdevices assigned to mntPT
  #if ! cut -f2 -d' ' /proc/mounts | grep $Q "^${mntPT}$"; then
  gPATTERN=`_convert_nl_tab_sp "${mntPT}"`
  _debug "gPATTERN='$gPATTERN'"
  if ! cut -f2 -d' ' /proc/mounts | grep $Q "^${gPTTERN}$"; then
  _debug freeing unused loop devices
  _LOSETUP_=`losetup || losetup -a` 2>>$ERR
  UNUSED_LOOPS=`echo "$_LOSETUP_" | grep " (${imgFILE})$" | cut -f1 -d':'` #losetup-FULL output
  UNUSED_LOOPSF=$UNUSED_LOOPS
  for ul in $UNUSED_LOOPS; do _debugx $ul ;
  devNR=${ul##*/}       #/dev/loop/0
  devNR=${devNR##*loop} #/dev/loop0
  _debugx $devNR
  if echo "$_LOSETUP_" | grep $Q -E "[ (]/dev/loop$devNR[)]$|[ (]/dev/loop/$devNR[)]$"; then
   UNUSED_LOOPSF=`echo "$UNUSED_LOOPSF" | grep -vw "^/dev/loop$devNR"`
   UNUSED_LOOPSF=`echo "$UNUSED_LOOPSF" | grep -vw "^/dev/loop/$devNR"`
  fi
  done

  for ul in $UNUSED_LOOPSF; do _debugx $ul ;
  devNR=${ul##*/}       #/dev/loop/0
  devNR=${devNR##*loop} #/dev/loop0
  _debugx $devNR
  grep $Q -w "^/dev/loop$devNR" /proc/mounts && continue
  grep $Q -w "^$ul" /proc/mounts && continue
  #fuser -c $ul || continue
  losetup -d $ul; done
  fi

  #: [ -d "$mntPT" ] && [ -z "`ls -A "$mntPT" 2>/dev/null`" ] && rmdir "$mntPT"
 fi

 if [ "$Err" -gt 0 ] ;then
  [ -n "$DISPLAY" ] && xmessage -bg red -title "$xmTITLE" "Error... Returned <$Err> ... mounting or unmounting '$mntPT'" &
  _LOSETUP_=`losetup || losetup -a` 2>>$ERR
  LAST_LOOP=`echo "$_LOSETUP_" | tail -n1 | cut -f1 -d':'`
  _debug "LAST_LOOP='$LAST_LOOP'"
  losetup -d "$LAST_LOOP"
 fi

exit $Err
# Very End of this file 'usr/sbin/filemnt' #
###END###
