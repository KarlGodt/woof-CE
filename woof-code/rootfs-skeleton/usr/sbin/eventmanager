#!/bin/ash
#Barry Kauler 2008.
#Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html). 2007 www.puppylinux.com
# A gui to provide choices for "events" -- things that occur at a systems level,
# usually hardware related.
#v411 checkbox to redraw/realign icons. #2015-10-18 disabled
#v412 workaround, someone exited with invalid settings.
#w007 mouse inactivity computer power-down.
#w464 /etc/puppyversion is now history.
#v424 automatic unmounting (see pup_event_frontend_d).


test -s /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG=""
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap
}

#KRG APR/MAY2011 : ADDED SUPPORT FOR EDITING (partly) /ETC/EVENTMANAGER VIA TAB "$PLACEMENTTB"
#KRG APR/MAY2011 : TRIED BACKWARDSCOMPATIBILITY VIA IF CHECKS

SHOWMODE=$1 #v405 optional to modify gui.

. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS
PUPPYVERSION="$DISTRO_VERSION"
[ "$KERNVER" ] || KERNVER=`uname -r`
. /etc/rc.d/MODULESCONFIG

MY_HOME=/var/local/PuppyLinux/pup_event
MY_CFG="$MY_HOME"/etc
MY_LOG="$MY_HOME"/log
MY_TMP="$MY_HOME"/tmp
mkdir $VERB -p "$MY_CFG" "$MY_LOG" "$MY_TMP"
chown $VERB pup_event:pup_event "$MY_HOME"
chown $VERB pup_event:pup_event "$MY_CFG" "$MY_LOG" "$MY_TMP"
chmod $VERB 1774 "$MY_CFG" "$MY_LOG"
chmod $VERB 1770 "$MY_TMP"
ls -ld "$MY_HOME"
ls -l  "$MY_HOME"
cd "$MY_HOME" || exit 2

STATE_DIR=${STATE_DIR:-"$HOME/Choices/Puppy"}
EXE_DIR=${EXE_DIR:-'pup_event'}
PUP_EVENT_DIR=${PUP_EVENT_DIR:="$STATE_DIR/$EXE_DIR"}
CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"

CONFFILE=${CONFFILE:-/etc/eventmanager.cfg}  #configuration file of this prog

while :;
do
# first (re-)read the config file
[ -s "$CONFFILE" ] && . "$CONFFILE"

#[ "$BACKENDON" = "true" -o "$BACKENDON" = "false" ]    ||       BACKENDON="true" ##udev
#[ "$HOTPLUGON" != "true" -a "$HOTPLUGON" != "false" ] &&       HOTPLUGON="true" #OLD
#[ "$ZCDPOLL" = "true" -o "$ZCDPOLL" = "false" ]        ||         ZCDPOLL="true" #NEW
#[ "$AUTOUNMOUNT" ]                                        ||  AUTOUNMOUNT="false" #v424
#[ "$HOTPLUGNOISY" = "true" -o "$HOTPLUGNOISY" = "false" ] || HOTPLUGNOISY="false"
#[ "$AUTOTARGET" = "true" -o "$AUTOTARGET" = "false" ]     ||   AUTOTARGET="true"

              _set_bool DESKDAEMON "$DESKDAEMON" true
[ $? = 0 ] || _set_bool DESKDAEMON "$DESKDAEMON" false
[ $? = 0 ] || { _notice "defaulting to true";DESKDAEMON=true; }

              _set_bool ICONDESK "$ICONDESK" true
[ $? = 0 ] || _set_bool ICONDESK "$ICONDESK" false
[ $? = 0 ] || { _notice "defaulting to true";ICONDESK=true; }

              _set_bool ICONPARTITIONS "$ICONPARTITIONS" true
[ $? = 0 ] || _set_bool ICONPARTITIONS "$ICONPARTITIONS" false
[ $? = 0 ] || { _notice "defaulting to true";ICONPARTITIONS=true; }

              _set_bool FD0ICON "$FD0ICON" true
[ $? = 0 ] || _set_bool FD0ICON "$FD0ICON" false
[ $? = 0 ] || { _notice "defaulting to true";FD0ICON=true; }

 test "${POWERTIMEOUT//[0-9]/}" && unset POWERTIMEOUT
 POWERTIMEOUT=${POWERTIMEOUT:-0} #w007 0=never.
 [ "$POWERTIMEOUT" -ge 0 ] || POWERTIMEOUT=0

 test "${RAMSAVEINTERVAL//[0-9]/}" && unset RAMSAVEINTERVAL
 RAMSAVEINTERVAL=${RAMSAVEINTERVAL:-30}
 [ "$RAMSAVEINTERVAL" -ge 0 ] || RAMSAVEINTERVAL=0

#w007 as have a optional cutdown gui, make sure these are all preset...
#     NEWAUTOTARGET="$AUTOTARGET"
#    NEWAUTOUNMOUNT="$AUTOUNMOUNT"
#      NEWBACKENDON="$BACKENDON"
        NEWFD0ICON="$FD0ICON"
#   NEWHOTPLUGNOISY="$HOTPLUGNOISY"
#      NEWHOTPLUGON="$HOTPLUGON"
#       NEWZCDPOLL="$ZCDPOLL"
       NEWICONDESK="$ICONDESK"
 NEWICONPARTITIONS="$ICONPARTITIONS"
   NEWPOWERTIMEOUT=$POWERTIMEOUT
NEWRAMSAVEINTERVAL=$RAMSAVEINTERVAL

 test "${POLL_PLUG_DEVICE//[0-9]/}" && unset POLL_PLUG_DEVICE
 POLL_PLUG_DEVICE=${POLL_PLUG_DEVICE:-2}
 [ "$POLL_PLUG_DEVICE" -gt 1 ] || POLL_PLUG_DEVICE=1
 [ "$POLL_PLUG_DEVICE" -lt 9 ] || POLL_PLUG_DEVICE=9

#combobox and list have no <default> tag or attribute (?)
POLL_ITEM_LIST="<item>$POLL_PLUG_DEVICE</item>"
for i in 1 2 3 4 5 6 7 8 9
do
 test $i = $POLL_PLUG_DEVICE && continue
POLL_ITEM_LIST="$POLL_ITEM_LIST
 <item>$i</item>"
done

#list
#for i in 1 2 3 4 5 6 7 8 9
#do
#POLL_ITEM_LIST="$POLL_ITEM_LIST
# <item>$i</item>"
#done

test "$DESKDAEMON" = true && POLL_SEN=true || POLL_SEN=false

COMBO_ATTR_ORIG='fixed_size="1" fixed-size="1" column-span-column="2" appears-as-list="true" editing-canceled="true" wrap_width="1" value-in-list="true" insert-text="false" editable="false" max_length="1" max-length="1" max-width-chars="1" width-chars="1" width_chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE"'

COMBO_ATTR='insert-text="false" editable="false" max-length="1" max-width-chars="1" width-chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE"'


POLL_PLUG_DEVICE_GUI_COMBO='
<frame Polling interval>
<hbox>
<vbox>
<text width-chars="78">
<label>Select the seconds that should poll for so called hotplug events. Polling for events is a bit code to be executed. The higher the value, the more seconds between polling is paused. Reasonable values are between 2 and 4 seconds. But you may want even faster plugable drives show on desktop or even wait a bit longer.</label>
</text>
</vbox>
<vbox>
<text><label>"  "</label></text>
</vbox>
<vbox>
<hbox>
 <combobox '"$COMBO_ATTR"'>
 <!-- <label>Some Label</label> -->
 <width>6</width>
  '"$POLL_ITEM_LIST"'
  <variable>NEWPOLL_PLUG_DEVICE</variable>
 </combobox>
</hbox>
<text width-chars="1">
<label>"  "</label>
</text>
</vbox>
</hbox>
</frame>
'

POLL_PLUG_DEVICE_GUI_LIST='
<frame Polling interval>
<hbox>
<vbox>
<text width-chars="78">
<label>Select the seconds that should poll for so called hotplug events. Polling for events is a bit code to be executed. The higher the value, the more seconds between polling is paused. Reasonable values are between 2 and 4 seconds. But you may want even faster plugable drives show on desktop or even wait a bit longer.</label>
</text>
</vbox>
<vbox>
<text><label>"  "</label></text>
</vbox>
<vbox>
<hbox>
 <list selection-mode="1" fixed-size="1" column-span-column="2" appears-as-list="true" editing-canceled="true" wrap-width="1" value-in-list="true" insert-text="false" editable="false" max-length="1" max-width-chars="1" width-chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE">
 <!-- <label>Some Label</label> -->
 <width>40</width>
 <height>70</height>
  '"$POLL_ITEM_LIST"'
  <variable>NEWPOLL_PLUG_DEVICE</variable>
 </list>
</hbox>
</vbox>
</hbox>
</frame>
'
POLL_PLUG_DEVICE_GUI=$POLL_PLUG_DEVICE_GUI_LIST

#case "$FORCE_POWERTIMEOUT_ALWAYS" in true|false):;;*) FORCE_POWERTIMEOUT_ALWAYS=true;;esac
              _set_bool FORCE_POWERTIMEOUT_ALWAYS "$FORCE_POWERTIMEOUT_ALWAYS" true
[ $? = 0 ] || _set_bool FORCE_POWERTIMEOUT_ALWAYS "$FORCE_POWERTIMEOUT_ALWAYS" false
[ $? = 0 ] || { _notice "defaulting to true";FORCE_POWERTIMEOUT_ALWAYS=true; }

#case "$DISTURB_DL"    in true|false):;; *) DISTURB_DL=true;;esac
              _set_bool DISTURB_DL "$DISTURB_DL" true
[ $? = 0 ] || _set_bool DISTURB_DL "$DISTURB_DL" false
[ $? = 0 ] || { _notice "defaulting to false";DISTURB_DL=false; }

#case "$DISTURB_DEV"   in true|false):;; *) DISTURB_DEV=true;; esac
              _set_bool DISTURB_DEV "$DISTURB_DEV" true
[ $? = 0 ] || _set_bool DISTURB_DEV "$DISTURB_DEV" false
[ $? = 0 ] || { _notice "defaulting to false";DISTURB_DEV=false; }

#case "$DISTURB_VIDEO" in true|false):;; *) DISTURB_VIDEO=true;; esac
              _set_bool DISTURB_VIDEO "$DISTURB_VIDEO" true
[ $? = 0 ] || _set_bool DISTURB_VIDEO "$DISTURB_VIDEO" false
[ $? = 0 ] || { _notice "defaulting to true";DISTURB_VIDEO=true; }

CB_DL_PT_SEN=true
EN_DL_PT_SEN=true
CB_MM_PT_SEN=true
EN_MM_PT_SEN=true
CB_DEV_PT_SEN=true
EN_DEV_PT_SEN=true

if test "$FORCE_POWERTIMEOUT_ALWAYS" = true; then
 CB_DL_PT_SEN=false
   DISTURB_DL=false
 CB_MM_PT_SEN=false
DISTURB_VIDEO=false
CB_DEV_PT_SEN=false
  DISTURB_DEV=false
fi

if test "$DISTURB_DL" = false; then
EN_DL_PT_SEN=false
fi

if test "$DISTURB_VIDEO" = false; then
EN_MM_PT_SEN=false
fi

if test "$DISTURB_DEV" = false; then
EN_DEV_PT_SEN=false
fi

NEWFORCE_POWERTIMEOUT_ALWAYS=$FORCE_POWERTIMEOUT_ALWAYS
NEWDISTURB_DL=$DISTURB_DL
NEWDISTURB_VIDEO=$DISTURB_VIDEO
NEWDISTURB_DEV=$DISTURB_DEV


FORCE_POWERTIMEOUT_GUI="<hbox>
  <checkbox xalign=\"0.0\" yalign=\"0.9\" tooltip-text=\"FORCE_POWERTIMEOUT_ALWAYS\">
  <label>Want to poweroff always regardless of important programs running</label>
   <default>${FORCE_POWERTIMEOUT_ALWAYS}</default>
   <variable>NEWFORCE_POWERTIMEOUT_ALWAYS</variable>

   <action>if true clear:NEWDISTURB_DL</action>
   <action>if true clear:NEWDISTURB_VIDEO</action>
   <action>if true clear:NEWDISTURB_DEV</action>

   <action>if false enable:NEWDISTURB_DL</action>
   <action>if true disable:NEWDISTURB_DL</action>

   <action>if true disable:NEWDISTURB_VIDEO</action>
   <action>if false enable:NEWDISTURB_VIDEO</action>

   <action>if true disable:NEWDISTURB_DEV</action>
   <action>if false enable:NEWDISTURB_DEV</action>

  </checkbox>
  </hbox>
"

DL_POWERTIMEOUT_GUI="<hbox>
  <checkbox sensitive=\"$CB_DL_PT_SEN\" xalign=\"0.0\" yalign=\"1.0\" tooltip-text=\"DISTURB_DL\">
   <label>Do not poweroff if one of the following dl programs are running</label>
    <default>${DISTURB_DL}</default>
    <variable>NEWDISTURB_DL</variable>
     <action>if true enable:NEWDO_NOT_DISTURB_DL</action>
     <action>if false disable:NEWDO_NOT_DISTURB_DL</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_DL_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_DL\">
   <default>$DO_NOT_DISTURB_DL</default>
   <variable>NEWDO_NOT_DISTURB_DL</variable>
  </entry>
  </hbox>
"

MM_POWERTIMEOUT_GUI="<hbox>
<checkbox sensitive=\"$CB_MM_PT_SEN\" xalign=\"0.0\" yalign=\"1.0\" tooltip-text=\"DISTURB_VIDEO\">
  <label>Do not poweroff if one of the following multi media programs are running</label>
   <default>${DISTURB_VIDEO}</default>
   <variable>NEWDISTURB_VIDEO</variable>
   <action>if true enable:NEWDO_NOT_DISTURB_VIDEO</action>
   <action>if false disable:NEWDO_NOT_DISTURB_VIDEO</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_MM_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_VIDEO\">
   <default>$DO_NOT_DISTURB_VIDEO</default>
   <variable>NEWDO_NOT_DISTURB_VIDEO</variable>
  </entry>
  </hbox>
"

DEV_POWERTIMEOUT_GUI="<hbox>
<checkbox sensitive=\"$CB_DEV_PT_SEN\" xalign=\"0.0\" yalign=\"1.0\" tooltip-text=\"DISTURB_DEV\">
  <label>Do not poweroff if one of the following developer programs are running</label>
   <default>${DISTURB_DEV}</default>
   <variable>NEWDISTURB_DEV</variable>
   <action>if true enable:NEWDO_NOT_DISTURB_DEV</action>
   <action>if false disable:NEWDO_NOT_DISTURB_DEV</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_DEV_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_DEV\">
   <default>$DO_NOT_DISTURB_DEV</default>
   <variable>NEWDO_NOT_DISTURB_DEV</variable>
  </entry>
  </hbox>
"

#udevd
UDEV_CHOICE_DISABLED="  <checkbox tooltip-text=\"BACKENDON\">
   <label>Tick box for hotplug module/firmware loading [ BACKENDON on/off udevd ]</label>
   <default>${BACKENDON}</default>
   <variable>NEWBACKENDON</variable>
  </checkbox>
"

#iconwipe
ICONWIPE_CHOICE2_DISABLED="  <checkbox tooltip-text=\"NEWICONWIPE2\">
   <label>Tick box to erase then redraw and realign existing icons</label>
   <default>true</default>
   <variable>NEWICONWIPE2</variable>
   <action>if false clear:NEWICONWIPE1</action>
  </checkbox>
"
ICONWIPE_CHOICE1_DISABLED="  <checkbox tooltip-text=\"NEWICONWIPE1\">
   <label>Tick box to erase then redraw and realign existing icons</label>
    <default>true</default>
   <variable>NEWICONWIPE1</variable>
   <action>if false clear:NEWICONWIPE2</action>
  </checkbox>
"

ICON_PLACE_START_X_GAP=${ICON_PLACE_START_X_GAP:-32}  #x-alignment
ICON_PLACE_START_Y_GAP=${ICON_PLACE_START_Y_GAP:-64}  #y-alignment
ICON_PLACE_ORIENTATION=${ICON_PLACE_ORIENTATION:-'bottom'}


PIN_GRID_STEP=`sed -n '/<!--/,/-->/!p' "$CONFFILEROX" | grep -m1 "pinboard_grid_step" | sed -e "s/ *<[^>]*>//g"`
test "${PIN_GRID_STEP//[0-9]/}" && unset PIN_GRID_STEP
PIN_GRID_STEP=${PIN_GRID_STEP:-32} #2=fine 16=medium 32=coarse.
[ "$PIN_GRID_STEP" -le 0 ] && PIN_GRID_STEP=32 #precaution.

test "${ICON_PLACE_SPACING//[0-9]/}" && unset ICON_PLACE_SPACING
ICON_PLACE_SPACING=${ICON_PLACE_SPACING:-64}
[ "$ICON_PLACE_SPACING" -ge 64 ]  || ICON_PLACE_SPACING=64
[ "$ICON_PLACE_SPACING" -le 160 ] || ICON_PLACE_SPACING=160
ICON_PLACE_SPACING=$(( ((ICON_PLACE_SPACING +1) / PIN_GRID_STEP) * PIN_GRID_STEP)) # always round to acceptable values
                                                            # ICON_PLACE_SPACING must be -ge PIN_GRID_STEP

if [ -n "$ICON_PLACE_ORIENTATION" ] ; then #KRG
case $ICON_PLACE_ORIENTATION in
bottom)  ICONPOSITIONB="true" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ;;
right)  ICONPOSITIONR="true" ; ICONPOSITIONB="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ;;
top)   ICONPOSITIONT="true" ; ICONPOSITIONR="false" ; ICONPOSITIONB="false" ; ICONPOSITIONL="false" ;;
left) ICONPOSITIONL="true" ; ICONPOSITIONB="false" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ;;
*)   ICONPOSITIONB="true" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ; _notice "defaulting to bottom";;
esac

ICON_POS="
  <hbox>
  <text xalign=\"0.0\"><label>Choose Position of the Drive Icon(s) : Tick box for</label></text>
  <radiobutton>
  <label>\"bottom  \"</label>
  <default>${ICONPOSITIONB}</default>
  <variable>ICONPSITIONB</variable>
  </radiobutton>
  <radiobutton>
  <label>\"right  \"</label>
  <default>${ICONPOSITIONR}</default>
  <variable>ICONPSITIONR</variable>
  </radiobutton>
  <radiobutton>
  <label>\"top  \"</label>
  <default>${ICONPOSITIONT}</default>
  <variable>ICONPSITIONT</variable>
  </radiobutton>
  <radiobutton>
  <label>\"left  \"</label>
  <default>${ICONPOSITIONL}</default>
  <variable>ICONPSITIONL</variable>
  </radiobutton>
  </hbox>
"
fi

PLACEMENTTB="Icon placement"

if [ -n "$ICON_PLACE_START_X_GAP" ] ; then
IP_E_GAP_X="
<hbox>
<text><label>Choose the Spacing 'x' to edge of screen:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_START_X_GAP\">
<default>${ICON_PLACE_START_X_GAP}</default>
<variable>NEWIPSGAPX</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_START_Y_GAP" ] ; then
IP_E_GAP_Y="
<hbox>
<text><label>Choose the Spacing 'y' to edge of screen:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_START_Y_GAP\">
<default>${ICON_PLACE_START_Y_GAP}</default>
<variable>NEWIPSGAPY</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_SPACING" ] ; then
IP_SPA_OLD="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> of the drive-icons [10-300]:\"</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING\">
<default>${ICON_PLACE_SPACING}</default>
<variable>NEWIPSPAC</variable>
</entry>
</hbox>
</hbox>
"


ITEM_SPACING="<item>$ICON_PLACE_SPACING</item>"
for i in `seq 64 $PIN_GRID_STEP 160`; do
test "$i" = $ICON_PLACE_SPACING && continue
ITEM_SPACING="$ITEM_SPACING
<item>$i</item>"
done


IP_SPA_COMBO="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> between drive icons [64-160]:\"</label></text>
<hbox>
<combobox tooltip-text=\"ICON_PLACE_SPACING\">
$ITEM_SPACING
<variable>NEWIPSPAC</variable>
</combobox>
</hbox>
</hbox>
"

IP_SPA_LIST="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> between drive icons [64-160]:\"</label></text>
<hbox>
<list selection-mode=\"1\" list_height=\"3\" editable=\"false\" tooltip-text=\"ICON_PLACE_SPACING\">
<width>50</width>
<height>70</height>
$ITEM_SPACING
<variable>NEWIPSPAC</variable>
</list>
</hbox>
</hbox>
"

IP_SPA=$IP_SPA_LIST

fi

if [ -n "$ICON_PLACE_SPACING_X" ] ; then
IP_SPA_X="
<hbox>
<text><label>Choose the Spacing X of drive-icons:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING_X\">
<default>${ICON_PLACE_SPACING_X}</default>
<variable>NEWIPSPACX</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_SPACING_Y" ] ; then
IP_SPA_Y="
<hbox>
<text><label>Choose the Spacing Y of drive-icons:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING_Y\">
<default>${ICON_PLACE_SPACING_Y}</default>
<variable>NEWIPSPACY</variable>
</entry>
</hbox>
</hbox>
"
fi

PLACEMENT="
<vbox>
$ICON_POS
$IP_E_GAP_UNUSED
$IP_E_GAP_X_DISABLED
$IP_E_GAP_Y_DISABLED
$IP_S_GAP_UNUSED
$IP_SPA
$IP_SPA_X_UNUSED
$IP_SPA_Y_UNUSED

  <hbox><text><label>\"  \"</label></text></hbox>
  <text use-markup=\"true\"><label>\"<b>NOTE :</b> the values above have to be a <b>power</b> of the <u>current <i>'pinboard_grid_step'</i> value of <b>$PIN_GRID_STEP</b></u> . Otherwise the drive icons would not render properly because the ROX-Filer would not place the icons as expected, but to the nearest value relative to the <i>'pinboard_grid_step'</i> . <b>If the values arent a power, then usually the icons would pile up on one place of the pinboard</b> . To change the PIN_GRID_STEP value : Go to ROX-Filer Options > Pinboard > Behavior\"</label></text>
</vbox>
"

_debugx "$PLACEMENT"

AUTOTARGET_CHOICE_DISABLED="  <frame>
  <text><label>This checkbox extends the default behavior, and will launch a more appropriate application. Currently, it adds detection of a video DVD or audio CD and launches the media player:</label></text>
  <checkbox tootip-text=\"AUTOTARGET\">
   <label>Tick box for auto-detection of target application [ AUTOTARRGET ]</label>
   <default>${AUTOTARGET}</default>
   <variable>NEWAUTOTARGET</variable>
  </checkbox>
  </frame>
"

HOTPLUGNOISY_CHOICE_DISABLED=" <vbox>
  <frame>
  <text><label>Normally you have to click on a partition icon to run the handler 'AppRun' in $PUP_EVENT_DIR, but this checkbox makes the 'handler' run as soon as a media is plugged in if polling every $POLL_PLUG_DEVICE seconds is enabled . For example, plug in a DVD and it will immediately either get automatically mounted, or [if the above checkbox is ticked] the media player will run. This is usefull if using a desktopmanager like enlightenment or when having disabled drive icons on desktop:</label></text>
  <checkbox tooltip-text=\"HOTPLUGNOISY\">
   <label>Tick box for auto-launch 'handler' when media plugged in [ HOTPLUGNOISY ]</label>
   <default>${HOTPLUGNOISY}</default>
   <variable>NEWHOTPLUGNOISY</variable>
  </checkbox>
  </frame>
 </vbox>
"

HANDLER_TAB_DISABLED="<frame Drive 'handler'>
 <vbox>
  <text use-markup=\"true\"><label>\"The <b>'handler'</b> decides what to do when you click on a desktop drive icon. <b>Normally</b>, this just starts <u>Pmount</u> if you click on a drive icon, <b>or</b> mounts it and starts <u>ROX-Filer</u> if a partition icon, but this behavior can be extended by these checkboxes.\"</label></text>
  $AUTOTARGET_CHOICE
 </vbox>

  $HOTPLUGNOISY_CHOICE

</frame>
"

AUTO_UNMOUNT_CHOICE_DISABLED="  <checkbox tooltip-text=\"AUTOUNMOUNT\" draw-as-radio=\"true\">
   <label>Tick box for auto unmounting of partitions [ AUTOUNMOUNT ]</label>
   <default>${AUTOUNMOUNT}</default>
   <variable>NEWAUTOUNMOUNT</variable>
  </checkbox>
  <text><label>(WARNING: auto unmounting is highly experimental)</label></text>
"

ZCDPOLL_DISABLED="  <checkbox tooltip-text=\"ZCDPOLL\" draw-as-radio=\"true\">
   <label>Tick box for polling Zip or CD devices every $POLL_PLUG_DEVICE seconds [ ZCDPOLL ]</label>
   <default>${ZCDPOLL}</default>
   <variable>NEWZCDPOLL</variable>
   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>
  </checkbox>
"

# REM: Disable entering anything if not a flash PUPMODE
#      for the RAMSAVE tab.
case $PUPMODE in 3|7|13)
   ENTRY_RAMSAVEINTERAL_SEN=true ;;
*) ENTRY_RAMSAVEINTERAL_SEN=false;;
esac

# REM: Disable entering anything if no floppy disk
#      for the Legacy tab.
FD0ICON_SEN=true
probedisk2 | grep $Q '^/dev/fd0|' || {
FD0ICON_SEN=false
FD0ICON=false
}

DRIVE_ICONS_GUI="
 <frame Drive icons on desktop>
 <vbox>
  <text width-chars=\"90\" use-markup=\"true\"><label>\"When this box is ticked, there will be an icon for each drive. If you plugin a USB pen drive for example, an icon will appear. Unplug and it will disappear. If you don't want these drive icons on the desktop, untick this box (but there will still remain <b>just one icon</b> that will launch Pmount when clicked on). The individual drive icons are purely a convenience and Puppy works fine without them.\"</label></text>
  <text><label>\" \"</label></text>
  <frame>
  <checkbox tooltip-text=\"ICONDESK\">
   <label>Tick box for drive icons on desktop</label>
   <default>${ICONDESK}</default>
   <variable>NEWICONDESK</variable>
   <action>if true enable:NEWICONPARTITIONS</action>
   <action>if false disable:NEWICONPARTITIONS</action>
   <action>if false clear:NEWICONPARTITIONS</action>
   <action>if true enable:NEWFD0ICON</action>
   <action>if false disable:NEWFD0ICON</action>
   <action>if false clear:NEWFD0ICON</action>
  </checkbox>

  <vbox>
  <text wrap=\"true\" width-chars=\"70\"><label>If the above is ticked, then you can choose to have an icon for each partition, rather than one icon for the entire drive:</label></text>
  <checkbox tooltip-text=\"ICONPARTITIONS\">
   <label>Tick box for an icon for each partition</label>
   <default>${ICONPARTITIONS}</default>
   <variable>NEWICONPARTITIONS</variable>
  </checkbox>
  </vbox>
  </frame>
  </vbox>
 </frame>

 <frame Icon Placement on Desktop>
 <hbox><text><label>\" \"</label></text></hbox>
  $PLACEMENT
 </frame>

 <frame Legacy>
  <text><label>\" \"</label></text>
  <text width-chars=\"90\" use-markup=\"true\"><label>\"<b>The Linux Kernel does not support hotplug detection of when a legacy floppy diskette is inserted or removed.</b> Periodic probing requires starting the drive motor, which is very slow -- and do you want the motor to startup every $POLL_PLUG_DEVICE seconds? Therefore, if your PC has a floppy drive, tick this box to have a permanent icon on desktop (regardless whether a diskette is actually inserted, or even a floppy drive!).\"</label></text>
  <text><label>\" \"</label></text>
  <checkbox tooltip-text=\"FD0ICON\" sensitive=\"$FD0ICON_SEN\">
   <label>Tick box for floppy drive icon on desktop</label>
   <default>${FD0ICON}</default>
   <variable>NEWFD0ICON</variable>
  </checkbox>
 </frame>

"
if [ "$SHOWMODE" = "desktop" ]; then
SELECT_FULL="   <hbox>
   <button>
    <label>Show full Event Manager</label>
    <action type=\"exit\">showfull</action>
   </button>
   </hbox>
"
else
SELECT_FULL="   <hbox>
   <button>
    <label>Show small Event Manager</label>
    <action type=\"exit\">showdesktop</action>
   </button>
   </hbox>
"
fi

APPLY_OR_EXIT_XALIGN="
 <hbox homogeneous=\"true\">
  <text xalign=\"0.0\"><label>\"Click  \"</label></text>
   <button tooltip-text=\"to save new settings to $CONFFILE configuration file\">
   <input file icon=\"gtk-apply\"></input>
   <label>OK:Apply!</label>
   </button>
  <text xalign=\"0.5\" use-markup=\"true\"><label>\"  <b>or</b>  \"</label></text>
   <button cancel></button>
  <text xalign=\"1.0\" use-markup=\"true\"><label>\"  <i>to Exit without saving changes</i>\"</label></text>
 </hbox>
   $SELECT_FULL
"

APPLY_OR_EXIT="
 <hbox homogeneous=\"false\" spacing=\"10\">
  <text><label>\"Click  \"</label></text>
   <button tooltip-text=\"to save new settings to $CONFFILE configuration file\">
   <input file icon=\"gtk-apply\"></input>
   <label>OK:Apply!</label>
   </button>
  <text use-markup=\"true\"><label>\"  <b>or</b>  \"</label></text>
   <button cancel></button>
  <text use-markup=\"true\"><label>\"  <i>to Exit without saving changes</i>            \"</label></text>
 </hbox>
   $SELECT_FULL
"

CHOSE_BELOW=""
if test "$USE_DISABLED"; then
CHOSE_BELOW="
  <vbox>
  <text><label>\"  \"</label></text>
  <hbox>
  <text wrap=\"false\"><label>So, if the above is ticked, then you can choose below :</label></text>

   $ZCDPOLL_DISABLED
   $AUTO_UNMOUNT_CHOICE_DISABLED
   $UDEV_CHOICE_DISABLED

  </hbox>
  </vbox>
"
fi


NOTEBOOK_LABEL2="<notebook labels=\"Desktop Icons|$PLACEMENTTB|Legacy\">"
NOTEBOOK_LABEL1="<notebook labels=\"Activate|Desktop Icons|$PLACEMENTTB|Legacy|Save Session|Power\">"

if [ "$SHOWMODE" = "desktop" ];then
 #cutdown, only show choices for setting the desktop icons...
 MAIN_DIALOG="
<window title=\"Event Manager: Desktop drive icons\" icon-name=\"gtk-execute\">
<vbox>

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

  $NOTEBOOK_LABEL2

  $DRIVE_ICONS_GUI

  </notebook>

   $APPLY_OR_EXIT

</vbox>
</window>
"

else

 MAIN_DIALOG="
<window title=\"Puppy Event Manager\" icon-name=\"gtk-execute\">
<vbox>

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

  $NOTEBOOK_LABEL1

  <frame Activate Puppy Event Manager>
  <vbox>
  <text><label>\" \"</label></text>

   <checkbox tooltip-text=\"DESKDAEMON\" indicator-size=\"20\">
   <label>Tick box for desktop hotplug support [ DESKDAEMON on/off daemon ]</label>

   <default>${DESKDAEMON}</default>
   <variable>NEWDESKDAEMON</variable>
   <action>if true enable:NEWZCDPOLL</action>
   <action>if false clear:NEWZCDPOLL</action>
   <action>if false disable:NEWZCDPOLL</action>

   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>

   <action>if true enable:NEWAUTOUNMOUNT</action>
   <action>if false disable:NEWAUTOUNMOUNT</action>
   <action>if false clear:NEWAUTOUNMOUNT</action>

   <action>if true enable:NEWRAMSAVEINTERVAL</action>
   <action>if false disable:NEWRAMSAVEINTERVAL</action>
   <action>if false clear:NEWRAMSAVEINTERVAL</action>

   <action>if true enable:NEWPOWERTIMEOUT</action>
   <action>if false disable:NEWPOWERTIMEOUT</action>
   <action>if false clear:NEWPOWERTIMEOUT</action>

   <action>if true enable:NEWPOLL_PLUG_DEVICE</action>
   <action>if false disable:NEWPOLL_PLUG_DEVICE</action>

   </checkbox>

  <text width-chars=\"90\" use-markup=\"true\"><label>\"The 'pup_event' Puppy Event Manager is running in the background and handles hotplugging of drives, including the desktop drive icons. However, turn it off, and Puppy will revert to the same behaviour as versions prior to 4.x, in which there is no hotplug support. This reduces resource usage, so try unticking these on very old slow PCs. <b>pmount</b> can still be run manually to mount and unmount partitions.\"</label></text>

  <!-- <text><label>\" \"</label></text> -->
  <hbox>
   <text use-markup=\"true\" wrap=\"true\" max-width-chars=\"80\" single-line-mode=\"false\">
   <label>\"<b>NOTE :</b> when you turn this off ,
  the freememapplet in the tray won't get updated , maybe not show at all .\"</label>
   </text>
  </hbox>

  $POLL_PLUG_DEVICE_GUI
  $CHOSE_BELOW
  </vbox>
  </frame>

 $DRIVE_ICONS_GUI

 <frame Periodic save from RAM>
 <vbox>
  <text><label>\" \"</label></text>
  <text width-chars=\"90\" use-markup=\"true\"><label>\"Puppy runs in a particular 'state' that we call the <b>PUPMODE</b>. This depends on the type of installation and the type of hardware. <b>Currently, PUPMODE=${PUPMODE}</b>. If it is an <b>odd</b> number 3,7 13, then Puppy is doing everything in RAM and saving the current session to a drive periodically -- this is done in the case of Flash memory to make it last longer. When Puppy runs in one of these PUPMODES, there will be a <b>save</b> icon on the desktop, <b>also a save occurs at shutdown</b>. You can also specify a periodic save here:\"</label></text>
  <text><label>\" \"</label></text>
  <frame Enter>
  <hbox homogenous=\"false\">
   <text><label>\"                                   Save interval (0=never):\"</label></text>
   <entry max-length=\"4\" width_chars=\"4\" width-chars=\"4\" width=\"4\" max-width-chars=\"4\" tooltip-text=\"RAMSAVEINTERVAL\" sensitive=\"$ENTRY_RAMSAVEINTERAL_SEN\">
    <width>40</width>
    <default>${RAMSAVEINTERVAL}</default>
    <variable>NEWRAMSAVEINTERVAL</variable>
   </entry>
   <text><label>\"minutes                                             \"</label></text>
   <!-- <text><label>\"       \"</label></text> -->
  </hbox>
  </frame>
  <text><label>\" \"</label></text>
  <text use-markup=\"true\"><label>\"<b>NOTE1:</b> PUPMODE=77 (multisession DVD) excluded, only manual save with desktop icon and at shutdown.\"</label></text>
  <text use-markup=\"true\"><label>\"<b>NOTE2:</b> PUPMODE=5 there are no saves, above value ignored.\"</label></text>
 </vbox>
 </frame>

 <frame Power>
 <vbox>
  <text><label>Puppy is able to power-off your computer after a period of mouse inactivity. This will occur if the mouse cursor has not been moved for the designated interval:</label></text>
  <hbox>
   <text><label>\"                              Inactivity interval (0=never):\"</label></text>
   <entry max-length=\"4\" tooltip-text=\"POWERTIMEOUT\">
    <default>${POWERTIMEOUT}</default>
    <variable>NEWPOWERTIMEOUT</variable>
   </entry>
   <text><label>\"minutes                              \"</label></text>
   <!-- <text><label>\"       \"</label></text> -->
  </hbox>

  <hbox><text><label>\" \"</label></text></hbox>
  <frame Power timeout preferences>
  <vbox>
  $FORCE_POWERTIMEOUT_GUI
  $DL_POWERTIMEOUT_GUI
  $MM_POWERTIMEOUT_GUI
  $DEV_POWERTIMEOUT_GUI
  </vbox>
  </frame>

  </vbox>
 </frame>

</notebook>

  $APPLY_OR_EXIT

</vbox>
</window>
"
fi

if [ "$HAVEMUT2" = "yes" ];then # <button file icon="top"> | icon-name=\"gtk-execute\"
 PREFSBUTTON="
   <button><label>Use mut2 engine</label>
    <action type=\"exit\">SETPREFS</action>
   </button>"
fi

if [ 2 = 1 ]; then #DEBUG
 echo "$MAIN_DIALOG" >/tmp/gtkdialog.tmp
 /usr/local/bin/cat -n /tmp/gtkdialog.tmp
 sed -i '/^$/ d' /tmp/gtkdialog.tmp
 geany /tmp/gtkdialog.tmp &
 exit
fi

MAIN_DIALOG=`_GTKdialog_remove_comments "$MAIN_DIALOG"`
[ "$DEBUG" ] && _GTKdialog_debug_gui "$MAIN_DIALOG"
times
export MAIN_DIALOG
#gtkdialog3 --debug --program=MAIN_DIALOG --center
RETSTRING=`gtkdialog3 --program=MAIN_DIALOG --center`
[ $? -ne 0 ] && exit 4

eval "$RETSTRING"

_debug "RETSTRING='$RETSTRING'" #TEST

case "$EXIT" in
abort|Cancel|'') RV=0; break;;
#v405 it is running with 'desktop' param, now rerun with all tabs...
showfull)    CMD=eventmanager; break;;
showdesktop) CMD='eventmanager desktop'; break;;
esac
times

#make sure that RAMSAVEINTERVAL is an integer only...
NEWRAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL:-0} #412
#[ ! "$NEWRAMSAVEINTERVAL" ] && [ "$PUPMODE" != 2 -a "$PUPMODE" != 6 -a "$PUPMODE" != 12 ] && NEWRAMSAVEINTERVAL=30 #412
NEWRAMSAVEINTERVAL=`echo "$NEWRAMSAVEINTERVAL" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent saves...
[ $NEWRAMSAVEINTERVAL -gt 0 -a $NEWRAMSAVEINTERVAL -lt 5 ] && NEWRAMSAVEINTERVAL=5
[ "$PUPMODE" = 2 -o "$PUPMODE" = 6 -o "$PUPMODE" = 12 ]    && NEWRAMSAVEINTERVAL=0 ##+++2012-01-18

#w007 make sure that POWERTIMEOUT is integer only...
NEWPOWERTIMEOUT=${NEWPOWERTIMEOUT:-0}
NEWPOWERTIMEOUT=`echo "$NEWPOWERTIMEOUT" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent power-down...
[ $NEWPOWERTIMEOUT -gt 0 -a $NEWPOWERTIMEOUT -lt 5 ] && NEWPOWERTIMEOUT=5

#v403 if major-switch has turned off hotplug support, only show one icon...
#NEWBACKENDON=${NEWBACKENDON:-"true"} #v412
#NEWHOTPLUGON=${NEWHOTPLUGON:-"true"} #v412
NEWDESKDAEMON=${NEWDESKDAEMON:-"true"} #v412
#[ "$NEWBACKENDON" = "false" ] && NEWHOTPLUGON="false"

if [ "$NEWDESKDAEMON" = "false" ];then
       NEWICONDESK="false"
 NEWICONPARTITIONS="false"
   NEWHOTPLUGNOISY="false"
     NEWAUTOTARGET="false"
    NEWAUTOUNMOUNT="false" #v424
        NEWZCDPOLL='false'
fi

[ "$NEWICONDESK" = 'false' ] && NEWICONPARTITIONS='false'
_debug 1 NEWIPSPAC=$NEWIPSPAC
NEWIPSGAPX=`echo "$NEWIPSGAPX" | sed 's/[^0-9]//g'`   #get rid of non-digits
NEWIPSGAPY=`echo "$NEWIPSGAPY" | sed 's/[^0-9]//g'`
 NEWIPSPAC=`echo "$NEWIPSPAC"  | sed 's/[^0-9]//g'`
_debug 2 NEWIPSPAC=$NEWIPSPAC
NEWIPSPAC=$(( ((NEWIPSPAC +1) / PIN_GRID_STEP) * PIN_GRID_STEP ))  #round to non-odd numbers
 _debug 3 NEWIPSPAC=$NEWIPSPAC
 NEWIPSGAPX=${NEWIPSGAPX:-32}
 NEWIPSGAPY=${NEWIPSGAPY:-64}
 NEWIPSPAC=${NEWIPSPAC:-64}
 _debug 4 NEWIPSPAC=$NEWIPSPAC
[ "$NEWIPSPAC" = 0 ] && NEWIPSPAC=64
 _debug 5 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSGAPX" -lt '24' -o "$NEWIPSGAPX" -gt '300' ] && NEWIPSGAPX=24 # x
 [ "$NEWIPSGAPY" -lt '32' -o "$NEWIPSGAPY" -gt '200' ] && NEWIPSGAPY=32 # y

#[ "$NEWIPSPAC" -lt '10' -o "$NEWIPSPAC" -gt '300' ] && NEWIPSPAC=64 # spacing
 [ "$NEWIPSPAC" -ge '64' ]  || NEWIPSPAC=64
 _debug 6 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSPAC" -le '160' ] || NEWIPSPAC=160
 _debug 7 NEWIPSPAC=$NEWIPSPAC
 NEWIPSPAC=$(( ((NEWIPSPAC +1) / PIN_GRID_STEP) * PIN_GRID_STEP ))  #round to non-odd numbers
 _debug 8 NEWIPSPAC=$NEWIPSPAC

# REM: The "$CONFFILE" file gets altered as variable first,
#       then the altered variable gets written to "$CONFFILE"
#       so that "$CONFFILE" gets overwritten ...
#      TODO : rename /etc/eventmanager to "$CONFFILE"
#              or /etc/pup_event.conf or pup_event_frontend.conf
#      TODO : make backup of old conf and create a default conf
#              to be able restore previous or default settings
#              and write a GUI for it...
CONFIG=`cat "$CONFFILE"`

_adjust_config(){
CONFIG=`echo "$CONFIG" | sed -e "$@"`
S=$((S+$?))
}

__adjust_config(){
VAR="$1"; shift
VAL="$*"
sP="s/^${VAR}=.*/${VAR}='${VAL}'/"
if grep $Q "^${VAR}=" "$CONFFILE"; then
 CONFIG=`echo "$CONFIG" | sed -e "$sP"`
else
 echo "${VAR}='${VAL}'" >>"$CONFFILE"
fi
S=$((S+$?))
}

#rsPATTERN="s/^RAMSAVEINTERVAL=.*/RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}/"
#grep $Q '^RAMSAVEINTERVAL=' "$CONFFILE" && {
# _adjust_config "$rsPATTERN"; true; } || echo "RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}" >>"$CONFFILE"
__adjust_config RAMSAVEINTERVAL $NEWRAMSAVEINTERVAL

#w007...
#ptPATTERN="s/^POWERTIMEOUT=.*/POWERTIMEOUT=${NEWPOWERTIMEOUT}/"
#grep $Q '^POWERTIMEOUT=' "$CONFFILE" && {
# _adjust_config  "$ptPATTERN"; true; } || echo "POWERTIMEOUT=${NEWPOWERTIMEOUT}" >>"$CONFFILE"
__adjust_config POWERTIMEOUT $NEWPOWERTIMEOUT

#idPATTERN="s/^ICONDESK=.*/ICONDESK=${NEWICONDESK}/"
#grep $Q '^ICONDESK='  "$CONFFILE" && {
# _adjust_config  "$idPATTERN"; true; } || echo "ICONDESK=${NEWICONDESK}" >>"$CONFFILE"
__adjust_config ICONDESK $NEWICONDESK

#ipPATTERN="s/^ICONPARTITIONS=.*/ICONPARTITIONS=${NEWICONPARTITIONS}/"
#grep $Q '^ICONPARTITIONS=' "$CONFFILE" && {
# _adjust_config "$ipPATTERN"; true; } || echo "ICONPARTITIONS=${NEWICONPARTITIONS}" >>"$CONFFILE"
__adjust_config ICONPARTITIONS $NEWICONPARTITIONS

#hnPATTERN="s/^HOTPLUGNOISY=.*/HOTPLUGNOISY=${NEWHOTPLUGNOISY}/"
#grep $Q '^HOTPLUGNOISY='  "$CONFFILE" && {
# _adjust_config "$hnPATTERN"; true; } || echo "HOTPLUGNOISY=${NEWNEWHOTPLUGNOISY}" >>"$CONFFILE"
__adjust_config HOTPLUGNOISY $NEWHOTPLUGNOISY

#atPATTERN="s/^AUTOTARGET=.*/AUTOTARGET=${NEWAUTOTARGET}/"
#grep $Q '^AUTOTARGET='  "$CONFFILE" && {
# _adjust_config "$atPATTERN"; true; } || echo "AUTOTARGET=${NEWAUTOTARGET}" >>"$CONFFILE"
#__adjust_config AUTOTARGET $NEWAUTOTARGET


#ddPATTERN="s/^DESKDAEMON=.*/DESKDAEMON=${NEWDESKDAEMON}/"
#grep $Q '^DESKDAEMON=' "$CONFFILE" && {
# _adjust_config "$ddPATTERN"; true; } || echo "DESKDAEMON=${NEWDESKDAEMON}" >>"$CONFFILE"
__adjust_config DESKDAEMON $NEWDESKDAEMON
if [ "$USE_DISABLED" ]; then

#boPATTERN="s/^BACKENDON=.*/BACKENDON=${NEWBACKENDON}/"
#grep $Q '^BACKENDON='  "$CONFFILE" && {
# _adjust_config "$boPATTERN"; true; } || echo "BACKENDON=$NEWBACKENDON" >>"$CONFFILE"
__adjust_config BACKENDON $NEWBACKENDON

#zcPATTERN="s/^ZCDPOLL=.*/ZCDPOLL=${NEWZCDPOLL}/"
#grep $Q '^ZCDPOLL='  "$CONFFILE" && {
# _adjust_config "$zcPATTERN"; true; } || echo "ZCDPOLL=${NEWZCDPOLL}" >>"$CONFFILE"
__adjust_config ZCDPOLL $NEWZCDPOLL

#auPATTERN="s/^AUTOUNMOUNT=.*/AUTOUNMOUNT=${NEWAUTOUNMOUNT}/" #v424
#grep $Q '^AUTOUNMOUNT=' "$CONFFILE" && {
# _adjust_config "$auPATTERN"; true; } || echo "AUTOUNMOUNT=${NEWAUTOUNMOUNT}" >>"$CONFFILE"
__adjust_config AUTOUNMOUNT $NEWAUTOUNMOUNT
fi

#fiPATTERN="s/^FD0ICON=.*/FD0ICON=${NEWFD0ICON}/"
#grep $Q '^FD0ICON=' "$CONFFILE" && {
# _adjust_config "$fiPATTERN"; true; } || echo "FD0ICON=${NEWFD0ICON}" >>"$CONFFILE"
__adjust_config FD0ICON $NEWFD0ICON

if [ "$ICONPSITIONB" = "true" ] ; then #KRG
#ibPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'bottom\'/"
# grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
# _adjust_config "$ibPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='bottom'" >>"$CONFFILE"
__adjust_config ICON_PLACE_ORIENTATION bottom
NEWICON_PLACE_ORIENTATION=bottom
elif [ "$ICONPSITIONR" = "true" ] ; then
#irPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'right\'/"
#grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
# _adjust_config "$irPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='right'" >>"$CONFFILE"
__adjust_config ICON_PLACE_ORIENTATION right
NEWICON_PLACE_ORIENTATION=right
elif [ "$ICONPSITIONT" = "true" ] ; then
#itPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'top\'/"
#grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
# _adjust_config "$itPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='top'"  >>"$CONFFILE"
__adjust_config ICON_PLACE_ORIENTATION top
NEWICON_PLACE_ORIENTATION=top
elif [ "$ICONPSITIONL" = "true" ] ; then
#ilPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'left\'/"
#grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
# _adjust_config "$ilPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='left'" >>"$CONFFILE"
__adjust_config ICON_PLACE_ORIENTATION left
NEWICON_PLACE_ORIENTATION=left
else
#ibPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'bottom\'/"
#grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
# _adjust_config "$ibPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='bottom'" >>"$CONFFILE"
__adjust_config ICON_PLACE_ORIENTATION bottom
NEWICON_PLACE_ORIENTATION=bottom
fi

if [ -n "`echo $NEWIPSPAC | grep -w -x '[0-9]\+'`" ] ; then
#newipspP="s/^ICON_PLACE_SPACING=.*/ICON_PLACE_SPACING=$NEWIPSPAC/"
#grep $Q '^ICON_PLACE_SPACING=' "$CONFFILE" && {
#    _adjust_config "$newipspP" ; true; } || echo "ICON_PLACE_SPACING=$NEWIPSPAC" >>"$CONFFILE"
__adjust_config ICON_PLACE_SPACING $NEWIPSPAC
fi

#fpPATTERN="s/^FORCE_POWERTIMEOUT_ALWAYS=.*/FORCE_POWERTIMEOUT_ALWAYS=${NEWFORCE_POWERTIMEOUT_ALWAYS}/"
#grep $Q '^FORCE_POWERTIMEOUT_ALWAYS=' "$CONFFILE" && {
#_adjust_config "$fpPATTERN"; true; } || echo "FORCE_POWERTIMEOUT_ALWAYS=${NEWFORCE_POWERTIMEOUT_ALWAYS}" >>"$CONFFILE"
__adjust_config FORCE_POWERTIMEOUT_ALWAYS $NEWFORCE_POWERTIMEOUT_ALWAYS

#dvPATTERN="s/^DISTURB_VIDEO=.*/DISTURB_VIDEO=${NEWDISTURB_VIDEO}/"
#grep $Q '^DISTURB_VIDEO=' "$CONFFILE" && {
#_adjust_config "$dvPATTERN"; true; } || echo "DISTURB_VIDEO=${NEWDISTURB_VIDEO}" >>"$CONFFILE"
__adjust_config DISTURB_VIDEO $NEWDISTURB_VIDEO

#ddPATTERN="s/^DISTURB_DL=.*/DISTURB_DL=${NEWDISTURB_DL}/"
#grep $Q '^DISTURB_DL=' "$CONFFILE" && {
#_adjust_config "$ddPATTERN"; true; } || echo "DISTURB_DL=${NEWDISTURB_DL}" >>"$CONFFILE"
__adjust_config DISTURB_DL $NEWDISTURB_DL

#dDPATTERN="s/^DISTURB_DEV=.*/DISTURB_DEV=${NEWDISTURB_DEV}/"
#grep $Q '^DISTURB_DEV=' "$CONFFILE" && {
#_adjust_config "$dDPATTERN"; true; } || echo "/DISTURB_DEV=${NEWDISTURB_DEV}" >>"$CONFFILE"
__adjust_config DISTURB_DEV $NEWDISTURB_DEV

#dvPATTERN="s/^DO_NOT_DISTURB_VIDEO=.*/DO_NOT_DISTURB_VIDEO='${NEWDO_NOT_DISTURB_VIDEO}'/"
#grep $Q '^DO_NOT_DISTURB_VIDEO=' "$CONFFILE" && {
#_adjust_config "$dvPATTERN"; true; } || echo "DO_NOT_DISTURB_VIDEO='${NEWDO_NOT_DISTURB_VIDEO}'" >>"$CONFFILE"
__adjust_config DO_NOT_DISTURB_VIDEO $NEWDO_NOT_DISTURB_VIDEO

#ddPATTERN="s/^DO_NOT_DISTURB_DL=.*/DO_NOT_DISTURB_DL='${NEWDO_NOT_DISTURB_DL}'/"
#grep $Q '^DO_NOT_DISTURB_DL=' "$CONFFILE" && {
#_adjust_config "$ddPATTERN"; true; } || echo "DO_NOT_DISTURB_DL='${NEWDO_NOT_DISTURB_DL}'" >>"$CONFFILE"
__adjust_config DO_NOT_DISTURB_DL $NEWDO_NOT_DISTURB_DL

#dDPATTERN="s/^DO_NOT_DISTURB_DEV=.*/DO_NOT_DISTURB_DEV='${NEWDO_NOT_DISTURB_DEV}'/"
#grep $Q '^DO_NOT_DISTURB_DEV=' "$CONFFILE" && {
#_adjust_config "$dDPATTERN"; true; } || echo "/DO_NOT_DISTURB_DEV='${NEWDO_NOT_DISTURB_DEV}'" >>"$CONFFILE"
__adjust_config DO_NOT_DISTURB_DEV $NEWDO_NOT_DISTURB_DEV

NEWPOLL_PLUG_DEVICE=${NEWPOLL_PLUG_DEVICE:-2}
test "$NEWPOLL_PLUG_DEVICE" -ge 1 || NEWPOLL_PLUG_DEVICE=1
test "$NEWPOLL_PLUG_DEVICE" -le 9 || NEWPOLL_PLUG_DEVICE=9

#ppPATTERN="s/^POLL_PLUG_DEVICE=.*/POLL_PLUG_DEVICE=${NEWPOLL_PLUG_DEVICE}/"
#grep $Q '^POLL_PLUG_DEVICE=' "$CONFFILE" && {
#_adjust_config "$ppPATTERN"; true; } || echo "POLL_PLUG_DEVICE=${NEWPOLL_PLUG_DEVICE}" >>"$CONFFILE"
__adjust_config POLL_PLUG_DEVICE $NEWPOLL_PLUG_DEVICE

echo "$CONFIG" > "$CONFFILE"
S=$((S+$?))
if [ "$S" = 0 ]; then
 xmessage -bg green -timeout 2 -title "Eventmanager" "Settings changed successfully" &
else
 xmessage -bg red              -title "Eventmanager" "Error occured writing
new $CONFFILE
" &
 RV=2
 break
fi
sleep 1

if [ "$NEWDESKDAEMON" = "true" ];then
 if [ ! "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d start &
 else
#echo 'sourceit' > "$MY_TMP"/pup_event_manager.flg
#echo 'force'    > /tmp/pup_event_change_icons.flg
#[ "$NEWICONWIPE1" = "true" -o "$NEWICONWIPE2" = "true" ] && echo "ICONWIPE" >/tmp/pup_event_change_icons.flg #v411
#v403 /sbin/clean_desk_icons can read this, then wipe all current icons...
#[ "$ICONPARTITIONS" != "$NEWICONPARTITIONS" ] && echo "ICONPARTITIONS"     > /tmp/pup_event_change_icons.flg
#[ "$ICONDESK" != "$NEWICONDESK" ]             && echo "ICONDESK"           > /tmp/pup_event_change_icons.flg
if [ "$ICONDESK" != "$NEWICONDESK" ]; then
DO_CHANGE_DRIVE_ICONS=1
fi
if [ "$ICONPARTITIONS" != "$NEWICONPARTITIONS" ]; then
DO_CHANGE_DRIVE_ICONS=1
fi
if [ "$FD0ICON" != "$NEWFD0ICON" ]; then
DO_CHANGE_DRIVE_ICONS=1
fi
if [ "$ICON_PLACE_ORIENTATION" != "$NEWICON_PLACE_ORIENTATION" ]; then
DO_CHANGE_DRIVE_ICONS=1
fi
if [ "$ICON_PLACE_SPACING" != "$NEWIPSPAC" ]; then
DO_CHANGE_DRIVE_ICONS=1
fi

echo 'sourceit' > "$MY_TMP"/pup_event_manager.flg
if test "$DO_CHANGE_DRIVE_ICONS"; then
 echo change >"$MY_TMP"/pup_event_change_icons.flg
fi
 fi
else #NEWDESKDAEMON" != "true"
 if [ "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d stop &
 fi
fi

unset DO_CHANGE_DRIVE_ICONS S

sleep 1
times
done
test "$CMD" && exec $CMD
exit $RV
###END###
