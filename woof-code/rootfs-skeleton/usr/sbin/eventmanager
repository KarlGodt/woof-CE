#!/bin/ash
#Barry Kauler 2008.
#Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html). 2007 www.puppylinux.com
# A gui to provide choices for "events" -- things that occur at a systems level,
# usually hardware related.
#v411 checkbox to redraw/realign icons. #2025-10-18 disabled
#v412 workaround, someone exited with invalid settings.
#w007 mouse inactivity computer power-down.
#w464 /etc/puppyversion is now history.
#v424 automatic unmounting (see pup_event_frontend_d).


test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG=""
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap
}


tmpDIR=/tmp/pup_event
[ -d "$tmpDIR" ] || mkdir $VERB -p "$tmpDIR"


#KRG APR/MAY2011 : ADDED SUPPORT FOR EDITING (partly) /ETC/EVENTMANAGER VIA TAB "$PLACEMENTTB"
#KRG APR/MAY2011 : TRYED BACKWARDSCOMPATIBILITY VIA IF CHECKS

SHOWMODE=$1 #v405 optional to modify gui.

. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS
PUPPYVERSION="$DISTRO_VERSION"
KERNVER=`uname -r`
. /etc/rc.d/MODULESCONFIG

CONFFILE=/etc/eventmanager.cfg
[ -f "$CONFFILE" ] && . "$CONFFILE"

STATE_DIR="$HOME/Choices/Puppy"
EXE_DIR='pup_event'
PUP_EVENT_DIR="$STATE_DIR/$EXE_DIR"

#[ "$BACKENDON" = "true" -o "$BACKENDON" = "false" ]           ||      BACKENDON="true" ##udev
 [ "$DESKDAEMON" = "true" -o "$DESKDAEMON" = "false" ]         ||     DESKDAEMON="true"
#[ "$HOTPLUGON" != "true" -a "$HOTPLUGON" != "false" ] && HOTPLUGON="true" #OLD
#[ "$ZCDPOLL" = "true" -o "$ZCDPOLL" = "false" ]      ||   ZCDPOLL="true" #NEW
#[ "$AUTOUNMOUNT" ]                                          || AUTOUNMOUNT="false" #v424
#[ "$HOTPLUGNOISY" = "true" -o "$HOTPLUGNOISY" = "false" ] || HOTPLUGNOISY="false"
#[ "$AUTOTARGET" = "true" -o "$AUTOTARGET" = "false" ]     ||   AUTOTARGET="true"

 [ "$ICONDESK" = "true" -o "$ICONDESK" = "false" ]             ||      ICONDESK="true"
 [ "$ICONPARTITIONS" = "true" -o "$ICONPARTITIONS" = "false" ] || ICONPARTITIONS="true"
 [ "$FD0ICON" = "true" -o "$FD0ICON" = "false" ]           ||      FD0ICON="true"

 [ $POWERTIMEOUT ]    || POWERTIMEOUT=0 #w007 0=never.
 [ $RAMSAVEINTERVAL ] || RAMSAVEINTERVAL=30


#udevd
UDEV_CHOICE_DISABLED="<checkbox>
   <label>Tick box for hotplug module/firmware loading [ BACKENDON on/off udevd ]</label>
   <default>${BACKENDON}</default>
   <variable>NEWBACKENDON</variable>
  </checkbox>
"

#iconwipe
ICONWIPE_CHOICE2_DISABLED="  <checkbox>
   <label>Tick box to erase then redraw and realign existing icons</label>
   <default>true</default>
   <variable>NEWICONWIPE2</variable>
   <action>if false clear:NEWICONWIPE1</action>
  </checkbox>
"
ICONWIPE_CHOICE1_DISABLED="  <checkbox>
   <label>Tick box to erase then redraw and realign existing icons</label>
    <default>true</default>
   <variable>NEWICONWIPE1</variable>
   <action>if false clear:NEWICONWIPE2</action>
  </checkbox>
"

#KRG
[ -z "$ICON_PLACE_START_X_GAP" ] && ICON_PLACE_START_GAP=32 #x-alignment
[ -z "$ICON_PLACE_START_Y_GAP" ] && ICON_PLACE_START_Y_GAP=64  #y-alignment
[ -z "$ICON_PLACE_ORIENTATION" ] && ICON_PLACE_ORIENTATION='bottom'

if [ -z "$ICON_PLACE_SPACING" ] ; then # icons are 48pixels ,
                                      # spacing from mid_of_icon to mid_of_icon,
                                     #less than 48 they overlap
                                    # so lets play with the screen geometry

SCREEN_Y=`xwininfo -root | grep '\-geometry' | sed 's#^[[:blank:]]*##' | cut -f2 -d ' ' | sed 's#+.*##' | cut -f 2 -d 'x'`
  if test $SCREEN_Y -le  480; then ICON_PLACE_SPACING=8
elif test $SCREEN_Y -le  600; then ICON_PLACE_SPACING=16
elif test $SCREEN_Y -le  768; then ICON_PLACE_SPACING=32
elif test $SCREEN_Y -le 1024; then ICON_PLACE_SPACING=48
elif test $SCREEN_Y -le 1200; then ICON_PLACE_SPACING=64
else                               ICON_PLACE_SPACING=56
  fi

fi
#KRG

#from /sbin/pup_event_frontend_d
CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"
PIN_GRID_STEP=`grep "pinboard_grid_step" $CONFFILEROX | sed -e "s/ *<[^>]*>//g"`
[ -z "$PIN_GRID_STEP" ]    && PIN_GRID_STEP=16 #16=medium.
[ "$PIN_GRID_STEP" -le 0 ] && PIN_GRID_STEP=16 #precaution.

if [ -n "$ICON_PLACE_ORIENTATION" ] ; then #KRG
case $ICON_PLACE_ORIENTATION in
bottom)  ICONPOSITIONB="true" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ;;
right)  ICONPOSITIONR="true" ; ICONPOSITIONB="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ;;
top)   ICONPOSITIONT="true" ; ICONPOSITIONR="false" ; ICONPOSITIONB="false" ; ICONPOSITIONL="false" ;;
left) ICONPOSITIONL="true" ; ICONPOSITIONB="false" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ;;
*)   ICONPOSITIONB="true" ; ICONPOSITIONR="false" ; ICONPOSITIONT="false" ; ICONPOSITIONL="false" ;;
esac

#w007 as have a optional cutdown gui, make sure these are all preset...
#     NEWAUTOTARGET="$AUTOTARGET"
#    NEWAUTOUNMOUNT="$AUTOUNMOUNT"
#      NEWBACKENDON="$BACKENDON"
        NEWFD0ICON="$FD0ICON"
#   NEWHOTPLUGNOISY="$HOTPLUGNOISY"
#      NEWHOTPLUGON="$HOTPLUGON"
#       NEWZCDPOLL="$ZCDPOLL"
       NEWICONDESK="$ICONDESK"
 NEWICONPARTITIONS="$ICONPARTITIONS"
   NEWPOWERTIMEOUT=$POWERTIMEOUT
NEWRAMSAVEINTERVAL=$RAMSAVEINTERVAL


ICON_POS="
  <hbox>
  <text xalign=\"0\"><label>Choose Position of Icons : Tick box for</label></text>
  <radiobutton>
  <label>\"bottom  \"</label>
  <default>${ICONPOSITIONB}</default>
  <variable>ICONPSITIONB</variable>
  </radiobutton>
  <radiobutton>
  <label>\"right  \"</label>
  <default>${ICONPOSITIONR}</default>
  <variable>ICONPSITIONR</variable>
  </radiobutton>
  <radiobutton>
  <label>\"top  \"</label>
  <default>${ICONPOSITIONT}</default>
  <variable>ICONPSITIONT</variable>
  </radiobutton>
  <radiobutton>
  <label>\"left  \"</label>
  <default>${ICONPOSITIONL}</default>
  <variable>ICONPSITIONL</variable>
  </radiobutton>
  </hbox>
"
fi

PLACEMENTTB=
PLACEMENTTB="Icon placement"

if [ -n "$ICON_PLACE_START_X_GAP" ] ; then
IP_E_GAP_X="
<hbox>
<text><label>Choose the Spacing 'x' to edge of screen:</label></text>
<hbox>
<entry>
<default>${ICON_PLACE_START_X_GAP}</default>
<variable>NEWIPSGAPX</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_START_Y_GAP" ] ; then
IP_E_GAP_Y="
<hbox>
<text><label>Choose the Spacing 'y' to edge of screen:</label></text>
<hbox>
<entry>
<default>${ICON_PLACE_START_Y_GAP}</default>
<variable>NEWIPSGAPY</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_SPACING" ] ; then
IP_SPA_OLD="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> of drive-icons [10-300]:\"</label></text>
<hbox>
<entry>
<default>${ICON_PLACE_SPACING}</default>
<variable>NEWIPSPAC</variable>
</entry>
</hbox>
</hbox>
"

CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"
PIN_GRID_STEP=`sed -n '/<!--/,/-->/!p' "$CONFFILEROX" | grep -m1 "pinboard_grid_step" | sed -e "s/ *<[^>]*>//g"`
[ -z "$PIN_GRID_STEP" ]    && PIN_GRID_STEP=32 #2=fine 16=medium 32=coarse.
[ "$PIN_GRID_STEP" -le 0 ] && PIN_GRID_STEP=32 #precaution.
ICON_PLACE_SPACING=$(( (ICON_PLACE_SPACING / PIN_GRID_STEP) * PIN_GRID_STEP)) # always round to acceptable values
                                                            # ICON_PLACE_SPACING must be -ge PIN_GRID_STEP
[ "$ICON_PLACE_SPACING" ]         || ICON_PLACE_SPACING=64
[ "$ICON_PLACE_SPACING" -ge 64 ]  || ICON_PLACE_SPACING=64
[ "$ICON_PLACE_SPACING" -le 160 ] || ICON_PLACE_SPACING=160

ITEM="<item>$ICON_PLACE_SPACING</item>"
for i in `seq 64 $PIN_GRID_STEP 160`; do
test "$i" = $ICON_PLACE_SPACING && continue
ITEM="$ITEM
<item>$i</item>"
done


IP_SPA="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> between drive icons [64-160]:\"</label></text>
<hbox>
<combobox>
$ITEM
<variable>NEWIPSPAC</variable>
</combobox>
</hbox>
</hbox>
"


fi

if [ -n "$ICON_PLACE_SPACING_X" ] ; then
IP_SPA_X="
<hbox>
<text><label>Choose the Spacing X of drive-icons:</label></text>
<hbox>
<entry>
<default>${ICON_PLACE_SPACING_X}</default>
<variable>NEWIPSPACX</variable>
</entry>
</hbox>
</hbox>
"
fi

if [ -n "$ICON_PLACE_SPACING_Y" ] ; then
IP_SPA_Y="
<hbox>
<text><label>Choose the Spacing Y of drive-icons:</label></text>
<hbox>
<entry>
<default>${ICON_PLACE_SPACING_Y}</default>
<variable>NEWIPSPACY</variable>
</entry>
</hbox>
</hbox>
"
fi


PLACEMENT="
<vbox>
$ICON_POS
$IP_E_GAP_UNUSED
$IP_E_GAP_X_DISABLED
$IP_E_GAP_Y_DISABLED
$IP_S_GAP_UNUSED
$IP_SPA
$IP_SPA_X_UNUSED
$IP_SPA_Y_UNUSED

  <hbox><text><label>\"  \"</label></text></hbox>
  <text use-markup=\"true\"><label>\"<b>NOTE :</b> the values above have to be a <b>power</b> of the <u>current <i>'pinboard_grid_step'</i> value of <b>$PIN_GRID_STEP</b></u> . Otherwise the drive icons would not render properly because the ROX-Filer would not place the icons as expected, but to the nearest value rel to the <i>'pinboard_grid_step'</i> . <b>Usually the icons would pile up on one place of the pinboard</b> . To change the PIN_GRID_STEP value : go to ROX-Filer Options > Pinboard > Behavior\"</label></text>
</vbox>
"

_debugx "$PLACEMENT"

AUTOTARGET_CHOICE_DISABLED="  <frame>
  <text><label>This checkbox extends the default behavior, and will launch a more appropriate application. Currently, it adds detection of a video DVD or audio CD and launches the media player:</label></text>
  <checkbox tootip-text=\"/ussr/local/bin/drive_all||.pup_event/drive_*/AppRun\">
   <label>Tick box for auto-detection of target application [ AUTOTARRGET ]</label>
   <default>${AUTOTARGET}</default>
   <variable>NEWAUTOTARGET</variable>
  </checkbox>
  </frame>
"

HOTPLUGNOISY_CHOICE_DISABLED=" <vbox>
  <frame>
  <text><label>Normally you have to click on a partition icon to run the handler 'AppRun' in $PUP_EVENT_DIR, but this checkbox makes the 'handler' run as soon as a media is plugged in if polling every $POLL_PLUG_DEVICE seconds is enabled . For example, plug in a DVD and it will immediately either get automatically mounted, or [if the above checkbox is ticked] the media player will run. This is usefull if using a desktopmanager like enlightenment or when having disabled drive icons on desktop:</label></text>
  <checkbox>
   <label>Tick box for auto-launch 'handler' when media plugged in [ HOTPLUGNOISY ]</label>
   <default>${HOTPLUGNOISY}</default>
   <variable>NEWHOTPLUGNOISY</variable>
  </checkbox>
  </frame>
 </vbox>
"

HANDLER_TAB_DISABLED="<frame Drive 'handler'>
 <vbox>
  <text use-markup=\"true\"><label>\"The <b>'handler'</b> decides what to do when you click on a desktop drive icon. <b>Normally</b>, this just starts <u>Pmount</u> if you click on a drive icon, <b>or</b> mounts it and starts <u>ROX-Filer</u> if a partition icon, but this behavior can be extended by these checkboxes.\"</label></text>
  $AUTOTARGET_CHOICE
 </vbox>

  $HOTPLUGNOISY_CHOICE

</frame>
"



AUTO_UNMOUNT_COICE_DISABLED="   <checkbox draw-as-radio=\"true\">
   <label>Tick box for auto unmounting of partitions [ AUTOUNMOUNT ]</label>
   <default>${AUTOUNMOUNT}</default>
   <variable>NEWAUTOUNMOUNT</variable>
  </checkbox>
  <text><label>(WARNING: auto unmounting is highly experimental)</label></text>
"

ZCDPOLL_DISABLED="<checkbox draw-as-radio=\"true\">
   <label>Tick box for polling Zip or CD devices every $POLL_PLUG_DEVICE seconds [ ZCDPOLL ]</label>
   <default>${ZCDPOLL}</default>
   <variable>NEWZCDPOLL</variable>
   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>
  </checkbox>
"

DRIVESPART2="
 <frame Drive icons on desktop>
 <vbox>
  <text use-markup=\"true\"><label>\"When this box is ticked, there will be an icon for each drive. If you plugin a USB pen drive for example, an icon will appear. Unplug and it will disappear. If you don't want these drive icons on the desktop, untick this box (but there will still remain <b>just one icon</b> that will launch Pmount when clicked on). The individual drive icons are purely a convenience and Puppy works fine without them.\"</label></text>
  <frame>
  <checkbox>
   <label>Tick box for drive icons on desktop</label>
   <default>${ICONDESK}</default>
   <variable>NEWICONDESK</variable>
   <action>if true enable:NEWICONPARTITIONS</action>
   <action>if false disable:NEWICONPARTITIONS</action>
  </checkbox>

  <vbox>
  <text wrap=\"true\" width-chars=\"70\"><label>If the above is ticked, then you can choose to have an icon for each partition, rather than one icon for the entire drive:</label></text>
  <checkbox>
   <label>Tick box for an icon for each partition</label>
   <default>${ICONPARTITIONS}</default>
   <variable>NEWICONPARTITIONS</variable>
  </checkbox>
  </vbox>
  </frame>
  </vbox>
 </frame>

 <frame IconPlacements>
  $PLACEMENT
 </frame>

 <frame Legacy>
  <text><label>Linux does not support hotplug detection of when a legacy floppy diskette is inserted or removed. Periodic probing requires starting the drive motor, which is very slow -- and do you want the motor to startup every $POLL_PLUG_DEVICE seconds? Therefore, if your PC has a floppy drive, tick this box to have a permanent icon on desktop (regardless whether a diskette is actually inserted, or even a floppy drive!).</label></text>
  <checkbox>
   <label>Tick box for floppy drive icon on desktop</label>
   <default>${FD0ICON}</default>
   <variable>NEWFD0ICON</variable>
  </checkbox>
 </frame>

"
if [ "$SHOWMODE" = "desktop" ]; then
SELECT_FULL="   <button>
    <label>Show full Event Manager</label>
    <action type=\"exit\">fullem</action>
   </button>
"
fi

APPLY_OR_EXIT="
 <hbox>
  <text><label>\"Click  \"</label></text>
   <button tooltip-text=\"to save new settings to $CONFFILE configuration file\">
   <input file icon=\"gtk-apply\"></input>
   <label>OK:Apply!</label>
   </button>
  <text use-markup=\"true\"><label>\"  <b>or</b>  \"</label></text>
   <button cancel></button>
  <text use-markup=\"true\"><label>\"  <i>to Exit without saving</i>\"</label></text>
  $SELECT_FULL
 </hbox>
"

#NOTEBOOK_LABEL2="<notebook labels=\"Icon Handler|Desktop Icons|$PLACEMENTTB|Legacy\">"
NOTEBOOK_LABEL2="<notebook labels=\"Desktop Icons|$PLACEMENTTB|Legacy\">"
#NOTEBOOK_LABEL1="<notebook labels=\"Activate|Icon Handler|Desktop Icons|$PLACEMENTTB|Legacy|Save Session|Power\">"
NOTEBOOK_LABEL1="<notebook labels=\"Activate|Desktop Icons|$PLACEMENTTB|Legacy|Save Session|Power\">"

if [ "$SHOWMODE" = "desktop" ];then
 #cutdown, only show choices for settng the desktop icons...
 export MAIN_DIALOG="
<window title=\"Event Manager: Desktop drive icons\" icon-name=\"gtk-execute\">
<vbox>

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

  $NOTEBOOK_LABEL2

  $DRIVESPART2

  </notebook>

   $APPLY_OR_EXIT

</vbox>
</window>
"
else
 export MAIN_DIALOG="
<window title=\"Puppy Event Manager\" icon-name=\"gtk-execute\">
<vbox>

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

  $NOTEBOOK_LABEL1

  <frame Activate Puppy Event Manager>

  <text use-markup=\"true\"><label>\"The 'pup_event' Puppy Event Manager is running in the background and handles hotplugging of drives, including the desktop drive icons. However, turn it off, and Puppy will revert to the same behaviour as versions prior to 4.x, in which there is no hotplug support. This reduces resource usage, so try unticking these on very old slow PCs. <b>pmount</b> can still be run manually to mount and unmount partitions.\"</label></text>

  <frame pup_event_frontend_d>
  <checkbox indicator-size=\"20\">
   <label>Tick box for desktop hotplug support [ DESKDAEMON on/off daemon ]</label>

   <default>${DESKDAEMON}</default>
   <variable>NEWDESKDAEMON</variable>
   <action>if true enable:NEWZCDPOLL</action>
   <action>if false clear:NEWZCDPOLL</action>
   <action>if false disable:NEWZCDPOLL</action>

   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>

   <action>if true enable:NEWAUTOUNMOUNT</action>
   <action>if false disable:NEWAUTOUNMOUNT</action>
   <action>if false clear:NEWAUTOUNMOUNT</action>

   <action>if true enable:NEWRAMSAVEINTERVAL</action>
   <action>if false disable:NEWRAMSAVEINTERVAL</action>
   <action>if false clear:NEWRAMSAVEINTERVAL</action>

   <action>if true enable:NEWPOWERTIMEOUT</action>
   <action>if false disable:NEWPOWERTIMEOUT</action>
   <action>if false clear:NEWPOWERTIMEOUT</action>

  </checkbox>
  <hbox>
   <text use-markup=\"true\" wrap=\"true\" max-width-chars=\"80\" single-line-mode=\"false\">
   <label>\"<b>NOTE :</b> when you turn this off ,
  the freememapplet in the tray won't get updated , maybe not show at all .\"</label>
   </text>
  </hbox>
  <hbox>
  <text><label>\"  \"</label></text>
  <vbox>
  <text wrap=\"false\"><label>So, if the above is ticked, then you can choose below :</label></text>
  </vbox>
  </hbox>
  </frame>
 </frame>

 $DRIVESPART2

 <frame Periodic save from RAM>
 <vbox>
  <text use-markup=\"true\"><label>\"Puppy runs in a particular 'state' that we call the <b>PUPMODE</b>. This depends on the type of installation and the type of hardware. <b>Currently, PUPMODE=${PUPMODE}</b>. If it is an <b>odd</b> number, for example 13, then Puppy is doing everything in RAM and saving the current session to a drive periodically -- this is done in the case of Flash memory to make it last longer. When Puppy runs in an odd PUPMODE, there will be a <b>save</b> icon on the desktop, <b>also a save occurs at shutdown</b>. You can also specify a periodic save here:\"</label></text>
  <hbox>
   <text><label>Save interval (0=never):</label></text>
   <entry max_length=\"4\">
    <default>${RAMSAVEINTERVAL}</default>
    <variable>NEWRAMSAVEINTERVAL</variable>
   </entry>
   <text><label>minutes</label></text>
   <text><label>\"       \"</label></text>
  </hbox>
  <text use-markup=\"true\"><label>\"<b>NOTE1:</b> PUPMODE=77 (multisession DVD) excluded, only manual save with desktop icon and at shutdown.\"</label></text>
  <text use-markup=\"true\"><label>\"<b>NOTE2:</b> PUPMODE=5 there are no saves, above value ignored.\"</label></text>
 </vbox>
 </frame>

 <frame Power>
 <vbox>
  <text><label>Puppy is able to power-off your computer after a period of mouse inactivity. This will occur if the mouse cursor has not been moved for the designated interval:</label></text>
  <hbox>
   <text><label>Inactivity interval (0=never):</label></text>
   <entry max_length=\"4\">
    <default>${POWERTIMEOUT}</default>
    <variable>NEWPOWERTIMEOUT</variable>
   </entry>
   <text><label>minutes</label></text>
   <text><label>\"       \"</label></text>
  </hbox>
  </vbox>
 </frame>

</notebook>

  $APPLY_OR_EXIT

</vbox>
</window>
"
fi

if [ "$HAVEMUT2" = "yes" ];then # <button file icon="top"> | icon-name=\"gtk-execute\"
 PREFSBUTTON="
   <button><label>$m_11</label>
    <action type=\"exit\">SETPREFS</action>
   </button>"
fi
#echo "$MAIN_DIALOG"
#exit
#gtkdialog3 --debug --program=MAIN_DIALOG --center
RETSTRING=`gtkdialog3 --program=MAIN_DIALOG --center`
[ $? -ne 0 ] && exit 4

eval "$RETSTRING"

#echo "$RETSTRING" #TEST

[ "$EXIT" = "abort" ]  && exit
[ "$EXIT" = "Cancel" ] && exit
[ "$EXIT" = "" ]       && exit

#v405 it is running with 'desktop' param, now rerun with all tabs...
[ "$EXIT" = "fullem" ] && exec eventmanager

#make sure that RAMSAVEINTERVAL is an integer only...
[ "$NEWRAMSAVEINTERVAL" ] || NEWRAMSAVEINTERVAL=0 #412
#[ ! "$NEWRAMSAVEINTERVAL" ] && [ "$PUPMODE" != 2 -a "$PUPMODE" != 6 -a "$PUPMODE" != 12 ] && NEWRAMSAVEINTERVAL=30 #412
NEWRAMSAVEINTERVAL=`echo -n "$NEWRAMSAVEINTERVAL" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent saves...
[ $NEWRAMSAVEINTERVAL -gt 0 -a $NEWRAMSAVEINTERVAL -lt 5 ] && NEWRAMSAVEINTERVAL=5
[ "$PUPMODE" = 2 -o "$PUPMODE" = 6 -o "$PUPMODE" = 12 ]    && NEWRAMSAVEINTERVAL=0 ##+++2012-01-18

#w007 make sure that POWERTIMEOUT is integer only...
[ "$NEWPOWERTIMEOUT" ] || NEWPOWERTIMEOUT=0
NEWPOWERTIMEOUT=`echo -n "$NEWPOWERTIMEOUT" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent power-down...
[ $NEWPOWERTIMEOUT -gt 0 -a $NEWPOWERTIMEOUT -lt 5 ] && NEWPOWERTIMEOUT=5

#v403 if major-switch has turned off hotplug support, only show one icon...
#[ "$NEWBACKENDON" ]  || NEWBACKENDON="true" #v412
#[ "$NEWHOTPLUGON" = "" ] && NEWHOTPLUGON="true" #v412
[ "$NEWDESKDAEMON" ] || NEWDESKDAEMON"true" #v412
#[ "$NEWBACKENDON" = "false" ] && NEWHOTPLUGON="false"

if [ "$NEWDESKDAEMON" = "false" ];then
 NEWICONDESK="false"
 NEWICONPARTITIONS="false"
 NEWHOTPLUGNOISY="false"
 NEWAUTOTARGET="false"
 NEWAUTOUNMOUNT="false" #v424
 NEWZCDPOLL='false'
fi

[ "$NEWICONDESK" = 'false' ] && NEWICONPARTITIONS='false'
echo 1 NEWIPSPAC=$NEWIPSPAC
NEWIPSGAPX=`echo "$NEWIPSGAPX" |sed 's/[^0-9]//g'`   #get rid of non-digits
NEWIPSGAPY=`echo "$NEWIPSGAPY" |sed 's/[^0-9]//g'`
NEWIPSPAC=`echo "$NEWIPSPAC" |sed 's/[^0-9]//g'`
echo 2 NEWIPSPAC=$NEWIPSPAC
NEWIPSPAC=$(( (NEWIPSPAC / PIN_GRID_STEP) * PIN_GRID_STEP ))  #round to non-odd numbers
 echo 3 NEWIPSPAC=$NEWIPSPAC
[ "$NEWIPSGAPX" ] || NEWIPSGAPX=32
[ "$NEWIPSGAPY" ] || NEWIPSGAPY=64
[ "$NEWIPSPAC" ]     || NEWIPSPAC=64
 echo 4 NEWIPSPAC=$NEWIPSPAC
[ "$NEWIPSPAC" = 0 ] && NEWIPSPAC=64
 echo 5 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSGAPX" -lt '24' -o "$NEWIPSGAPX" -gt '300' ] && NEWIPSGAPX=24 # x
 [ "$NEWIPSGAPY" -lt '32' -o "$NEWIPSGAPY" -gt '200' ] && NEWIPSGAPY=32 # y

#[ "$NEWIPSPAC" -lt '10' -o "$NEWIPSPAC" -gt '300' ] && NEWIPSPAC=64 # spacing
 [ "$NEWIPSPAC" -ge '64' ]  || NEWIPSPAC=64
 echo 6 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSPAC" -le '160' ] || NEWIPSPAC=160
 echo 7 NEWIPSPAC=$NEWIPSPAC

# REM: The "$CONFFILE" file gets altered as variable first,
#       then the altered variable gets written to "$CONFFILE"
#       so that "$CONFFILE" gets overwritten ...
#      TODO : rename /etc/eventmanager to "$CONFFILE"
#              or /etc/pup_event.conf or pup_event_frontend.conf
#      TODO : make backup of old conf and create a default conf
#              to be able restore previous or default settings
#              and write a GUI for it...
CONFIG=`cat "$CONFFILE"`

_adjust_config(){
CONFIG=`echo "$CONFIG" | sed -e "$@"`
S=$((S+$?))
}

rsPATTERN="s/^RAMSAVEINTERVAL=.*/RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}/"
grep $Q '^RAMSAVEINTERVAL=' "$CONFFILE" && {
 _adjust_config "$rsPATTERN"; true; } || echo "RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}" >>"$CONFFILE"

#w007...
ptPATTERN="s/^POWERTIMEOUT=.*/POWERTIMEOUT=${NEWPOWERTIMEOUT}/"
grep $Q '^POWERTIMEOUT=' "$CONFFILE" && {
 _adjust_config  "$ptPATTERN"; true; } || echo "ICONDESK=${NEWICONDESK}" >>"$CONFFILE"

idPATTERN="s/^ICONDESK=.*/ICONDESK=${NEWICONDESK}/"
grep $Q '^ICONDESK='  "$CONFFILE" && {
 _adjust_config  "$idPATTERN"; true; } || echo "ICONPARTITIONS=${NEWICONPARTITIONS}" >>"$CONFFILE"

ipPATTERN="s/^ICONPARTITIONS=.*/ICONPARTITIONS=${NEWICONPARTITIONS}/"
grep $Q '^ICONPARTITIONS=' "$CONFFILE" && {
 _adjust_config "$ipPATTERN"; true; } || echo "HOTPLUGNOISY=${NEWHOTPLUGNOISY}" >>"$CONFFILE"

hnPATTERN="s/^HOTPLUGNOISY=.*/HOTPLUGNOISY=${NEWHOTPLUGNOISY}/"
grep $Q '^HOTPLUGNOISY='  "$CONFFILE" && {
 _adjust_config "$hnPATTERN"; true; } || echo "AUTOTARGET=${NEWAUTOTARGET}" >>"$CONFFILE"

#atPATTERN="s/^AUTOTARGET=.*/AUTOTARGET=${NEWAUTOTARGET}/"
#grep $Q '^AUTOTARGET='  "$CONFFILE" && {
# _adjust_config "$atPATTERN"; true; } || echo "BACKENDON=${NEWBACKENDON}" >>"$CONFFILE"

#boPATTERN="s/^BACKENDON=.*/BACKENDON=${NEWBACKENDON}/"
#grep $Q '^BACKENDON='  "$CONFFILE" && {
# _adjust_config "$boPATTERN"; true; } || echo "$" >>"$CONFFILE"

ddPATTERN="s/^DESKDAEMON=.*/DESKDAEMON=${NEWDESKDAEMON}/"
grep $Q '^DESKDAEMON=' "$CONFFILE" && {
 _adjust_config "$ddPATTERN"; true; } || echo "DESKDAEMON=${NEWDESKDAEMON}" >>"$CONFFILE"

zcPATTERN="s/^ZCDPOLL=.*/ZCDPOLL=${NEWZCDPOLL}/"
grep $Q '^ZCDPOLL='  "$CONFFILE" && {
 _adjust_config "$zcPATTERN"; true; } || echo "ZCDPOLL=${NEWZCDPOLL}" >>"$CONFFILE"

#auPATTERN="s/^AUTOUNMOUNT=.*/AUTOUNMOUNT=${NEWAUTOUNMOUNT}/" #v424
#grep $Q '^AUTOUNMOUNT=' "$CONFFILE" && {
# _adjust_config "$auPATTERN"; true; } || echo "AUTOUNMOUNT=${NEWAUTOUNMOUNT}" >>"$CONFFILE"

fiPATTERN="s/^FD0ICON=.*/FD0ICON=${NEWFD0ICON}/"
grep $Q '^FD0ICON=' "$CONFFILE" && {
 _adjust_config "$fiPATTERN"; true; } || echo "FD0ICON=${NEWFD0ICON}" >>"$CONFFILE"



if [ "$ICONPSITIONB" = "true" ] ; then #KRG
ibPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'bottom\'/"
 grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
 _adjust_config "$ibPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='bottom'" >>"$CONFFILE"
elif [ "$ICONPSITIONR" = "true" ] ; then
irPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'right\'/"
grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
 _adjust_config "$irPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='right'" >>"$CONFFILE"
elif [ "$ICONPSITIONT" = "true" ] ; then
itPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'top\'/"
grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
 _adjust_config "$itPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='top'"  >>"$CONFFILE"
elif [ "$ICONPSITIONL" = "true" ] ; then
ilPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'left\'/"
grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
 _adjust_config "$ilPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='left'" >>"$CONFFILE"
else
ibPATTERN="s/^ICON_PLACE_ORIENTATION=.*/ICON_PLACE_ORIENTATION=\'bottom\'/"
grep $Q '^ICON_PLACE_ORIENTATION=' "$CONFFILE" && {
 _adjust_config "$ibPATTERN" ; true; } || echo "ICON_PLACE_ORIENTATION='bottom'" >>"$CONFFILE"
fi



if [ -n "`echo $NEWIPESAPX | grep -w -x '[0-9]\+'`" ] ; then
newipegxP="s/^ICON_PLACE_START_X_GAP=.*/ICON_PLACE_START_X_GAP=$NEWIPSGAPX/"
grep $Q '^ICON_PLACE_START_X_GAP=' "$CONFFILE" && {
    _adjust_config "$newipegxP" ; true; } || echo "ICON_PLACE_START_X_GAP=$NEWIPSGAPX" >>"$CONFFILE"
#compat old NAME
newipegxP="s/^ICON_PLACE_START_GAP=.*/ICON_PLACE_START_GAP=$NEWIPSGAPX/"
grep $Q '^ICON_PLACE_START_X_GAP=' "$CONFFILE" && {
    _adjust_config "$newipegxP" ; true; } || echo "ICON_PLACE_START_GAP=$NEWIPSGAPX" >>"$CONFFILE"

fi
if [ -n "`echo $NEWIPSGAPY | grep -w -x '[0-9]\+'`" ] ; then
newipegyP="s/^ICON_PLACE_START_Y_GAP=.*/ICON_PLACE_START_Y_GAP=$NEWIPSGAPY/"
grep $Q '^ICON_PLACE_START_Y_GAP=' "$CONFFILE" && {
    _adjust_config "$newipegyP" ; true; } || echo "ICON_PLACE_START_Y_GAP=$NEWIPSGAPY" >>"$CONFFILE"
#compat old NAME
newipegyP="s/^ICON_PLACE_EDGE_GAP=.*/ICON_PLACE_EDGE_GAP=$NEWIPSGAPY/"
grep $Q '^ICON_PLACE_START_Y_GAP=' "$CONFFILE" && {
    _adjust_config "$newipegyP" ; true; } || echo "ICON_PLACE_EDGE_GAP=$NEWIPSGAPY" >>"$CONFFILE"
fi
if [ -n "`echo $NEWIPSPAC | grep -w -x '[0-9]\+'`" ] ; then
newipspP="s/^ICON_PLACE_SPACING=.*/ICON_PLACE_SPACING=$NEWIPSPAC/"
grep $Q '^ICON_PLACE_SPACING=' "$CONFFILE" && {
    _adjust_config "$newipspP" ; true; } || echo "ICON_PLACE_SPACING=$NEWIPSPAC" >>"$CONFFILE"
#NEW
newipspP="s/^ICON_PLACE_SPACING_XY=.*/ICON_PLACE_SPACING_XY=$NEWIPSPAC/"
grep $Q '^ICON_PLACE_SPACING=' "$CONFFILE" && {
    _adjust_config "$newipspP" ; true; } || echo "ICON_PLACE_SPACING_XY=$NEWIPSPAC" >>"$CONFFILE"
fi

[ "$S" = 0 ] || { xmessage -bg red -title "Eventmanager" "Error occured writing
new $CONFFILE"; exit 5; }

echo "$CONFIG" > "$CONFFILE"
sleep 1

#if [ "$NEWBACKENDON" = "true" ];then
#if [ ! "`ps-FULL --no-headers -C udevd`" ];then udevd --daemon;fi;fi

if [ "$NEWDESKDAEMON" = "true" ];then
 if [ ! "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d start &
 fi
else #NEWDESKDAEMON" != "true"
 if [ "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d stop &
 fi
fi

echo 'sourceit' > /tmp/pup_event_manager.flg
echo 'force'    > /tmp/pup_event_change_icons.flg
#[ "$NEWICONWIPE1" = "true" -o "$NEWICONWIPE2" = "true" ] && echo "ICONWIPE" >/tmp/pup_event_change_icons.flg #v411
#v403 /sbin/clean_desk_icons can read this, then wipe all current icons...
#[ "$ICONPARTITIONS" != "$NEWICONPARTITIONS" ] && echo "ICONPARTITIONS"     > /tmp/pup_event_change_icons.flg
#[ "$ICONDESK" != "$NEWICONDESK" ]             && echo "ICONDESK"           > /tmp/pup_event_change_icons.flg


sleep 2
exec "$MY_SELF" &
exit "$?"

###END###
