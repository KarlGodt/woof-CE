#!/bin/ash
#Barry Kauler 2008.
#Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html). 2007 www.puppylinux.com
# A gui to provide choices for "events" -- things that occur at a systems level,
# usually hardware related.
#v411 checkbox to redraw/realign icons. #2015-10-18 disabled
#v412 workaround, someone exited with invalid settings.
#w007 mouse inactivity computer power-down.
#w464 /etc/puppyversion is now history.
#v424 automatic unmounting (see pup_event_frontend_d).

USE_DISABLED=yes
#USE_ALTERNATIVE=yes
DEBUG=1

test -s /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG=""
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap
}

LC_NUMERIC=C
SHOWMODE=$1 #v405 optional to modify gui.

. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS
PUPPYVERSION="$DISTRO_VERSION"
[ "$KERNVER" ] || KERNVER=`uname -r`
. /etc/rc.d/MODULESCONFIG

MY_SELF=${MY_SELF:-`realpath "$0"`}
MY_HOME=/var/local/PuppyLinux/pup_event
MY_CFG="$MY_HOME"/etc
MY_LOG="$MY_HOME"/log
MY_TMP="$MY_HOME"/tmp
mkdir $VERB -p "$MY_CFG" "$MY_LOG" "$MY_TMP"
chown $VERB pup_event:pup_event "$MY_HOME"
chown $VERB pup_event:pup_event "$MY_CFG" "$MY_LOG" "$MY_TMP"
chmod $VERB 1774 "$MY_CFG" "$MY_LOG"
chmod $VERB 1770 "$MY_TMP"
[ "$DEBUG" ] && ls -ld "$MY_HOME"
[ "$DEBUG" ] && ls -l  "$MY_HOME"
cd "$MY_HOME" || _exit 2 "Unable to change into '$MY_HOME' ."

STATE_DIR=${STATE_DIR:-"$HOME/Choices/Puppy"}
EXE_DIR=${EXE_DIR:-'pup_event'}
PUP_EVENT_DIR=${PUP_EVENT_DIR:="$STATE_DIR/$EXE_DIR"}
CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"

CONFFILE=${CONFFILE:-/etc/eventmanager.cfg}  #configuration file of this prog

#===== unused functions =====:

_create_mut2_button(){
# mut and mut2 are busybox like multicallbinaries.
# they do not support ext4 file-system.

#/usr/sbin/mut: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.16, dynamically linked (uses shared libs), stripped
#bash-3.00# file /usr/sbin/mutclient
#/usr/sbin/mutclient: symbolic link to `mut'
#bash-3.00# file /usr/sbin/mutd
#/usr/sbin/mutd: symbolic link to `mut'
#bash-3.00# file /usr/sbin/mutdaemon
#/usr/sbin/mutdaemon: symbolic link to `mut'
#bash-3.00# file /usr/sbin/mutforeground
#/usr/sbin/mutforeground: symbolic link to `mut'

#multi-call binary options are: (sym link or cmd line option)
#  mut  mutd  mutdaemon  mutforeground  mutclient  probepart  probedisk  probedisk2  probepci  drivelist  guess_fstype  mounts  mediaplug
#Meta Options are:
#  --exit        : stops the mut 2 daemon
#  --debug       : all log messages written, no threads
#  --noserv      : scan hardware directly
#  --version     : output version/build numbers
#  --foreground  : run server in the foreground terminal
#mut Options are:
#  --timing  -t      : print out time to execute application
# sda:  250GB   disk    sata   11 partitions
# sr0:          cdrom   scsi   DVD-ROM DH-16D3S
# sr1:          cdrom   scsi   DVD-RAM GH10L

#bash-3.00# pidof mut
#29921

#mut --version
#mut 2 multi-call binary version: mut2_1.3.2.1238

which mut >>$OUT || return 1
mut --version | grep $Q 'mut 2 multi-call binary version:' || return 1
HAVEMUT2=yes
if [ "$HAVEMUT2" = "yes" ];then # <button file icon="top"> | icon-name=\"gtk-execute\"
 PREFSBUTTON="
   <button><label>Use mut2 engine</label>
    <action type=\"exit\">SETPREFS</action>
   </button>"
fi
}

# Formerly it was clean_desk_icons script that if marker file found
# erased the drive icons on desktop. This script was started from
# .xinitrc before pup_event_frontend_d. This required restart of X .
# Usually it was used by me when accidentally deleting by low-battery
# mouse double right-click on a drive icon.
# Now pup_event_frontend_d rewrites the drive icons. X does not need to be restarted.
_create_iconwipe_checkbox2(){
#iconwipe
ICONWIPE_CHOICE2_DISABLED="  <checkbox tooltip-text=\"NEWICONWIPE2\">
   <label>Tick box to erase then redraw and realign existing icons</label>
   <default>true</default>
   <variable>NEWICONWIPE2</variable>
   <action>if false clear:NEWICONWIPE1</action>
  </checkbox>
"
}
_create_iconwipe_checkbox1(){
ICONWIPE_CHOICE1_DISABLED="  <checkbox tooltip-text=\"NEWICONWIPE1\">
   <label>Tick box to erase then redraw and realign existing icons</label>
    <default>true</default>
   <variable>NEWICONWIPE1</variable>
   <action>if false clear:NEWICONWIPE2</action>
  </checkbox>
"
}

#=== icon spacing ===:
# Many possibilities to enter.
# problems arise with changes of ROX-Filer pin_grid_step values
# ICON_PLACE_START_X_GAP used to set start distance to x edge of screen
_create_hbox_x_gap(){
if [ -n "$ICON_PLACE_START_X_GAP" ] ; then
IP_E_GAP_X="
<hbox>
<text><label>Choose the Spacing 'x' to edge of screen:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_START_X_GAP\">
<default>${ICON_PLACE_START_X_GAP}</default>
<variable>NEWIPSGAPX</variable>
</entry>
</hbox>
</hbox>
"
fi
}

# ICON_PLACE_START_Y_GAP set the distance to bottom of screen
_create_hbox_y_gap(){
if [ -n "$ICON_PLACE_START_Y_GAP" ] ; then
IP_E_GAP_Y="
<hbox>
<text><label>Choose the Spacing 'y' to edge of screen:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_START_Y_GAP\">
<default>${ICON_PLACE_START_Y_GAP}</default>
<variable>NEWIPSGAPY</variable>
</entry>
</hbox>
</hbox>
"
fi
}

# ICON_PLACE_SPACING the distance between the icons. Since the distance in y needs
# to be larger than the distance in x because of the size of the label underneath the icon
# and Rox computes them apparently from a center x/y value of the icons and not some top/left 0/0
# value, difficult to work with.
_create_hbox_entry_icon_place_spacing_old(){
IP_SPA_OLD="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> of the drive-icons [10-300]:\"</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING\">
<default>${ICON_PLACE_SPACING}</default>
<variable>NEWIPSPAC</variable>
</entry>
</hbox>
</hbox>
"
}
# since the manually entered ICON_PLACE_SPACING could lead to errors,
# give some values to choose
_create_hbox_combobox_icon_place_spacing(){
IP_SPA_COMBO="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> between drive icons [64-160]:\"</label></text>
<hbox>
<combobox tooltip-text=\"ICON_PLACE_SPACING\">
$ITEM_SPACING
<variable>NEWIPSPAC</variable>
</combobox>
</hbox>
</hbox>
"
}
# the distance between icons in x
_create_hbox_entry_spacing_x(){
if [ -n "$ICON_PLACE_SPACING_X" ] ; then
IP_SPA_X="
<hbox>
<text><label>Choose the Spacing X of drive-icons:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING_X\">
<default>${ICON_PLACE_SPACING_X}</default>
<variable>NEWIPSPACX</variable>
</entry>
</hbox>
</hbox>
"
fi
}
# the distance between icons in y
_create_hbox_entry_spacing_y(){
if [ -n "$ICON_PLACE_SPACING_Y" ] ; then
IP_SPA_Y="
<hbox>
<text><label>Choose the Spacing Y of drive-icons:</label></text>
<hbox>
<entry tooltip-text=\"ICON_PLACE_SPACING_Y\">
<default>${ICON_PLACE_SPACING_Y}</default>
<variable>NEWIPSPACY</variable>
</entry>
</hbox>
</hbox>
"
fi
}

#=== icon spacing ===.
#===== unused functions =====.

#===== alternatives =====:

_create_frame_polling_combobox(){
[ "$USE_ALTERNATIVE" ] || return 0
_set_polling_gui_variables

COMBO_ATTR_ORIG='fixed_size="1" fixed-size="1" column-span-column="2" appears-as-list="true" editing-canceled="true" wrap-width="1" value-in-list="true" insert-text="false" editable="false" max-length="1" max-width-chars="1" width-chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE"'

COMBO_ATTR='insert-text="false" editable="false" max-length="1" max-width-chars="1" width-chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE"'

POLL_PLUG_DEVICE_GUI_COMBO='
<frame Polling interval>
<hbox>
<vbox>
<text width-chars="78" selectable="true">
<label>Select the seconds that should poll for so called hotplug events. Polling for events is a bit code to be executed. The higher the value, the more seconds between polling is paused. Reasonable values are between 2 and 4 seconds. But you may want even faster plugable drives show on desktop or even wait a bit longer.</label>
</text>
</vbox>
<vbox>
<text><label>"  "</label></text>
</vbox>
<vbox>
<hbox>
 <combobox '"$COMBO_ATTR"'>
 <!-- <label>Some Label</label> -->
 <width>6</width>
  '"$POLL_ITEM_LIST"'
  <variable>NEWPOLL_PLUG_DEVICE</variable>
 </combobox>
</hbox>
<text width-chars="1">
<label>"  "</label>
</text>
</vbox>
</hbox>
</frame>
'
POLL_PLUG_DEVICE_ELEMENT=$POLL_PLUG_DEVICE_GUI_COMBO
_debug "Finished _create_frame_polling_combobox ."
}

#===== alternatives =====.

__adjust_config(){
CONFIG=`echo "$CONFIG" | sed -e "$@"`
S=$((S+$?))
}

_adjust_config(){
VAR="$1"; shift
VAL="$*"
sP="s/^${VAR}=.*/${VAR}='${VAL}'/"
if grep $Q "^${VAR}=" "$CONFFILE"; then
 CONFIG=`echo "$CONFIG" | sed -e "$sP"`
else
CONFIG="$CONFIG

#Automatically added by eventmanager:'
${VAR}='${VAL}'"
fi
S=$((S+$?))
}

# +++++ gui functions:

# FIRST NOTEBOOK TAB:
_set_frontend_d_variables_disabled(){
[ "USE_DISABLED" ] || return 0

              _set_bool BACKENDON "$BACKENDON" true
[ $? = 0 ] || _set_bool BACKENDON "$BACKENDON" false
[ $? = 0 ] || { _notice "defaulting to true";BACKENDON=true; }

              _set_bool HOTPLUGON "$HOTPLUGON" true
[ $? = 0 ] || _set_bool HOTPLUGON "$HOTPLUGON" false
[ $? = 0 ] || { _notice "defaulting to true";HOTPLUGON=true; }

              _set_bool ZCDPOLL "$ZCDPOLL" true
[ $? = 0 ] || _set_bool ZCDPOLL "$ZCDPOLL" false
[ $? = 0 ] || { _notice "defaulting to true";ZCDPOLL=true; }

              _set_bool AUTOUNMOUNT "$AUTOUNMOUNT" true
[ $? = 0 ] || _set_bool AUTOUNMOUNT "$AUTOUNMOUNT" false
[ $? = 0 ] || { _notice "defaulting to true";AUTOUNMOUNT=true; }

              _set_bool HOTPLUGNOISY "$HOTPLUGNOISY" true
[ $? = 0 ] || _set_bool HOTPLUGNOISY "$HOTPLUGNOISY" false
[ $? = 0 ] || { _notice "defaulting to true";HOTPLUGNOISY=true; }

              _set_bool AUTOTARGET "$AUTOTARGET" true
[ $? = 0 ] || _set_bool AUTOTARGET "$AUTOTARGET" false
[ $? = 0 ] || { _notice "defaulting to true";AUTOTARGET=true; }

   NEWHOTPLUGNOISY="$HOTPLUGNOISY"
      NEWHOTPLUGON="$HOTPLUGON"
        NEWZCDPOLL="$ZCDPOLL"
     NEWAUTOTARGET="$AUTOTARGET"
    NEWAUTOUNMOUNT="$AUTOUNMOUNT"
      NEWBACKENDON="$BACKENDON"
}

_set_frontend_d_variables_main(){
              _set_bool DESKDAEMON "$DESKDAEMON" true
[ $? = 0 ] || _set_bool DESKDAEMON "$DESKDAEMON" false
[ $? = 0 ] || { _notice "defaulting to true";DESKDAEMON=true; }
 NEWDESKDAEMON="$DESKDAEMON"
}

_set_frontend_d_variables_poll(){
test "${POLL_PLUG_DEVICE//[0-9]/}" && unset POLL_PLUG_DEVICE
 POLL_PLUG_DEVICE=${POLL_PLUG_DEVICE:-2}
 [ "$POLL_PLUG_DEVICE" -gt 1 ] || POLL_PLUG_DEVICE=1
 [ "$POLL_PLUG_DEVICE" -lt 9 ] || POLL_PLUG_DEVICE=9
}

_create_polling_entry(){

_set_polling_gui_variables(){
_set_frontend_d_variables_poll
#combobox and list have no <default> tag or attribute (?)
POLL_ITEM_LIST="<item>$POLL_PLUG_DEVICE</item>"
for i in 1 2 3 4 5 6 7 8 9
do
 test $i = $POLL_PLUG_DEVICE && continue
POLL_ITEM_LIST="$POLL_ITEM_LIST
 <item>$i</item>"
done

test "$DESKDAEMON" = true && POLL_SEN=true || POLL_SEN=false
}

_create_frame_polling_list(){
[ "$USE_ALTERNATIVE" ] && return 0
_set_polling_gui_variables

POLL_PLUG_DEVICE_GUI_LIST='
<frame Polling interval>
<hbox>
<vbox>
<text width-chars="78" selectable="true">
<label>Select the seconds that should poll for so called hotplug events. Polling for events is a bit code to be executed. The higher the value, the more seconds between polling is paused. Reasonable values are between 2 and 4 seconds. But you may want even faster plugable drives show on desktop or even wait a bit longer.</label>
</text>
</vbox>
<vbox>
<text><label>"  "</label></text>
</vbox>
<vbox>
<hbox>
 <list selection-mode="1" fixed-size="1" column-span-column="2" appears-as-list="true" editing-canceled="true" wrap-width="1" value-in-list="true" insert-text="false" editable="false" max-length="1" max-width-chars="1" width-chars="1" sensitive="'$POLL_SEN'" tooltip-text="POLL_PLUG_DEVICE">
 <!-- <label>Some Label</label> -->
 <width>40</width>
 <height>70</height>
  '"$POLL_ITEM_LIST"'
  <variable>NEWPOLL_PLUG_DEVICE</variable>
 </list>
</hbox>
</vbox>
</hbox>
</frame>
'
POLL_PLUG_DEVICE_ELEMENT=$POLL_PLUG_DEVICE_GUI_LIST
}

_create_polling_element(){
if [ "$USE_ALTERNATIVE" ]; then
 _create_frame_polling_combobox
else
 _create_frame_polling_list
fi
}
_create_polling_element

}

_create_gui_disabled(){
[ "$USE_DISABLED" ] || return 0
_set_frontend_d_variables_disabled

#udevd
UDEV_CHOICE_DISABLED="  <checkbox tooltip-text=\"BACKENDON\">
   <label>Tick box for hotplug module/firmware loading [ BACKENDON on/off udevd ]</label>
   <default>${BACKENDON}</default>
   <variable>NEWBACKENDON</variable>
  </checkbox>
"

#hbox/vbox
#homogeneous :
#   %TRUE if all children are to be given equal space allotments.
#spacing :
#   the number of pixels to place by default between children.

#>> Align widget. xalign/yalign may hold 0 (left), 1 (right) and 2 (center).
#xalign/yalign works for most widgets.
#For button/progressbar they describe placement of label rather than widget itself.
#<text xalign="0">...</text>
#(gtkdialog3:28810): GLib-GObject-WARNING **: value "2.000000" of type `gfloat' is invalid or out of range for property `xalign' of type #`gfloat'
#GTKalignment
#The "xalign" property
#"xalign"                   gfloat                : Read / Write
#Horizontal position of child in available space. 0.0 is left aligned, 1.0 is right aligned.
#Allowed values: [0,1]
#Default value: 0.5

# pup_event_frontend_d
AUTO_UNMOUNT_CHOICE_DISABLED="  <checkbox tooltip-text=\"AUTOUNMOUNT\" draw-as-radio=\"true\">
   <label>Tick box for auto unmounting of partitions [ AUTOUNMOUNT ]</label>
   <default>${AUTOUNMOUNT}</default>
   <variable>NEWAUTOUNMOUNT</variable>
  </checkbox>
  <text><label>(WARNING: auto unmounting is highly experimental)</label></text>
"
# pup_event_frontend_d
ZCDPOLL_DISABLED="  <checkbox tooltip-text=\"ZCDPOLL\" draw-as-radio=\"true\">
   <label>Tick box for polling Zip or CD devices every $POLL_PLUG_DEVICE seconds [ ZCDPOLL ]</label>
   <default>${ZCDPOLL}</default>
   <variable>NEWZCDPOLL</variable>
   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>
  </checkbox>
"

# drive_all:
AUTOTARGET_CHOICE_DISABLED="  <frame>
  <text selectable=\"true\"><label>This checkbox extends the default behavior, and will launch a more appropriate application. Currently, it adds detection of a video DVD or audio CD and launches the media player:</label></text>
  <checkbox tootip-text=\"AUTOTARGET\">
   <label>Tick box for auto-detection of target application [ AUTOTARRGET ]</label>
   <default>${AUTOTARGET}</default>
   <variable>NEWAUTOTARGET</variable>
  </checkbox>
  </frame>
"
# pup_event-frontend_d
HOTPLUGNOISY_CHOICE_DISABLED=" <vbox>
  <frame>
  <text selectable=\"true\"><label>Normally you have to click on a partition icon to run the handler 'AppRun' in $PUP_EVENT_DIR, but this checkbox makes the 'handler' run as soon as a media is plugged in if polling every $POLL_PLUG_DEVICE seconds is enabled . For example, plug in a DVD and it will immediately either get automatically mounted, or [if the above checkbox is ticked] the media player will run. This is usefull if using a desktopmanager like enlightenment or when having disabled drive icons on desktop:</label></text>
  <checkbox tooltip-text=\"HOTPLUGNOISY\">
   <label>Tick box for auto-launch 'handler' when media plugged in [ HOTPLUGNOISY ]</label>
   <default>${HOTPLUGNOISY}</default>
   <variable>NEWHOTPLUGNOISY</variable>
  </checkbox>
  </frame>
 </vbox>
"
HANDLER_TAB_DISABLED="<frame Drive 'handler'>
 <vbox>
  <text use-markup=\"true\" selectable=\"true\"><label>\"The <b>'handler'</b> decides what to do when you click on a desktop drive icon. <b>Normally</b>, this just starts <u>Pmount</u> if you click on a drive icon, <b>or</b> mounts it and starts <u>ROX-Filer</u> if a partition icon, but this behavior can be extended by these checkboxes.\"</label></text>
  $AUTOTARGET_CHOICE_DISABLED
 </vbox>
  $HOTPLUGNOISY_CHOICE_DISABLED
</frame>
"

}

_create_disabled_entry(){

_create_gui_disabled
CHOSE_BELOW_ELEMENT=""
test "$USE_DISABLED" || return 0

# REM: locale may need 0,x instead 0.x
# maybe either busybox needs to be configured to support locale
# or locale installation is buggy in lucid-218
# at least prints 0.2, while in Fox3 it prints 0,2 for de_DE
XA01=`dc 2 10 \/ p`
[ "$XA01" ] || XA01=0.2 # locale=C fallback
CHOSE_BELOW_ELEMENT="
  <vbox>
  <text><label>\"  \"</label></text>
  <!-- <hbox> -->
  <text xalign=\"$XA01\" wrap=\"false\" selectable=\"true\"><label>So, if the above is ticked, then you can choose below :</label></text>

   $ZCDPOLL_DISABLED
   $AUTO_UNMOUNT_CHOICE_DISABLED
   $UDEV_CHOICE_DISABLED

  <!-- </hbox> -->
  </vbox>
"
}

_create_frame_frontend_d(){

_set_frontend_d_variables_main
_create_polling_entry
_create_disabled_entry
NTAB_FRONTEND_D=`gettext "Activate frontend daemon"`

FRAME_FRONTEND_D="
  <frame Activate Puppy Event Manager>
  <vbox scrollable=\"true\">
  <text><label>\"  \"</label></text>

   <checkbox tooltip-text=\"DESKDAEMON\" indicator-size=\"20\">
   <label>Tick box for desktop hotplug support [ DESKDAEMON on/off daemon ]</label>

   <default>${DESKDAEMON}</default>
   <variable>NEWDESKDAEMON</variable>
   <action>if true enable:NEWZCDPOLL</action>
   <action>if false clear:NEWZCDPOLL</action>
   <action>if false disable:NEWZCDPOLL</action>

   <action>if true enable:NEWHOTPLUGNOISY</action>
   <action>if false clear:NEWHOTPLUGNOISY</action>
   <action>if false disable:NEWHOTPLUGNOISY</action>

   <action>if true enable:NEWAUTOUNMOUNT</action>
   <action>if false clear:NEWAUTOUNMOUNT</action>
   <action>if false disable:NEWAUTOUNMOUNT</action>

   <action>if true enable:NEWRAMSAVEINTERVAL</action>
   <action>if false clear:NEWRAMSAVEINTERVAL</action>
   <action>if false disable:NEWRAMSAVEINTERVAL</action>

   <action>if true enable:NEWPOWERTIMEOUT</action>
   <action>if false clear:NEWPOWERTIMEOUT</action>
   <action>if false disable:NEWPOWERTIMEOUT</action>

   <action>if true enable:NEWPOLL_PLUG_DEVICE</action>
   <action>if false disable:NEWPOLL_PLUG_DEVICE</action>

   </checkbox>

  <text width-chars=\"90\" use-markup=\"true\" selectable=\"true\"><label>\"The 'pup_event' Puppy Event Manager is running in the background and handles hotplugging of drives like inserting a CD or removing an USB, updating the status of the desktop drive icons. However, turn it off, and Puppy will revert to the same behaviour as versions prior to 4.x, in which there is no hotplug support. This reduces resource usage, so try unticking these on very old slow PCs. The <b>pmount</b> application can still be run from Menu > Filesystem to mount and unmount partitions.\"</label></text>

  <!-- <text><label>\"  \"</label></text> -->
  <hbox>
   <text use-markup=\"true\" wrap=\"true\" width-chars=\"80\" single-line-mode=\"false\" selectable=\"true\">
   <label>\"<b>NOTE :</b> Puppy-4.y when you turn this off, the freememapplet in the tray would not get updated, maybe not show at all .\"</label>
   </text>
  </hbox>

  $POLL_PLUG_DEVICE_ELEMENT
  $CHOSE_BELOW_ELEMENT
  </vbox>
  </frame>
"
}

# FIRST NOTEBOOK TAB.

# SECOND, THIRD, FOURTH TAB:
_set_icon_variables_main(){

              _set_bool ICONDESK "$ICONDESK" true
[ $? = 0 ] || _set_bool ICONDESK "$ICONDESK" false
[ $? = 0 ] || { _notice "defaulting to true";ICONDESK=true; }

              _set_bool ICONPARTITIONS "$ICONPARTITIONS" true
[ $? = 0 ] || _set_bool ICONPARTITIONS "$ICONPARTITIONS" false
[ $? = 0 ] || { _notice "defaulting to true";ICONPARTITIONS=true; }

              _set_bool FD0ICON "$FD0ICON" true
[ $? = 0 ] || _set_bool FD0ICON "$FD0ICON" false
[ $? = 0 ] || { _notice "defaulting to true";FD0ICON=true; }

#w007 as have a optional cutdown gui, make sure these are all preset...
        NEWFD0ICON="$FD0ICON"
       NEWICONDESK="$ICONDESK"
 NEWICONPARTITIONS="$ICONPARTITIONS"
}

_set_icon_variables_placement(){

ICON_PLACE_START_X_GAP=${ICON_PLACE_START_X_GAP:-32}  #x-alignment
ICON_PLACE_START_Y_GAP=${ICON_PLACE_START_Y_GAP:-64}  #y-alignment
ICON_PLACE_ORIENTATION=${ICON_PLACE_ORIENTATION:-'bottom'}

PIN_GRID_STEP=`sed -n '/<!--/,/-->/!p' "$CONFFILEROX" | grep -m1 "pinboard_grid_step" | sed -e "s/ *<[^>]*>//g"`
test "${PIN_GRID_STEP//[0-9]/}" && unset PIN_GRID_STEP
PIN_GRID_STEP=${PIN_GRID_STEP:-32} #2=fine 16=medium 32=coarse.
[ "$PIN_GRID_STEP" -le 0 ] && PIN_GRID_STEP=32 #precaution.

test "${ICON_PLACE_SPACING//[0-9]/}" && unset ICON_PLACE_SPACING
ICON_PLACE_SPACING=${ICON_PLACE_SPACING:-64}
[ "$ICON_PLACE_SPACING" -ge 64 ]  || ICON_PLACE_SPACING=64
[ "$ICON_PLACE_SPACING" -le 160 ] || ICON_PLACE_SPACING=160
ICON_PLACE_SPACING=$(( ((ICON_PLACE_SPACING +1) / PIN_GRID_STEP) * PIN_GRID_STEP)) # always round to acceptable values
                                                            # ICON_PLACE_SPACING must be -ge PIN_GRID_STEP
ICONPOSITIONB=false #bottom
ICONPOSITIONR=false #right
ICONPOSITIONT=false #top
ICONPOSITIONL=false #left
case $ICON_PLACE_ORIENTATION in
bottom)  ICONPOSITIONB="true" ;;
right)  ICONPOSITIONR="true" ;;
top)   ICONPOSITIONT="true" ;;
left) ICONPOSITIONL="true" ;;
*)   ICONPOSITIONB="true" ; _notice "defaulting to bottom";;
esac
}

_create_icon_placement_tab(){

_set_icon_variables_placement

ICON_POSITION_ELEMENT="
  <hbox>
  <text xalign=\"0.0\"><label>Choose Position of the Drive Icon(s) : Tick box for</label></text>
  <radiobutton>
  <label>\"bottom  \"</label>
  <default>${ICONPOSITIONB}</default>
  <variable>ICONPSITIONB</variable>
  </radiobutton>
  <radiobutton>
  <label>\"right  \"</label>
  <default>${ICONPOSITIONR}</default>
  <variable>ICONPSITIONR</variable>
  </radiobutton>
  <radiobutton>
  <label>\"top  \"</label>
  <default>${ICONPOSITIONT}</default>
  <variable>ICONPSITIONT</variable>
  </radiobutton>
  <radiobutton>
  <label>\"left  \"</label>
  <default>${ICONPOSITIONL}</default>
  <variable>ICONPSITIONL</variable>
  </radiobutton>
  </hbox>
"

ICON_PLACE_SPACING=${ICON_PLACE_SPACING:-64}
ITEM_SPACING="<item>$ICON_PLACE_SPACING</item>"
for i in `seq 64 $PIN_GRID_STEP 160`; do
test "$i" = $ICON_PLACE_SPACING && continue
ITEM_SPACING="$ITEM_SPACING
<item>$i</item>"
done

_create_hbox_list_icon_place_spacing(){
IP_SPA_LIST="
<hbox>
<text use-markup=\"true\"><label>\"Choose the <b>Spacing</b> between drive icons [64-160]:\"</label></text>
<hbox>
<list selection-mode=\"1\" list_height=\"3\" editable=\"false\" tooltip-text=\"ICON_PLACE_SPACING\">
<width>50</width>
<height>70</height>
$ITEM_SPACING
<variable>NEWIPSPAC</variable>
</list>
</hbox>
</hbox>
"
ICON_SPACING_ELEMENT=$IP_SPA_LIST
}
_create_hbox_list_icon_place_spacing

PLACEMENT="
<vbox scrollable=\"true\">
  $ICON_POSITION_ELEMENT
  $ICON_SPACING_ELEMENT

  <hbox><text><label>\"  \"</label></text></hbox>
  <text use-markup=\"true\" width-chars=\"70\" selectable=\"true\"><label>\"<b>NOTE :</b> the values above have to be a <b>power</b> of the <u>current <i>'pinboard_grid_step'</i> value of <b>$PIN_GRID_STEP</b></u> . Otherwise the drive icons would not render properly because the ROX-Filer would not place the icons as expected, but to the nearest value relative to the <i>'pinboard_grid_step'</i> . <b>If the values arent a power, then usually the icons would pile up on one place of the pinboard</b> . To change the PIN_GRID_STEP value : Go to ROX-Filer Options > Pinboard > Behavior\"</label></text>
</vbox>
"

_debugx "$PLACEMENT"
}

_create_drive_icons_frames(){

_set_icon_variables_main
_create_icon_placement_tab
#NTAB_ICONPLACEMENT=$"Icon placement"
NTAB_ICONPLACEMENT=`gettext "Icon placement"`

# REM: Disable checkbox if no floppy disk
#      for the Legacy tab.
FD0ICON_SEN=true
probedisk2 | grep $Q '^/dev/fd0|' || {
FD0ICON_SEN=false
FD0ICON=false
NEWFD0ICON=$FD0ICON
FD0ICON_MSG_EXTRA=`gettext "Note: Could not find any trace of a legacy floppy drive in /sys/block"`
FD0ICON_MSG_EXTRA_DLG='<hbox><text><label>"  "</label></text></hbox>
<text use-markup="true" wrap="false" selectable="true"><label>"<b>'"$FD0ICON_MSG_EXTRA"'</b>"</label></text>
'
}
NTAB_FLOPPY=`gettext "Legacy Floppy"`
NTAB_DESK_ICONS=`gettext "Desktop icons"`

DRIVE_ICONS_FRAMES="
 <frame Drive icons on desktop>
 <vbox scrollable=\"true\">
  <text width-chars=\"90\" use-markup=\"true\" selectable=\"true\"><label>\"When this box is ticked, there will be an icon for each drive. If you plugin a USB pen drive for example, an icon will appear. Unplug and it will disappear. If you do not want these drive icons on the desktop, untick this box (but there will still remain <b>just one icon</b> that will launch Pmount when clicked on). The individual drive icons are purely a convenience and Puppy works fine without them.\"</label></text>
  <text><label>\"  \"</label></text>
  <frame>
  <checkbox tooltip-text=\"ICONDESK\">
   <label>Tick box for drive icons on desktop</label>
   <default>${ICONDESK}</default>
   <variable>NEWICONDESK</variable>
   <action>if true enable:NEWICONPARTITIONS</action>
   <action>if false clear:NEWICONPARTITIONS</action>
   <action>if false disable:NEWICONPARTITIONS</action>
   <action>if true enable:NEWFD0ICON</action>
   <action>if false clear:NEWFD0ICON</action>
   <action>if false disable:NEWFD0ICON</action>
  </checkbox>

  <vbox>
  <text wrap=\"true\" width-chars=\"70\" selectable=\"true\"><label>If the above is ticked, then you can choose to have an icon for each partition, rather than one icon for the entire drive:</label></text>
  <checkbox tooltip-text=\"ICONPARTITIONS\">
   <label>Tick box for an icon for each partition</label>
   <default>${ICONPARTITIONS}</default>
   <variable>NEWICONPARTITIONS</variable>
  </checkbox>
  </vbox>
  </frame>
  </vbox>
 </frame>

 <frame Icon Placement on Desktop>
 <hbox><text><label>\"  \"</label></text></hbox>
  $PLACEMENT
 </frame>

 <frame Legacy>
  <text><label>\"  \"</label></text>
  <text width-chars=\"90\" use-markup=\"true\" selectable=\"true\"><label>\"<b>The Linux Kernel does not support hotplug detection of when a legacy floppy diskette is inserted or removed.</b> Periodic probing requires starting the drive motor, which is very slow -- and do you want the motor to startup every $POLL_PLUG_DEVICE seconds? Therefore, if your PC has a floppy drive, tick this box to have a permanent icon on desktop (regardless whether a diskette is actually inserted, or even a floppy drive!).\"</label></text>
  <text><label>\"  \"</label></text>
  <checkbox tooltip-text=\"FD0ICON\" sensitive=\"$FD0ICON_SEN\">
   <label>Tick box for floppy drive icon on desktop</label>
   <default>${FD0ICON}</default>
   <variable>NEWFD0ICON</variable>
  </checkbox>

  $FD0ICON_MSG_EXTRA_DLG  <!-- if no floppy found -->

 </frame>

"
}

# SECOND, THIRD, FOURTH TAB.

# FIFTH TAB:
_set_ramsave_variables(){
 test "${RAMSAVEINTERVAL//[0-9]/}" && unset RAMSAVEINTERVAL
 RAMSAVEINTERVAL=${RAMSAVEINTERVAL:-30}
 [ "$RAMSAVEINTERVAL" -ge 0 ] || RAMSAVEINTERVAL=0
NEWRAMSAVEINTERVAL=$RAMSAVEINTERVAL
}

_create_frame_ramsave(){

_set_ramsave_variables
NTAB_RAMSAVE=`gettext "Save session"`

FRAME_RAMSAVE=" <frame Periodic save from RAM>
 <vbox scrollable=\"true\">
  <text><label>\"  \"</label></text>
  <text width-chars=\"90\" use-markup=\"true\" selectable=\"true\"><label>\"Puppy runs in a particular 'state' that we call the <b>PUPMODE</b>. This depends on the type of installation and the type of hardware. <b>Currently it is PUPMODE=${PUPMODE}</b>. If it is an <b>odd</b> number 3,7, 13, then Puppy is doing everything in RAM and saving the current session to a partition or file periodically -- this is done in the case of Flash memory to make it last longer. When Puppy runs in one of these PUPMODES, there will be a <b>save</b> icon on the desktop, <b>also a save occurs at shutdown</b>. You can also specify a periodic save time interval here:\"</label></text>
  <text><label>\"  \"</label></text>
  <frame Enter>
  <hbox homogenous=\"false\">
   <text><label>\"                          Save interval in minutes (0=never):\"</label></text>
   <entry max-length=\"4\" width-chars=\"4\" width=\"4\" max-width-chars=\"4\" tooltip-text=\"RAMSAVEINTERVAL\" sensitive=\"$ENTRY_RAMSAVEINTERAL_SEN\">
    <width>40</width>
    <default>${RAMSAVEINTERVAL}</default>
    <variable>NEWRAMSAVEINTERVAL</variable>
   </entry>
   <text><label>\"minutes                                             \"</label></text>
   <!-- <text><label>\"       \"</label></text> -->
  </hbox>
  </frame>
  <text><label>\"  \"</label></text>
  <text use-markup=\"true\" selectable=\"true\"><label>\"<b>NOTE1:</b> PUPMODE=77 (multisession DVD) excluded, only manual save with desktop icon and at shutdown.\"</label></text>
  <text use-markup=\"true\" selectable=\"true\"><label>\"<b>NOTE2:</b> PUPMODE=5 there are no saves, above value ignored.\"</label></text>
 </vbox>
 </frame>
"

}
# FITH TAB.

# SIXTH TAB:
_set_shutdown_variables_main(){

 test "${POWERTIMEOUT//[0-9]/}" && unset POWERTIMEOUT
 POWERTIMEOUT=${POWERTIMEOUT:-0} #w007 0=never.
 [ "$POWERTIMEOUT" -ge 0 ] || POWERTIMEOUT=0
  NEWPOWERTIMEOUT=$POWERTIMEOUT
}

_set_shutdown_variables_programs(){
              _set_bool FORCE_POWERTIMEOUT_ALWAYS "$FORCE_POWERTIMEOUT_ALWAYS" true
[ $? = 0 ] || _set_bool FORCE_POWERTIMEOUT_ALWAYS "$FORCE_POWERTIMEOUT_ALWAYS" false
[ $? = 0 ] || { _notice "defaulting to true";FORCE_POWERTIMEOUT_ALWAYS=true; }

              _set_bool DISTURB_DL "$DISTURB_DL" true
[ $? = 0 ] || _set_bool DISTURB_DL "$DISTURB_DL" false
[ $? = 0 ] || { _notice "defaulting to false";DISTURB_DL=false; }

              _set_bool DISTURB_DEV "$DISTURB_DEV" true
[ $? = 0 ] || _set_bool DISTURB_DEV "$DISTURB_DEV" false
[ $? = 0 ] || { _notice "defaulting to false";DISTURB_DEV=false; }

              _set_bool DISTURB_VIDEO "$DISTURB_VIDEO" true
[ $? = 0 ] || _set_bool DISTURB_VIDEO "$DISTURB_VIDEO" false
[ $? = 0 ] || { _notice "defaulting to true";DISTURB_VIDEO=true; }

NEWFORCE_POWERTIMEOUT_ALWAYS=$FORCE_POWERTIMEOUT_ALWAYS
               NEWDISTURB_DL=$DISTURB_DL
            NEWDISTURB_VIDEO=$DISTURB_VIDEO
              NEWDISTURB_DEV=$DISTURB_DEV
}

_create_shutdown_programs_entries(){
_set_shutdown_variables_programs
# sensevity of checkboxes and entries:
CB_DL_PT_SEN=true
CB_MM_PT_SEN=true
CB_DEV_PT_SEN=true

if test "$FORCE_POWERTIMEOUT_ALWAYS" = true; then
 CB_DL_PT_SEN=false
 CB_MM_PT_SEN=false
CB_DEV_PT_SEN=false
fi

 EN_DL_PT_SEN=$CB_DL_PT_SEN
   DISTURB_DL=$CB_DL_PT_SEN
 EN_MM_PT_SEN=$CB_MM_PT_SEN
DISTURB_VIDEO=$CB_MM_PT_SEN
EN_DEV_PT_SEN=$CB_DEV_PT_SEN
  DISTURB_DEV=$CB_DEV_PT_SEN

FORCE_POWERTIMEOUT_HBOX="<hbox>
  <checkbox tooltip-text=\"FORCE_POWERTIMEOUT_ALWAYS\">
  <label>Want to poweroff always regardless of important programs running</label>
   <default>${FORCE_POWERTIMEOUT_ALWAYS}</default>
   <variable>NEWFORCE_POWERTIMEOUT_ALWAYS</variable>

   <action>if true clear:NEWDISTURB_DL</action>
   <action>if true clear:NEWDISTURB_VIDEO</action>
   <action>if true clear:NEWDISTURB_DEV</action>

   <action>if true disable:NEWDISTURB_DL</action>
   <action>if false enable:NEWDISTURB_DL</action>

   <action>if true disable:NEWDISTURB_VIDEO</action>
   <action>if false enable:NEWDISTURB_VIDEO</action>

   <action>if true disable:NEWDISTURB_DEV</action>
   <action>if false enable:NEWDISTURB_DEV</action>

  </checkbox>
  </hbox>
"

DO_NOT_DISTURB_DL=${DO_NOT_DISTURB_DL:-wget}
DO_NOT_DISTURB_DL=${DO_NOT_DISTURB_DL//[,;:|&\/]/}
DL_POWERTIMEOUT_HBOX="<hbox>
  <checkbox sensitive=\"$CB_DL_PT_SEN\" tooltip-text=\"DISTURB_DL\">
   <label>Do not poweroff if one of the following dl programs are running</label>
    <default>${DISTURB_DL}</default>
    <variable>NEWDISTURB_DL</variable>
     <action>if true enable:NEWDO_NOT_DISTURB_DL</action>
     <action>if false disable:NEWDO_NOT_DISTURB_DL</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_DL_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_DL\">
   <default>$DO_NOT_DISTURB_DL</default>
   <variable>NEWDO_NOT_DISTURB_DL</variable>
  </entry>
  </hbox>
"

DO_NOT_DISTURB_VIDEO=${DO_NOT_DISTURB_VIDEO:-'gnome-mplayer'}
DO_NOT_DISTURB_VIDEO=${DO_NOT_DISTURB_VIDEO//[,;:|&\/]/}
MM_POWERTIMEOUT_HBOX="<hbox>
<checkbox sensitive=\"$CB_MM_PT_SEN\" tooltip-text=\"DISTURB_VIDEO\">
  <label>Do not poweroff if one of the following multi media programs are running</label>
   <default>${DISTURB_VIDEO}</default>
   <variable>NEWDISTURB_VIDEO</variable>
   <action>if true enable:NEWDO_NOT_DISTURB_VIDEO</action>
   <action>if false disable:NEWDO_NOT_DISTURB_VIDEO</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_MM_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_VIDEO\">
   <default>$DO_NOT_DISTURB_VIDEO</default>
   <variable>NEWDO_NOT_DISTURB_VIDEO</variable>
  </entry>
  </hbox>
"

DO_NOT_DISTURB_DEV=${DO_NOT_DISTURB_DEV:-make}
DO_NOT_DISTURB_DEV=${DO_NOT_DISTURB_DEV//[,;:|&\/]/}
DEV_POWERTIMEOUT_HBOX="<hbox>
<checkbox sensitive=\"$CB_DEV_PT_SEN\" tooltip-text=\"DISTURB_DEV\">
  <label>Do not poweroff if one of the following developer programs are running</label>
   <default>${DISTURB_DEV}</default>
   <variable>NEWDISTURB_DEV</variable>
   <action>if true enable:NEWDO_NOT_DISTURB_DEV</action>
   <action>if false disable:NEWDO_NOT_DISTURB_DEV</action>
  </checkbox>
  </hbox><hbox>
  <entry sensitive=\"$EN_DEV_PT_SEN\" tooltip-text=\"DO_NOT_DISTURB_DEV\">
   <default>$DO_NOT_DISTURB_DEV</default>
   <variable>NEWDO_NOT_DISTURB_DEV</variable>
  </entry>
  </hbox>
"
}

_create_frame_shutdown(){

_set_shutdown_variables_main
_create_shutdown_programs_entries
NTAB_SHUTDOWN=`gettext "Shutdown"`

FRAME_SHUTDOWN=" <frame Power>
 <vbox scrollable=\"true\">
  <text selectable=\"true\"><label>Puppy is able to power-off your computer after a period of mouse inactivity. This will occur if the mouse cursor has not been moved for the designated interval:</label></text>
  <hbox>
   <text><label>\"                              Inactivity interval (0=never):\"</label></text>
   <entry max-length=\"4\" tooltip-text=\"POWERTIMEOUT\">
    <default>${POWERTIMEOUT}</default>
    <variable>NEWPOWERTIMEOUT</variable>
   </entry>
   <text><label>\"minutes                              \"</label></text>
   <!-- <text><label>\"       \"</label></text> -->
  </hbox>

  <hbox><text><label>\"  \"</label></text></hbox>
  <frame Power timeout preferences>
  <vbox>
  $FORCE_POWERTIMEOUT_HBOX
  $DL_POWERTIMEOUT_HBOX
  $MM_POWERTIMEOUT_HBOX
  $DEV_POWERTIMEOUT_HBOX
  </vbox>
  </frame>

  </vbox>
 </frame>
"
}
# SIXTH TAB.

_create_first_tab(){
_create_frame_frontend_d  #
}
_create_second_third_fourth_tab(){
_create_drive_icons_frames  #has fd0icon
}
_create_fifth_tab(){
_create_frame_ramsave
}
_create_sixth_tab(){
_create_frame_shutdown
}

_create_switch_window_button(){
if [ "$SHOWMODE" = "desktop" ]; then
 LABEL=`gettext "Show full Event Manager"`
 EXIT=showfull
else
 LABEL=`gettext "Show small Event Manager"`
 EXIT=showdesktop
fi

SELECT_MGR="   <hbox>
   <button>
    <label>\"$LABEL\"</label>
    <action type=\"exit\">$EXIT</action>
   </button>
   </hbox>
"
}

_create_save_or_exit_button(){

_create_switch_window_button

APPLY_OR_EXIT="
 <hbox homogeneous=\"false\" spacing=\"10\">
  <text><label>\"Click  \"</label></text>
   <button tooltip-text=\"to save new settings to $CONFFILE configuration file\">
   <input file icon=\"gtk-apply\"></input>
   <label>OK:Apply!</label>
   </button>
  <text use-markup=\"true\"><label>\"  <b>or</b>  \"</label></text>
   <button cancel></button>
  <text use-markup=\"true\"><label>\"  <i>to Exit without saving changes</i>            \"</label></text>
 </hbox>
   $SELECT_MGR
"
}

_create_window_small_eventmanager(){
#cutdown, only show choices for setting the desktop icons...

_create_second_third_fourth_tab
_create_save_or_exit_button

NOTEBOOK_LABEL="labels=\"$NTAB_DESK_ICONS|$NTAB_ICONPLACEMENT|$NTAB_FLOPPY\""
NOTEBOOK_CONTAINER="<notebook scrollable=\"false\" show-tabs=\"true\" homogeneous=\"true\" $NOTEBOOK_LABEL>"

 MAIN_DIALOG="
<window resizable=\"true\" title=\"Event Manager: Desktop drive icons\" icon-name=\"gtk-execute\" width-request=\"400\" height-request=\"350\">
<vbox scrollable=\"true\">

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

  $NOTEBOOK_CONTAINER

   $DRIVE_ICONS_FRAMES

  </notebook>

  $APPLY_OR_EXIT

</vbox>
</window>
"
}

_create_window_big_eventmanager(){

_create_first_tab
_create_second_third_fourth_tab
_create_fifth_tab
_create_sixth_tab
_create_save_or_exit_button

NOTEBOOK_LABEL="labels=\"$NTAB_FRONTEND_D|$NTAB_DESK_ICONS|$NTAB_ICONPLACEMENT|$NTAB_FLOPPY|$NTAB_RAMSAVE|$NTAB_SHUTDOWN\""
NOTEBOOK_CONTAINER="<notebook scrollable=\"true\" arrow-spacing=\"2\" show-tabs=\"true\" homogeneous=\"false\" $NOTEBOOK_LABEL>"

W_ATTRS="title=\"Puppy Event Manager\" icon-name=\"gtk-execute\""
#W_ATTRS="$W_ATTRS resizable=\"true\" allow-grow=\"true\" allow-shrink=\"true\""
#W_ATTRS="$W_ATTRS default-height=\"350\" default-width=\"350\""
W_ATTRS="$W_ATTRS height-request=\"400\" width-request=\"400\""

 MAIN_DIALOG="
<window ${W_ATTRS}>
<vbox scrollable=\"true\">

  <text use-markup=\"true\">
  <label>\"<b>pup_event_frontend_d configuration</b>\"</label></text>

 $NOTEBOOK_CONTAINER

  $FRAME_FRONTEND_D

  $DRIVE_ICONS_FRAMES

  $FRAME_RAMSAVE

  $FRAME_SHUTDOWN

 </notebook>

  $APPLY_OR_EXIT

</vbox>
</window>
"
}
# +++++ gui functions.

while :;
do
# first (re-)read the config file and make a backup
[ -s "$CONFFILE" ] && . "$CONFFILE" && cp $VERB -f "$CONFFILE" "${CONFFILE}OLD"

if [ "$SHOWMODE" = "desktop" ];then
_create_window_small_eventmanager
else
_create_window_big_eventmanager
fi


if [ 2 = 1 ]; then #DEBUG
 echo "$MAIN_DIALOG" >/tmp/gtkdialog.tmp
 /usr/local/bin/cat -n /tmp/gtkdialog.tmp
 sed -i '/^$/ d' /tmp/gtkdialog.tmp
 geany /tmp/gtkdialog.tmp &
 exit
fi

MAIN_DIALOG=`_GTKdialog_remove_comments "$MAIN_DIALOG"`
[ "$DEBUG" ] && _GTKdialog_debug_gui "$MAIN_DIALOG"
[ "$DEBUG" ] && times
export MAIN_DIALOG

#gtkdialog3 --debug --program=MAIN_DIALOG --center
RETSTRING=`gtkdialog --program=MAIN_DIALOG`
[ $? -ne 0 ] && exit 4

eval "$RETSTRING"

_debug "RETSTRING='$RETSTRING'" #TEST

case "$EXIT" in
abort|Cancel|'') RV=0; break;;
#v405 it is running with 'desktop' param, now rerun with all tabs...
showfull)    CMD="$MY_SELF"; break;;
showdesktop) CMD="$MY_SELF desktop"; break;;
esac
[ "$DEBUG" ] && times

# REM: The "$CONFFILE" file gets altered as variable first,
#       then the altered variables are written to "$CONFFILE"
#       so that "$CONFFILE" gets overwritten ...
#      TODO : make backup of old conf and create a default conf
#              to be able restore previous or default settings
#              and write a GUI for it...
CONFIG=`cat "$CONFFILE"`

if [ "$SHOWMODE" != 'desktop' ]; then
#make sure that RAMSAVEINTERVAL is an integer only...
NEWRAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL:-0} #412
NEWRAMSAVEINTERVAL=`echo "$NEWRAMSAVEINTERVAL" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent saves...
[ "$NEWRAMSAVEINTERVAL" -gt 0 -a "$NEWRAMSAVEINTERVAL" -lt 5 ] && NEWRAMSAVEINTERVAL=5
[ "$PUPMODE" = 2 -o "$PUPMODE" = 6 -o "$PUPMODE" = 12 ]        && NEWRAMSAVEINTERVAL=0 ##+++2012-01-18

#w007 make sure that POWERTIMEOUT is integer only...
NEWPOWERTIMEOUT=${NEWPOWERTIMEOUT:-0}
NEWPOWERTIMEOUT=`echo "$NEWPOWERTIMEOUT" | sed -e 's/[^0-9]//g'`
#do not allow too-frequent power-down...
[ "$NEWPOWERTIMEOUT" -gt 0 -a "$NEWPOWERTIMEOUT" -lt 5 ] && NEWPOWERTIMEOUT=5

if [ "$USE_DISABLED" ]; then
#v403 if major-switch has turned off hotplug support, only show one icon...
NEWBACKENDON=${NEWBACKENDON:-"true"} #v412
NEWHOTPLUGON=${NEWHOTPLUGON:-"true"} #v412
[ "$NEWBACKENDON" = "false" ] && NEWHOTPLUGON="false"
fi

NEWDESKDAEMON=${NEWDESKDAEMON:-"true"}  #v412
if [ "$NEWDESKDAEMON" = "false" ];then
#       NEWICONDESK="false"
# NEWICONPARTITIONS="false"
   NEWHOTPLUGNOISY="false"
     NEWAUTOTARGET="false"
    NEWAUTOUNMOUNT="false" #v424
        NEWZCDPOLL='false'
fi

_adjust_config DESKDAEMON $NEWDESKDAEMON
NEWPOLL_PLUG_DEVICE=${NEWPOLL_PLUG_DEVICE:-2}
test "$NEWPOLL_PLUG_DEVICE" -ge 1 || NEWPOLL_PLUG_DEVICE=1
test "$NEWPOLL_PLUG_DEVICE" -le 9 || NEWPOLL_PLUG_DEVICE=9
_adjust_config POLL_PLUG_DEVICE $NEWPOLL_PLUG_DEVICE

#rsPATTERN="s/^RAMSAVEINTERVAL=.*/RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}/"
#grep $Q '^RAMSAVEINTERVAL=' "$CONFFILE" && {
# __adjust_config "$rsPATTERN"; true; } || echo "RAMSAVEINTERVAL=${NEWRAMSAVEINTERVAL}" >>"$CONFFILE"
_adjust_config RAMSAVEINTERVAL $NEWRAMSAVEINTERVAL
#w007...
_adjust_config POWERTIMEOUT $NEWPOWERTIMEOUT
_adjust_config FORCE_POWERTIMEOUT_ALWAYS $NEWFORCE_POWERTIMEOUT_ALWAYS
_adjust_config DISTURB_VIDEO $NEWDISTURB_VIDEO
_adjust_config DISTURB_DL $NEWDISTURB_DL
_adjust_config DISTURB_DEV $NEWDISTURB_DEV
_adjust_config DO_NOT_DISTURB_VIDEO $NEWDO_NOT_DISTURB_VIDEO
_adjust_config DO_NOT_DISTURB_DL $NEWDO_NOT_DISTURB_DL
_adjust_config DO_NOT_DISTURB_DEV $NEWDO_NOT_DISTURB_DEV

#_adjust_config AUTOTARGET $NEWAUTOTARGET
if [ "$USE_DISABLED" ]; then
_adjust_config BACKENDON $NEWBACKENDON  #udev
_adjust_config ZCDPOLL $NEWZCDPOLL
_adjust_config AUTOUNMOUNT $NEWAUTOUNMOUNT
_adjust_config HOTPLUGNOISY $NEWHOTPLUGNOISY
_adjust_config HOTPLUGON $NEWHOTPLUGON
_adjust_config AUTOTARGET $NEWAUTOTARGET
fi

fi # SHOWMODE != desktop

#desktop gui and full gui
[ "$NEWICONDESK" = 'false' ] && { NEWICONPARTITIONS='false'; FD0ICON='false'; }
_adjust_config ICONDESK $NEWICONDESK
_adjust_config ICONPARTITIONS $NEWICONPARTITIONS
_adjust_config FD0ICON $NEWFD0ICON
if [ "$ICONPSITIONB" = "true" ] ; then
_adjust_config ICON_PLACE_ORIENTATION bottom
NEWICON_PLACE_ORIENTATION=bottom
elif [ "$ICONPSITIONR" = "true" ] ; then
_adjust_config ICON_PLACE_ORIENTATION right
NEWICON_PLACE_ORIENTATION=right
elif [ "$ICONPSITIONT" = "true" ] ; then
_adjust_config ICON_PLACE_ORIENTATION top
NEWICON_PLACE_ORIENTATION=top
elif [ "$ICONPSITIONL" = "true" ] ; then
_adjust_config ICON_PLACE_ORIENTATION left
NEWICON_PLACE_ORIENTATION=left
else
_adjust_config ICON_PLACE_ORIENTATION bottom
NEWICON_PLACE_ORIENTATION=bottom
fi

_debug 1 NEWIPSPAC=$NEWIPSPAC
NEWIPSGAPX=`echo "$NEWIPSGAPX" | sed 's/[^0-9]//g'`   #get rid of non-digits
NEWIPSGAPY=`echo "$NEWIPSGAPY" | sed 's/[^0-9]//g'`
 NEWIPSPAC=`echo "$NEWIPSPAC"  | sed 's/[^0-9]//g'`
_debug 2 NEWIPSPAC=$NEWIPSPAC
NEWIPSPAC=$(( ((NEWIPSPAC +1) / PIN_GRID_STEP) * PIN_GRID_STEP ))  #round to non-odd numbers
 _debug 3 NEWIPSPAC=$NEWIPSPAC
 NEWIPSGAPX=${NEWIPSGAPX:-32}
 NEWIPSGAPY=${NEWIPSGAPY:-64}
 NEWIPSPAC=${NEWIPSPAC:-64}
 _debug 4 NEWIPSPAC=$NEWIPSPAC
[ "$NEWIPSPAC" = 0 ] && NEWIPSPAC=64
 _debug 5 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSGAPX" -lt '24' -o "$NEWIPSGAPX" -gt '300' ] && NEWIPSGAPX=24 # x
 [ "$NEWIPSGAPY" -lt '32' -o "$NEWIPSGAPY" -gt '200' ] && NEWIPSGAPY=32 # y

#[ "$NEWIPSPAC" -lt '10' -o "$NEWIPSPAC" -gt '300' ] && NEWIPSPAC=64 # spacing
 [ "$NEWIPSPAC" -ge '64' ]  || NEWIPSPAC=64
 _debug 6 NEWIPSPAC=$NEWIPSPAC
 [ "$NEWIPSPAC" -le '160' ] || NEWIPSPAC=160
 _debug 7 NEWIPSPAC=$NEWIPSPAC
 NEWIPSPAC=$(( ((NEWIPSPAC +1) / PIN_GRID_STEP) * PIN_GRID_STEP ))  #round to non-odd numbers
 _debug 8 NEWIPSPAC=$NEWIPSPAC

if [ -n "`echo $NEWIPSPAC | grep -w -x '[0-9]\+'`" ] ; then
_adjust_config ICON_PLACE_SPACING $NEWIPSPAC
fi

echo "$CONFIG" > "$CONFFILE"
S=$((S+$?))
if [ "$S" = 0 ]; then
 xmessage -bg green -timeout 2 -title "Eventmanager" "Settings changed successfully" &
else
 xmessage -bg red              -title "Eventmanager" "Error occured writing
new $CONFFILE
" &
 RV=2
 break
fi
sleep 1

NEWDESKDAEMON=${NEWDESKDAEMON:-"$DESKDAEMON"} #desktop gui does not have NEWDESKDAEMON
if [ "$NEWDESKDAEMON" = "true" ];then
 if [ ! "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d start &
 else
 [ "$FD0ICON" = "$NEWFD0ICON" ]                               || DO_CHANGE_DRIVE_ICONS=1
 [ "$ICONDESK" = "$NEWICONDESK" ]                             || DO_CHANGE_DRIVE_ICONS=1
 [ "$ICON_PLACE_SPACING" = "$NEWIPSPAC" ]                     || DO_CHANGE_DRIVE_ICONS=1
 [ "$ICONPARTITIONS" = "$NEWICONPARTITIONS" ]                 || DO_CHANGE_DRIVE_ICONS=1
 [ "$ICON_PLACE_ORIENTATION" = "$NEWICON_PLACE_ORIENTATION" ] || DO_CHANGE_DRIVE_ICONS=1

  echo 'sourceit' > "$MY_TMP"/pup_event_manager.flg
  if test "$DO_CHANGE_DRIVE_ICONS"; then
  echo change >"$MY_TMP"/pup_event_change_icons.flg
  fi
 fi
else #NEWDESKDAEMON" != "true"
 if [ "`pidof pup_event_frontend_d`" ];then
    exec pup_event_frontend_d stop &
 fi
fi

unset DO_CHANGE_DRIVE_ICONS S CMD

sleep 1
[ "$DEBUG" ] && times
done
test "$CMD" && exec $CMD
exit $RV
###END###
