#!/bin/ash
# ROX App.: Click image files to mount & unmount. by: Terry Becker    aka: SunBurnt
# File types = ".2fs, .3fs, .sfs, .iso, & initrd.gz".
#v423 detect wrong squashfs version 3.x or 4.x.
#v424 advise of sfs-version-converter.

###KRG Fr 31. Aug 23:34:58 GMT+1 2012

Version='2.0.0-getopts Macpup_Foxy_3-Puppy-Linux-430/2 KRG'
Version='2.5.0-getopts Puppy-Linux-luci-218 KRG' ## Complete overhaul
                                                 ## manage different mount executables
                                                 ## manage filenames longer than 62 characters
                                                 ## Xdialog gui or xmessage gui
                                                 ## manage initrd files
                                                 ## Added lots of remarks
                                                 ## support for f4puppy5

test -f /etc/rc.d/f4puppy5 && source /etc/rc.d/f4puppy5

xmTITLE="PuppyFileMount"

usage(){
MSG="
$0 [-V|-v|-d|-h|-l] FILENAME.sfs
Script to mount and unmount
loop image, iso and squashfs files
[ by simple left click ] .

-V) show version
-v) verbose
-d) debug
-h) show this usage
-l) log to /tmp/filemnt.log
"
echo "$MSG"
[ "$DISPLAY" ] && xmessage -bg lightgreen -title "$xmTITLE" "$MSG"
exit $1
}
case $@ in
*-?help|*-?"help "*|-?help) usage 0;;
-?version) echo -e "\n$0: Version '$Version'\n";exit 0;;
esac
OUT=/dev/null;ERR=$OUT
while getopts Vvdhl opt;do
case $opt in
V) echo -e "\n$0: Version '$Version'\n";exit 0;;
v) VERBOSE=1;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;ERR=/dev/stderr;OUT=/dev/stdout;shift;;
d) DEBUG=1;set -x;shift;;
h) usage 0;;
l) shift;exec 1>>/tmp/filemnt.log 2>&1;;
*) :;;
esac;done


_kernel_version5 ## f4puppy5

# REM: Variables
MOUNT_DIR=/mnt  # parent dir there where files should be mounted

MOUNT_EXE='/bin/mount'    # /bin/mount  is a script, also possible: 'mount-FULL' ,  'busybox mount'
UMOUNT_EXE='/bin/umount'  # /bin/umount is a script, also possible: 'umount-FULL' , 'busybox umount'

DEBUG=1

if test -f "$*"; then
   imgFILE="$@"
   _debug "$0:$*:Is file"  ##DEBUG

else
   _debug "$0:$*:Is NOT file"  ##DEBUG
# REM: Filter filename parameter from other possible
#       parameters (--help,.. etc)
while [ $# != 0 ]; do
 if test -e "$1"
 then imgFILE="$1"
 else
 posPARAMS="$posPARAMS $1"
 fi
 shift
done

set - $posPARAMS

fi

_info "$0:$*:$imgFILE"  ##DEBUG

test "$imgFILE" || _exit 3 "Need existing filename ..."

# REM: Need to handle relative path
#      regular readlink -e should print absolute path if file exists
#      regular readlink -f should print absolute path if parent directory of directory or file exists
#       ( if I understand "-f, --canonicalize
#              canonicalize  by  following  every symlink in every component of
#              the given name recursively; all  but  the  last  component  must
#              exist" correctly
#      busybox readlink has no -e option
#                       but a  -f option that works as -e
#imgFILE=`readlink -f "$imgFILE"`
imgFILE=`realpath "$imgFILE"`

# REM: Sanity checks
 case "$imgFILE" in
 ./*|../*)
     dn_imgFILE=${imgFILE%/*}
     [ "$dn_imgFILE" = '.' ] && dn_imgFILE=''
     bn_imgFILE=${imgFILE##*/}
     imgFILE=`pwd`/"$dn_imgFILE"/"$bn_imgFILE"
     ;;
 */*)
     dn_imgFILE=${imgFILE%/*}
     bn_imgFILE=${imgFILE##*/}
     ;;
  *)
     dn_imgFILE=`pwd`
     bn_imgFILE="$imgFILE"
     ;;
 esac

# REM: Sanity checks
#test -e "$imgFILE" || imgFILE=`pwd`/"$bn_imgFILE"
test -f  "$imgFILE" || imgFILE=`pwd`/"$bn_imgFILE"
#test -e "$imgFILE" || _exit 4 "Error while testing for existance of '$imgFILE'"
test -f "$imgFILE" || _exit 4 "Error while testing for existance of '$imgFILE'"

_debugx "dn_imgFILE='$dn_imgFILE'"  ##DEBUG
_debugx "bn_imgFILE='$bn_imgFILE'"  ##DEBUG


# REM: Try to handle initrd files.
#      These may be compressed.
#      As of 2010 and later, Puppy Linux initrd are cpio archives.
#      Before, they seem to have been ext2 file-system files.

# REM: First some functions...

_change_into_dir_where_initrd_is(){
 parentDIR="${imgFILE%/*}"
 cd "$parentDIR" || _exit 5 "Could not change into '$parentDIR'"
 return $?
}

_make_backup_of_initrd(){
test -e "$*" || return 6
test -e "$*".bak && mv $VERB -f "$*".bak "$*".bak.old
cp $VERB -a "$*" "$*".bak
return $?
}

_make_backup_of_initrd_dir_tree(){
test -e "$*".bak && mv $VERB -f "$*".bak "$*".bak.old
test -e "$*" && mv $VERB -f "$*" "$*".bak
}

_create_and_change_into_initrd_dir_tree(){
test -e "$*" && rm -rf "$*"
mkdir $VERB -p "$*"
cd "$*" || _exit 7 "Could nor change into directory `pwd`/./initrd-tree"
}

_where_am_i(){
case `pwd` in
*${*}) :;;
*) return 8;;
esac
return 0
}

_unpack_initrd_cpio(){
_info "_unpack_initrd_cpio:$*" ##DEBUG
COMPRESS="$1"
case $COMPRESS in
gz)   dec_cat=zcat;;
bz2)  dec_cat=bzcat;;
lzo)  dec_cat=lzcat;;
lzma) dec_cat=lzmacat;;
xz)   dec_cat=xzcat;;
no)   dec_cat=cat;;
*)    echo "Unhandled compression '$COMPRESS'"
      return 10;;
esac

shift
_debug "$*"  ##DEBUG
test -e "$*" || return 8
which $dec_cat >>$OUT || return 9
$dec_cat "$*" | cpio -i -d
return $?
}

_is_initrd_cpio(){
 disktype "$imgFILE" | grep $Q -i 'cpio' && return 0
 return 1
}

_is_initrd_fs(){
 disktype "$imgFILE" | grep $Q -i 'File system' && return 0
 return 1
}

# REM: Variables
INTRD_DIR_TREE="initrd-tree" # name of the initrd_dir_tree to extract files from initrd

_prepare(){
# REM: Prepare the working directory
_change_into_dir_where_initrd_is
_make_backup_of_initrd "$imgFILE"
_make_backup_of_initrd_dir_tree "$INTRD_DIR_TREE"
_create_and_change_into_initrd_dir_tree "$INTRD_DIR_TREE"
_where_am_i || _exit 9 "Something feels wrong in this directory '`pwd`'"
}

case "$imgFILE" in
*initrd*)


# REM: Define compression from extension
case "$imgFILE" in
*initrd*.gz)   COMPRESS=gz;;
*initrd*.bz2)  COMPRESS=bz2;;
*initrd*.lzo)  COMPRESS=lzo;;
*initrd*.lza|*initrd*.lzm|*initrd*.lzma|*initrd*.lz)  COMPRESS=lzma;;
*initrd*.xz)   COMPRESS=xz;;
*initrd*)      COMPRESS=no;;
*) _err "Unhandled extension of '$bn_imgFILE'";;
esac


# REM: Is initrd a file-system
#      or cpio archive
if  _is_initrd_cpio; then
 _prepare
 _unpack_initrd_cpio "$COMPRESS" "$imgFILE"
 [ $? = 0 ] || { echo "something went wrong ..."; false; }
   exit $?

elif _is_initrd_fs; then
    _info "$imgFILE seems to contain a file system"  ##DEBUG
    # REM: further down it will be mounted


else
_err "Unhandled file type for '$imgFILE' - neither cpio or file-system"
exit 2
fi


;;
esac


mntPT="${MOUNT_DIR}/$bn_imgFILE"

_debug "mntPT='$mntPT'"  ##DEBUG

grepPatternMntPt=`echo "$mntPT" | sed 's#\([[:punct:]]\)#\\\1#g'`
grepPatternImgFile=`echo "$imgFILE" | sed 's#\([[:punct:]]\)#\\\1#g'`

# REM: _create_new_folder_name()
#      function to create another mountpoint
#      for GUI entry
_create_new_folder_name(){
test "$*" || { _return 4 "Usage: _create_new_folder_name DIRECTORY"; return $?; }
while read path_to_folder
do
_debug "_create_new_folder_name:$path_to_folder"  ##DEBUG
c=$((c+1))
test -e "$path_to_folder".$c && continue
mntPT="$path_to_folder".$c
break
done << EoI
`ls -1dv "$*"*`
EoI
}


# REM: functions if rox and creating/deleting of mountpoint directories
#      is not handled by mount/umount script ...
_open_filer_window(){
[ "$DISPLAY" ] || return 6
case $MOUNT_EXE in
/bin/mount) return 0;;
esac
test "$*"    || return 4
test -d "$*" || return 5
rox -d "$*"
}

_close_filer_window(){
[ "$DISPLAY" ] || return 6
case $UMOUNT_EXE in
/bin/umount) return 0;;
esac
test "$*"    || return 4
test -d "$*" || return 5
rox -D "$*"
}

_mkdir_mountpoint(){
case $MOUNT_EXE in
/bin/mount) return 0;;
esac
test "$*" || return 4
mkdir $VERB -p "$*"
}

_rmdir_mountpoint(){
# REM: here need to split in case mount fails
if [ "$UNMOUNT" ]; then
 case $UMOUNT_EXE in
 /bin/umount) return 0;;
 esac
else
 case $MOUNT_EXE in
 /bin/mount) return 0;;
 esac
fi

test "$*"    || return 4
test -d "$*" || return 5
sleep 2
rmdir $VERB "$*"
}


_check_already_mounted(){

  #BK check if already mounted elsewhere...
  for oneLOOP in `mount | grep '^/dev/loop' | cut -f 1 -d ' '`
  do

  # REM: Aug 2010 introduced /sys/class/block/loopX/loop/backing_file  :

   #Author: Milan Broz <mbroz@redhat.com>
   #Date:   Mon Aug 23 15:16:00 2010 +0200
   #
   #  loop: add some basic read-only sysfs attributes
   #
   #  Create /sys/block/loopX/loop directory and provide these attributes:
   #   - backing_file
   #   - autoclear
   #   - offset
   #   - sizelimit
   #
   #  This loop directory is present only if loop device is configured.
   #
   #  To be used in util-linux-ng (and possibly elsewhere like udev rules)
   #  where code need to get loop attributes from kernel (and not store
   #  duplicate info in userspace).
   #
   #  Moreover loop ioctls are not even able to provide full backing
   #  file info because of buffer limits.

   unset oneIMGF

   # REM: So if /sys/class/block/${oneLOOP##*/}/loop/backing_file
   #      exists, use it :
   if _test_fr     /sys/class/block/${oneLOOP##*/}/loop/backing_file; then
    read oneIMGF </sys/class/block/${oneLOOP##*/}/loop/backing_file

       # REM: that file might contain error messages ...
       test -f "$oneIMGF" || unset oneIMGF
   fi


   if test ! "$oneIMGF"; then
   # REM: else use losetup... or above code fails

   # REM: Now try to get the basename of the file associated with oneLOOP
   #      Older losetup-FULL had no -a option,
   #        so need to test all associated loop devices each one at a time...
   #       Also had no --version option ...
   oneIMGF=`losetup-FULL "$oneLOOP" | awk '{print $3}' | sed 's!^(!!;s!)$!!'`
   fi

   # REM: error conditions
   _debug "oneIMGF='$oneIMGF'"
   test "$oneIMGF" || continue

    oneIMGBASE=`basename "$oneIMGF"`
    #TODO 62/63/64/65 chars
    #bash-3.2# losetup-FULL /dev/loop1
    #/dev/loop1: [0700]:2579 (/mnt/xubuntu-11.10-desktop-i386.iso.29782/casper/filesystem.sq*)
                             #123456789012345678901234567890123456789012345678901234567890123




    _debug "oneIMGBASE='$oneIMGBASE' bn_imgFILE='$bn_imgFILE'" #TEST
    #not perfect, but paths may be symlinks...

    # REM: losetup prints 65 chars incl. '(' ')'
    #if [ "$oneIMGBASE" = "$bn_imgFILE" ];then #if [ "$MNTDIMG" = "$imgFILE" ];then #6

    # REM: and losetup-FULL ends with * for the last of the ?62?/?63?/?64? chars and beyound
     case "$oneIMGF" in
      *\*)
        # REM: tests gave 62 chars are printed and the 63th is wildcard
        #      so limit to 62 chars
          c64_oneIMGF=${oneIMGF:0:62}
          c64_imgFILE=${imgFILE:0:62}
         _debug "c64_oneIMGF='$c64_oneIMGF' c64_imgFILE='$c64_imgFILE'" #TEST

      # REM: but adds a * even if it is straight 62-65 chars ...
      #   c64_oneIMGBASE=`echo "${c64_oneIMGF##*/}" | sed 's%.$%%'`
      #c64_bn_imgFILE=`echo "${c64_imgFILE##*/}" | sed 's%.$%%'`
         c64_oneIMGBASE=`echo "${c64_oneIMGF##*/}"`
         c64_bn_imgFILE=`echo "${c64_imgFILE##*/}"`

      ;;
     *)
         # REM: could limit to 62 chars for now like above case *\*)
          #c64_oneIMGF=${oneIMGF:0:62}
          #c64_imgFILE=${imgFILE:0:62}
          #c64_oneIMGBASE=`echo "${c64_oneIMGF##*/}"`
          #c64_bn_imgFILE=`echo "${c64_imgFILE##*/}"`

          c64_oneIMGBASE=`echo "${oneIMGF##*/}"`
          c64_bn_imgFILE=`echo "${imgFILE##*/}"`
      ;;
     esac

      _debug "c64_oneIMGBASE='$c64_oneIMGBASE' c64_bn_imgFILE='$c64_bn_imgFILE'" #TEST

     if [ "$c64_oneIMGBASE" = "$c64_bn_imgFILE" ]; then #6

      # REM: If frugal install check if it is in use
      IMG_MNTPT=`busybox mount | grep "$c64_oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
      _debug "IMG_MNTPT='$IMG_MNTPT'"
      case "$IMG_MNTPT" in
      */pup_ro[0-9]*) IN_USE_BY_PUPPY="and in use by Puppy" ;;
      esac

     if [ -n "$DISPLAY" ] ; then #66

_xmessage_menu(){

xmessage -buttons "

Just
Quit
-->:190,

Open ROX-
Filer window
-->:191,

Open
console
-->:192,

Just Unmount
$oneIMGBASE
-->:193,

Unmount all
$oneIMGBASE
-->:194,

Mount an-
other time
-->:199
" -title "$xmTITLE" "$imgFILE
is already mounted $IN_USE_BY_PUPPY .
Do you want to unmount it
or mount it to another mount point ?"

RETVAL=$?

}

_xdialog_menu(){

Xdialog\
    -title "xmTITLE"\
    -stdout\
    -no-cancel\
    -menu\
    "$imgFILE
is already mounted $IN_USE_BY_PUPPY .
Do you want to unmount it
or mount it to another mount point ?"\
    350x250 7\
    "Quit" "do nothing - just leave"\
    "ROX" "open ROX-Filer window"\
    "Console" "open rxvt console window"\
    "unmount" "just unmount $bn_imgFILE"\
    "Unmount all" "unmount all $bn_imgFILE"\
    "mount again" "mount $bn_imgFILE again"\
    >/tmp/filemnt_dialog.out

[ $? = 0 ] || exit 0
read RETVAL </tmp/filemnt_dialog.out
case "$RETVAL" in
Quit)          RETVAL=190;;
ROX)           RETVAL=191;;
Console)       RETVAL=192;;
unmount)       RETVAL=193;;
Unmount*all)   RETVAL=194;;
mount*again)   RETVAL=199;;
esac

}

   if which Xdialog >>$OUT; then _xdialog_menu
 elif which xmessage>>$OUT; then _xmessage_menu
 else UNMOUNT='yes'; RETVAL=193
   fi

  if [ "$RETVAL" = "190" ] ; then #666  ## Quit
     exit 0

  elif [ "$RETVAL" = "191" ] ; then #666  ## open a ROX-Filer window
       mntPT=`busybox mount | grep "$c64_oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
       _open_filer_window "$mntPT"
       exit $?

  elif [ "$RETVAL" = "192" ] ; then #666  ## console
       mntPT=`busybox mount | grep "$c64_oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
       cd "$mntPT"
       _debug "`pwd`"
       rxvt &
       exit $?

  elif [ "$RETVAL" = "193" ] ; then #666  ## umount
       UNMOUNT='yes'
       mntPT=`busybox mount | grep "$c64_oneIMGBASE" | head -n 1 | cut -f 3 -d ' '`
       return 0

  elif [ "$RETVAL" = "194" ] ; then #666  ## umount ALL $oneIMGBASE
       UNMOUNT='yes'
       mntPT=`busybox mount | grep "$c64_oneIMGBASE" | cut -f 3 -d ' '`
       _debug "194:$mntPT"
       MntPt2=`echo "$mntPT" | sed "1 d"` ## only umount all others exect one
       _debug "194:$MntPt2"

       for i in $MntPt2 ; do

       # REM: closing filer widow needs be done here already,
       #      otherwise pid gets detected by fuser
       #      and that would kill rox completely incl. pinboard
       _close_filer_window "$i"

       GREP=`echo "$i" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "194:$GREP"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "194:$LOOPD"
       #USEapps=`fuser -c $LOOPD`     ##---2011-10-27
       USEapps=`fuser -m "$i"`   ##+++2011-10-27
       _notice "194:fuser:$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g'`
       _debugx "194:fuser:$USEapps"

       # REM: kill signal - use your preferred signal
       #      Supported signals are listed by 'help trap'
       SIG=2
       for j in $USEapps ; do
       _debugx "fuser claims PID '$j' is using '$mntPT'"
       kill -$SIG $j
       done

       $UMOUNT_EXE "$i"
       [ $? = 0 ] || continue
       #sleep 2
       _rmdir_mountpoint "$i"
       done

       mntPT=`busybox mount | grep "$c64_oneIMGBASE" | cut -f 3 -d ' '`
       [ "$mntPT" ] && return 0
       return 1

  else   #666
     MOUNT='again'
     return 0
  fi   ###666

 else ##66
 # REM: Without X, no sophisticated GUI - just unmount
 UNMOUNT='yes'  ##+++2011-10-27
 # REM: END DISPLAY test
 fi ##66

else : # do nothing
# REM: END basename comparisons of files printed by losetup and imgFILE
fi #6

# REM: check /dev/loop in proc/mounts
done

}

_check_already_mounted

# REM: UNMOUNT is not set until it gets set by GUI or automatically if no DISPLAY
if [ -z "$UNMOUNT" ] ; then
 # REM: mount imgFILE

  # REM: Do not use a Ext variable, case is better
  # get file type from extension
  #Ext=`echo "$imgFILE" |sed 's/^.*\.//'`
  #Ext=${imgFILE##*.}

 case "$imgFILE" in
 *.2fs|*.ext2|*.ext2fs.img) Type=ext2;;
 *.3fs|*.ext3|*.ext3fs.img) Type=ext3;;
 *.4fs|*.ext4|*.ext4fs.img) Type=ext4;;
 *.sfs|*.squashfs|*.sqfs|*.squashfs.img) Type=squashfs;;
 *.iso|*.ISO|*.Iso)
   #Fatdog fat16 first and iso9660 second  ###+++2013-03-02
   TYPES=`disktype "$imgFILE" |grep 'file system'`
   if [ "`echo "$TYPES" |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]' | grep -i 'UDF'`" ]; then
    Type=udf
   else
    Type=iso9660
   fi
  ;;
  *)
   Type=`disktype "$imgFILE" |grep 'file system' |head -n1 |awk '{print $1}' |tr '[A-Z]' '[a-z]'` ##+++2012-06-04 udf or iso9660
   #Type='iso9660' ##---2012-06-04
   # BK
   #elif [ "$imgFILE" = 'initrd.gz' ] ;then
   # Type='ext2'
   # gunzip $imgFILE             # handle gzip image file
   # imgFILE="echo "$imgFILE" |sed 's/.gz$//'"
  ;;
  esac

  #v423 detect wrong squashfs version...
  if [ "$Type" = "squashfs" ];then
   DISK_TYPE=`disktype "${imgFILE}"`
   if [ "`echo "${DISK_TYPE}" | grep "$SFSSTR"`" = "" ];then
    xmessage -bg orange1 "$DISK_TYPE"
    if [ $KERNEL_MAJ = 2 -a $KERNELSUBVER -gt 28 ] || [ $KERNEL_MAJ -gt 2 ];then
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This may be an older version 3.x squashfs file, not usable.
All Linux kernels around 2.6.29 or later require version 4.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    else
     [ -n "$DISPLAY" ] && xmessage -center -bg '#FFC0C0' "NOTICE: This may be a newer version 4.x squashfs file, not usable.
All Linux kernels around 2.6.28 or earlier require version 3.x squashfs files.
Note, there is an SFS-version-converter in the Utility menu, run that first."
    fi
    _err "Wrong squashfs version"
    exit 0
   fi
  fi

  # REM: Older pups need to mknod a /dev/loop
  #      Since kernel 3.1 they are automatically created by the kernel
  _mk_free_loop  # see f4puppy5

  # REM: if choosen mount again
  [ "$MOUNT" = 'again' ] && _create_new_folder_name "$mntPT"
  _debug "mntPT='$mntPT'"  ##DEBUG
  _mkdir_mountpoint "$mntPT"    ## mount.sh should do this

  # REM: New problem in case of additional mount 2014-11-27,
  #      mount complains that /dev/loop is in use - don't know why ...
  #      2014-12-03: Now I know - it is mount-FULL searching automatically
  #       for a free loop device and using it,
  #       busybox mount does not !!
  freeLOOP=`losetup -f`
  [ -b $freeLOOP ] && losetup $freeLOOP "$imgFILE" && {

  _debug "\n$MOUNT_EXE: '$Type' '$freeLOOP' '$mntPT'\n"
  $MOUNT_EXE $VERB -t $Type -o loop "$freeLOOP" "$mntPT"
   Err=$?
  } || {

  __old_mount_code_that_worked_flawless_until_today__(){
  _debug "\n$MOUNT_EXE: '$Type' '$imgFILE' '$mntPT'\n"
  $MOUNT_EXE $VERB -t $Type -o loop "$imgFILE" "$mntPT";
   Err=$?
   }
  __old_mount_code_that_worked_flawless_until_today__
  }

  if [ "$Err" -eq 0 ]; then
   if [ -n "$DISPLAY" ] ; then #99
    yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg green -text "SUCCESS! Click $imgFileBASE icon again to unmount it" & #BK
   fi
  elif [ -n "`mount | grep "$mntPT"`" ];then
   :
  else
   # REM: In case of mount error,
   #      disassociale loop device and
   #      remove created directory
   #: sleep 2s
   losetup -d $freeLOOP
   _rmdir_mountpoint "$mntPT"
  fi


 else
 # REM: unmount imgFILE using mntPT
   [ -n "$DISPLAY" ] && {
    #:rox -D "$mntPT"
    yaf-splash -timeout 3 -font "8x16" -outline 0 -margin 4 -bg orange -text "Unmounting $bn_imgFILE" &
   }
       GREP=`echo "$mntPT" | sed 's#\.#\\\.#g;s#\+#\\\+#g;s#-#\\\-#g'`
       _debug "unmount:$GREP"
       LOOPD=$(busybox mount | grep "$GREP" | cut -f 1 -d ' ')
       _debug "unmount:$LOOPD"
       #USEapps=`fuser -c $LOOPD`   ##---2011-10-27
       USEapps=`fuser -m "$mntPT"`  ##---2011-10-27
       _notice "unmount:fuser:$USEapps"
       USEapps=`echo "$USEapps" | sed 's/[[:alpha:]]//g;s/[[:punct:]]//g'`
       _debugx "unmount:fuser:$USEapps"

       # REM: kill signal - use your preferred signal
       #      Supported signals are listed by 'help trap'
       SIG=2
       for j in $USEapps; do
       _debugx "fuser claims PID '$j' is using '$mntPT'"
       kill -$SIG $j
       done

  _debug "\n$UMOUNT_EXE: '$mntPT'\n"
  $UMOUNT_EXE "$mntPT"
  Err=$?
  _rmdir_mountpoint "$mntPT"
 fi

 if [ "$Err" -gt 0 ] ;then
  [ -n "$DISPLAY" ] && xmessage -bg red -title "$xmTITLE" "Error... Returned <$Err> ... mounting or unmounting '$mntPT'"
 fi

exit $Err
# Very End of this file 'usr/sbin/filemnt' #
###END###
