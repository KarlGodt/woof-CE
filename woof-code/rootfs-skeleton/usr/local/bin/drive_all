#!/bin/ash
#(c) Copyright 2008 Barry Kauler, puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#
# /sbin/pup_event_frontend_d creates a desktop icon and copy of this script for each drive, ex:
#  for drive sda: cp -a /usr/local/bin/drive_all /root/.pup_event/drive_sda/AppRun
#
# This script is launched by pup_event_frontend_d when the icon is first created.
#  also, this script is launched when user clicks on deskop icon
#  (former is configurable, see /usr/sbin/eventmanager).
#
# Optional passed parameters are :
#  category of drive: card, floppy, optical, usbdrv, drive.
#  pmount_{DRV_CATEGORY}:
#  mountro
#  unmount
#  unmountall
#  fsck
#  eventmanager
#  FS_TYPE
#  MOUNT_OPTS
#
#v4.0.2 jun08: first write of this script, expanding 'pup_eventd' management.
#v403 icon menu, can call with 'unmount', 'eventmanager' and 'pmount_<DRV_CATEGORY>' params.
#v411 added 'quiet' option for vfat, suppresses error msg when file attribs not preserved on copy.
#w002 left click to unmount a partition.
#w476 fix codepage for vfat f.s.


########################################################################
#
# Changes by Karl Reimer Godt
# 01.0 : killzombies function : sed beginning spaces away .
# 02.0 : Show nested mounts in umount xmessage gui .. see also /bin/umount script
# 03.0 : Added usage, trap, version, debug macros .
# 04.0 : Added support for udf .
# 05.0 : Added support for different /sbin/probepart output
#
#
# TODO 1 : Update drive's AppInfo.xml if media change (for cd- drives)
#
########################################################################

exec 2>>/tmp/drive_all.log

  _TITLE_=puppy_drive_all
_VERSION_=2.1-Fox3-Dell755
_COMMENT_="Default AppRun for the Partition Icons on Desktop."

MY_SELF="$0"
MY_PID=$$
PARENT_PID=$PPID

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST="eventmanager|unmount|unmountall|[pmount_]DRV_CATEGORY ] [ FSTYPE ]"
ADD_PARAMETERS="pmount_DRV_CATEGORY :
eventmanager : Run small eventmanager GUI
unmount      : Unmount the partition
unmountall   : Unmount all unmountable drives

DRV_CATEGORY : all, drive
FSTYPE : File system type ie. ext4"
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap
}

# VARIABLES
### *** ROX-Filer Pinboard *** ###
STATE_DIR="$HOME/Choices/Puppy"
EXE_DIR='pup_event'
PUP_EVENT_DIR="$STATE_DIR/$EXE_DIR"
#PUP_EVENT_DIR="$HOME/Choices/Puppy/pup_event"
#PUP_EVENT_DIR="$HOME/.pup_event"
DRIVE_ICON_DIR="/usr/local/lib/X11/pixmaps"
CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"
  PUPPY_PIN="$HOME/Choices/ROX-Filer/PuppyPin"


#w002 extracted as a func...
_killzombies(){
   ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | sed 's#^[[:blank:]]*##'|sed -e 's/  /|/g' | grep -v '|||' | awk '{print $1}'`
   for oneZOMBIE in $ZOMBIES
   do
    echo "Killing parent(less?) zombie process $oneZOMBIE"
    /bin/ps --no-header -p $oneZOMBIE && kill $oneZOMBIE
   done
}

_close_filer_window(){
rox -D "$MNTPT"
}

_sync_usb(){
 # REM: syncs to disks  ...
 awk "{if (\$3 == \"$oneDRVNAME\") print \$12}" /proc/diskstats ##DEBUG
 _pidof sync || sync
 awk "{if (\$3 == \"$oneDRVNAME\") print \$12}" /proc/diskstats ##DEBUG

 # REM: sleep handling only for USB drives
 #        to better ensure reads/writes to usb are completed ..
 readlink /sys/block/$oneDRVNAME | grep $Q 'usb' && {
 sleep 2 ##2012-06-05

 # REM: linux/Documentation/ABI/testing/procfs-diskstats
 #      12 - I/Os currently in progress
 #       3 - device name
 IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`
 [ "$IOs" ] || IOs=0
 [ "$IOs" = '0' ] || yaf-splash -bg orange2 -text "Waiting for IO ops on '$oneDRVNAME' to complete ..." & yioPID=$!
 while [ "$IOs" != '0' ];
 do sleep 2;
 IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`;
 done
 [ "$yioPID" ] && { /bin/ps -p $yioPID >>$OUT 2>>$ERR && kill $yioPID; }
 }
}

_check_if_mounted(){
grep $Q -w "$MNTPT" /proc/mounts || { _info "'$MNTPT' not listed (anymore) in /proc/mounts ."; continue; }
}

_do_unmount(){
_check_if_mounted || return $?
_sync_usb
/bin/umount $VERB "$MNTPT"
}

_get_fusers(){
  # use fuser binary that supports -v option, bb fuser does not
   EXTRAMSG0=`_command fuser -v -m "$MNTPT" 2>&1 | grep -vwE 'fuser|_command|grep'`
}

_get_filemnt_mounts(){
   # detect loop mounts using the default filemnt mount directory syntax
   umPATTERN_2=`echo "$MNTPT" |sed 's|/|\\\\+|g'`
   NESTEDS_=`busybox mount | grep "$umPATTERN_2"`

}

_get_loop_mounts(){
   # another attempt to detect loop mounts ##+++2014-11-10
   # losetup: Ungültige Option -- a
   # BusyBox v1.21.1
   FILE_MOUNTS_=`losetup -a 2>>$ERR || losetup`
   FILE_MOUNTS=`echo "$FILE_MOUNTS_" | grep -w "$MNTPT"`
}

_get_sub_mounts(){

_get_filemnt_mounts
   if [ "$NESTEDS_" ]; then
   EXTRAMSG0="$EXTRAMSG0
$NESTEDS_ "
   fi

_get_loop_mounts
   if [ "$FILE_MOUNTS" ]; then
   EXTRAMSG0="$EXTRAMSG0
$FILE_MOUNTS"
   fi
}

_say_error_removable(){
    xmessage -bg "#ff8080" -title "Puppy drive manager: ERROR" -center "FAILURE! In the case of removable media, the most
common reason is the media is not currently inserted.
If so, please remedy.
"
}

_say_error_kill(){
   # Reset irritating fuser message "kernel", which likely means 'lo' driver
   [ "$EXTRAMSG0" = 'kernel' ] && EXTRAMSG0=''
   [ "$yPID_" ] && { /bin/ps -p $yPID_ >>$OUT 2>>$ERR && kill $yPID_; }
    xmessage -bg "#ff00ff" -title "KILL, UNMOUNT..." -center \
 -buttons KILL:10,EXIT:20 -default "EXIT" "FAILURE! One or more processes (programs) are currently
using /dev/${oneDRVNAME}. Here they are:
PIDS , apps or file mounts :
$EXTRAMSG0

If you press the \"KILL\" button, Puppy will attempt to
kill the offending programs and or unmount any sub mounts
for you. Only do this as a last resort.
Firstly you should try to close the programs manually,
since fuser may also try to kill kernel processes or even init.
For savetiness reason: PLEASE PRESS THE \"EXIT\" BUTTON!"
    if [ $? -eq 10 ];then
     #fuser -k -m "$MNTPT"
     # REM: Use code from rc.shutdown
     BADPIDS=`_command fuser -v -m "$MNTPT" | grep -v -E 'kernel|COMMAND|^$|grep|fuser|_command' |awk '{print $3}' | grep -vwE "1|${MY_PID}|${PARENT_PID}"`
     for oneBAD in $BADPIDS
     do
     _notice "Killing process $oneBAD..."
     #kill    $oneBAD 2>>$ERR
     sleep 1
     kill -9 $oneBAD 2>>$ERR
     done

     while read device inode file
     do
     _debug "'$device' '$inode' '$file'"
     [ "$device" ] || continue
     device=${device%:*}
     _debug "'$device' '$inode' '$file'"
     test -b "$device" || continue
     #grep -w "^$device" /proc/mounts
     #grep -w "^$device" /proc/mounts | tac
     #grep -w "^$device" /proc/mounts | tac | cut -f2 -d ' '
     MOUNTPOINTS=`grep -w "^$device" /proc/mounts | tac | cut -f2 -d ' '`
     if test "$MOUNTPOINTS"; then
     for aMNT in $MOUNTPOINTS
     do
      aMNT=`echo -e "$aMNT"`
      _debug "aMNT='$aMNT'"
      /bin/umount $VERB $LAZY -d "$aMNT"
      sleep 1
     done
     else #umount -l succeeded. no mountpoint entry in /proc/mounts .
     # IF Program is still running: both below will fail
     # IF Program is closed, unmount will fail but losetup -d should free the loop device
     #                                             so the entry does not show anymore in losetup [-a] output .
       /bin/umount $VERB -l -d "$device" || losetup -d "$device"
     fi
     done <<EoI
`echo "$FILE_MOUNTS"`
EoI
fi

}

_say_error_message(){
_get_fusers
_get_sub_mounts

   if [ "$EXTRAMSG0" = "" ];then
   _say_error_removable
   else
   _say_error_kill
   fi

}

_unmount_cleanup(){
  case $oneDRVNAME in
    sr[0-9]*|scd[0-9]*|hd[a-d]) _command eject $VERB /dev/$oneDRVNAME;;
  esac
  [ "$yPID_" ] && { /bin/ps -p $yPID_ >>$OUT 2>>$ERR && kill $yPID_; }
}

_unmount(){

while :
do

_close_filer_window
_do_unmount
case $? in
0) return 0;;
1) _killzombies;;
*) _warn "__unmount:FIXME: Got unhanled returnvalue";;
esac

_do_unmount
case $? in
0) return 0;;
1) _say_error_message;; # && { _unmount_cleanup; return 0; } ;;
*) _warn "__unmount:FIXME: Got unhanled returnvalue";;
esac

done
}

__unmount() {
  #REM: Preparing for unmounting
 #pidof sync || sync  ##2012-06-05
 rox -D "$MNTPT"

 # REM: syncs to disks  ...
 awk "{if (\$3 == \"$oneDRVNAME\") print \$12}" /proc/diskstats ##DEBUG
 _pidof sync || sync
 awk "{if (\$3 == \"$oneDRVNAME\") print \$12}" /proc/diskstats ##DEBUG

 # REM: sleep handling only for USB drives
 #        to better ensure reads/writes to usb are completed ..
 readlink /sys/block/$oneDRVNAME | grep $Q 'usb' && {
 sleep 2 ##2012-06-05

 # REM: linux/Documentation/ABI/testing/procfs-diskstats
 #      12 - I/Os currently in progress
 #       3 - device name
 IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`
 [ "$IOs" ] || IOs=0
 [ "$IOs" = '0' ] || yaf-splash -bg orange2 -text "Waiting for IO ops on '$oneDRVNAME' to complete ..." & yioPID=$!
 while [ "$IOs" != '0' ]; do sleep 2; IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`; done
 [ "$yioPID" ] && { /bin/ps -p $yioPID >>$OUT 2>>$ERR && kill $yioPID; }
 }

 # REM: Now unmounting
 while [ 1 ];do
  # REM: give a splash telling whats on, kill previous splash
  [ "$yPID_" ] && { /bin/ps -p $yPID_ >>$OUT 2>>$ERR && kill $yPID_; }
  # REM: since we loop to unmount again if fuser or loop sub mounts
  #      umount -l does alter /proc/mounts anyway
  grep $Q -w "$MNTPT" /proc/mounts || { _info "'$MNTPT' not listed (anymore) in /proc/mounts ."; continue; }
  yaf-splash -bg purple3 -text "Unmounting '$MNTPT' .." & yPID_=$!
  /bin/umount $VERB "$MNTPT" ; umVAL=$?
  #fix zombie process prevents partition unmount, invisible to fuser...
  if [ $umVAL -ne 0 ];then
   _killzombies
   [ -n "`busybox mount | grep "$MNTPT"`" ] && {
       [ "$DEBUG" ] || {
           # REM: get rid of multiple xmessages from umount script
           xmPIDS=`ps -o pid,args | grep xmessage | grep umount | grep -v grep | awk '{print $1}'`
           for aPID in $xmPIDS; do /bin/ps -p $aPID >>$OUT 2>>$ERR && kill $aPID; done
       }
       /bin/umount $VERB "$MNTPT"; umVAL=$?; }
  fi

  #rare ocassion, partition got unmounted before umount runs above...
  umPATTERN=" ${MNTPT} "
  MOUNT_=`busybox mount | grep "$umPATTERN"`
  [ "${MOUNT_}" ] || umVAL=0

  if [ $umVAL -ne 0 ];then
   # use fuser binary that supports -v option, bb fuser does not
   EXTRAMSG0=`_command fuser -v -m "$MNTPT" 2>&1 | grep -vwE 'fuser|_command|grep'`

   # detect loop mounts using the default filemnt mount directory syntax
   umPATTERN_2=`echo "$MNTPT" |sed 's|/|\\\\+|g'`
   NESTEDS_=`busybox mount | grep "$umPATTERN_2"`

   if [ "$NESTEDS_" ]; then
   EXTRAMSG0="$EXTRAMSG0
$NESTEDS_ "
   fi

   # another attempt to detect loop mounts ##+++2014-11-10
   # losetup: Ungültige Option -- a
   # BusyBox v1.21.1
   FILE_MOUNTS_=`losetup -a 2>>$ERR || losetup`
   FILE_MOUNTS=`echo "$FILE_MOUNTS_" | grep -w "$MNTPT"`

   if [ "$FILE_MOUNTS" ]; then
   EXTRAMSG0="$EXTRAMSG0
$FILE_MOUNTS"
   fi

   if [ "$EXTRAMSG0" = "" ];then
    xmessage -bg "#ff8080" -title "Puppy drive manager: ERROR" -center "FAILURE! In the case of removable media, the most
common reason is the media is not currently inserted.
If so, please remedy.
"
   else
   # Reset irritating fuser message "kernel", which likely means 'lo' driver
   [ "$EXTRAMSG0" = 'kernel' ] && EXTRAMSG0=''
   [ "$yPID_" ] && { /bin/ps -p $yPID_ >>$OUT 2>>$ERR && kill $yPID_; }
    xmessage -bg "#ff00ff" -title "KILL, UNMOUNT..." -center \
 -buttons KILL:10,EXIT:20 -default "EXIT" "FAILURE! One or more processes (programs) are currently
using /dev/${oneDRVNAME}. Here they are:
PIDS , apps or file mounts :
$EXTRAMSG0

If you press the \"KILL\" button, Puppy will attempt to
kill the offending programs and or unmount any sub mounts
for you. Only do this as a last resort.
Firstly you should try to close the programs manually,
since fuser may also try to kill kernel processes or even init.
For savetiness reason: PLEASE PRESS THE \"EXIT\" BUTTON!"
    if [ $? -eq 10 ];then
     #fuser -k -m "$MNTPT"
     # REM: Use code from rc.shutdown
     BADPIDS=`_command fuser -v -m "$MNTPT" | grep -v -E 'kernel|COMMAND|^$|grep|fuser|_command' |awk '{print $3}' | grep -vwE "1|${MY_PID}|${PARENT_PID}"`
     for oneBAD in $BADPIDS
     do
     _notice "Killing process $oneBAD..."
     #kill    $oneBAD 2>>$ERR
     sleep 1
     kill -9 $oneBAD 2>>$ERR
     done

     while read device inode file
     do
     _debug "'$device' '$inode' '$file'"
     [ "$device" ] || continue
     device=${device%:*}
     _debug "'$device' '$inode' '$file'"
     test -b "$device" || continue
     #grep -w "^$device" /proc/mounts
     #grep -w "^$device" /proc/mounts | tac
     #grep -w "^$device" /proc/mounts | tac | cut -f2 -d ' '
     MOUNTPOINTS=`grep -w "^$device" /proc/mounts | tac | cut -f2 -d ' '`
     if test "$MOUNTPOINTS"; then
     for aMNT in $MOUNTPOINTS
     do
      aMNT=`echo -e "$aMNT"`
      _debug "aMNT='$aMNT'"
      /bin/umount $VERB $LAZY -d "$aMNT"
      sleep 1
     done
     else
       /bin/umount $VERB -l -d "$device" || losetup -d "$device"
     fi
     done <<EoI
`echo "$FILE_MOUNTS"`
EoI
     continue
    fi
   fi

  else  # Unmount succeded

   case $oneDRVNAME in
    sr[0-9]*|scd[0-9]*|hd[a-d]) _command eject $VERB /dev/$oneDRVNAME;;
   esac
  fi

  [ "$yPID_" ] && { /bin/ps -p $yPID_ >>$OUT 2>>$ERR && kill $yPID_; }
  break

 done

}

_notice "Called with \$*='$*'"

_debug "\$*=$*"
DRV_CATEGORY="${1}"
   [ "$DRV_CATEGORY" = "" ] && DRV_CATEGORY="drive" #precaution.
[ "$DRV_CATEGORY" = "all" ] && DRV_CATEGORY="drive" #precaution.

FSTYPE="";
[ "$2" ] && FSTYPE="$2" #see pup_eventd
case "$FSTYPE" in
*not*inserted*|*none*) FSTYPE="";;
esac

MOUNT_OPTS=
[ "$3" ] && MOUNT_OPTS="-o $3" #see pup_eventd
case "$MOUNT_OPS" in
#FILESYSTEM INDEPENDENT MOUNT OPTIONS
*sync*|*time*|*auto*|*context*|*defaults*|*dev*|*exec*|*group*|*version*|*mand*|*suid*|*owner*|*mount*|ro|rw|*user*) :;;
*) unset MOUNT_OPTS;;
esac
DEBUG=1
#extract drive name from end of the script name...
#note, when click on desktop icon, /root/.pup_event/drive_<oneDRVNAME> is executed,
#however a script may run /root/.pup_event/drive_<oneDRVNAME>/AppRun ...
# REM: TODO : however a script may run ./AppRun ...
#oneDRVNAME=`realpath "${0}" | sed -e 's%.*/AppRun%%' | rev | cut -f 1 -d '_' | rev`
oneDRVNAME=`realpath "${0}"`
_debugx "oneDRVNAME='$oneDRVNAME'"
oneDRVNAME=${oneDRVNAME%/*}
_debugx "oneDRVNAME='$oneDRVNAME'"
oneDRVNAME=${oneDRVNAME##*/}
_debugx "oneDRVNAME='$oneDRVNAME'"
oneDRVNAME=${oneDRVNAME##*\_}

_debug "oneDRVNAME='$oneDRVNAME'"
_notice "DRV_CATEGORY='$DRV_CATEGORY' FSTYPE='$FSTYPE' MOUNT_OPTS='$MOUNT_OPTS'"
[ -b /dev/"$oneDRVNAME" ] || _exit 6

[ -f /etc/eventmanager.cfg ] && . /etc/eventmanager.cfg #written to by /usr/sbin/eventmanager
#[ $RAMSAVEINTERVAL ] || RAMSAVEINTERVAL=30

#[ "$AUTOTARGET" != "true" -a "$AUTOTARGET" != "false" ]     && AUTOTARGET="true"
case $AUTOTARGET in
TRUE|True|true|Y|YES|Yes|yes|y|1|FALSE|False|false|N|NO|No|no|n|0) :;;
*) AUTOTARGET="true";;
esac
#[ "$HOTPLUGNOISY" != "true" -a "$HOTPLUGNOISY" != "false" ] && HOTPLUGNOISY="false"
case $HOTPLUGNOISY in
TRUE|True|true|Y|YES|Yes|yes|y|1|FALSE|False|false|N|NO|No|no|n|0) :;;
*) HOTPLUGNOISY="false";;
esac
#[ "$ICONDESK" != "true" -a "$ICONDESK" != "false" ]             && ICONDESK="true"
case $ICONDESK in
TRUE|True|true|Y|YES|Yes|yes|y|1|FALSE|False|false|N|NO|No|no|n|0) :;;
*) ICONDESK="true";;
esac
#[ "$ICONPARTITIONS" != "true" -a "$ICONPARTITIONS" != "false" ] && ICONPARTITIONS="true"
case $ICONPARTITIONS in
TRUE|True|true|Y|YES|Yes|yes|y|1|FALSE|False|false|N|NO|No|no|n|0) :;;
*) ICONPARTITIONS="true";;
esac

#if ICONDESK=false (see /etc/eventmanager and /sbin/pup_eventd) then there will only
#be one icon on the desktop, labelled 'drives' and handler script is ?/usr/local/bin/drive_drives?
if [ "$oneDRVNAME" = "drives" ];then
 if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, kill it.
  killall gtkdialog_pmount 2>$ERR
  sleep 0.1
 fi
 exec pmount $DRV_CATEGORY
fi
# pmount_,eventmanager,unmount,unmountall

case $DRV_CATEGORY in
 pmount_*)
 DRV_CATEGORY=`echo -n "${1}" | cut -f 2 -d '_'`
 if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, kill it.
  killall gtkdialog_pmount 2>$ERR
  sleep 0.1
 fi
 exec pmount ${DRV_CATEGORY}
;;

eventmanager)
 #v405 'desktop' param, cutdown tabs for desktop drive icons only...
 exec eventmanager desktop
;;

unmount)
 mPATTERN='^/dev/'"$oneDRVNAME"' '

 MNTPT=`/bin/df | tac | grep -m1 "$mPATTERN" | tr -s ' ' | cut -f 6- -d ' '`
 if [ "$MNTPT" = "" ]; then
  #case $DRV_CATEGORY in optical)
  case $oneDRVNAME in scd[0-9]*|sr[0-9]*|hd[a-d])
     _command eject $VERB -T /dev/$oneDRVNAME
     exit 201;;
  *) exit 200;;
  esac #precaution.
 fi
 if [ "$MNTPT" = "/" -o "`echo "$MNTPT" | grep '/initrd/'`" ];then
  xmessage -bg "#ff8080" -title "Puppy drive manager" -center "/dev/${oneDRVNAME} mounted on ${MNTPT}
is in use by Puppy. You cannot unmount it."
  exit 201
 fi
  _unmount
 exit $?
;;
#v424 have added right-click menu item to unmount all partitions (see pup_event_frontend_d)...

unmountall)

 while read -r oneDRVNAME MNTPT rest  #Note now oneDRVNAME gets /dev/ preset
 do
 [ "$MNTPT" ] || continue
 MNTPT=`echo -e "$MNTPT"`
 case $MNTPT in */initrd/*|/) continue;;esac
  #yaf-splash -bg seagreen -text "Unmounting '$MNTPT' ..." & yPID=$!
  oneDRVNAME=${oneDRVNAME##*/}
  _unmount
  #kill $yPID >>$OUT 2>>$ERR
  sleep 1
 done <<EoI
`tac /proc/mounts | grep '^/dev/' | grep -vE '^/dev/loop|^/dev/ram|^/dev/md|^/dev/mtd|^/dev/nbd'`
EoI
 exit $?
;;

*mountro)
         grep $Q -w "^/dev/$oneDRVNAME" /proc/mounts && {

 # REM: linux/Documentation/ABI/testing/procfs-diskstats
 #      12 - I/Os currently in progress
 #       3 - device name
 awk "{if (\$3 == \"$oneDRVNAME\") print \$12}" /proc/diskstats  ##DEBUG
 IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`
 [ "$IOs" ] || IOs=0
 [ "$IOs" = '0' ] || yaf-splash -bg orange2 -text "Waiting for IO ops on '$oneDRVNAME' to complete ..." & yioPID=$!
 while [ "$IOs" != '0' ]; do sleep 2; IOs=`awk "{if (\\$3 == \\"$oneDRVNAME\\") print \\$12}" /proc/diskstats`; done
 [ "$yioPID" ] && { /bin/ps -p $yioPID >>$OUT 2>>$ERR && kill $yioPID; }


   if grep -w "^/dev/$oneDRVNAME" /proc/mounts | awk '{print $4}' | grep $Q -w 'rw'
 then
        /bin/mount $VERB -o remount,ro /dev/"$oneDRVNAME" /mnt/"$oneDRVNAME" || false

 elif grep -w "^/dev/$oneDRVNAME" /proc/mounts | awk '{print $4}' | grep $Q -w 'ro'
 then
        /bin/mount $VERB -o remount,rw /dev/"$oneDRVNAME" /mnt/"$oneDRVNAME" || false

 else :
   fi
        } || {
         mkdir $VERB -p /mnt/"$oneDRVNAME"
        /bin/mount $VERB -o         ro /dev/"$oneDRVNAME" /mnt/"$oneDRVNAME" || false
    }
    exit $?
;;
*fsck_*)
grep $Q -w "^/dev/$oneDRVNAME" /proc/mounts && _exit 10 "Found '$oneDRVNAME' in /proc/mounts"
 FSTYPE=${DRV_CATEGORY#*_}
 _notice "DRV_CATEGORY='$DRV_CATEGORY' FSTYPE='$FSTYPE'"
 [ "$FSTYPE" ] || _exit 11 "Missing FSTYPE"
echo '#!/bin/sh
fsck -C0 -v /dev/'"$oneDRVNAME"'
RV=$?
read -p "Press enter to close this window" CloseKey
exit $RV
'                >/tmp/fsck-$oneDRVNAME.sh
 chmod $VERB 0744 /tmp/fsck-$oneDRVNAME.sh

 rxvt -title "Fsck $oneDRVNAME" -e /tmp/fsck-$oneDRVNAME.sh
 exit $?
;;

esac

# pmount_,eventmanager,unmount,unmountall

# REM: Since the drive icons for cd drives stay on desktop,
#      Tooltips need updated when hoovering over icon
#      For Media no fstype ..
#      I make a whole title list
_update_appinfo_mediacd(){

cdINFO=`disktype /dev/$oneDRVNAME`
test "$cdINFO" || return 1

 SIZE=`echo "$cdINFO" | grep -o 'size .*' | cut -f1-3 -d ' '`
TITLE=`echo "$cdINFO" | grep -e 'CD-ROM.*'`

TRACKS=`echo "$cdINFO" | grep '^Track'`

mINFO="<Summary>
$TITLE
$SIZE"

while read T NR MEDIA t SIZE POWER size b TIME
do
[ "$T" ] || continue
mINFO="$mINFO
$T $NR $MEDIA $SIZE $POWER $TIME"

done<<EoI
`echo "$TRACKS"`
EoI

mINFO="$mINFO
</Summary>"

mkdir $VERB -p "$drive_iconDIR"

echo "<?xml version=\"1.0\"?>
<AppInfo>
   ${mINFO}
" >/tmp/AppInfo.xml

#sed -n '/<About>/,/<\/AppInfo>/ p' $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml
sed -n '/<About>/,/<\/AppInfo>/ p' $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml >>/tmp/AppInfo.xml
test $? = 0 && cp $VERB -f /tmp/AppInfo.xml $PUP_EVENT_DIR/drive_${oneDRVNAME}/

}

#oh, now have to analyse the media, decide what app to run...
#if [ "$oneDRVNAME" = "sr0" -o "$oneDRVNAME" = "sr1" ];then
#if [ "`echo "$oneDRVNAME" |grep -E '^sr[0-9]|^scd[0-9]|^hd[a-d]$'`" ];then  ###+++2012-01-20 2014-10-16
if [ "$DRV_CATEGORY" = optical ]; then
 srPATTERN='^/dev/'"$oneDRVNAME"' '
 if [ ! "`busybox mount | grep "$srPATTERN"`" ];then
  QUEST_CD=`cddetect $Q $VERB -d/dev/${oneDRVNAME}`
  RETVAL=$?
  __cddetect_returnvals__(){
    cat >&2 <<EoI
    sets exit value according to detected cd type:
    - audio       1
    - data        2
    - ISO         3
    - dvd         4
    - VideoDVD    5
    - VCD         6
    - SVCD        7
    - UVCD        8
    - mixed      50
    no disk!    255
    no disc!    255
    tray open!  255
    drive not ready! 255
EoI
}
	# REM: busybox eject does error if -v option given as of v.1.21.1
	#      busybox eject needs full path of device
  case $QUEST_CD in
    'tray open!')   # REM: If tray open, try to close it
     eject $VERB -t /dev/$oneDRVNAME
     while :; do
     #eject -t /dev/$oneDRVNAME
     sleep 5
     QUEST_CD2=`cddetect $Q $VERB -d/dev/${oneDRVNAME}`; RETVAL=$?
     [ "$RETVAL" = 255 ] || break
      case $QUEST_CD2 in
      'no disk!'|'no disc!') break;; #fall through
      'tray open!') eject $VERB -t /dev/$oneDRVNAME;;
      'drive not ready!') :;;
      *) _warn "Unhandled QUEST_CD2='$QUEST_CD2'";;
      esac
     done
    ;;
    'no disk!'|'no disc!')
      #STUB should I error out or fall through to bottom ?
     eject $VERB -t /dev/$oneDRVNAME
     sleep 5
     cddetect $Q $VERB -d/dev/${oneDRVNAME}; RETVAL=$?
    #xmessage -title "$MY_SELF" "Please insert a CD/DVD first."; exit 0
    ;;
    'drive not ready!')
     while :; do
     sleep 5
     QUEST_CD3=`cddetect $Q $VERB -d/dev/${oneDRVNAME}`; RETVAL=$?
     [ "$RETVAL" = 255 ] || break
      case $QUEST_CD3 in
      'no disk!'|'no disc!') break;; #fall through
      'tray open!') eject $VERB -t /dev/$oneDRVNAME;;
      'drive not ready!') :;;
      *) _warn "Unhandled QUEST_CD3='$QUEST_CD3'";;
      esac
     done
    ;;
    *) _warn "Unhandled QUEST_CD='$QUEST_CD'";;
  esac

  case $RETVAL in

  0) #failed to detect type.
   #cddetect does not work properly for dvd's, try something else...
   __start_mediaplayer(){
    if [ "`dvd+rw-mediainfo /dev/sr0 | grep 'Mounted Media: .* DVD-ROM'`" ];then

     ln $VERB -sf /dev/${oneDRVNAME} /dev/dvd
     exec defaultmediaplayer dvd://
    fi
   }
   true
   ;;

  1) #audio
     _update_appinfo_mediacd
     ln $VERB -sf /dev/${oneDRVNAME} /dev/cdrom
     exec defaultmediaplayer cdda://
   ;;
  3) #iso file: normal data cd. iso9660
     true
   ;;
  5) #video dvd
     _update_appinfo_mediacd
     ln $VERB -sf /dev/${oneDRVNAME} /dev/dvd
     exec defaultmediaplayer dvd://
   ;;
  8) # udf with .wma wav files [VCD: , ] 8 ##+++2012-01-20
     # FSTYPE='udf'
     FSTYPE=`guess_fstype /dev/$oneDRVNAME`
     _update_appinfo_mediacd
     ln $VERB -sf /dev/${oneDRVNAME} /dev/dvd
     exec defaultmediaplayer dvd://
   ;;
  esac
 fi
 #[ ! "$FSTYPE" ] && FSTYPE="iso9660"
 [ "$FSTYPE" ] || FSTYPE=`guess_fstype /dev/$oneDRVNAME`
 [ "$FSTYPE" ] || FSTYPE=unknown
 [ "$FSTYPE" = unknown ] && FSTYPE=`blkid /dev/$oneDRVNAME | grep -m1 -w "^/dev/$oneDRVNAME" | grep -oE ' TYPE="[^"]+"' | cut -f2 -d'"'`
 [ "$FSTYPE" ] || FSTYPE=unknown
 [ "$FSTYPE" = unknown ] && unset FSTYPE
fi

_format_size(){ #from pup_event_frontend_d
 SIZE="$1"
 [ $SIZE ] || SIZE=0
 if [ $SIZE -gt 1048576 ];then #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p` #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 elif [ $SIZE -gt 1024 ];then
  SIZE="$(( SIZE / 1024 ))"'MB'
 else
   SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
   SIZE="`LANG=$OLDLANG printf "%.3f" $SIZE`MB" #100613
 fi
 [ "$SIZE" = "0.0MB" ] && SIZE="0"
 [ "$SIZE" = "0,0MB" ] && SIZE="0" #100613
}

# REM: Media may have changed or FSTYPE
#      Want to update AppInfo.xml
_update_appinfo_mount(){
#<Summary>Filesystem: ext4 Size: 31.5GB</Summary>

case $oneDRVNAME in
fd[0-9]*|hd[a-d]|scd[0-9]*|sr[0-9]*) DISK=$oneDRVNAME;;
*) DISK=`echo "$oneDRVNAME" | sed 's#[0-9]*$##'`;;
esac

if test -f /sys/block/$oneDRVNAME/size; then
read SIZE </sys/block/$oneDRVNAME/size
DESCR=`probedisk2 | grep "^/dev/${oneDRVNAME}|" | cut -f3 -d'|'`
SUMMARY1="<Summary>$DESCR"

elif test -f /sys/block/$DISK/$oneDRVNAME/size; then
read SIZE </sys/block/$DISK/$oneDRVNAME/size
FSTYPE=`probepart -d/dev/$oneDRVNAME |cut -f2 -d'|'`
SUMMARY1="<Summary>Filesystem: $FSTYPE"

else
SIZE=0
DESCR=`probedisk2 | grep "^/dev/${DISK}" | cut -f3 -d'|'`
SUMMARY1="<Summary>$DESCR"

fi

SIZE=$((SIZE/2))
_format_size $SIZE

echo "<?xml version=\"1.0\"?>
<AppInfo>
 $SUMMARY1 Size: $SIZE</Summary>
" >/tmp/AppInfo.xml

sed -n '/<About>/,/<\/AppInfo>/ p' $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml >>/tmp/AppInfo.xml
test $? = 0 && cp $VERB -f /tmp/AppInfo.xml $PUP_EVENT_DIR/drive_${oneDRVNAME}/
#if test -f $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml; then
#sed -i "s%<Summary>.*</Summary>%<Summary>Filesystem: $FSTYPE Size: $SIZE</Summary>%" $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml
#else
#false
#fi
}

_debug "FSTYPE=$FSTYPE"
#if dropped down here, it is likely to be a data partition...
#if it is a mountable partition then mount and open with rox. If already mntd then open in rox...
#if [ "$ICONPARTITIONS" = "true" ];then
if [ "$FSTYPE" ];then
 dPATTERN='^/dev/'"$oneDRVNAME"' '
 if [ ! "`/bin/df | grep "$dPATTERN"`" ];then
  #not mounted...
  yaf-splash -bg purple2 -text "Mounting '$oneDRVNAME' ..." & yPID=$!
  mkdir $VERB -p /mnt/$oneDRVNAME
  case $FSTYPE in
   NTFS|Ntfs|ntfs)
    #'mount' is a script that takes care of mounting ntfs...
    /bin/mount $VERB $MOUNT_OPTS -t ntfs /dev/$oneDRVNAME /mnt/$oneDRVNAME
    RETVAL1=$?
    ;;
   fat*|FAT*|Fat*|vfat)
    #w476 modify codepage and iocharset (note: this code also in /usr/sbin/pmount)...
    #note, could also set iocharset=iso8859-2 (default: codepage=437, iocharset=iso8859-1)
    NLS_PARAM=''
    if [ -f /etc/keymap ];then #set in /etc/rc.d/rc.country
     KEYMAP=`cut -f 1 -d '.' /etc/keymap`
     case $KEYMAP in
      de|be|br|dk|es|fi|fr|it|no|se|pt)
       NLS_PARAM=',codepage=850'
      ;;
      slovene|croat|hu101|hu|cz-lat2|pl|ro_win)
       NLS_PARAM=',codepage=852,iocharset=iso8859-2'
      ;;
     esac
    fi
    /bin/mount $VERB $MOUNT_OPTS -t vfat -o shortname=mixed,quiet${NLS_PARAM} /dev/$oneDRVNAME /mnt/$oneDRVNAME #v411
    RETVAL1=$?
    ;;
   *)
    # REM: file-system type not needed usually,
    #       but may be useful if changed, ie from ext2 to ext3 ..
    FSTYPE=`echo "$FSTYPE" | tr '[[:upper:]]' '[[:lower:]]'`
    # REM: If all fs-types are compiled into kernel could check for
    #      fs support
    #       else unset FSTYPE and try without FSTYPE
    #       mount-FULL is quite capable to detect fs automatically
    #        and load fs-driver if not inside kernel (already loaded)
    #        but busybox mount is also good but fails sometimes
    #        autodetecting the fstype and always falls back to ocfs2
    grep $Q -w "$FSTYPE" /proc/filesystems || unset FSTYPE
    [ "$FSTYPE" ] && {
    /bin/mount $VERB $MOUNT_OPTS -t $FSTYPE /dev/$oneDRVNAME /mnt/$oneDRVNAME || false
    } || {
    /bin/mount $VERB $MOUNT_OPTS            /dev/$oneDRVNAME /mnt/$oneDRVNAME || false
    }
    RETVAL1=$?
    ;;
  esac
  [ $RETVAL1 -eq 0 ] && : #exec rox -x /mnt/$oneDRVNAME -d /mnt/$oneDRVNAME
  WARN_MSG=`dmesg | tail -n5 | grep -w "($oneDRVNAME)" | grep $Q -E 'emerg|alert|crit|error|warning'`
  [ "$WARN_MSG" ] && xmessage -title "DRIVE_ALL MOUNT WARNING" "$WARN_MSG" &
  /bin/ps -p $yPID >>$OUT && kill $yPID
  _update_appinfo_mount
  [ "$RETVAL1" = 0 ] && exit $RETVAL1
 else
  #mounted...
  MNTPT=`/bin/df | grep "$dPATTERN" | tr -s ' ' | cut -f 6- -d ' '`
  #if [ -h /mnt/home ];then
  # [ "`readlink /mnt/home`" = "$MNTPT" ] && MNTPT="/mnt/home"
  #fi
  #exec rox -x /mnt/$oneDRVNAME -d /mnt/$oneDRVNAME
  oIFS="$IFS"
  IFS=$'\n'
  for aMNTPT in $MNTPT; do
  if [ -h /mnt/home ];then
   [ "`readlink /mnt/home`" = "$aMNTPT" ] && aMNTPT="/mnt/home"
  fi
  exec rox -x "$aMNTPT" -d "$aMNTPT" &
  : #now done by /bin/mount.sh
  done
  IFS="$oIFS"
  exit $?
 fi
fi

_launch_pmount(){
#decision... we can bring up a "handler" window, that explains things, good for beginners.
#or jump direct to most appropriate target application, or do nothing.
#for now only have AUTOTARGET=true go direct to most appropriate target app,
# =false always start Pmount.
if [ "$AUTOTARGET" = "false" ];then
 _notice "AUTOTARGET set false, will now run pmount .."
 if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, kill it.
  killall gtkdialog_pmount 2>$ERR
  sleep 0.1
 fi
 exec pmount $DRV_CATEGORY
fi
}

_kill_pmount(){
#NOTE: if pmount already running, don't really want to kill then restart,
# just want to bring the window up if it's minimised ...how?
if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, kill it.
 killall gtkdialog_pmount 2>$ERR
 sleep 0.1
fi
}

_update_appinfo_no_media(){
#<Summary>Filesystem: ext4 Size: 31.5GB</Summary>
case $oneDRVNAME in
fd[0-9]*|hd[a-d]|scd[0-9]*|sr[0-9]*) DISK=$oneDRVNAME;;
*) DISK=`echo "$oneDRVNAME" | sed 's#[0-9]*$##'`;;
esac

if test -f /sys/block/$oneDRVNAME/size; then
read SIZE </sys/block/$oneDRVNAME/size
DESCR=`probedisk2 | grep "^/dev/${oneDRVNAME}|" | cut -f3 -d'|'`
SUMMARY1="<Summary>$DESCR"

elif test -f /sys/block/$DISK/$oneDRVNAME/size; then
read SIZE </sys/block/$DISK/$oneDRVNAME/size
FSTYPE=`probepart -d/dev/$oneDRVNAME |cut -f2 -d'|'`
SUMMARY1="<Summary>Filesystem: $FSTYPE"

else
SIZE=0
DESCR=`probedisk2 | grep "^/dev/${DISK}" | cut -f3 -d'|'`
SUMMARY1="<Summary>$DESCR"

fi
    #TODO: if no media inseted, the files inside do not get updated at k3.9.9
    #SIZE should be 0 but stays at last known size.
SIZE=$((SIZE/2))
_format_size $SIZE

echo "<?xml version=\"1.0\"?>
<AppInfo>
 $SUMMARY1 Size: $SIZE</Summary>
" >/tmp/AppInfo.xml
sed -n '/<About>/,/<\/AppInfo>/ p' $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml >>/tmp/AppInfo.xml
test $? = 0 && cp $VERB -f /tmp/AppInfo.xml $PUP_EVENT_DIR/drive_${oneDRVNAME}/

#if test -f $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml; then
#sed -i "s%<Summary>.*</Summary>%<Summary>Filesystem: $FSTYPE Size: $SIZE</Summary>%" $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml
#else
#false
#fi
}

if test  "$DRV_CATEGORY" = optical; then
 _update_appinfo_no_media
xmessage -title "$MY_SELF" "Please insert a CD/DVD first."
elif test "$DRV_CATEGORY" = floppy; then
 _update_appinfo_no_media
xmessage -title "$MY_SELF" "Please insert a floppy first."
else
xmessage -title "PMOUNT LAST FALLBACK" -buttons "Pmount:100,Quit:101" "NOTICE : Encountered unknown situation..
Will now run pmount '$DRV_CATEGORY' as last resort."
[ "$?" = 100 ] && exec pmount ${DRV_CATEGORY}
fi

###END###
