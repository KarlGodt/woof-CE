#!/bin/ash

[ "$HAVE_F4PUPPY5DEBUG" ] && return 0

# REM: debugging and logging related functions
#

# REM:

# REM: logging functions
_logger()
{
local MESSAGE PRIORITY TAG
case $# in
1) MESSAGE="$*";;
2) PRIORITY=$1
   shift
   MESSAGE="$*";;
''|0) echo "$0:_logger [ PRRIORITY ] [[ TAG ]]:Need at least MESSAGE." >&2
      return 1;;
*)
PRIORITY=$1
shift
TAG="$1"
shift
MESSAGE="$*"
;;
esac

#_test "\"$PRIORITY\"" != '""' || PRIORITY=7
#_test "\"$TAG\"" != '""'      || TAG=${0##*/}

_check_content "$PRIORITY" || PRIORITY=7
_check_content "$TAG"      || TAG=${0##*/}

logger -p $PRIORITY -t "$TAG" "$MESSAGE"
return $?

#May 29 09:21:57 puppypc user.debug  /bin/sh: TESTING logger 7
#May 29 09:22:13 puppypc user.info   /bin/sh: TESTING logger 6
#May 29 09:22:19 puppypc user.notice /bin/sh: TESTING logger 5
#May 29 09:22:26 puppypc user.warn   /bin/sh: TESTING logger 4
#May 29 09:22:32 puppypc user.err    /bin/sh: TESTING logger 3
#May 29 09:22:37 puppypc user.crit   /bin/sh: TESTING logger 2
#May 29 09:22:43 puppypc user.alert  /bin/sh: TESTING logger 1
#May 29 09:22:48 puppypc user.emerg  /bin/sh: TESTING logger 0
#May 29 09:22:06 puppypc user.emerg  /bin/sh: TESTING logger 8

}

#=============== Rotate Logs =================================================
_log_rotate()
{
test "$*" || { _err "_log_rotate:Need filename to rotate"; return 1; }
test -f "$*" || { _err "_log_rotate: '$*' not a regular file"; return 1; }

DEBUG=
nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
#[ "$nrLOGS" ] || nrLOGS=0
#nrLOGS=$((nrLOGS-1))
_debug "nrLOGS='$nrLOGS'"

while read oneLOG
do
 test "$oneLOG" || continue
 test -f "$oneLOG" || continue

 nrLOGS=$((nrLOGS-1))
  _debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
 mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))
 #nrLOGS=$((nrLOGS-1))

done <<EoI
`ls -1v "$*".[0-9]* | tac`
EoI

test -e "${*}.0" && { _err "Something went wrong"; return 1 ; }
 _info "moving $* --> ${*}.0"
mv $VERB "$*" "${*}.0"
}

_date(){
P="$1"
[ -z "$P" ] && P='s'

case $P in
s) date +%Y_%m_%d ;;
o) date +%d%b%Y ;;
*) date;;
esac
}

# simple functions with date and timestamp:
_date_FT(){ _DATE_FT_=`date +%F-%T`; }

 _emergd(){ test "$EMERGENCY" || return 0; _date_FT ; echo "$0:$_DATE_FT_:EMERGENGY:$*"; unset _DATE_FT_; }
 _alertd(){ test "$ALERT"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ALERT:$*";    unset _DATE_FT_;     }
  _critd(){ test "$CRIT"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:CRITICAL:$*"; unset _DATE_FT_;     }
   _errd(){ test "$ERROR"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ERROR:$*";    unset _DATE_FT_;     }
  _warnd(){ test "$WARN"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:WARNING:$*";  unset _DATE_FT_;     }
_noticed(){ test "$NOTICE" || return 0; _date_FT ; echo "$0:$_DATE_FT_:NOTICE:$*";   unset _DATE_FT_;     }
  _infod(){ test "$INFO"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:INFO:$*";     unset _DATE_FT_;     }
 _debugd(){ test "$DEBUG"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUG:$*";    unset _DATE_FT_;     }
_debugxd(){ test "$DEBUGX" || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUGX:$@";   unset _DATE_FT_;     }

[ "$DEBUGT" ] || DEBUGT=
_debugt()
{  #$1 label #$2 time

test "$DEBUGT" || return 0
    #unset LANG LC_ALL
    local _TIME_ LC_NUMERIC=C LANG= LC_ALL=
    _DATE_=`date +%s.%N | sed 's:.*\(..\..*\):\1:'`
    #_DATE_=`date +%s,%N | sed 's:.*\(..\,.*\):\1:'`
    if test "$2"; then
    _TIME_=`dc $_DATE_ $2 \- p`
    echo "$0:TIME:$1:$_TIME_"
    else
    #echo "$0:TIME:$*:`date +%s.%N | sed 's:.*\(..\..*\):\1:'`"
    echo "$0:TIME:$*:$_DATE_"
    fi
}

#=============== LOGLEVEL / DEBUG MESSAGES ==================================
[ "$EMERGENCY" ] || EMERGENCY=1
[ "$ALERT" ]     || ALERT=1
[ "$CRIT" ]      || CRIT=1
[ "$ERROR" ]     || ERROR=1
[ "$WARN" ]      || WARN=1
[ "$NOTICE" ]    || NOTICE=1
[ "$NOTICE2" ]   || NOTICE2=1
[ "$INFO" ]      || INFO=
[ "$INFO2" ]     || INFO2=
[ "$DEBUG" ]     || DEBUG=
[ "$DEBUGX" ]    || DEBUGX=

# simple functions:
 _emerg(){ test "$EMERGENCY" || return 0; echo "$0:EMERGENGY:$*"; }
 _alert(){ test "$ALERT"  || return 0; echo "$0:ALERT:$*";     }
  _crit(){ test "$CRIT"   || return 0; echo "$0:CRITICAL:$*";  }
   _err(){ test "$ERROR"  || return 0; echo "$0:ERROR:$*";     }
  _warn(){ test "$WARN"   || return 0; echo "$0:WARNING:$*";   }
_notice(){ test "$NOTICE" || return 0; echo "$0:NOTICE:$*";    }
  _info(){ test "$INFO"   || return 0; echo "$0:INFO:$*";      }
 _debug(){ test "$DEBUG"  || return 0; echo "$0:DEBUG:$*";     }
_debugx(){ test "$DEBUGX" || return 0; echo "$0:DEBUGX:$@";    }

_parse_cmdline_loglevel(){

                            local LOG_LEVEL LOG_LEVEL_ aL

if test "$loglevel"; then
 LOG_LEVEL="$loglevel"
elif test "$LOGLEVEL"; then
 LOG_LEVEL="$LOGLEVEL"
fi

if test ! "$LOG_LEVEL"; then
 test -e /proc/cmdline || return 0
 LOG_LEVEL_=`grep -i -o 'loglevel=[^[:space:]]*' /proc/cmdline | tr '[:upper:]' '[:lower:]'`
 test "$LOG_LEVEL_" && { eval "$LOG_LEVEL_" && LOG_LEVEL=$loglevel; }
 test "$LOG_LEVEL" || { grep $Q -w debug /proc/cmdline >&2 && LOG_LEVEL=7; }
fi

#if test "$LOG_LEVEL" && [ ! "${LOG_LEVEL//[[:digit:]-]/}" ];
if test "$LOG_LEVEL"; then
if test ! "${LOG_LEVEL//[[:digit:]-]/}"; then
    # setting loglevel 8 to 0 and 9 to 1 ...
    while test "$LOG_LEVEL" -gt 7; do LOG_LEVEL=$((LOG_LEVEL-8)); done
    test "$LOG_LEVEL" -lt 0 && LOG_LEVEL=0

    for aL in `seq $LOG_LEVEL -1 0`; do
    case $aL in
    7) DEBUG=1;;
    6) INFO=1;;
    5) NOTICE=1;;
    4) WARN=1;;
    3) ERROR=1;;
    2) CRIT=1;;
    1) ALERT=1;;
    0) EMERGENCY=1;;
    *) false;;
    esac                        ; done
else
 _crit "CRITICAL WARNING: loglevel set to wrong '$LOG_LEVEL' parameter at the bootloader kernel commandline" >&2
fi;else
 _notice "No loglevel specified at bootloader kernel commandline" >&2
fi
}


### END ###
  HAVE_F4PUPPY5DEBUG=1
_HAVE_F4PUPPY5DEBUG_=1
### END ###
