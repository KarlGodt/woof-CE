#!/bin/ash

[ "$HAVE_F4PUPPY5" ] && return 0

_assign_version()
{
case $1 in
_VERSION_) VERSION=$_VERSION_; Version=$_VERSION_; version=$_VERSION_;;
VERSION) _VERSION_=$VERSION; Version=$VERSION; version=$VERSION;;
Version) _VERSION_=$Version; VERSION=$Version; version=$Version;;
version) _VERSION_=$version; VERSION=$version; Version=$version;;
esac
}

test "$_VERSION_" && _assign_version _VERSION_ || _VERSION_=0.0.5z
test "$VERSION"   && _assign_version VERSION   ||   VERSION=0.0.5z
test "$Version"   && _assign_version Version   ||   Version=0.0.5z
test "$version"   && _assign_version version   ||   version=0.0.5z

SCRIPT_NAME=f4puppy5 # short for functions for puppy 5

# Handle $0 :
#test "$MY_SELF" || MY_SELF="$0"
# Handle login shell
case $0 in
-*) MY_SELF="$0";;
*)
MY_SELFR=`readlink -f "$0"`
MY_SELF0="$0"

[ "$WARN" ]    || WARN=1
[ "$WARN" ]    && WARNING="$WARN"
[ "$WARNING" ] || WARNING=1
_warn(){
test "$WARN" || return 1
echo -e "$0:WARNING:$*"
}

if test "$MY_SELFR" -a "$MY_SELF0"; then
test "$MY_SELFR" = "$MY_SELF0" && MY_SELF="$MY_SELF0" || {
_warn "readlink -f \$0 is not same as \$0"
MY_SELF="$MY_SELFR"
}

elif test "$MY_SELFR"; then
_warn "Could not determine \$0"
MY_SELF="$MY_SELFR"

elif test "$MY_SELF0"; then
_warn "Could not determine readlik -f \$0"
MY_SELF="$MY_SELF0"

else
_warn "Could not determine \$0 and readlink -f \$0"
test "$MY_SELF" || MY_SELF="$0"
fi
;;
esac

# Handle relative path
case "$MY_SELF" in
./*) MY_SELF=`pwd`/"$MY_SELF";;
esac
# Handle terminal
case ${MY_SELF##*/} in
ash|bash|dash|hush|msh|sh|-sh|-ash|-bash|-dash|-hush|-msh) EXIT=return;;
*)           EXIT=exit;;
esac

[ "$MY_PID" ] || MY_PID=$$

# colours
 Black0='\033[0;30m'
 Black1='\033[1;30m'
   Red0='\033[0;31m'
   Red1='\033[1;31m'
 Green0='\033[0;32m'
 Green1='\033[1;32m'
Yellow0='\033[0;33m'
Yellow1='\033[1;33m'
  Blue0='\033[0;34m'
  Blue1='\033[1;34m'
  Pink0='\033[0;35m'
  Pink1='\033[1;35m'
  Cyan0='\033[0;36m'
  Cyan1='\033[1;36m'
 White0='\033[0;37m'
 White1='\033[1;37m'

  Back0='\033[0;39m'
 Reset0='\033[0;39m'
Normal0='\033[0;39m'

 BackBlack0='\033[0;40m'
 BackBlack1='\033[1;30m'
   BackRed0='\033[0;41m'
   BackRed1='\033[1;41m'
 BackGreen0='\033[0;42m'
 BackGreen1='\033[1;42m'
BackYellow0='\033[0;43m'
BackYellow1='\033[1;43m'
  BackBlue0='\033[0;44m'
  BackBlue1='\033[1;44m'
  BackPink0='\033[0;45m'
  BackPink1='\033[1;45m'
  BackCyan0='\033[0;46m'
  BackCyan1='\033[1;46m'
 BackWhite0='\033[0;47m'
 BackWhite1='\033[1;47m'

  BackBack0='\033[0;49m'
 BackReset0='\033[0;49m'
BackNormal0='\033[0;49m'

 UsBlack0='\033[4;30m'
 UsBlack1='\033[4;1;30m'
   UsRed0='\033[4;31m'
   UsRed1='\033[4;1;31m'
 UsGreen0='\033[4;32m'
 UsGreen1='\033[4;1;32m'
UsYellow0='\033[4;33m'
UsYellow1='\033[4;1;33m'
  UsBlue0='\033[4;34m'
  UsBlue1='\033[4;1;34m'
  UsPink0='\033[4;35m'
  UsPink1='\033[4;1;35m'
  UsCyan0='\033[4;36m'
  UsCyan1='\033[4;1;36m'
 UsWhite0='\033[4;37m'
 UsWhite1='\033[4;1;37m'

 BoldBlack0='\033[5;30m'
 BoldBlack1='\033[5;1;30m'
   BoldRed0='\033[5;31m'
   BoldRed1='\033[5;1;31m'
 BoldGreen0='\033[5;32m'
 BoldGreen1='\033[5;1;32m'
BoldYellow0='\033[5;33m'
BoldYellow1='\033[5;1;33m'
  BoldBlue0='\033[5;34m'
  BoldBlue1='\033[5;1;34m'
  BoldPink0='\033[5;35m'
  BoldPink1='\033[5;1;35m'
  BoldCyan0='\033[5;36m'
  BoldCyan1='\033[5;1;36m'
 BoldWhite0='\033[5;37m'
 BoldWhite1='\033[5;1;37m'

 InvBlack0='\033[7;30m'
 InvBlack1='\033[7;5;30m'
   InvRed0='\033[7;31m'
   InvRed1='\033[7;5;31m'
 InvGreen0='\033[7;32m'
 InvGreen1='\033[7;5;32m'
InvYellow0='\033[7;33m'
InvYellow1='\033[7;5;33m'
  InvBlue0='\033[7;34m'
  InvBlue1='\033[7;5;34m'
  InvPink0='\033[7;35m'
  InvPink1='\033[7;5;35m'
  InvCyan0='\033[7;36m'
  InvCyan1='\033[7;5;36m'
Inv_White0='\033[0;47m'
Inv_White1='\033[1;47m'
# /colours

_status(){
 _TTY_=`tty`
 [ "$_TTY_" = 'not a tty' ] && _TTY_=/dev/console

 _CHARS_=${1//[[:digit:]]/}
 if [ "$_CHARS_" ];then echo -e "\\033[60G\\033[1;36m${_CHARS_}$Normal0" >$_TTY_
 set -- 0
 elif [ "$1" = 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone$Normal0"   >$_TTY_ #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed$Normal0" >$_TTY_ #red [failed].
  STATUS=0
 fi

 return $1 #return with same status as entry param.
}

_cd_program_dir()
{
ME_PROG=`readlink -f "$0"`
ME_DIR=${ME_PROG%/*}
cd "$ME_DIR"
test $? = 0 || _exit 1 "Could not change into directory '$ME_DIR'"
return 0
}

__check_if_already_running()
{
local PROGRAM
test "$*" && PROGRAM="$*" || PROGRAM=$MY_SELF
#pidof -o $$ -o %PPID "${0##*/}" >>$OUT && {
#echo;echo
pidof -o $$ -o %PPID "${PROGRAM##*/}" >>$OUT && {
    case $OUT in
    /dev/null) echo -e "\\033[1F""Program '$PROGRAM' already running.\n"   ;;
            *) echo -e "\\033[2F""Program '$PROGRAM' already running:\n"   ;;
    esac
        #$EXIT 1
        $EXIT 0
 }
return $?
}

_check_if_already_running()
{
local PROGRAM TTY_
test "$*" && PROGRAM="$*" || PROGRAM=$MY_SELF
TTY_=`tty`

#echo "$$:%PPID:$PPID"
#pidof -o $$ -o %PPID "${PROGRAM##*/}"
#echo "PROGRAM='$PROGRAM'"

#pidof -o $$ -o %PPID "${0##*/}" >>$OUT && {
pidof -o $$ -o %PPID "${PROGRAM##*/}" >>$OUT && {
        case "$TTY_" in
        *not*a*tty*)
        echo "Program '$PROGRAM' already running."
        ;;
        *)
        echo -e "\\033[1F\\033[7G""Program '$PROGRAM' already running."
        ;;
        esac
        return 1
 }
return 0
}

_exit_if_already_running()
{
local PROGRAM
test "$*" && PROGRAM="$*" || PROGRAM=$MY_SELF
#pidof -o $$ -o %PPID "${0##*/}" >>$OUT && {
pidof -o $$ -o %PPID "${PROGRAM##*/}" >>$OUT && {
        echo -e "\\033[1F\\033[7G""Program '$PROGRAM' already running."
        $EXIT 1
 }
return $?
}

_run_status()
{
test "$*"  || { _return 2 "_run_status: Usage: _run_status BASENAMEPROGRAM"; return $?; }
pidof "${*##*/}" >>$OUT && { _info " '$*' running."; return 0; } || { _info " '$*' not running."; return 1; }
}

_check_for_terminal()
{
local MSG
MSG="Need a contolling terminal"
tty >>$OUT || {
[ "$OUT" = 'dev/null' ] || echo -n "Pid of X server:"
pidof X >>$OUT && xmessage -br red "$MSG"; $EXIT 2; } || {
echo "$MSG"; $EXIT 2; }
return $?
}

_who_is_X_user(){
_X_USER_=`ps -o pid,ppid,user,group,args | awk '{if (match($5, ".*X$") && $6 == ":0") print $3}'`
echo "$_X_USER_"
}

_exit()
{
local RV
test "$*" || { _err "Usage:_exit EXITCODE MESSAGE"; }
RV=$1
[ "${RV//[[:digit:]]/}" ] && { _err "\$1 must be a digit number."; RV=255; } || shift
echo "$*"
case ${MY_SELF##*/} in
ash|bash|sh) return $RV;;
*) exit $RV;;
esac
}

_trap()
{
trap "_exit 99 \"Caught Signal\"" INT KILL TERM
}

_version()
{
echo "$0:Version:$VERSION"

if [ "$TWO_VERSION" ]; then
 return 0
else
 $EXIT 0
fi
}

_have_all_commands()
{

haveALL_COMMANDS=MAYBE

grep -I -oE -e '=`[^ ]*| \| [^ ]*' "$0" | grep -v '=.*=' | sort -u | sed 's@^=`@@;s@| @@' |
while read oneCOMMAND;
  do
#which $oneCOMMAND || haveALL_COMMANDS=NO;
test "`which "$oneCOMMAND"`" -o "`type "$oneCOMMAND"`" || { haveNOT_COMMAND="$haveNOT_COMMAND $oneCOMMAND"; haveALL_COMMANDS=NOT; }
done

[ "$haveALL_COMMANDS" = MAYBE ] && haveALL_COMMANDS=YES

  if test "$haveALL_COMMANDS" = YES; then
_debug "haveALL_COMMANDS=$haveALL_COMMANDS"
elif test "$haveALL_COMMANDS" = NOT; then
_warn "Don't have all needed commands! Here they are:
$haveNOT_COMMAND
"
else
_error "Unhandled haveALL_COMMANDS '$haveALL_COMMANDS'"
  fi
}

_usage()
{
local USAGE_MSG RV
RV=$1
shift
test "$PARAMETER_LIST" || PARAMETER_LIST=PARAMETERS
test "$PARAMETERS" || PARAMETERS="NONE YET"
USAGE_MSG="
$0 [ $PARAMETER_LIST ]

PARAMETERS :
$PARAMETERS
--
$*
"
echo "$USAGE_MSG"

if test "$TWO_HELP"; then
 return $RV
else
 if test "$RV" != 0; then
  _exit $RV "Try again. Good Luck!"
 else
  $EXIT $RV
 fi
fi
return $?
}

_provide_basic_parameters()
{
test "$ADD_PARAMETER_LIST" && ADD_PARAMETER_LIST="|$ADD_PARAMETER_LIST"
PARAMETER_LIST="-help|-version|-verbose|-debug$ADD_PARAMETER_LIST"
PARAMETERS="
-h|--help    : Show this message and exit.
-V|--version : Show version information and exit.
-v|--verbose : Supress /dev/null and quiet options, verbose options to binaries.
-d|--debug   : Run program with set -x .
$ADD_PARAMETERS"
}

                  OUT=/dev/null;  ERR=$OUT;       Q=-q;QUIET=--quiet;DBG='';L_DBG='';     A_DBG=''
[ "$DEBUG" ] && {
    if [ "`tty`" = 'not a tty' ]; then
     OUT=/tmp/${MY_SELF##*/}_out.log; ERR=/tmp/${MY_SELF##*/}_err.log
    else
     OUT=/dev/stdout;ERR=/dev/stderr;
    fi
    Q='';QUIET=$Q;     DBG=-d;L_DBG=--debug;A_DBG=-debug; }
[ "$DEBUG" = "2" ] && set -x
_parse_basic_parameters()
{
OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=--quiet;DBG='';L_DBG='';A_DBG='';DO_SHIFT=0
case $1 in
-h|-H|*help) _usage 0 "$ADD_HELP_MSG";;
-V|*version) _version;;
-v|*verbose) VERBOSE=1;VERB=-v;A_VERB=-verbose;L_VERB=--verbose;
             Q='';QUIET=$Q;
             DEBUG=1;DBG=-d;L_DBG=--debug;A_DBG=-debug;
             if [ "`tty`" = 'not a tty' ]; then
              OUT=/tmp/${MY_SELF##*/}_out.log; ERR=/tmp/${MY_SELF##*/}_err.log
             else
              OUT=/proc/self/fd/1;ERR=/proc/self/fd/2;
             fi
             [ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1));;
-d|*debug)   set -x; [ "$TWO_DEBUG" ] || DO_SHIFT=$((DO_SHIFT+1));;
esac
export VERBOSE VERB L_VERB A_VERB Q QUIET DEBUG DBG L_DBG A_DBG OUT ERR
}

_parse_options()
{  ## MACRO kind of
local OPT_ OPTIONS_ aLINE
oldIFS="$IFS"
IFS=$'\n'

while getopts ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz- OPT_
 do
  _debugx "$OPT_='$OPT_' OPT_ARG='$OPTARG' OPT_IND='$OPTIND'"
  case $OPT_ in
  A):;;
  B):;;
  C):;;
  D):;;
  E):;;
  F):;;
  G):;;
  H):;;
  I):;;
  J):;;
  K):;;
  L):;;
  M):;;
  N):;;
  O):;;
  P):;;
  Q):;;
  R):;;
  S):;;
  T):;;
  U):;;
  V):;;
  W):;;
  X):;;
  Y):;;
  Z):;;
  a):;;
  b):;;
  c):;;
  d):;;
  e):;;
  f):;;
  g):;;
  h):;;
  i):;;
  j):;;
  k):;;
  l):;;
  m):;;
  n):;;
  o):;;
  p):;;
  q):;;
  r):;;
  s):;;
  t):;;
  u):;;
  v):;;
  w):;;
  x):;;
  y):;;
  z):;;
  -*) :;; # long option?
  esac
done

_debugx "\$#='$#' OPT_IND='$OPTIND'"
for i in `seq 1 1 $((OPTIND-1))`; do shift; done
_debugx "\$#='$#' OPT_IND='$OPTIND'"

while read -r aLINE
 do

  _debugx "aLINE='$aLINE'"

  case "$aLINE" in

### HANDLE OPTARG s ####
#    -x)              #example -x "ARG"
#      read anoLINE
#      echo "anoLINE='$anoLINE'"
#      OPTIONS_="$OPTIONS_
#$aLINE $anoLINE"
#      ;;
#    -x*)             #example -x"ARG"
#OPTIONS_="$OPTIONS_
#$aLINE";;
### HANDLE OPTARG s ####

  -*) OPTIONS_="$OPTIONS_
$aLINE";;
  *)  _PARAMETERS_="$_PARAMETERS_
$aLINE";;
  esac

 done <<EoI
`echo "$*"`
EoI

_debugx "OPTIONS_='$OPTIONS_' _PARAMETERS_='$_PARAMETERS_'"

set - $OPTIONS_ $_PARAMETERS_
_debug "\$*='$*'"
_debug "\$@='$@'"
_debugx "\$#='$#' OPT_IND='$OPTIND'"

while getopts ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz- OPT_
 do
  _debugx "$OPT_='$OPT_' OPT_ARG='$OPTARG' OPT_IND='$OPTIND'"
    case $OPT_ in
  A):;;
  B):;;
  C):;;
  D):;;
  E):;;
  F):;;
  G):;;
  H):;;
  I):;;
  J):;;
  K):;;
  L):;;
  M):;;
  N):;;
  O):;;
  P):;;
  Q):;;
  R):;;
  S):;;
  T):;;
  U):;;
  V):;;
  W):;;
  X):;;
  Y):;;
  Z):;;
  a):;;
  b):;;
  c):;;
  d):;;
  e):;;
  f):;;
  g):;;
  h):;;
  i):;;
  j):;;
  k):;;
  l):;;
  m):;;
  n):;;
  o):;;
  p):;;
  q):;;
  r):;;
  s):;;
  t):;;
  u):;;
  v):;;
  w):;;
  x):;;
  y):;;
  z):;;
  -*) :;; # long option?
  esac
done

_debugx "\$#='$#' OPT_IND='$OPTIND'"
for i in `seq 1 1 $((OPTIND-1))`; do shift; done
_debug "\$#='$#' OPT_IND='$OPTIND'"

_debug "\$*='$*'"
_debug "\$@='$@'"
_debugx "\$#='$#' OPT_IND='$OPTIND'"
}

_old_intro()
{

cat <<EoI

trap "exit 1" HUP INT QUIT KILL TERM

OUT=/dev/null;ERR=$OUT
[ "$DEBUG" ] && { OUT=/dev/stdout;ERR=/dev/stderr; }
[ "$DEBUG" = "2" ] && set -x

Version='1.1'

usage(){
USAGE_MSG="
$0 [ PARAMETERS ]

-V|--version : showing version information
-H|--help : show this usage information

*******  *******  *******  *******  *******  *******  *******  *******  *******
$2
"
exit $1
}

[ "`echo "$1" | grep -wiE "help|\-H"`" ] && usage 0
[ "`echo "$1" | grep -wiE "version|\-V"`" ] && { echo "$0 -version $Version"; exit 0; }

EoI

}

_string_to_octal()
{
oldDEBUG="$DEBUG"
DEBUG=

#oldIFS=$"$IFS"
#IFS='\012'

_debug "_string_to_octal:\$*='$*'" >&2
unset oSTRING

if test "$*"; then
STRING_ORIG="$*"

#STRING=`echo "$STRING_ORIG" | sed 's!\(.\)!"\1"\n!g'`
#STRING=`echo "$STRING_ORIG" | sed -r 's!(.)!"\1"\n!g;s!^$!"NEWLINE"!'`
STRING=`while read -r aLINE; do aLINE=$(echo "$aLINE" | sed 's!\(.\)!"\1" !g;s!$!\n!;s!" "!"\n"!g'); echo "$aLINE";done <<EoI
$(echo "$STRING_ORIG")
EoI
`

_debug "_string_to_octal:STRING='$STRING'" >&2


while read -r oneCHAR
do

oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
oCHAR=`printf %o \'"$oneCHAR"`

#case $oneCHAR in
#NEWLINE) oCHAR=12;;
#esac

#oprevCHAR=$oCHAR
case $oCHAR in
0)  oCHAR=12;;
esac

case $oprevCHAR in
0)
 oSTRING=$oSTRING"\\0$oCHAR"
;;
*)
oSTRING=$oSTRING"\\0$oCHAR"
;;
esac

oprevCHAR=$oCHAR

done <<EoI
`echo "$STRING"`
EoI

else

while read -r oneLINE
do
#test "$oneLINE" || continue

 _debug "oneLINE='$oneLINE'" >&2
 #STRING=`echo "$oneLINE" | sed 's!\(.\)!"\1"\n!g'`
  STRING=`echo "$oneLINE" | sed -r 's!(.)!"\1"\n!g;s!^$!"NEWLINE"!'`
 _debugx "STRING='$STRING'"  >&2

 while read -r oneCHAR
 do
 _debugx "oneCHAR='$oneCHAR'" >&2
 oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
 _debug "oneCHAR='$oneCHAR'"  >&2
 oCHAR=`printf %o \'"$oneCHAR"`

case $oneCHAR in
NEWLINE) oCHAR=12;;
esac

 _debug "oCHAR='$oCHAR'"      >&2
 oSTRING=$oSTRING"\\0$oCHAR"
 _debugx "oSTRING='$oSTRING'" >&2

 done <<EoI
`echo "$STRING"`
EoI

oSTRING=$oSTRING"\\012"
done

fi

echo "$oSTRING"
#IFS=$"$oldIFS"
DEBUG="$oldDEBUG"
}

_square(){

test $# = 2              || { _err "_square : Usage _square BASE EXPO";   return 3; }
test "${1//[[:digit:]]}" && { _err "_square : \$1 needs to be a :digit:"; return 4; }
test "${2//[[:digit:]]}" && { _err "_square : \$2 needs to be a :digit:"; return 5; }

local b s number i

b=$1
s=$2

number=1
for i in `seq 1 1 $s`
do
number=$((number*b))
done
echo $number
}

_oct2dec(){

test $# = 1 || { _err "_oct2dec: Usage: _oct2dec 0[0-7]*" >&2; return 3; }

case $1 in
0[0-7]*):;;
0*) _err " needs [0-7] range"; return 4;;
*) _err " needs 0 prefix";
   return 5
;;
esac

#test "${1//[0-7]/} && { _err " [0-7] only"; return 6; }

local octNUMBER_ roctNUMBER_ octNUMBER__ h c aO_ aO base dec sq

octNUMBER_=${1#*0}
test "${octNUMBER//[0-7]/}" && { _err " [0-7] only" >&2; return 6; }
_debug "$octNUMBER_"  >&2
roctNUMBER_=`echo "$octNUMBER_" | rev | sed -r 's/(.)/\1 /g'`
_debug "$roctNUMBER_" >&2

octNUMBER__=`echo "$octNUMBER_" | sed -r 's/(.)/\1 /g'`
_debug "$octNUMBER__" >&2

echo
h=0
c=0
for aO_ in $roctNUMBER_
do
   base=$((8*h))
   case $aO_ in
   [0-8]) aO=$aO_    ;;
   *) _err "Wrong $aO_ -- not between 0-7" >&2; return 6;;
   esac

  test $c = 0 && {

  dec=$((dec+(1*aO)))

  } || {

  sq=`_square 8 $c`
  _debugx sq=$sq  >&2
  dec=$(((sq*aO)+dec))

        }

  _debug dec=$dec >&2
  c=$((c+1))


done
echo $dec
}


_hex2dec(){

test $# = 1 || { _err "_hex2dec: Usage: _hex2dec 0x[:xdidgit:]*" >&2; return 3; }
case $1 in
0x[[:xdigit:]]*):;;
0x*) _err " not in :xdigit: range"; return 4;;
*) _err "needs 0x prefix" >&2 ;
   return 5
;;
esac

#test "${1//[[:xdigit:]]/} && { _err " [[:xdigit:]] only"; return 6; }

local hexNUMBER_ rhexNUMBER_ hexNUMBER__ h c aH_ aH base dec sq

hexNUMBER_=${1#*0x}
test "${hexNUMBER//[[:xdigit:]]/}" && { _err " [[:xdigit:]] only" >&2; return 6; }
_debug "$hexNUMBER_" >&2

rhexNUMBER_=`echo "$hexNUMBER_" | rev | sed -r 's/(.)/\1 /g'`
_debug "$rhexNUMBER_" >&2

hexNUMBER__=`echo "$hexNUMBER_" | sed -r 's/(.)/\1 /g'`
_debug "$hexNUMBER__" >&2

h=0
c=0
for aH_ in $rhexNUMBER_
do
   base=$((16*h))
   case $aH_ in
   [0-9]) aH=$aH_    ;;
   a) aH=10        ;;
   b) aH=11      ;;
   c) aH=12    ;;
   d) aH=13  ;;
   e) aH=14;;
   f) aH=15;;
   *) _err "Wrong $aH_ --not between 0-9a-f"; return 6;;
   esac

  test $c = 0 && {

  dec=$((dec+(1*aH)))

  } || {

  sq=`_square 16 $c`
  _debugx sq=$sq  >&2
  dec=$(((sq*aH)+dec))

        }

  _debug dec=$dec >&2
  c=$((c+1))


done
echo $dec
}



__getopt()
{

#POSIXLY_CORRECT=    ##
#GETOPT_COMPATIBLE=  ##

GET_OPT=`busybox getopt \
      -a -l help,version \
      -o h,V \
      -s sh \
      "$*"`
test $? = 0 || _usage 2 "Wrong option."

set - "`echo "$GET_OPT" | sed "s^' '^'\n'^g"`"

while read oneOPTION
do
 test "$oneOPTION" || continue
 case $oneOPTION
 in
 *) :;;
 esac
done <<EoI
`set`
EoI

set -
return $?
}

_getopts()
{
local oneOPTION
allOPS=AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz-
#while getopts hV oneOPTION
while getopts $allOPS oneOPTION
do
case $oneOPTION
in
h) _usage 0;;
V) _version;;
*) _warn "Unsupported option '$oneOPTION'";;
esac
done
return $?
}

_test()
{
#test "$*"
test $*
case $? in
0)
echo "'$*'" OK
return 0
;;
1)
echo "! '$*'"
return 1
;;
2)
echo "'$*'" wrong input
return 1
;;
esac
return $?
}

_get_argv()
{
local oneARG
for oneARG in $*
do
case $oneARG
in
-*help|help) _usage 0;;
-*version|version) _version;;
*) :;;
esac
done
return $?
}

_lineno(){
## Usage like :
#LINEP=D001
#[ "$VERBOSE" ] && echo "$DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"
## Or
#LINEP=D001;[ "$VERBOSE" ] && echo "$DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"
    if [ "$1" ]; then
    echo `grep -h -n -w -m1 "$1" "$MY_SELF" |cut -f1 -d':'`" (tag '$*')"
    else
    echo 'UNKNOWN -- missing $1'
    fi
}

_lineno2(){
## Usage like :
#[ "$VERBOSE" ] && echo "$DBG line `[ $LINENO ] && echo $LINENO || LINEP=D001 _lineno`"
    if [ "$LINEP" ]; then
    echo `grep -h -n -w -m1 "$LINEP" "$MY_SELF" |cut -f1 -d':'`" (tag '$LINEP')"
    else
    echo 'UNKNOWN -- missing env LINEP variable'
    fi
}

_logger()
{
local MESSAGE PRIORITY TAG
case $# in
1) MESSAGE="$*";;
2) PRIORITY=$1
   shift
   MESSAGE="$*";;
''|0) echo "$0:_logger [ PRRIORITY ] [[ TAG ]]:Need at least MESSAGE." >&2
      return 1;;
*)
PRIORITY=$1
shift
TAG="$1"
shift
MESSAGE="$*"
;;
esac

#_test "\"$PRIORITY\"" != '""' || PRIORITY=7
#_test "\"$TAG\"" != '""'      || TAG=${0##*/}

_check_content "$PRIORITY" || PRIORITY=7
_check_content "$TAG"      || TAG=${0##*/}

logger -p $PRIORITY -t "$TAG" "$MESSAGE"
return $?

#May 29 09:21:57 puppypc user.debug  /bin/sh: TESTING logger 7
#May 29 09:22:13 puppypc user.info   /bin/sh: TESTING logger 6
#May 29 09:22:19 puppypc user.notice /bin/sh: TESTING logger 5
#May 29 09:22:26 puppypc user.warn   /bin/sh: TESTING logger 4
#May 29 09:22:32 puppypc user.err    /bin/sh: TESTING logger 3
#May 29 09:22:37 puppypc user.crit   /bin/sh: TESTING logger 2
#May 29 09:22:43 puppypc user.alert  /bin/sh: TESTING logger 1
#May 29 09:22:48 puppypc user.emerg  /bin/sh: TESTING logger 0
#May 29 09:22:06 puppypc user.emerg  /bin/sh: TESTING logger 8

}

#======== Accumulate Errors and create Message Variable ====================
_basic_error_check()
{
local USAGE RV
USAGE="Usage: _basic_error_check \$? \"MESSAGE\""
RV=$1
test "$RV"           || { RV=127; set - $USAGE $*; echo -n "$1"; shift; echo " -- got '$*'" >&2; }
test "${RV//[0-9]/}" && { RV=127; set - $USAGE $*; echo -n "$1"; shift; echo " -- got '$*'" >&2; }
shift
if test "$RV" != "0"; then
__ERRORS__="$__ERRORS__
'$*' returned '$RV'"
fi
return $RV
}

_check_content()
{
test "$*" || { _err "Usage: _check_content VARIABLE -- got '$*'"; return 0; }
ENOCONTENT=28
#test "$*" && return 0 || { _err "NO content."; return $ENOCONTENT; }
#echo "'`eval echo \\$$*`'"
test "`eval echo \\$$*`" && return 0 || { _err "$*:NO content."; return $ENOCONTENT; }
}

_check_content2()
{
test "$2" || { _err "Usage: _check_content2 PATTERN VARIABLE -- got '$*'"; return 0; }
EWRONGCONTENT=29
unset sPATTERN gPATTERN
local sPATTERN gPATTERN
#echo -n "`eval echo \\$$*`"' : '
#echo "`eval echo \\$\${*//[[:digit:]]/}`"

case $1 in
  digit) gPATTERN="[[:digit:]]";;
nodigit|onlydigit|digitonly) gOPT=-v;gPATTERN="[[:digit:]]";
test "`echo $(eval echo \\$\${*//[[:digit:]]/})`" && { _warn "$*:Other than :digit: content."; return $EWRONGCONTENT; } || return 0;;
  alpha) gPATTERN="[[:alpha:]]";;
noalpha|onlyalpha|alphaonly) gOPT=-v;gPATTERN="[[:alpha:]]";
test "`echo $(eval echo \${*//[[:alpha:]]/})`" && { _warn "$*:Other than :alpha: content."; return $EWRONGCONTENT; } || return 0;;
  alnum) gPATTERN="[[:alnum:]]";;
noalnum|onlyalnum|alnumonly) gOPT=-v;gPATTERN="[[:alnum:]]";
test "`echo $(eval echo \${*//[[:alnum:]]/})`" && { _warn "$*:Other than :alnum: content."; return $EWRONGCONTENT; } || return 0;;
  punct) gPATTERN="[[:punct:]]";;
nopunct|onlypunct|punctonly) gOPT=-v;gPATTERN="[[:punct:]]";
test "`echo $(eval echo \\$\${*//[[:punct:]]/})`" && { _warn "$*:Other than :punct: content."; return $EWRONGCONTENT; } || return 0;;
  space) gPATTERN="[[:space:]]";;
nospace|onlyspace|spaceonly) gOPT=-v;gPATTERN="[[:space:]]";
test "`echo $(eval echo \\$\${*//[[:space:]]/})`" && { _warn "$*:Other than :space: content."; return $EWRONGCONTENT; } || return 0;;
  blank) gPATTERN="[[:blank:]]";;
noblank|onlyblank|blankonly) gOPT=-v;gPATTERN="[[:blank:]]";
test "`echo $(eval echo \\$\${*//[[:blank:]]/})`" && { _warn "$*:Other than :blank: content."; return $EWRONGCONTENT; } || return 0;;
'') :;;
no*|only*|*only) gOPT=-v;gPATTERN="$*";;
*) gPATTERN="$*";;
esac
shift

#test "`echo "$*" | grep -E "$gPATTERN"`" && return 0 || return $EWRONGCONTENT
#echo "$*" | grep -q -E "$gPATTERN" && return 0 || return $EWRONGCONTENT
#echo "`eval echo \\$$*`"

#Q=-q
if test "$gOPT" = '-v'; then
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && { _warn "$*:Other than '$gPATTERN' content."; return $EWRONGCONTENT; } || return 0
else
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && return 0 || { _warn "$*:No '$gPATTERN' content."; return $EWRONGCONTENT; }
fi
}

#================= Check /tmp if read-write ==================================
_check_proc()
{
  mountpoint $Q /proc && return $? || {
  busybox mount $VERB $VERB -o remount,rw /dev/root/ /
  test -d /proc || mkdir -p /proc
  busybox mount $VERB $VERB -t proc proc /proc
  return $?
 }
}

_check_tmp()
{
 test -d /tmp && return $? || {
 local STATUS_
 busybox mount $VERB $VERB -o remount,rw /dev/root/ /
 STATUS_=$((STATUS_+$?))
 mkdir -p /tmp
 STATUS_=$((STATUS_+$?))
 chmod $VERB 1777 /tmp
 STATUS_=$((STATUS_+$?))
 return $STATUS_
 }
}

_check_tmp_rw()
{
_check_proc || _crit "Difficulties with /proc  .."
_check_tmp  || _crit "Difficulties with /tmp  .."

mountpoint $Q /tmp && {
grep  ' /tmp ' /proc/mounts    | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw tmpfs /tmp;   return $?; }
 } || {
grep '^/dev/root' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw /dev/root/ /; return $?; }
 }
}

#============= Avoid multiple instances of sync ==============================
# busybox CONFIG_FEATURE_ SH_STANDALONE=y and SH_NOFORK=y do not emit a PID
[ "`which sync`" ] && alias sync="`which sync`"
_sync()
{
pidof sync >>$OUT || sync
}

#=
_grep_one_tail(){
test "$*" || { _return 2 "Usage:_grep_one_tail PATTERN [ FILENAME ]" >&2; return $?; }
if test ! "$2"; then
#piped
grep "$*" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | tail -n1
else
 local REV nREV FILENAME
 REV=`echo $* | rev`
 set - $REV
 _debug "\$*='$*'"             >&2
 FILENAME=`echo $* | awk '{print $1}' | rev`
 _debug "FILENAME='$FILENAME'" >&2
 shift
 nREV=`echo $* | rev`
 set - $nREV
 _debug "\$*='$*'"             >&2
 grep "$*" "$FILENAME" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | tail -n1
fi
}

_grep_one_head(){
test "$*" || { _return 2 "Usage:_grep_one_tail PATTERN [ FILENAME ]" >&2; return $?; }
if test ! "$2"; then
#piped
grep "$*" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | head -n1
else
 local REV nREV FILENAME
 REV=`echo $* | rev`
 set - $REV
 _debug "\$*='$*'"             >&2
 FILENAME=`echo $* | awk '{print $1}' | rev`
 _debug "FILENAME='$FILENAME'" >&2
 shift
 nREV=`echo $* | rev`
 set - $nREV
 _debug "\$*='$*'"             >&2
 grep "$*" "$FILENAME" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | head -n1
fi
}

_get_screen_resolution(){
 local RV
 ROOT_SCREEN_DIM_=`xwininfo -root`
 RV=$?
 ROOT_SCREEN_DIM_=`echo "$ROOT_SCREEN_DIM_" | tac | grep -vE '^[#!;]|^[[:blank:]]*[#!;]|^[/\*][/\*]|^[[:blank:]]*[/\*][/\*]' | grep -m1 '\-geometry'`
 RV=$((RV+$?))
_ROOT_SCREEN_DIM_=`echo "$ROOT_SCREEN_DIM_" | awk '{print $2}'`
 RV=$((RV+$?))
echo ${_ROOT_SCREEN_DIM_}
 return $RV
}

_get_screen_resolution2(){
 local RV
 ROOT_SCREEN_XY_=`xrandr`
 RV=$?
 ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | grep -o -m 1 'current [0-9]* x [0-9]*,'`
 RV=$((RV+$?))
_ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | grep -oe '[0-9]*'`
 RV=$((RV+$?))
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_resolution3(){
 local RV
 ROOT_SCREEN_XY_=`xrandr`
 RV=$?
 ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | grep -o -m 1 'current [0-9]* x [0-9]*,'`
 RV=$((RV+$?))
_ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | sed 's%[^0-9x]%%g'`
 RV=$((RV+$?))
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_resolution4(){
 local RV
 ROOT_SCREEN_XY_=`xrandr`
 RV=$?
_ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | sed -n '/current/ s%.*current \(.*\), maximum.*%\1%p'`
 RV=$((RV+$?))
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_resolution7(){
 local RV
#_ROOT_SCREEN_XY_=`xdpyinfo | grep -A1 -m 1 '^screen #0:' | tail -n1 | awk '{print $2}'`
 ROOT_SCREEN_XY_=`xdpyinfo`
 RV=$?
 ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | grep -m 1 'dimensions:'`
 RV=$((RV+$?))
_ROOT_SCREEN_XY_=`echo "$ROOT_SCREEN_XY_" | awk '{print $2}'`
 RV=$((RV+$?))
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_resolution8(){
 local RV
_ROOT_SCREEN_XY_=`xdpyinfo | awk '/dimensions:/ {print $2}'`
 RV=$?
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_resolution9(){
 local RV
_ROOT_SCREEN_XY_=`xdpyinfo | sed -n '/dimensions:/ s%.*dimensions:[[:blank:]]*\([0-9x]*\) pixels.*%\1%p'`
 RV=$?
echo ${_ROOT_SCREEN_XY_}
 return $RV
}

_get_screen_x(){
 local RV
_ROOT_SCREEN_X_=`xwininfo -root | tac | grep -vE '^[#!;]|^[[:blank:]]*[#!;]|^[/\*][/\*]|^[[:blank:]]*[/\*][/\*]' | grep -m1 '\-geometry' | awk '{print $2}' | awk -F'x' '{print $1}'`
 RV=$?
echo ${_ROOT_SCREEN_X_}
 return $RV
}

_get_screen_x2(){
 local RV
_ROOT_SCREEN_X_=`xrandr | grep -o -m 1 'current [0-9]* x [0-9]*,' | cut -f2 -d' '`
 RV=$?
echo ${_ROOT_SCREEN_X_}
 return $RV
}

_get_screen_x8(){
 local RV
_ROOT_SCREEN_X_=`xdpyinfo | awk -F'[ x]' '/dimensions:/ {print $7}'`
 RV=$?
echo ${_ROOT_SCREEN_X_}
 return $RV
}

_get_screen_x8(){
 local RV
_ROOT_SCREEN_X_=`xdpyinfo | awk -F'[ x]' '/dimensions:/ {print $7}'`
 RV=$?
echo ${_ROOT_SCREEN_X_}
 return $RV
}

_get_screen_x81(){
 local RV
_ROOT_SCREEN_Y_=`xdpyinfo | awk '/dimensions:/ {print $2}' | cut -f1 -dx`
 RV=$?
echo ${_ROOT_SCREEN_Y_}
 return $RV
}

_get_screen_y(){
 local RV
_ROOT_SCREEN_Y_=`xwininfo -root | tac | grep -vE '^[#!;]|^[[:blank:]]*[#!;]|^[/\*][/\*]|^[[:blank:]]*[/\*][/\*]' | grep -m1 '\-geometry' | awk '{print $2}' | awk -F'[x+]' '{print $2}'`
 RV=$?
echo ${_ROOT_SCREEN_Y_}
 return $RV
}

_get_screen_y2(){
 local RV
_ROOT_SCREEN_Y_=`xrandr | grep -o -m 1 'current [0-9]* x [0-9]*,' | awk -F' ' '{print $NF}'`
 RV=$?
echo ${_ROOT_SCREEN_Y_/,/}
 return $RV
}

_get_screen_y3(){
 local RV
_ROOT_SCREEN_Y_=`xrandr | grep -o -m 1 'current [0-9]* x [0-9]*,' | sed -r 's%(.*) x ([0-9]*),%\2%'`
 RV=$?
echo ${_ROOT_SCREEN_Y_}
 return $RV
}

_get_screen_y8(){
 local RV
_ROOT_SCREEN_Y_=`xdpyinfo | awk -F'[ x]' '/dimensions:/ {print $8}'`
 RV=$?
echo ${_ROOT_SCREEN_Y_}
 return $RV
}

_get_screen_y81(){
 local RV
_ROOT_SCREEN_Y_=`xdpyinfo | awk '/dimensions:/ {print $2}' | cut -f2 -dx`
 RV=$?
echo ${_ROOT_SCREEN_Y_}
 return $RV
}

#=

#=============== LOGLEVEL / DEBUG MESSAGES ==================================
[ "$ERMERGENCY" ] || EMERGENCY=1
[ "$ERMERGENCY" ] && EMERG="$EMERGENCY"
[ "$ERMERG" ]     || EMERG=1
_emerg(){
test "$EMERGENCY" || return 1
echo -e "$0:EMERGENGY:$*"
}
_emergency(){
test "$EMERGENCY" || return 1
echo -e "$0:EMERGENGY:$*"
}

[ "$ALERT" ] || ALERT=1
[ "$ALERT" ] && ALARM="$ALERT"
[ "$ALARM" ] || ALARM=1
_alert(){
test "$ALERT" || return 1
echo -e "$0:ALERT:$*"
}
_alarm(){
test "$ALERT" || return 1
echo -e "$0:ALERT:$*"
}

[ "$CRIT" ]     || CRIT=1
[ "$CRIT" ]     && CRITICAL="$CRIT"
[ "$CRITICAL" ] || CRITICAL=1
_crit(){
test "$CRIT" || return 1
echo -e "$0:CRITICAL:$*"
}
_critical(){
test "$CRIT" || return 1
echo -e "$0:CRITICAL:$*"
}

[ "$ERROR" ] || ERROR=1
#[ "$ERROR" ] && ERR="$ERROR"
#[ "$ERR" ]   || ERR=/dev/stderr
_err(){
test "$ERROR" || return 1
echo -e "$0:ERROR:$*"
}
_error(){
test "$ERROR" || return 1
echo -e "$0:ERROR:$*"
}

[ "$WARN" ]    || WARN=1
[ "$WARN" ]    && WARNING="$WARN"
[ "$WARNING" ] || WARNING=1
_warn(){
test "$WARN" || return 1
echo -e "$0:WARNING:$*"
}
_warning(){
test "$WARN" || return 1
echo -e "$0:WARNING:$*"
}

[ "$NOTICE" ] || NOTICE=1
[ "$NOTICE" ] && NOTE="$NOTICE"
[ "$NOTE" ]   || NOTE=1
_notice(){
test "$NOTICE" || return 1
echo -e "$0:NOTICE:$*"
}
_note(){
test "$NOTICE" || return 1
echo -e "$0:NOTICE:$*"
}

[ "$INFO" ]        || INFO=1
[ "$INFO" ]        && INFORMATION="$INFO"
[ "$INFORMATION" ] || INFORMATION=1
_info(){
test "$INFO" || return 1
echo -e "$0:INFO:$*"
}
_information(){
test "$INFO" || return 1
echo -e "$0:INFO:$*"
}

[ "$DEBUG" ] || DEBUG=
_debug(){
test "$DEBUG" || return 1
echo -e "$0:DEBUG:$*"
}

[ "$DEBUGX" ] || DEBUGX=
_debugx(){
test "$DEBUGX" || return 1
echo -e "$0:DEBUGX:$@"
}

 _emergdt(){ test "$EMERGENCY" || return 1; echo -e "`date +%F-%T`:$0:EMERGENGY:$*"; }
 _alertdt(){ test "$ALERT"     || return 1; echo -e "`date +%F-%T`:$0:ALERT:$*";     }
  _critdt(){ test "$CRIT"      || return 1; echo -e "`date +%F-%T`:$0:CRITICAL:$*";  }
   _errdt(){ test "$ERROR"     || return 1; echo -e "`date +%F-%T`:$0:ERROR:$*";     }
  _warndt(){ test "$WARN"      || return 1; echo -e "`date +%F-%T`:$0:WARNING:$*";   }
_noticedt(){ test "$NOTICE"    || return 1; echo -e "`date +%F-%T`:$0:NOTICE:$*";    }
  _infodt(){ test "$INFO"      || return 1; echo -e "`date +%F-%T`:$0:INFO:$*";      }
 _debugdt(){ test "$DEBUG"     || return 1; echo -e "`date +%F-%T`:$0:DEBUG:$*";     }


DEBUGT=
_debugt(){  #$1 label #$2 time

test "$DEBUGT" || return 1
#unset LANG LC_ALL
local _TIME_ LC_NUMERIC=C LANG= LC_ALL=
_DATE_=`date +%s.%N | sed 's:.*\(..\..*\):\1:'`
#_DATE_=`date +%s,%N | sed 's:.*\(..\,.*\):\1:'`
if test "$2"; then
_TIME_=`dc $_DATE_ $2 \- p`
echo "$0:TIME:$1:$_TIME_"
else
#echo "$0:TIME:$*:`date +%s.%N | sed 's:.*\(..\..*\):\1:'`"
echo "$0:TIME:$*:$_DATE_"
fi
}

#=================== Prefer Busybox applets ==================================
_use_busybox_applets()
{
[ "`which busybox`" ] && BBEXE=`which busybox`
[ "$BBEXE" ] || { [ -s /bin/busybox -a -x /bin/busybox ] && BBEXE='/bin/busybox'; }
[ "$BBEXE" ] || return 2  ##errno.h:define ENOENT 2 /* No such file or directory */

BBAPPLETS=`$BBEXE --list`

test "$BBAPPLETS" || BBAPPLETS='basename cat chmod chown clear cut
date dc dd dirname dmesg du ed expr false find free
head kill ln login ls lsmod mkdir mknod more mv nice pidof
readlink rev rm rmdir sleep sort stat su sync tail tar touch tr true
uname usleep waitmax wc which xargs'

for applet in $BBAPPLETS
do
#echo $applet
#file "`which $applet`" | grep 'link' | grep busybox || continue
eval "alias ${applet}=\"$BBEXE $applet\"";

done
}

#================ return with message, same as _exit =========================
_return()
{
local RV
RV=$1
 test "$RV" && shift || {
 false
 }
test "${RV//[0-9]/}" && RV=123
echo "$*" >&2
return $RV
}

#================== Use binary instead of busybox applet =====================
_command() # This is for busybox with internals first .
{          # sed -i and grep -w may not work as the regular binaries ,
           # especially if compiled without REGEX or not with GLIBC
#echo "$0:_command:$1:$*"
COM="$1"
shift
#echo "$0:_command:$1:$*"

typeCOM=`type -p "$COM"`
test "$typeCOM" ||{  _return 1 "No such type \"$COM\"" >&2;return $?; }

whichCOM=`which "$COM"`
test "$whichCOM" ||{  _return 1 "No such which \"$COM\"" >&2;return $?; }

_debug "_command:$COM:$@" >&2

test "$typeCOM" = "$whichCOM" && {
 "$typeCOM" "$@"    # "$*" does not work, so needs "$@"
 return $?
 } || {
 "$whichCOM" "$@"
 return $?
 }
}

#========= make nodes in /dev if /dev not mounted ============================
_mkdevices()
{
mountpoint $Q /dev && return 0
test "`type mdev`" && { mdev -s; return $?; }
 while read maj min siz dev ; do
  [ "${maj//[[:digit:]]/}" ] && continue
  [ "$maj" -a "$min" -a "$dev" ] || continue
  test -b /dev/$dev || mknod /dev/$dev b $maj $min
 done </proc/partitions
}

#============ Test to filter out links =======================================
_test_f()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" && return 0
return 1
}

_test_fr(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -r "$*" && return 0
return 1
}

_test_fw(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -w "$*" && return 0
return 1
}

_test_frw(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_fx(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -x "$*" && return 0
return 1
}

_test_d()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" && return 0
return 1
}

_test_dr()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -r "$*" && return 0
return 1
}

_test_dw()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -w "$*" && return 0
return 1
}

_test_dx()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*"  -a -x "$*" && return 0
return 1
}

_test_drw()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_drx()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -x "$*" && return 0
return 1
}

 _test_dwx()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -w "$*" -a -x "$*" && return 0
return 1
}

 _test_drwx()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -w "$*" -a -x "$*" && return 0
return 1
}

_test_p()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -p "$*" && return 0
return 1
}

_test_S()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -S "$*" && return 0
return 1
}

_test_c(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -c "$*" && return 0
return 1
}

_test_b(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -b "$*" && return 0
return 1
}

_test_L(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 0
return 1
}

_test_h(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -h "$*" && return 0
return 1
}

_test_correct_device()
{
test "$*" || { _err "Usage: _test_correct_device /dev/DEVICE SPECIAL MAJOR MINOR - like mknod"; return 2; }
local thisDEVICE DEVICE thisSPECIAL SPECIAL thisMAJ MAJ thisMIN MIN RV=0
DEVICE="$1"
SPECIAL="$2"
MAJ="$3"
MIN="$4"
_debug "_test_correct_device:$*: '$DEVICE' '$SPECIAL' '$MAJ' '$MIN'"

 thisDEVICE=`LC_ALL=C ls -l "$DEVICE"`
 thisSPECIAL=`echo "$thisDEVICE" | cut -b 1`
 thisMAJ=`echo "$thisDEVICE" | awk '{print $5}' | tr -d ','`
 thisMIN=`echo "$thisDEVICE" | awk '{print $6}'`

if test "$thisSPECIAL" != "$SPECIAL"; then
  _err "Got '$SPECIAL' but found '$thisSPECIAL' for '$DEVICE'"; RV=1
fi
if test "$thisMAJ" != "$MAJ"; then
  _err "Got '$MAJ' but found '$thisMAJ' for '$DEVICE'"; RV=1
fi
if test "$thisMIN" != "$MIN"; then
  _err "Got '$MIN' but found '$thisMIN' for '$DEVICE'"; RV=1
fi
test "$RV" = 1 && return 1
return 0
}

_secure_remove()
{
test "$*"    || { _err "Usage: _remove /path/to/filename"; return 2; }
test -e "$@" || { _info "'$@' does not exist already";     return 0; }

  if test -L "$@"; then rm "$@"
elif test -p "$@"; then rm "$@"
elif test -S "$@"; then rm "$@"
elif test -f "$@"; then rm "$@"
elif test -c "$@"; then rm "$@"
elif test -b "$@"; then rm "$@"
elif test -d "$@"; then rm -r "$@"
else { _warn "Unknown filetype '$@' - neither Link, pipe, Socket, file nor directory"; return 1; }
  fi
  return $?
}

#=============== Rotate Logs =================================================
__log_rotate__()
{
test "$*"    || { _err "__log_rotate:Need filename to rotate";  return 1; }
test -f "$*" || { _err "__log_rotate: '$*' not a regular file"; return 1; }

local nrLOGS oneLOG
nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
_debug "nrLOGS='$nrLOGS'"
while read oneLOG
do
   test "$oneLOG" || continue
test -f "$oneLOG" || continue

_debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))
nrLOGS=$((nrLOGS-1))

done <<EoI
`ls -1v "$*".[0-9]* | tac`
EoI

test -e "${*}.1" && { _err "Something went wrong"; return 1 ; }
_info "moving $* --> ${*}.1"
mv $VERB "$*" "${*}.1"
}

__log_rotate()
{
test "$*"    || { _err "__log_rotate:Need filename to rotate";  return 1; }
test -f "$*" || { _err "__log_rotate: '$*' not a regular file"; return 1; }

local nrLOGS oneLOG
nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
_debug "nrLOGS='$nrLOGS'"
while read oneLOG
do
   test "$oneLOG" || continue
test -f "$oneLOG" || continue

nrLOGS=$((nrLOGS-1))
_debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))
#nrLOGS=$((nrLOGS-1))

done <<EoI
`ls -1v "$*".[0-9]* | tac`
EoI

test -e "${*}.0" && { _err "Something went wrong"; return 1 ; }
_info "moving $* --> ${*}.0"
mv $VERB "$*" "${*}.0"
}

_log_rotate()
{
test "$*"    || { _err "_log_rotate:Need filename to rotate";  return 1; }
test -f "$*" || { _err "_log_rotate: '$*' not a regular file"; return 1; }

local max rotates r n
max=0
rotates=`ls -1 "$*".[0-9]* |cut -f3 -d.`

for r in $rotates ; do
[ "$r" -gt $max ] && max=$r
done

## start at last number (max) and rotate down
for n in `seq $max -1 0` ; do
#[ -e "$*".$n ] && mv $VERB "$*".$n "$*".$((n+1))
 [ -e "$errlog".$n ] || continue
 #grep -q -Ei 'warning|error|warnung|fehler' "$*".$n || { rm "$*".$n; continue; }
 mv $VERB "$*".$n "$*".$((n+1))
done

#[ -f "$*" ] && mv $VERB "$*" "$*".0
 [ -f "$*" ] && { cat "$*" >>"$*".0; rm "$*"; }

}

_rotate_err_log(){
 local errlog max rotates r n

errlog=make-errs.log
test -e "$errlog" || { _return 4 "'$errlog does not exist."; return $?; }

## get max number
max=0
rotates=`ls -1 "$errlog".[0-9]* |cut -f3 -d.`

for r in $rotates ; do
[ "$r" -gt $max ] && max=$r
done

## start at last number (max) and rotate down
for n in `seq $max -1 0` ; do
#[ -e "$errlog".$n ] && mv $VERB "$errlog".$n "$errlog".$((n+1))
 [ -e "$errlog".$n ] || continue
 grep -q -Ei 'warning|error|warnung|fehler' "$errlog".$n || { rm "$errlog".$n; continue; }
 mv $VERB "$errlog".$n "$errlog".$((n+1))
done

#[ -f "$errlog" ] && mv $VERB "$errlog" "$errlog".0
 [ -f "$errlog" ] && { cat "$errlog" >>"$errlog".0; rm "$errlog"; }

}

__set_bool_right(){
test "$#" = 3 || { _return 4 "_set_bool_right:Usage:_set_bool_right VARIABLE VAR_VALUE WANTED_VALUE -- got '$*'"; return $?; }

local VARIABLE VAR_VALUE WANTED_VALUE RV
VARIABLE="$1"
VAR_VALUE="$2"
WANTED_VALUE="$3"
RV=0
case $VAR_VALUE in
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1)
  case $WANTED_VALUE in
   FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0)
   _err "_set_bool_right: WANTED_VALUE should be one of these:
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1"
   return 5;;
  esac
eval "$VARIABLE=\"$WANTED_VALUE\"";;
FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0)
   case $WANTED_VALUE in
    TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1)
    _err "_set_bool_right: WANTED_VALUE should be one of these:
FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0"
    return 6;;
   esac
eval "$VARIABLE=\"$WANTED_VALUE\"";;
*) _err "_set_bool_right:Unhandled '$VAR_VALUE' -- Needs to be one of these:
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1 FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0"
RV=7
esac
return $RV
}

_set_bool_right(){
test "$#" = 3 || { _return 4 "_set_bool_right:Usage:_set_bool_right VARIABLE VAR_VALUE WANTED_VALUE -- got '$*'"; return $?; }

local VARIABLE VAR_VALUE WANTED_VALUE RV
VARIABLE="$1"
VAR_VALUE="$2"
WANTED_VALUE="$3"

YES_STRING='TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1'
NOT_STRING='FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0'
RV=0
case $VAR_VALUE in
[$YES_STRING])
  case $WANTED_VALUE in
   "$NOT_STRING")
   _err "_set_bool_right: WANTED_VALUE should be one of these:
$YES_STRING"
   return 5;;
  esac
eval "$VARIABLE=\"$WANTED_VALUE\""
;;

[$NOT_STRING])
   case $WANTED_VALUE in
    "$YES_STRING")
    _err "_set_bool_right: WANTED_VALUE should be one of these:
$NOT_STRING"
    return 6;;
   esac
eval "$VARIABLE=\"$WANTED_VALUE\"";;
*) _err "_set_bool_right:Unhandled '$VAR_VALUE' -- Needs to be one of these:
$YES_STRING $NOT_STRING"
RV=7
esac
return $RV
}

#================= KERNEL VERSION and SFS VERSION ============================

#VERSION = 3
#PATCHLEVEL = 13
#SUBLEVEL = 3
#EXTRAVERSION =
#Mounting Squashfs 1.x filesystems IS supported by the 2.0 kernel patch.
#Mounting 2.0 filesystems is supported by Squashfs 2.1.
#Squashfs 3.0 supports 2.x filesystems.  Support for 1.x filesystems
#will be added in the future.
#3.2: Unsquashfs now supports Squashfs 2.x filesystems.
#Welcome to Squashfs 4.0.  This is an initial tools only release to
#support users of the 2.6.29 kernel
#Later releases will probably contain kernel patches supporting 4.0
#layouts for earlier kernels.

_kernel_version()
{
oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"
KERNEL_RELEASE="$KERNELVER"
UNAME_R="$KERNELVER"

SFSSTR='squashfs, version 4'
SFSMAJOR=4
squashXZ=YES

if vercmp $KERNELVER ge 3.0;then #111016
:    # if vercmp not installed would run else
_info "Kernel 3.0 or greater"
else # assume 2.6
 #test $? = 127 && { _warn "_kernel_version:Is vercomp installed in PATH? -- using _kernel_version2 instead..."; _kernel_version2; }
 #echo $?
 #which vercmp || _kernel_version2
case $KERNELVER in
2.6.*)
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`

 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
   SFSSTR='squashfs, version 3'
   SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
 squashXZ=NOT
 fi
;;
*) _err "_kernel_version:UNHANDLED KERNELVER '$KERNELVER'";;
esac
fi 2>>$ERR #if vercmp is not installed :P

#kVERSION="$K_VERSION"
#kPATCHLEVEL="$K_PATCHLEVEL"
#kSUBLEVEL="$K_SUBLEVEL"
#kEXTRAVERSION="$K_EXTRAVERSION"
#kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version:KERNELVER='$KERNELVER'"
_info "_kernel_version:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version:squashXZ='$squashXZ'"

INFO=$oldINFO
DEBUG=$oldDEBUG
}







_kernel_version2()
{
oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION K_LOCALVERSION
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"
KERNEL_RELEASE="$KERNELVER"
UNAME_R="$KERNELVER"

SFSSTR='squashfs, version 3'
SFSMAJOR=3
squashXZ=NOT

ifsv='.-_'
#ifsv='[[:punct:]]' # also [:punct:] does not work
ifsv='^°!"§$%&/()=?`¹²³¼½¬{[]}\ß´+*~#-_.:·,;'"'"  # '\' seems not to work , even as '\\' '\\\' '\\\\'

      K_VERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion localversion;echo $kversion; }` ##code from /usr/sbin/laptop_mode, Maintainer: Bart Samwel (bart@samwel.tk)
   K_PATCHLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel localversion;echo $patchlevel; }`
     K_SUBLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $sublevel; }`
   KERNELSUBVER="$K_SUBLEVEL"

 #test "$K_VERSION" || _err "_kernel_version2:Could not get K_VERSION"
 _check_content K_VERSION
 #test "${K_VERSION//[[:digit:]]/}" && _warn "_kernel_version2:Got '$K_VERSION' with other than :digit:"
 _check_content2 onlydigit "$K_VERSION"

 if test $K_VERSION = 3; then
  _info "Newer kernel 3 series"
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $localversion; }`
 elif
 test $K_VERSION = 2; then
  _info "Older Kernel 2 series"
  K_EXTRAVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $extraversion; }`
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $localversion; }`
 else
  _err "Unhandled K_VERSION '$K_VERSION'"
 fi

[ "$K_EXTRAVERSION" ] || K_EXTRAVERSION=0
[ "${K_EXTRAVERSION//[[:digit:]]/}" ] && { K_LOCALVERSION="$K_EXTRAVERSION $K_LOCALVERSION";K_EXTRAVERSION=0; }
KERNELSUBSUBVER="$K_EXTRAVERSION"

case $K_VERSION in
3) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
2)
        case $K_PATCHLEVEL in
        6)
                case $K_SUBLEVEL in
                29|30|31|32|33|34|35|36|37) SFSSTR='squashfs, version 4';SFSMAJOR=4;;
                38|39) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
                28)
                    case $K_EXTRAVERSION in
                    47) SFSSTR='squashfs, version 4';;
                    esac
                ;;
                *) _notice "Old 2.6 kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' sublevel '$K_SUBLEVEL' .";;
                esac;;
        0|1|2|3|4|5) _crit "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        *) _alert "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        esac;;
*) _emerg "Unhandled kernel version '$K_VERSION' .";;
esac

kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version2:KERNELVER='$KERNELVER'"
_info "_kernel_version2:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version2:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version2:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version2:squashXZ='$squashXZ'"

INFO=$oldINFO
DEBUG=$oldDEBUG
}











_kernel_version3()
{
oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset VERSIONS LOCALVERSION K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

test -f /proc/config.gz || modprobe -v configs
test -f /proc/config.gz && {

 if test "$*"; then
 KERNELVER="$@"
 fi

 VERSIONS=`zcat /proc/config.gz | grep -m2 -iE '# Linux.*kernel.*|CONFIG_LOCALVERSION=".*"'`
 test "$KERNELVER" || KERNELVER=`echo "$VERSIONS" | grep -m1 -i '# Linux.*kernel.*' | awk '{print $3}'`
 LOCALVERSION=`echo "$VERSIONS" | grep -m1 -i 'CONFIG_LOCALVERSION=".*"' | cut -f2 -d=`
_debug "KERNELVER='$KERNELVER'"
_debug "LOCALVERSION='$LOCALVERSION'"
 test "$KERNELVER" || KERNELVER="`uname -r`"
 KERNVER="$KERNELVER"
 KERNEL="$KERNELVER"
 KERNEL_RELEASE="$KERNELVER"
 UNAME_R="$KERNELVER"

 SFSSTR='squashfs, version 4'
 SFSMAJOR=4
 squashXZ=YES

 if test "`echo "$KERNELVER" | grep '^3\.[0-9]\.'`"; then #111016
 _info "Kernel 3. series"
 K_VERSION=${KERNELVER:0:1}
 K_PATCHLEVEL=${KERNELVER:2:1}
 K_SUBLEVEL=${KERNELVER:4:1}

 KERNELSUBVER=$K_SUBLEVEL
 KERNELSUBSUBVER=0

 elif echo "$KERNELVER" | grep $Q '^2\.6'; then
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi

 else # assume 2.6
 _warn "Assuming kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi
fi


kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version3:KERNELVER='$KERNELVER'"
_info "_kernel_version3:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version3:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version3:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version3:squashXZ='$squashXZ'"

INFO=$oldINFO
DEBUG=$oldDEBUG
return 0
 } || _kernel_version

INFO=$oldINFO
DEBUG=$oldDEBUG
}












_kernel_version4()
{
oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

_process_kernel_2dotX()
{
squashXZ=NOT
case $kVERSION in
0|1) _crit "TODO: Unhandled kVERSION '$kVERSION'"; return 1;;
2)
  case $kPATCHLEVEL in
  0|2|4|5) _warn "TODO: Unhandled kVERSION '$kVERSION' kPATCHLEVEL '$kPATCHLEVEL'"; return 1;;
  6) test "$kSUBLEVEL" -ge 38 && squashXZ=YES
     test "$kSUBLEVEL" -gt 28 && return 0
     case $kSUBLEVEL in
      27) test "$kEXTRAVERSION" -eq 47 && return 0
          return 1;;
     esac
  ;;
  esac
;;
esac
return 1
}

_eval_sfsversion()
{
case $1 in
1) SFSSTR='squashfs, version 3';SFSMAJOR=3; test "$squashXZ" || squashXZ=NOT;;
*) SFSSTR='squashfs, version 4';SFSMAJOR=4; test "$squashXZ" || squashXZ=YES;;
esac
}

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi

_old(){
case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
esac
}

_new(){
_debug "case \"$KERNEL\" start"
oldIFS="$IFS"
#IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄä:;'"'"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"  #bash-3.2 does not like * as IFS in case
_debug "case \"$KERNEL\" start"
case "$KERNEL" in
0*|1*|2*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
;;
3*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
;;
*) _debug "UNHANDLED KERNEL='$KERNEL'"
;;
esac
_debug "case \"$KERNEL\" end"
IFS="$oldIFS"
}

_old
#_new

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"
KERNEL_RELEASE="$KERNEL"
UNAME_R="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

test "$kVERSION" -le 2 && { _process_kernel_2dotX; _eval_sfsversion $?; } || _eval_sfsversion 0
_debug "_kernel_version4:End"

_notice "_kernel_version4:KERNELVER='$KERNELVER'"
_info "_kernel_version4:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version4:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version4:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version4:squashXZ='$squashXZ'"

INFO=$oldINFO
DEBUG=$oldDEBUG
}




































_kernel_version5()
{
oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi
KERNEL_RELEASE="$KERNEL"
KERNELVER="$KERNEL"
KERNVER="$KERNEL"
UNAME_R="$KERNEL"

unset SFSSTR SFS_STR SFS_MAJOR SFSMAJOR squashXZ

if test ! "$*"; then
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
test "$SFS_STR" || { ( busybox modprobe -l | grep $Q '/squashfs.ko' ) && {
[ -f /proc/modules ] &&
grep $Q 'squashfs' /proc/modules || { modprobe $VERB squashfs; sleep 1; } ; }
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
}
test "$SFS_STR" || { _warn "Could not determine squashfs in dmesg, assuming \"version 4.0\""; SFS_STR='version 4.0'; }

SFS_MAJOR=`echo ${SFS_STR##* } | cut -b 1`
test "${SFS_MAJOR//[[:digit:]]/}" && SFS_MAJOR='';
test "$SFS_MAJOR" || { _warn "Could not determine squashfs major version, assuming '4'"; SFS_MAJOR=4; }

SFS_STR="squashfs, $SFS_STR"

else
:
fi

squashXZ=NOT
case "$KERNEL" in
3.*) squashXZ=YES
test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
test "$SFS_MAJOR" || SFS_MAJOR=4
;;
2.6.*) case $KERNEL in
     2.6.38*|2.6.39*) squashXZ=YES
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.29*|2.6.3[0-7]*)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.28*)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     2.6.27.47)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     *)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     esac
;;
*) _warn "_kernel_version5:UNHANDLED kernel version '$KERNEL' , assuming squashXZ=$squashXZ";;
esac

SFSSTR="$SFS_STR"
SFSMAJOR="$SFS_MAJOR"

case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
esac

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"
KERNEL_RELEASE="$KERNEL"
UNAME_R="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

_notice "_kernel_version5:KERNELVER='$KERNELVER'"
_info "_kernel_version5:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version5:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version5:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version5:squashXZ='$squashXZ'"

INFO=$oldINFO
DEBUG=$oldDEBUG
}

_ps_p(){
ps -A -o pid | grep -v 'grep' | grep $Q -w "$*"
return $?
}

__kill_pid(){
test "$*" || { _return 4 "_kill_pid: Usage: _kill_pid SIG PID"; return $?; }
test "$2" && kSIG="$2"
test "$1" && gPID="$1"
ps -A -o pid | grep -v 'grep' | grep $Q -w "$gPID" && kill $kSIG $gPID
return $?
}

_kill_pid(){
test "$*" || { _return 4 "_kill_pid: Usage: _kill_pid SIG PID"; return $?; }
test "$2" && kSIG="$2"
test "$1" && gPID="$1"
_ps_p "$gPID" && kill $kSIG $gPID
return $?
}


#================ Make free loop device ======================================
__mk_free_loop()
{
  FREE_LOOP=`losetup -f 2>>$ERR`  # find free and create loop
  [ "$FREE_LOOP" ] || {   # for kernel 3.0 and earlier
  LOOPS_ALL=`ls -1v /dev/loop* |sed 's%[^[:digit:]]%%g'`
  LOOP_LAST=`echo "$LOOPS_ALL" | tail -n1`
  LOOP_NEW=$(( $LOOP_LAST + 1 ))
  mknod /dev/loop${LOOP_NEW} b 7 $LOOP_NEW
  }
}

_mk_free_loop(){
    losetup -f >>$OUT 2>>$ERR || {
    read NR <<EoI
`echo $(ls /dev/loop[0-9]*) | wc -w`
EoI
    mknod /dev/loop$((NR+1)) b 7 $((NR+1))
}; }

#================ Check GETTEXT ==============================================
_check_gettext()
{
_G=`which gettext`
test "$_G" && {
 test "`which gettext.sh`" && {
export TEXTDOMAIN=f4puppy5 #NOTE: rename to avoid clash with 'remasterpup2.mo' used by previous i18n method.
export OUTPUT_CHARSET=UTF-8
. gettext.sh
test "`type -t eval_gettext`"   &&  _eG=eval_gettext
if test "`which ngettext`"; then
 test "`type -t eval_ngettext`" && _eNG=eval_ngettext
fi
  }
 }

test "$_G"   ||   _G=echo
test "$_eG"  ||  _eG=echo
test "$_eNG" || _eNG='echo -n'
#echo "_G='$_G'"
#echo "_eG='$_eG'"
#echo "_eNG='$_eNG'"
alias g_="$_G"
alias eg_="$_eG"
alias eng_="$_eNG"
}
_check_gettext

_killzombies()
{
 ZOMBIES="`_command ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -vE 'grep|\|\|\|' | awk '{print $1}'`"
 ZOMBIES=`_command ps -H -A | awk '{if ($3 == "Z" || $3 == "Z+" || $3 == "Z<" || $3 == "ZL" || $3 == "Zl" || $3 == "ZN" || $3 == "Zs") print $1}'`
 ZOMBIES=`_command ps -H -A | awk '{if (match($3,"Z[+<LlNs]") || $3 == "Z") print $1}'`
 for oneZOMBIE in $ZOMBIES
 do
  _command ps --no-header -p $oneZOMBIE || continue
  _notice " :Killing (parentless) zombie process '$oneZOMBIE' ..."
  kill $oneZOMBIE
 done
}

#===== XMESSAGE or SPLASH ====================================================
_get_yaf_args()
{
for exe in pupmessage gtkdialog-splash yaf-splash gxmessage xmessage; do
YAF=`which $exe`
test "$YAF" || continue
test -L "$YAF" && continue
case $YAF in

 pupmessage)yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#gtkdialog-splash

# an easy replacement for yaf-splash in Puppy (NOT Puppy <=4.x)
# mave 30.05.2010
# no warranty
# Thanks for Puppy!

# usage: gtkdialog-splash [OPTIONS] [-timeout SEC] -text TEXT | -kill [ PID ]

# -text EXPRESSION
# -timeout COUNT (in seconds)
# -icon GTK-XXX (for example: gtk-info all gtk-stock-symbols, default: none)
# OR path/to/pixmap.png|gif|jpeg
# -icon_width WIDTH in pixels
# -bg COLOR (background color red, blue, yellow..., default: grey)
# -bg_gradient true|false (default: true)
# -fg COLOR (font color, default: black)
# -placement center|mouse|top|bottom|top-left|bottom-left (default: center)
# -close never|mouseover|box (default is mouseover)
# -deco TITLE (shows windows decorations, with title)
# -font NAME
# -fontsize SIZE
# -align ALIGNMENT left, right or center -margin SIZE (default: 10)
# -border true|false (default: true)
# -kill [ PID ] ( When PID omitted, kills all GTKDIALOG_SPLASH found
# in ps output, PID must exist as /tmp/GTKDIALOG-SPLASHPID with PID content )

 gtkdialog-splash) yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#Usage: yaf-splash [ options ]
#Where options include:

#  -text                         Message to display.
#  -timeout                      How long to display the message before
#                                exiting. Default is 0, which means forever.
#  -clock                        Enable clock display.
#  -12                           Display twelve hour time (default).
#  -24                           Display twenty-four hour time.
#  -seconds                      Display seconds (default).
#  -noseconds                    Don't display seconds.
#  -countdown <date>             Display a countdown instead of a clock.
#                                Run `-countdown foo' to see date syntax.
#  -countdownquit                Quit after the countdown has reached
#                                zero (default).
#  -nocountdownquit              Keep counting after reaching zero.
#  -geometry <geometry>          Size and position of window.
#  -placement <placement name>   A screen location, one of center, top,
#                                bottom, right, left, top-right, top-left,
#                                bottom-left, bottom-right. Defaults to center.
#                                A specified placement will override -geometry.
#  -font <font>                  Name of an X font to use.
#  -transparent                  Make the window background be transparent,
#                                if possible.
#  -nontransparent               Don't (default).
#  -mirror                       Flip the text about the y axis. Useful for
#                                back projection.
#  -nomirror                     Don't (default).
#  -fg                           Set the forground text colour (default: black).
#  -bg                           Set the background colour (default: white).
#  -bd                           Set the border colour (default: black).
#  -bw                           Set the border width (default: 2).
#  -outline                      Set the text outline width (default: 1).
#  -margin                       Set the margin size (default: 0).

 yaf-splash) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg black"; yafFG="-fg orange"; yafPL="-placement center"; yafFONT="-font -*-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafFONT="-font -misc-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafEXTRA="-transparent"
  #yaf-splash: couldn't load font "'*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

 gxmessage)#yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;

#gxmessage - a GTK-based xmessage clone

#Usage: gxmessage [OPTIONS] message ...
#       gxmessage [OPTIONS] -file FILENAME

#xmessage options:
#  -file FILENAME         Get message text from file, '-' for stdin
#  -buttons BUTTON_LIST   List of "LABEL:EXIT_CODE", comma separated
#  -default LABEL         Give keyboard focus to the specified button
#  -print                 Send the selected button's LABEL to stdout
#  -center                Try to open window in the centre of the screen
#  -nearmouse             Try to open window near the mouse pointer
#  -timeout SECONDS       Exit with code 0 after SECONDS seconds

#X-like options:
#  -display DISPLAY       X display to use
#  -fn FONT | -font FONT  Set message font (works with GTK font names)
#  -fg COLOUR             Set message font colour
#  -bg COLOUR             Set message background colour
#  -geometry GEOMETRY     Set window size (position will be ignored)
#  -iconic                Start iconified
#  -name NAME             Program name as used by the window manager
#  -title TITLE           Set window title to TITLE

#gxmessage options:
#  -borderless            Try to open window without border decoration
#  -nofocus               Don't focus the window when it opens
#  -encoding CHARSET      Expect CHARSET as the message encoding
#  -entry                 Prompt for text to be sent to stdout
#  -entrytext TEXT        Same as -entry, but with TEXT as default text
#  -wrap                  Wrap lines of text to fit window width
#  -help | -?             Show this usage information
#  -version               Show gxmessage version information

 xmessage) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;
esac
break
done
_debug "Using '$YAF'"
}

_GTKdialog_error()
{
local RV MSG
test "$1" && { RV="$1"; shift; } || RV=1
test "$*" && { MSG="$0:$*"; shift; }
test "$MSG" || MSG="$0:GTKdialog GUI crashed. Please run with -d option"

if _pidof -q X; then
xmessage -bg red "$MSG"
else
_err "$MSG"
fi

case $RV in
0) return 0;;
*) $EXIT $RV;;
esac
}

_GTKdialog_remove_comments()
{

test "$*" || { _return 1 "No Input. Usage _GTKdialog_remove_comments DIALOG_GUI_CODE"; return 1; }
local sPATTERN1 sPATTERN2 sPATTERN3 sPATTERN4
sPATTERN1='s%<!--.*-->%%g'
sPATTERN2='/<!--/,/-->/d'
sPATTERN3='s%^#.*%%'
sPATTERN4='s%>.*#[^>]*$%%'

echo "$*" | sed -e "$sPATTERN1" -e "$sPATTERN2" -e "$sPATTERN3" -e "$sPATTERN4" || return 1
}

_GTKdialog_debug_gui()
{
test "$*" || { _return 2 "_GTKdialog_debug_gui: Usage: debugGUI=\`_GTKdialog_debug_gui \"$MAIN_DIALOG\"\`"; return $?; }

local lNR
lNR=0
echo "$*" | while read -r aLINE; do lNR=$((lNR+1)); echo "$lNR: $aLINE";done

}

_eval_error()
{
local RV MSG
test "$1" && { RV="$1"; shift; } || RV=1
test "$*" && { MSG="$0:$*"; shift; }
test "$MSG" || MSG="$0:eval failed. Probably due to faulty input."

if _pidof -q X; then
xmessage -bg red "$MSG"
else
_err "$MSG"
fi

case $RV in
0) return 0;;
*) $EXIT $RV;;
esac
}

_pidof()
{
local RV
case $1 in
-q) shift;
pidof ${*##*/} >/dev/null; return $?
;;
*)
echo -n "Pids of '$*' ( ${*##*/} ) :"
pidof ${*##*/}; RV=$?
test "$RV" = 0 || echo
return $RV
;;
esac
}

__get_jobs__(){

DEBUG=
DEBUGX=
[ "$MY_PID" ] || MY_PID=$$
local COMMANDO PiDS ProcPiD ProcPids pid ppid rest

[ "$*" ] && COMMANDO="$*" || COMMANDO="$MY_SELF"

 _debug "COMMANDO='$COMMANDO'"
 PiDS=`_command ps -o pid,ppid,s,args -C ${COMMANDO##*/},${MY_SELF##*/} --no-headers`
# PiDS="$PiDS
#`_command ps -o pid,ppid,s,args -C ${MY_SELF##*/} --no-headers`"
 _debug "PiDS='$PiDS'"
# ProcPiD=`echo "$PiDS" | awk '{print $1}'`
  ProcPids=`ps -o pid,ppid,s,args`
 _debug "ProcPiD='$ProcPiD'"

while read pid ppid rest
#while read pid
 do
  _debugx "pid=$pid ppid=$ppid MY_PID=$MY_PID unused=$rest"
  #[ "`echo "$ProcPiD" | grep -w "$ppid" | grep -vEw 'grep|read|echo|while|do|done|ps'`" ] && echo "$pid"
  #[ "`echo "$PiDS" | awk "{ if (\\$2 == $ppid) print}"`" ] && echo $pid
  #  echo "$PiDS" | awk "{ if (\$1 == $pid && \$2 == $MY_PID) print}"
  # [ "`echo "$PiDS" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
   _debugx `echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`
   [ "`echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
#done <<EoI
#$(echo "$ProcPids")
#EoI
  done <<EoI
$(echo "$PiDS" | tac)
EoI
return 0

}

__get_jobs(){

DEBUG=
DEBUGX=
[ "$MY_PID" ] || MY_PID=$$
local COMMANDO PiDS ProcPiD ProcPids pid ppid rest

[ "$*" ] && COMMANDO="$*" || COMMANDO="$MY_SELF"

 _debug "COMMANDO='$COMMANDO'"
 PiDS=`_command ps -o pid,ppid,s,args -C ${COMMANDO##*/},${MY_SELF##*/} --no-headers`
 _debug "PiDS='$PiDS'"

  ProcPids=`ps -o pid,ppid,s,args`
 _debug "ProcPiD='$ProcPiD'"

while read pid ppid rest
#while read pid
 do
  _debugx "pid=$pid ppid=$ppid MY_PID=$MY_PID unused=$rest"
  #[ "`echo "$ProcPiD" | grep -w "$ppid" | grep -vEw 'grep|read|echo|while|do|done|ps'`" ] && echo "$pid"
  #[ "`echo "$PiDS" | awk "{ if (\\$2 == $ppid) print}"`" ] && echo $pid
  #  echo "$PiDS" | awk "{ if (\$1 == $pid && \$2 == $MY_PID) print}"
  # [ "`echo "$PiDS" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
  # _debugx `echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`
  # [ "`echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
  echo "$ProcPids" | awk "{ if (\$1 == $pid && \$2 == $MY_PID) print \$1}"

#done <<EoI
#$(echo "$ProcPids")
#EoI
  done <<EoI
$(echo "$PiDS" | tac)
EoI
return 0

}

_get_jobs__(){

DEBUG=
DEBUGX=
[ "$MY_PID" ] || MY_PID=$$
local COMMANDO PiDS ProcPiD ProcPids pid ppid rest

[ "$*" ] && COMMANDO="$*" || COMMANDO="$MY_SELF"

 _debug "COMMANDO='$COMMANDO'"
 PiDS=`_command ps -o pid,ppid,s,args -C ${COMMANDO##*/},${MY_SELF##*/} --no-headers`
 _debug "PiDS='$PiDS'"

  ProcPids=`ps -o pid,ppid,s,args`
 _debug "ProcPiD='$ProcPiD'"

while read pid ppid rest
#while read pid
 do
  _debugx "pid=$pid ppid=$ppid MY_PID=$MY_PID unused=$rest"
  # [ "`echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
  echo "$ProcPids" | awk "{ if (\$1 == $pid && \$2 == $MY_PID) print \$1}"

#done <<EoI
#$(echo "$ProcPids")
#EoI
  done <<EoI
$(echo "$PiDS" | tac)
EoI
return 0

}

_get_jobs(){

DEBUG=
DEBUGX=
[ "$MY_PID" ] || MY_PID=$$
local COMMANDO PiDS ProcPiD ProcPids pid ppid rest

[ "$*" ] && COMMANDO="$*" || COMMANDO="$MY_SELF"

 _debug "COMMANDO='$COMMANDO'"
 PiDS=`_command ps -o pid,ppid,s,args --no-headers | awk "{ if (\\$2 == $MY_PID) print}"`
 _debug "PiDS='$PiDS'"

  ProcPids=`ps -o pid,ppid,s,args`
 _debug "ProcPiD='$ProcPiD'"

while read pid ppid rest
#while read pid
 do
  _debugx "pid=$pid ppid=$ppid MY_PID=$MY_PID unused=$rest"
  # [ "`echo "$ProcPids" | awk "{ if (\\$1 == $pid && \\$2 == $MY_PID) print}"`" ] && echo $pid
  echo "$ProcPids" | awk "{ if (\$1 == $pid && \$2 == $MY_PID) print \$1}"

#done <<EoI
#$(echo "$ProcPids")
#EoI
  done <<EoI
$(echo "$PiDS" | tac)
EoI
return 0

}

_get_jobs(){

DEBUG=
DEBUGX=
[ "$MY_PID" ] || MY_PID=$$
local COMMANDO PiDS ProcPiD ProcPids pid ppid rest

[ "$*" ] && COMMANDO="$*" || COMMANDO="$MY_SELF"

 _debug "COMMANDO='$COMMANDO'"
 MY_CHILDREN_PIDS=`_command ps -o pid,ppid,s,args --no-headers k -start_time | awk "{ if (\\$2 == $MY_PID) print \\$1}"`

 for oCP in $MY_CHILDREN_PIDS; do
   _command ps -o pid,ppid,s,args --no-headers k -start_time | awk "{ if (\$2 == $oCP) print \$1}"
   echo $oCP
 done

return 0

}

_kill_jobs(){

local KILL_PIDS pid
KILL_PIDS=`_get_jobs $* 2>>$ERR` || return 3

for pid in $KILL_PIDS
do
 _debug "pid=$pid"
 _command ps -p $pid --no-header && kill -9 $pid
done

for pid in `jobs -p`;
do
 _debug "pid='$pid'"
 _command ps -p $pid --no-header && kill -9 $pid
done
}

_batch_diff1()
{
local SIMPLE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2
_debug "_batch_diff1: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff [ -s ] DIR"; return 1 2>>$ERR || $EXIT 1; }

test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory"; return 1 2>>$ERR || $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>>$ERR || $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

#FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

#FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

     test "$oneF1" = "$oneF2" && continue

     if test "$SIMPLE"; then
      diff $Q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII
done <<EoI
`echo "$FILES1"`
EoI

}

_batch_diff2()
{
local SIMPLE INVERT FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff2 [ -s |& -i ] DIR"; return 1 2>>$ERR || $EXIT 1; }


test "$1" = '-s' && { SIMPLE=YES; shift; }
test "$1" = '-i' && { INVERT=YES; shift; }
test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory"; return 1 2>>$ERR || $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>>$ERR || $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff $Q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff $Q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_batch_diff3()
{
oldDEBUG=$DEBUG
DEBUG=1
local SIMPLE INVERT REMOVE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff3 [ -s -i | -r ] DIR"; return 1 2>>$ERR || $EXIT 1; }

while [ "$2" ]; do
case "$1" in
-s) SIMPLE=YES;;
-i) INVERT=YES;;
-r) REMOVE=YES;;
esac
shift
done

test -d "$@" || { _err "'$@' not a directory"; return 1 2>>$ERR || $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>>$ERR || $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff $Q "$oneF2" "$oneF1" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff $Q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff $Q "$oneF1" "$oneF2" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff $Q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi
DEBUG="$oldDEBUG"
}

_add_header()
{
local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

test "$DRY" || DRY=  ##DRY RUN - don't change the original file

pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep -viE 'perl|python|murgaLua_Dynamic' || continue

   grep 'f4puppy5' "$file" && continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   SHELLBANG=`head -n1 "$file"`

   case "$SHELLBANG" in
   \#\!*) :;;
   *) continue;;
   esac

   cat >/tmp/${file##*/} <<EoI
$SHELLBANG
#
# New header by $_AUTHOR_, $_MONTH_ $_YEAR_
  _TITLE_="Puppy_${file##*/}"
_VERSION_=1.0omega
_COMMENT_="\$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/$file"
MY_PID=\$\$

test -f /etc/rc.d/f4puppy5 && {
[ "\$HAVE_F4PUPPY5" ] || source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="\$_COMMENT_"
_parse_basic_parameters "\$@"
[ "\$DO_SHIFT" ] && [ ! "\${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in \`seq 1 1 \$DO_SHIFT\`; do shift; done; }

_trap

}
# End new header
#
EoI

   cat "$file" | sed '1d' >>/tmp/${file##*/}
   [ "$?" = 0 ] || continue
   if test ! "$DRY"; then ## DRY RUN
    rm "$file"
    mv $VERB /tmp/${file##*/} "$file"
    chmod $VERB $PERM "$file"
   fi

done
}

_remove_header()
{
 local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

test "$DRY" || DRY=  ##DRY RUN - don't change the original file

 pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep $Q -viE 'perl|python|murgaLua_Dynamic' || continue

   grep $Q "# New header by $_AUTHOR_, $_MONTH_ $_YEAR_" "$file" || continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   sed '/# New header by Karl Reimer Godt, September 2014/,/# End new header/ d' "$file" >/tmp/${file##*/}
   sed -i '2,3 d' /tmp/${file##*/}

   if test ! "$DRY"; then
   mv $VERB /tmp/${file##*/} "$file"
   chmod $VERB $PERM "$file"
   fi

done
}

_part_umount_func(){

rootSCREEN_XY=`_get_screen_resolution`     || rootSCREEN_XY=800x600+0+0
 rootCENTER_X=$((${rootSCREEN_XY%%x*}/2))
 #rootCENTER_Y=`expr $(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}') / 2`
 _Y_=$(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}')
 rootCENTER_Y=$((_Y_ / 2))

                    local M_POI M_OPS mpart_ yPID

 MOUNTED=`tac /proc/mounts |grep -E "^/dev/[fhms][dmr][[:alnum:]][^ ]*[0-9]? "`

 M_POI=`echo "$MOUNTED" | awk '{print $2}'`
 M_POI=`echo -e "$M_POI"`

 M_OPS=`echo "$MOUNTED" | awk '{print $4}'`
 M_OPS=`echo -e "$M_OPS"`

 M_DEV=`echo "$MOUNTED" | awk '{print $1}'`
 M_DEV=`echo -e "$M_DEV"`

for mpart_ in $M_POI;
do

    ## BIG PROBLEM un-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/umount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 5 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 1 Exit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # xmessage -bg orange "Slow drive '$mpart_' is mounted ..!
    # Please un-mount it manually,
    # and try to put the machine to sleep again !!"
    # exit 1
    #;;
    #esac

    ## Solution Nr. 3 Omit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    yaf-splash -bg pink -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Unmounting $mpart_ ..." & yPID=$!

    ##Solution Nr. 2 and 4 Reasonable or BIG sleep :
    case $mpart_ in
    */sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    esac

    /bin/umount $VERB -r "$mpart_"
[ $? -ne 0 ] && { xmessage -bg red2 "Please umount '$mpart_' manually and try again";exit 0; }

    ## Solution Nr. 2 Reasonable sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 15 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 15 seconds.." &
    # sleep 15;;
    #esac

    ## Solution Nr. 4 BIG sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg pink3 -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to stop the drive
    case $mpart_ in
     */sr[0-9]*|*/scd[0-9]*)
      hdparm $L_VERB -C /dev/${mpart_##*/} | grep $Q 'active' && {
           MSG="ERROR: Drive '/dev/${mpart_##*/}' still recognized as active.
           Exiting $PWD/$0."
           MSG=`echo "$MSG" | sed 's%^[[:blank:]]*%%'`
           xmessage -bg red -title "$MY_SELF" "$MSG"
           exit 5
      }
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C stop /dev/${mpart_##*/}
      sleep 17
     ;;

     */hd[a-d])
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB -Y /dev/${mpart_##*/}
      sleep 17
     ;;

     */fd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

    sleep 1
    kill $yPID
done
}

_restore_mounts(){

rootSCREEN_XY=`_get_screen_resolution`     || rootSCREEN_XY=800x600+0+0
 rootCENTER_X=$((${rootSCREEN_XY%%x*}/2))
 #rootCENTER_Y=`expr $(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}') / 2`
 _Y_=$(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}')
 rootCENTER_Y=$((_Y_ / 2))

                    local part_ basn FS_TYPE reMOUNT mntOPS yPID

for part_ in $M_DEV;
do

    ## BIG PROBLEM re-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/mount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 4 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 2 and 3 Omit to un- and or re-mount :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    yaf-splash -bg purple -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Restoring mount of $part_ ..." & yPID=$!

        grep $Q -w "$part_" /proc/mounts && reMOUNT='remount,'
        mntOPS=`echo "$MOUNTED" | grep -m1 -w "^$part_" | awk '{print $4}'`
            [ "$mntOPS" ] || mntOPS=rw
        FS_TYPE=`guess_fstype $part_`

    ## Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to wake-up the drive
    case $part_ in
     */sr[0-9]*|*/scd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C start $part_
      sleep 17
     ;;

     */hd[a-d])
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB --idle-immediate $part_
      sleep 17
     ;;

     */fd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

        basn=${part_##*/}
        mkdir -p /mnt/$basn

[ "$FS_TYPE" = unknown -o "$FS_TYPE" = "" ] && {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS             $part_ /mnt/$basn || true
} || {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS -t $FS_TYPE $part_ /mnt/$basn || false
}

    ## Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg purple3 -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    sleep 1
    kill $yPID
    unset reMOUNT mntOPS FS_TYPE
done
}

###END###
_HAVE_F4PUPPY5_=1
  HAVE_F4PUPPY5=1
###END###
