#!/bin/ash

[ "$HAVE_F4PUPPY5" ] && return 0

_assign_version()
{
case $1 in
_VERSION_) VERSION=$_VERSION_; Version=$_VERSION_; version=$_VERSION_;;
VERSION) _VERSION_=$VERSION; Version=$VERSION; version=$VERSION;;
Version) _VERSION_=$Version; VERSION=$Version; version=$Version;;
version) _VERSION_=$version; VERSION=$version; Version=$version;;
esac
}

test "$_VERSION_" && _assign_version _VERSION_ || _VERSION_=0.0.1b
test "$VERSION"   && _assign_version VERSION   ||   VERSION=0.0.1b
test "$Version"   && _assign_version Version   ||   Version=0.0.1b
test "$version"   && _assign_version version   ||   version=0.0.1b
SCRIPT_NAME=f4puppy5 # short for functions for puppy 5
test "$MY_SELF" || MY_SELF="$0"

case ${MY_SELF##*/} in
ash|bash|sh) EXIT=return;;
*)           EXIT=exit;;
esac

# colours
 Black0='\033[0;30m'
 Black1='\033[1;30m'
   Red0='\033[0;31m'
   Red1='\033[1;31m'
 Green0='\033[0;32m'
 Green1='\033[1;32m'
Yellow0='\033[0;33m'
Yellow1='\033[1;33m'
  Blue0='\033[0;34m'
  Blue1='\033[1;34m'
  Pink0='\033[0;35m'
  Pink1='\033[1;35m'
  Cyan0='\033[0;36m'
  Cyan1='\033[1;36m'
 White0='\033[0;37m'
 White1='\033[1;37m'

  Back0='\033[0;39m'
 Reset0='\033[0;39m'
Normal0='\033[0;39m'

 BackBlack0='\033[0;40m'
 BackBlack1='\033[1;30m'
   BackRed0='\033[0;41m'
   BackRed1='\033[1;41m'
 BackGreen0='\033[0;42m'
 BackGreen1='\033[1;42m'
BackYellow0='\033[0;43m'
BackYellow1='\033[1;43m'
  BackBlue0='\033[0;44m'
  BackBlue1='\033[1;44m'
  BackPink0='\033[0;45m'
  BackPink1='\033[1;45m'
  BackCyan0='\033[0;46m'
  BackCyan1='\033[1;46m'
 BackWhite0='\033[0;47m'
 BackWhite1='\033[1;47m'

  BackBack0='\033[0;49m'
 BackReset0='\033[0;49m'
BackNormal0='\033[0;49m'

 UsBlack0='\033[4;30m'
 UsBlack1='\033[4;1;30m'
   UsRed0='\033[4;31m'
   UsRed1='\033[4;1;31m'
 UsGreen0='\033[4;32m'
 UsGreen1='\033[4;1;32m'
UsYellow0='\033[4;33m'
UsYellow1='\033[4;1;33m'
  UsBlue0='\033[4;34m'
  UsBlue1='\033[4;1;34m'
  UsPink0='\033[4;35m'
  UsPink1='\033[4;1;35m'
  UsCyan0='\033[4;36m'
  UsCyan1='\033[4;1;36m'
 UsWhite0='\033[4;37m'
 UsWhite1='\033[4;1;37m'

 BoldBlack0='\033[5;30m'
 BoldBlack1='\033[5;1;30m'
   BoldRed0='\033[5;31m'
   BoldRed1='\033[5;1;31m'
 BoldGreen0='\033[5;32m'
 BoldGreen1='\033[5;1;32m'
BoldYellow0='\033[5;33m'
BoldYellow1='\033[5;1;33m'
  BoldBlue0='\033[5;34m'
  BoldBlue1='\033[5;1;34m'
  BoldPink0='\033[5;35m'
  BoldPink1='\033[5;1;35m'
  BoldCyan0='\033[5;36m'
  BoldCyan1='\033[5;1;36m'
 BoldWhite0='\033[5;37m'
 BoldWhite1='\033[5;1;37m'

 InvBlack0='\033[7;30m'
 InvBlack1='\033[7;5;30m'
   InvRed0='\033[7;31m'
   InvRed1='\033[7;5;31m'
 InvGreen0='\033[7;32m'
 InvGreen1='\033[7;5;32m'
InvYellow0='\033[7;33m'
InvYellow1='\033[7;5;33m'
  InvBlue0='\033[7;34m'
  InvBlue1='\033[7;5;34m'
  InvPink0='\033[7;35m'
  InvPink1='\033[7;5;35m'
  InvCyan0='\033[7;36m'
  InvCyan1='\033[7;5;36m'
 InvWhite0='\033[7;37m'
 InvWhite1='\033[7;5;37m'
# /colours

_status(){
 _TTY_=`tty`
 [ "$_TTY_" = 'not a tty' ] && _TTY_=/dev/console

 _CHARS_=${1//[[:digit:]]/}
 if [ "$_CHARS_" ];then echo -e "\\033[60G\\033[1;36m${_CHARS_}$Normal0" >$_TTY_
 set -- 0
 elif [ "$1" = 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone$Normal0"   >$_TTY_ #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed$Normal0" >$_TTY_ #red [failed].
  STATUS=0
 fi

 return $1 #return with same status as entry param.
}

_cd_program_dir()
{
ME_PROG=`readlink -f "$0"`
ME_DIR=${ME_PROG%/*}
_debug "Changing into '$ME_DIR'"
cd "$ME_DIR"
}

_check_if_already_running()
{
pidof -o $$ -o %PPID "${0##*/}" && {
        echo "Already running."
        $EXIT 1
 }
return $?
}

_check_for_terminal()
{
local MSG
MSG="Need a contolling terminal"
tty >/dev/null || {
echo -n "Pid of X server:"
pidof X && xmessage -br red "$MSG"; $EXIT 2; } || {
echo "$MSG"; $EXIT 2; }
return $?
}

__which_tty_is_X(){
#  2014-10-25
local ttyALL ttyX
#ps-FULL
ttyALL=`/bin/ps -A -o pid,ppid,tty,args | awk '{if (match($3, "tty[0-9]?")) print}'`
#busybox ps
#ttyALL=`busybox ps -A -o pid,ppid,tty,args | awk '{if (match($3, "4,[0-9]?")) print}'`
  _debugx "ttyALL='$ttyALL'"

#ps-FULL
   ttyX=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
#busybox ps
  #ttyX_=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  #ttyX=`stat -c %t','%T' '%n /dev/tty* | grep -w "^$ttyX_" | awk '{print $2}'`

  _info "X server found running on '$ttyX'"

#ps-FULL
  _DEV_TTY_X_="/dev/$ttyX"
      _TTY_X_="$ttyX"
#busybox ps
  #_DEV_TTY_X_="$ttyX"
  #    _TTY_X_=${ttyX##*/}

echo "$ttyX"
return 0
}

_which_tty_is_X(){
#  2014-10-25
local ttyALL ttyX
#ps-FULL
#ttyALL=`ps -A -o pid,ppid,tty,args | awk '{if (match($3, "tty[0-9]?")) print}'`
#busybox ps
ttyALL=`busybox ps -A -o pid,ppid,tty,args | awk '{if (match($3, "4,[0-9]?")) print}'`
  _debugx "ttyALL='$ttyALL'"
#ps-FULL
 #ttyX=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  ttyX_=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  ttyX=`stat -c %t','%T' '%n /dev/tty* | grep -w "^$ttyX_" | awk '{print $2}'`
  _info "X server found running on '$ttyX'"
#ps-FULL
  #_DEV_TTY_X_="/dev/$ttyX"
  #    _TTY_X_="$ttyX"
#busybox ps
  _DEV_TTY_X_="$ttyX"
      _TTY_X_=${ttyX##*/}

echo "$ttyX"
return 0
}

_get_tty_X_nr(){
#  2014-10-25
local ttyX nrVT
ttyX=`_which_tty_is_X`
test "$ttyX" || return 1
nrVT=${ttyX##*[[:alpha:][:punct:]_]}
   case $nrVT in
    [1-9]|[1-9][0-9]) echo $nrVT; true;;
    *) _err "'$nrVT' not in range of 1-9 | 10-99"; false;;
   esac
return $?
}

_switch_to_tty_X(){
#  2014-10-25
local nrVT RV
nrVT=`_get_tty_X_nr`
   case $nrVT in
    [1-9]|[1-9][0-9]) chvt $nrVT
                      RV=$?;
    [ $RV = 0 ] && {
    _info "OK, switched to tty${nrVT}"
     return 0
     true; } || {
    _err "chvt '$nrVT' returned with '$RV' exitcode"
     return 1
     false; }
    ;;
    *) _err "'$nrVT' not in range of 1-9 | 10-99"; false;;
   esac
return $?
}

_logged_in_on_tty(){
local WHO_ RV USERS_ USERSm USERSs USERSa
WHO_=`_command who -a`
RV=$?
USERS_=`echo "$WHO_" | grep '^[[:alnum:][:punct:]_]'`
RV=$((RV+$?))
[ "$USERS_" ] || RV=$((RV+1))
USERSm=`echo "$USERS_" | tr -s ' '`
RV=$((RV+$?))
[ "$USERSm" ] || RV=$((RV+1))
USERSs=`echo "$USERSm"| sort -k4,5 -t' '`
RV=$((RV+$?))
[ "$USERSs" ] || RV=$((RV+1))
USERSa=`echo "$USERSs" | awk '{if (match($3, "tty[0-9]?")) print}'`
RV=$((RV+$?))
[ "$USERSa" ] || RV=$((RV+1))
echo "$USERSa"
RV=$((RV+$?))
return $RV
}

__logged_in_on_tty(){
###STUB### ##BB who does not show YEAR :(##
local WHO_ RV USERS_ USERSm USERSs USERSa
WHO_=`busybox who -a`
RV=$?
USERS_=`echo "$WHO_" | grep '^[[:alnum:][:punct:]_]'`
RV=$((RV+$?))
[ "$USERS_" ] || RV=$((RV+1))
USERSm=`echo "$USERS_" | tr -s ' '`
RV=$((RV+$?))
[ "$USERSm" ] || RV=$((RV+1))
USERSs=`echo "$USERSm"| sort -k4,5 -t' '`
RV=$((RV+$?))
[ "$USERSs" ] || RV=$((RV+1))
USERSa=`echo "$USERSs" | awk '{if (match($3, "tty[0-9]?")) print}'`
RV=$((RV+$?))
[ "$USERSa" ] || RV=$((RV+1))
echo "$USERSa"
RV=$((RV+$?))
return $RV
}

_last_logged_in_on_tty(){
local lastL RV
lastL=`_logged_in_on_tty | tail -n1`
RV=$?
[ "$lastL" ] || RV=$((RV+1))
echo "$lastL"
RV=$((RV+$?))
return $RV
}


_exit()
{
RV=$1
shift
echo "$*"
$EXIT $RV
}

_trap()
{
trap "_exit 99 \"Caught Signal\"" INT KILL TERM
}

_version()
{
echo "$0:Version:$VERSION"
[ "$TWO_VERSION" ] && return 0
$EXIT 0
}

 _have_all_commands()
{

haveALL_COMMANDS=MAYBE

grep -I -oE -e '=`[^ ]*| \| [^ ]*' "$0" | grep -v '=.*=' | sort -u | sed 's@^=`@@;s@| @@' |
while read oneCOMMAND;
  do
#which $oneCOMMAND || haveALL_COMMANDS=NO;
test "`which "$oneCOMMAND"`" -o "`type "$oneCOMMAND"`" || { haveNOT_COMMAND="$haveNOT_COMMAND $oneCOMMAND"; haveALL_COMMANDS=NOT; }
done

[ "$haveALL_COMMANDS" = MAYBE ] && haveALL_COMMANDS=YES

  if test "$haveALL_COMMANDS" = YES; then
_debug "haveALL_COMMANDS=$haveALL_COMMANDS"
elif test "$haveALL_COMMANDS" = NOT; then
_warn "Don't have all needed commands! Here they are:
$haveNOT_COMMAND
"
else
_err "Unhandled haveALL_COMMANDS '$haveALL_COMMANDS'"
  fi
}

_usage()
{
local USAGE_MSG RV
RV=$1
shift
test "$PARAMETER_LIST" || PARAMETER_LIST=PARAMETERS
test "$PARAMETERS" || PARAMETERS="NONE YET"
USAGE_MSG="
$0 [ $PARAMETER_LIST ]

PARAMETERS :
$PARAMETERS
--
$*
"
echo "$USAGE_MSG"

if [ "$TWO_HELP" ]; then
 return 0
else
 if test "$RV" != 0; then
   _exit $RV "Try again. Good Luck!"
 else
   $EXIT $RV
 fi
fi
return $?
}

_provide_basic_parameters()
{
test "$ADD_PARAMETER_LIST" && ADD_PARAMETER_LIST="|$ADD_PARAMETER_LIST"
PARAMETER_LIST="-help|-version|-verbose|-debug$ADD_PARAMETER_LIST"
PARAMETERS="
-h|--help    : Show this message and exit.
-V|--version : Show version information and exit.
-v|--verbose : Supress /dev/null and quiet options, verbose options to binaries.
-d|--debug   : Run program with set -x .
$ADD_PARAMETERS
"
}

#Set defaults
_set_default_flags(){
OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=--quiet;DBG='';L_DBG='';A_DBG=''
export OUT ERR Q QUIET DBG L_DBG A_DBG
}
_set_default_flags

_set_verbose_flags(){
    _parse_cmdline_loglevel
    VERBOSE=1;
    EMERGENCY=1;ALERT=1;CRIT=1;ERROR=1;WARN=1;NOTICE=1;
    NOTICE2=1;INFO=1;
    VERB=-v;A_VERB=-verbose;L_VERB=--verbose;
    Q='';   QUIET='';
    DBG=-d;L_DBG=--debug;  A_DBG=-debug;
    OUT=/proc/self/fd/1;ERR=/proc/self/fd/2;
}

_parse_basic_parameters()
{

[ "$OUT" ]   || OUT=/dev/null;
[ "$ERR" ]   || ERR=$OUT;
[ "$Q" ]     || Q=-q;
[ "$QUIET" ] || QUIET=--quiet;
[ "$DBG" ]   || DBG=''
[ "$L_DBG" ] || L_DBG=''
[ "$A_DBG" ] || A_DBG=''

local OPT_ARG oldOPTIND=$OPTIND oldOPTERR=$OPTERR
OPTERR=0
OPTIND=0

_debug "_parse_basic_parameters: \$1='$1'"
case $1 in

-h|-H|*help)

while getopts h:: option_ 2>$ERR
do
 case $option_ in
  h) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done

#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR

DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"

[ "$OPT_ARG" = elp ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

_usage 0 "$ADD_HELP_MSG";;
#VERSION
-V|*version)

while getopts V:: option_ 2>$ERR
do
 case $option_ in
  V) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done
DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
[ "$OPT_ARG" = ersion ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

_version;;

#VERBOSE
-v*|*verbose*)
_debug "HAVE verbose"
while getopts v:: option_ 2>$ERR
do
 case $option_ in
  v) OPT_ARG="$OPTARG";;
  *) false;;
 esac
 sleep 0.1
done
DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
#[ "$OPT_ARG" = erbose ] && OPT_ARG='';
case $OPT_ARG in
erbose|cli|composeonly) OPT_ARG='';;
[v\-]*) _debug "GOT '$OPT_ARG'";OPT_ARG_="$OPT_ARG";OPT_ARG='';
esac
_debug "OPT_ARG='$OPT_ARG' OPT_ARG_='$OPT_ARG_'"
[ "$OPT_ARG" ] && return 0

#VERBOSE=1;VERB=-v;A_VERB=-verbose;L_VERB=--verbose;Q='';QUIET=$Q;DBG=-d;L_DBG=--debug;A_DBG=-debug
#INFO=1;OUT=/proc/self/fd/1;ERR=/proc/self/fd/2; [ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1));;
_set_verbose_flags
INFO=1

increaseV=0
for aCHAR in `echo "$OPT_ARG_" |sed -r 's%(.)% \1%g'`; do
_debug "aCHAR='$aCHAR'"
case $aCHAR in
v) :;;
*) continue;;
esac
increaseV=$((increaseV+1));                     done

  if test $increaseV = 1; then
INFO2=1;DEBUG=1
elif test $increaseV -ge 2; then
INFO2=1;DEBUG=1;DEBUG2=1
fi

[ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1))
;;
#DEBUG
-d*|*debug*)

while getopts d:: option_ 2>$ERR
do
 case $option_ in
  d) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done
DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
[ "$OPT_ARG" = ebug ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

set -x; [ "$TWO_DEBUG" ] || DO_SHIFT=$((DO_SHIFT+1));;
esac
OPTERR=$oldOPTERR
export OUT ERR Q QUIET DBG VERB L_VERB A_VERB
}

__order_parameters()
{
oldIFS="$IFS"
IFS=$'\n'

while read -r aLINE
 do

  _debugx "aLINE='$aLINE'"

  case "$aLINE" in

## Example for option having OPTARG :
#  -X) read anoLINE
#      echo "anoLINE='$anoLINE'"
#      OPTIONS_="$OPTIONS_
#$aLINE $anoLINE";;

  -*)  OPTIONS_="$OPTIONS_
$aLINE";;
  *)   PARAMETERS_="$PARAMETERS_
$aLINE";;
  esac

 done <<EoI
`echo "$*"`
EoI

_debug "OPTIONS_='$OPTIONS_'"
_debug "PARAMETERS_='$PARAMETERS_'"

set - $OPTIONS_ $PARAMETERS_
_debug "\$*='$*'"
_debug "\$@='$@'"
_debug "\$#='$#' OPT_IND='$OPTIND'"
IFS="$oldIFS"
}

_order_parameters()
{
    _debug "\$*='$*'"
    _debug "\$@='$@'"
    _debug "\$#='$#'"
__order_parameters $*
                    if [ "$OPTIONS_" -a "$PARAMETERS_" ]; then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $OPTIONS_ $PARAMETERS_
                        IFS="$oldIFS"
                elif [ "$OPTIONS_" ];    then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $OPTIONS_
                        IFS="$oldIFS"
                elif [ "$PARAMETERS_" ]; then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $PARAMETERS_
                        IFS="$oldIFS"
                     fi
    _debug "\$*='$*'"
    _debug "\$@='$@'"
    _debug "\$#='$#'"
    unset OPTIONS_ PARAMETERS_
}

__getopt()
{

#POSIXLY_CORRECT=    ##
#GETOPT_COMPATIBLE=  ##

GET_OPT=`busybox getopt \
      -a -l help,version \
      -o h,V \
      -s sh \
      "$*"`
test $? = 0 || _usage 2 "Wrong option."

set - "`echo "$GET_OPT" | sed "s^' '^'\n'^g"`"

while read oneOPTION
do
test "$oneOPTION" || continue
case $oneOPTION
in
*) :;;
esac
done<<EoI
`set`
EoI
set -
return $?
}

_getopts()
{
    DEBUG=1;DEBUG2=1
    _debug  "_getopts:'$*'"
    _debuge "_getopts:OPTIND=$OPTIND OPTERR=$OPTERR"
local oneOPTION
allOPS=AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz-
#while getopts hV oneOPTION
while getopts $allOPS oneOPTION
do
case $oneOPTION
in
d|h|V|v) _parse_basic_parameters $*; break;;
#h) _usage 0;;
#V) _version;;
#v) _parse_basic_parameters $*;;
#d) set -x;;
*) _warn -p "Unsupported option '$oneOPTION'";;
esac
sleep 0.1
done
return $?
}


_string_to_octal()
{
_debug "_string_to_octal:$*" >&2
unset oSTRING
if test "$*"; then
STRING_ORIG="$*"

STRING=`echo "$STRING_ORIG" | sed 's!\(.\)!"\1"\n!g'`
_debug "_string_to_octal:STRING='$STRING'" >&2


while read -r oneCHAR
do
oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
oCHAR=`printf %o \'"$oneCHAR"`

oSTRING=$oSTRING"\\0$oCHAR"

done<<EoI
`echo "$STRING"`
EoI

else

while read -r oneLINE
do
#test "$oneLINE" || continue
 _debug "oneLINE='$oneLINE'" >&2
 STRING=`echo "$oneLINE" | sed 's!\(.\)!"\1"\n!g'`
 _debugx "STRING='$STRING'" >&2
 while read -r oneCHAR
 do
 _debugx "oneCHAR='$oneCHAR'" >&2
 oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
 _debug "oneCHAR='$oneCHAR'" >&2
 oCHAR=`printf %o \'"$oneCHAR"`
 _debug "oCHAR='$oCHAR'" >&2
 #test "$oCHAR" = 134 && oCHAR=0134

 oSTRING=$oSTRING"\\0$oCHAR"
 _debugx "oSTRING='$oSTRING'" >&2

 done<<EoI
`echo "$STRING"`
EoI

oSTRING=$oSTRING"\\012"
done

fi

echo "$oSTRING"

}

_test()
{
#test "$*"
test $*
case $? in
0)
echo "'$*'" OK
return 0
;;
1)
echo "! '$*'"
return 1
;;
2)
echo "'$*'" wrong input
return 1
;;
esac
return $?
}

_get_argv()
{
local oneARG
for oneARG in $*
do
case $oneARG
in
*help)    _usage 0;;
*version) _version;;
*) :;;
esac
done
return $?
}

_logger()
{
local MESSAGE PRIORITY TAG
case $# in
1) MESSAGE="$*";;
2) PRIORITY=$1
   shift
   MESSAGE="$*";;
''|0) echo "$0:_logger [ PRRIORITY ] [[ TAG ]]:Need at least MESSAGE." >&2
      return 1;;
*)
PRIORITY=$1
shift
TAG="$1"
shift
MESSAGE="$*"
;;
esac

#_test "\"$PRIORITY\"" != '""' || PRIORITY=7
#_test "\"$TAG\"" != '""'      || TAG=${0##*/}

_check_content "$PRIORITY" || PRIORITY=7
_check_content "$TAG"      || TAG=${0##*/}

logger -p $PRIORITY -t "$TAG" "$MESSAGE"
return $?

#May 29 09:21:57 puppypc user.debug  /bin/sh: TESTING logger 7
#May 29 09:22:13 puppypc user.info   /bin/sh: TESTING logger 6
#May 29 09:22:19 puppypc user.notice /bin/sh: TESTING logger 5
#May 29 09:22:26 puppypc user.warn   /bin/sh: TESTING logger 4
#May 29 09:22:32 puppypc user.err    /bin/sh: TESTING logger 3
#May 29 09:22:37 puppypc user.crit   /bin/sh: TESTING logger 2
#May 29 09:22:43 puppypc user.alert  /bin/sh: TESTING logger 1
#May 29 09:22:48 puppypc user.emerg  /bin/sh: TESTING logger 0
#May 29 09:22:06 puppypc user.emerg  /bin/sh: TESTING logger 8

}

_date(){
P="$1"
[ -z "$P" ] && P='s'

case $P in
s) date +%Y_%m_%d ;;
o) date +%d%b%Y ;;
*) date;;
esac
}

#======== Accumulating Errors and create Message Variable ====================
_basic_error_check()
{
local USAGE RV
USAGE="Usage: _basic_error_check \$? \"MESSAGE\""
RV=$1
test "$RV" || { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
test "${RV//[0-9]/}" && { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
shift
if test "$RV" != "0"; then
__ERRORS__="$__ERRORS__
'$*' returned '$RV'"
fi
return $RV
}

_check_content()
{
test "$*" || { _err "Usage: _check_content VARIABLE -- got '$*'"; return 0; }
ENOCONTENT=28
#test "$*" && return 0 || { _err "NO content."; return $ENOCONTENT; }
#echo "'`eval echo \\$$*`'"
test "`eval echo \\$$*`" && return 0 || { _err "$*:NO content."; return $ENOCONTENT; }
}

_check_content2()
{
test "$2" || { _err "Usage: _check_content2 PATTERN VARIABLE -- got '$*'"; return 0; }
EWRONGCONTENT=29
unset sPATTERN gPATTERN
local sPATTERN gPATTERN
#echo -n "`eval echo \\$$*`"' : '
#echo "`eval echo \\$\${*//[[:digit:]]/}`"

case $1 in
  digit) gPATTERN="[[:digit:]]";;
nodigit|onlydigit|digitonly) gOPT=-v;gPATTERN="[[:digit:]]";
test "`echo $(eval echo \\$\${*//[[:digit:]]/})`" && { _warn "$*:Other than :digit: content."; return $EWRONGCONTENT; } || return 0;;
  alpha) gPATTERN="[[:alpha:]]";;
noalpha|onlyalpha|alphaonly) gOPT=-v;gPATTERN="[[:alpha:]]";
test "`echo $(eval echo \${*//[[:alpha:]]/})`" && { _warn "$*:Other than :alpha: content."; return $EWRONGCONTENT; } || return 0;;
  alnum) gPATTERN="[[:alnum:]]";;
noalnum|onlyalnum|alnumonly) gOPT=-v;gPATTERN="[[:alnum:]]";
test "`echo $(eval echo \${*//[[:alnum:]]/})`" && { _warn "$*:Other than :alnum: content."; return $EWRONGCONTENT; } || return 0;;
  punct) gPATTERN="[[:punct:]]";;
nopunct|onlypunct|punctonly) gOPT=-v;gPATTERN="[[:punct:]]";
test "`echo $(eval echo \\$\${*//[[:punct:]]/})`" && { _warn "$*:Other than :punct: content."; return $EWRONGCONTENT; } || return 0;;
  space) gPATTERN="[[:space:]]";;
nospace|onlyspace|spaceonly) gOPT=-v;gPATTERN="[[:space:]]";
test "`echo $(eval echo \\$\${*//[[:space:]]/})`" && { _warn "$*:Other than :space: content."; return $EWRONGCONTENT; } || return 0;;
  blank) gPATTERN="[[:blank:]]";;
noblank|onlyblank|blankonly) gOPT=-v;gPATTERN="[[:blank:]]";
test "`echo $(eval echo \\$\${*//[[:blank:]]/})`" && { _warn "$*:Other than :blank: content."; return $EWRONGCONTENT; } || return 0;;
'') :;;
no*|only*|*only) gOPT=-v;gPATTERN="$*";;
*) gPATTERN="$*";;
esac
shift

#test "`echo "$*" | grep -E "$gPATTERN"`" && return 0 || return $EWRONGCONTENT
#echo "$*" | grep -q -E "$gPATTERN" && return 0 || return $EWRONGCONTENT
#echo "`eval echo \\$$*`"

if test "$gOPT" = '-v'; then
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && { _warn "$*:Other than '$gPATTERN' content."; return $EWRONGCONTENT; } || return 0
else
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && return 0 || { _warn "$*:No '$gPATTERN' content."; return $EWRONGCONTENT; }
fi
}

#================= Check /tmp if read-write ==================================
_check_proc()
{
  mountpoint $Q /proc && return $? || {
  busybox mount $VERB $VERB -o remount,rw /dev/root/ /
  test -d /proc || mkdir -p /proc
  busybox mount $VERB $VERB -t proc none /proc
  return $?
 }
}

_check_tmp()
{
 test -d /tmp && return $? || {
 busybox mount $VERB $VERB -o remount,rw /dev/root/ /
 mkdir -p /tmp
 chmod $VERB 1777 /tmp
 return $?
 }
}

_check_tmp_rw()
{
_check_proc || _crit "Difficulties with /proc  .."
_check_tmp  || _crit "Difficulties with /tmp  .."

mountpoint $Q /tmp && {
grep -w '/tmp' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw tmpfs /tmp; return $?; }
 } || {
grep '^/dev/root' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw /dev/root/ /; return $?; }
 }
}

#============= Avoid multiple instances of sync ==============================
# busybox NOFORK and SH_STANDALONE sync do not emit a PID
[ "`which sync`" ] && alias sync="`which sync`"
_sync()
{
pidof sync >>$OUT || sync
}

#=============== LOGLEVEL / DEBUG MESSAGES ==================================
[ "$EMERGENCY" ] || EMERGENCY=1
[ "$ALERT" ]     || ALERT=1
[ "$CRIT" ]      || CRIT=1
[ "$ERROR" ]     || ERROR=1
[ "$WARN" ]      || WARN=1
[ "$NOTICE" ]    || NOTICE=1
[ "$NOTICE2" ]   || NOTICE2=1
[ "$INFO" ]      || INFO=
[ "$INFO2" ]     || INFO2=
[ "$DEBUG" ]     || DEBUG=
[ "$DEBUGX" ]    || DEBUGX=

# simple functions:
 _emerg(){ test "$EMERGENCY" || return 0; echo "$0:EMERGENGY:$*"; }
 _alert(){ test "$ALERT"  || return 0; echo "$0:ALERT:$*";     }
  _crit(){ test "$CRIT"   || return 0; echo "$0:CRITICAL:$*";  }
   _err(){ test "$ERROR"  || return 0; echo "$0:ERROR:$*";     }
  _warn(){ test "$WARN"   || return 0; echo "$0:WARNING:$*";   }
_notice(){ test "$NOTICE" || return 0; echo "$0:NOTICE:$*";    }
  _info(){ test "$INFO"   || return 0; echo "$0:INFO:$*";      }
 _debug(){ test "$DEBUG"  || return 0; echo "$0:DEBUG:$*";     }
_debugx(){ test "$DEBUGX" || return 0; echo "$0:DEBUGX:$@";    }

_parse_cmdline_loglevel(){

                            local LOG_LEVEL LOG_LEVEL_ aL

if test "$loglevel"; then
 LOG_LEVEL="$loglevel"
elif test "$LOGLEVEL"; then
 LOG_LEVEL="$LOGLEVEL"
fi

if test ! "$LOG_LEVEL"; then
 test -e /proc/cmdline || return 0
 LOG_LEVEL_=`grep -i -o 'loglevel=[^[:space:]]*' /proc/cmdline | tr '[:upper:]' '[:lower:]'`
 test "$LOG_LEVEL_" && { eval "$LOG_LEVEL_" && LOG_LEVEL=$loglevel; }
 test "$LOG_LEVEL" || { grep $Q -w debug /proc/cmdline >&2 && LOG_LEVEL=7; }
fi

#if test "$LOG_LEVEL" && [ ! "${LOG_LEVEL//[[:digit:]-]/}" ];
if test "$LOG_LEVEL"; then
if test ! "${LOG_LEVEL//[[:digit:]-]/}"; then
    # setting loglevel 8 to 0 and 9 to 1 ...
    while test "$LOG_LEVEL" -gt 7; do LOG_LEVEL=$((LOG_LEVEL-8)); done
    test "$LOG_LEVEL" -lt 0 && LOG_LEVEL=0

    for aL in `seq $LOG_LEVEL -1 0`; do
    case $aL in
    7) DEBUG=1;;
    6) INFO=1;;
    5) NOTICE=1;;
    4) WARN=1;;
    3) ERROR=1;;
    2) CRIT=1;;
    1) ALERT=1;;
    0) EMERGENCY=1;;
    *) false;;
    esac                        ; done
else
 _crit "CRITICAL WARNING: loglevel set to wrong '$LOG_LEVEL' parameter at the bootloader kernel commandline" >&2
fi;else
 _notice "No loglevel specified at bootloader kernel commandline" >&2
fi
}
#_parse_cmdline_loglevel


#advanced functions:
# simple functions with p postchar and or echo -n -e options as first parameter
_print_pretty(){
                # $1=LABEL ie ERROR, $2=Color for Label, $3=Color for EXE, $4 fg color for :, $5 bg color for :, $* MESSAGE
    if test "$PRETTY"; then
 echo -en "$3""$0""$4""$5"":""${Normal0}""$2""$1""$4""$5"":""${Normal0}"
    for i in `seq 1 1 5`; do shift; done
 echo -e "$*"

    else
 echo -n "$1:"
    for i in `seq 1 1 5`; do shift; done
 echo $echoOPT "$*"
    fi
   unset PRETTY echoOPT
}

_test_echo_opt(){
    unset echoOPT
    #DEBUG=1
    _debug "_test_echo_opt: \$1='$1' \$*='$*'"
    DO_SHIFT=0
    _debug "_test_echo_opt: \$1='$1' \$*='$*'"
        while test $# -gt 1 ; do
        _debugx "\$1='$1' \$#='$#'"

        {
        case $1 in -ne|-en|-n|-e) echoOPT="$echoOPT $1";DO_SHIFT=$((DO_SHIFT+1));; -p) PRETTY=1;DO_SHIFT=$((DO_SHIFT+1));; *) PRETTY=1;; esac; shift
        };                 done
}

_emergp(){
test "$EMERGENCY" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty "0* EMERGENCY" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_alertp(){
test "$ALERT" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "1*     ALERT" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"
}

_critp(){
test "$CRIT" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "2*  CRITICAL" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_errp(){
test "$ERROR" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty "3*        ERROR" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_warnp(){
test "$WARN" || return 0

  DO_SHIFT=0
 _debug "_warn:\$#=$# \$*='$*'"
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "4*   WARNING" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_noticep(){
test "$NOTICE" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "5*    NOTICE" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_notice2p(){
test "$NOTICE2" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**   NOTICE2" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_infop(){
test "$INFO" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "6*      INFO" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_info2p(){
test "$INFO2" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**     INFO2" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_debugp(){
test "$DEBUG" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "7*     DEBUG" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

#[ "$DEBUGX" ] || DEBUGX=
#_debugx(){
#test "$DEBUGX" || return 0
#echo "$0:DEBUGX:$@"
#}

[ "$DEBUGE" ] || DEBUGE=
[ "$DEBUGX" ] && DEBUGE=$DEBUGX
[ "$DEBUG2" ] && DEBUGE=$DEBUG2
[ "$DEBUGA" ] && DEBUGE=$DEBUGA
_debugep()
{
[ "$DEBUGX" ] && DEBUGE=$DEBUGX
[ "$DEBUG2" ] && DEBUGE=$DEBUG2
[ "$DEBUGA" ] && DEBUGE=$DEBUGA
test "$DEBUGE" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**   EXTREME" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

alias _debugap=_debugep
alias _debug2p=_debugep
alias _debugxp=_debugep
alias -p >>$OUT 2>$ERR

# simple functions with date and timestamp:
_date_FT(){ _DATE_FT_=`date +%F-%T`; }

 _emergd(){ test "$EMERGENCY" || return 0; _date_FT ; echo "$0:$_DATE_FT_:EMERGENGY:$*"; unset _DATE_FT_; }
 _alertd(){ test "$ALERT"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ALERT:$*";    unset _DATE_FT_;     }
  _critd(){ test "$CRIT"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:CRITICAL:$*"; unset _DATE_FT_;     }
   _errd(){ test "$ERROR"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ERROR:$*";    unset _DATE_FT_;     }
  _warnd(){ test "$WARN"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:WARNING:$*";  unset _DATE_FT_;     }
_noticed(){ test "$NOTICE" || return 0; _date_FT ; echo "$0:$_DATE_FT_:NOTICE:$*";   unset _DATE_FT_;     }
  _infod(){ test "$INFO"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:INFO:$*";     unset _DATE_FT_;     }
 _debugd(){ test "$DEBUG"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUG:$*";    unset _DATE_FT_;     }
_debugxd(){ test "$DEBUGX" || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUGX:$@";   unset _DATE_FT_;     }

[ "$DEBUGT" ] || DEBUGT=
_debugt()
{  #$1 label #$2 time

test "$DEBUGT" || return 0
    #unset LANG LC_ALL
    local _TIME_ LC_NUMERIC=C LANG= LC_ALL=
    _DATE_=`date +%s.%N | sed 's:.*\(..\..*\):\1:'`
    #_DATE_=`date +%s,%N | sed 's:.*\(..\,.*\):\1:'`
    if test "$2"; then
    _TIME_=`dc $_DATE_ $2 \- p`
    echo "$0:TIME:$1:$_TIME_"
    else
    #echo "$0:TIME:$*:`date +%s.%N | sed 's:.*\(..\..*\):\1:'`"
    echo "$0:TIME:$*:$_DATE_"
    fi
}

#=================== Prefer Busybox applets ==================================
_use_busybox_applets()
{
[ "`which busybox`" ] && BBEXE=`which busybox`
[ "$BBEXE" ] || { [ -s /bin/busybox -a -x /bin/busybox ] && BBEXE='/bin/busybox'; }
[ "$BBEXE" ] || return 2  ##errno.h:define ENOENT 2 /* No such file or directory */

BBAPPLETS=`$BBEXE --list`

test "$BBAPPLETS" || BBAPPLETS='basename cat chmod chown clear cut
date dc dd dirname dmesg du ed expr false find free
head kill ln login ls lsmod mkdir mknod more mv nice pidof
readlink rev rm rmdir sleep sort stat su sync tail tar touch tr true
uname usleep waitmax wc which xargs'

for applet in $BBAPPLETS
do
#echo $applet
#file "`which $applet`" | grep 'link' | grep busybox || continue
eval "alias ${applet}=\"$BBEXE $applet\"";

done
}

#================ return with message, same as _exit =========================
_return()
{
RV=$1
 test "$RV" && shift || {
 false
 }
test "${RV//[0-9]/}" && RV=123
echo "$*"
return $RV
}

#================== Use binary instead of busybox applet =====================
_command() # This is for busybox with internals first .
{          # sed -i and grep -w may not work as the regular binaries ,
           # especially if compiled without REGEX or not with GLIBC
#echo "$0:_command:$1:$*"
COM="$1"
shift
#echo "$0:_command:$1:$*"

typeCOM=`type -p "$COM"`
test "$typeCOM"  ||  { _return 1 "No such type \"$COM\"" >&2;return $?; }

whichCOM=`which "$COM"`
test "$whichCOM" || { _return 1 "No such which \"$COM\"" >&2;return $?; }

_debug "_command:$COM:$@" >&2

test "$typeCOM" = "$whichCOM" && {
 "$typeCOM" "$@"    # "$*" does not work, so needs "$@"
 return $?
 } || {
 "$whichCOM" "$@"
 return $?
 }
}

#========= make nodes in /dev if /dev not mounted ============================
_mkdevices()
{
mountpoint $Q /dev && return 0
test "`type mdev`" && { mdev -s; return $?; }
 while read maj min siz dev ; do
  [ "${maj//[[:digit:]]/}" ] && continue
  [ "$maj" -a "$min" -a "$dev" ] || continue
  test -b /dev/$dev || mknod /dev/$dev b $maj $min
 done</proc/partitions
}

#============ Test to filter out links =======================================
_test_f()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" && return 0
return 1
}
#= readable to source
_test_fr(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -r "$*" && return 0
return 1
}
#= writable to write to
_test_fw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -w "$*" && return 0
return 1
}
_test_frw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}
#= file and xecutable
_test_fx(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -x "$*" && return 0
return 1
}
#= file and has size
_test_fs(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -s "$*" && return 0
return 1
}
#= file readable and size
_test_frs(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -r "$*" -a -s "$*" && return 0
return 1
}

_test_d()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" && return 0
return 1
}

_test_drwx()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -w "$*" -a -x "$*" && return 0
return 1
}

_test_drx()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -x "$*" && return 0
return 1
}

_test_dwx()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -w "$*" -a -x "$*" && return 0
return 1
}

_test_drw()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_dr()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -r "$*" && return 0
return 1
}

_test_dw()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -w "$*" && return 0
return 1
}

_test_dx()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" -a -x "$*" && return 0
return 1
}

_test_p()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -p "$*" && return 0
return 1
}
_test_S()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -S "$*" && return 0
return 1
}

_test_c(){
test -e "$*" || return 2
test -L "$*" && return 3
test -c "$*" && return 0
return 1
}

_test_crw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -c "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_cr(){
test -e "$*" || return 2
test -L "$*" && return 3
test -c "$*" -a -r "$*" && return 0
return 1
}

_test_cw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -c "$*" -a -w "$*" && return 0
return 1
}


_test_b(){
test -e "$*" || return 2
test -L "$*" && return 3
test -b "$*" && return 0
return 1
}

_test_brw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -b "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_br(){
test -e "$*" || return 2
test -L "$*" && return 3
test -b "$*" -a -r "$*" && return 0
return 1
}

_test_bw(){
test -e "$*" || return 2
test -L "$*" && return 3
test -b "$*" -a -w "$*" && return 0
return 1
}

#=============== Rotate Logs =================================================
_log_rotate()
{
test "$*" || { _err "_log_rotate:Need filename to rotate"; return 1; }
test -f "$*" || { _err "_log_rotate: '$*' not a regular file"; return 1; }

nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
_debug "nrLOGS='$nrLOGS'"

while read oneLOG
do
 test "$oneLOG" || continue
 test -f "$oneLOG" || continue
  _debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
 mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))
 nrLOGS=$((nrLOGS-1))
done <<EoI
`ls -1v "$*".[0-9]* | tac`
EoI

test -e "${*}.1" && { _err "Something went wrong"; return 1 ; }
 _info "moving $* --> ${*}.1"
mv $VERB "$*" "${*}.1"
}



#================= KERNEL VERSION and SFS VERSION ============================

#VERSION = 3
#PATCHLEVEL = 13
#SUBLEVEL = 3
#EXTRAVERSION =
#Mounting Squashfs 1.x filesystems IS supported by the 2.0 kernel patch.
#Mounting 2.0 filesystems is supported by Squashfs 2.1.
#Squashfs 3.0 supports 2.x filesystems.  Support for 1.x filesystems
#will be added in the future.
#3.2: Unsquashfs now supports Squashfs 2.x filesystems.
#Welcome to Squashfs 4.0.  This is an initial tools only release to
#support users of the 2.6.29 kernel
#Later releases will probably contain kernel patches supporting 4.0
#layouts for earlier kernels.

_kernel_version()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"

SFSSTR='squashfs, version 4'
SFSMAJOR=4
squashXZ=YES

if vercmp $KERNELVER ge 3.0;then #111016
:    # if vercmp not installed would run else
_info "Kernel 3.0 or greater"
else # assume 2.6
 #test $? = 127 && { _warn "_kernel_version:Is vercomp installed in PATH? -- using _kernel_version2 instead..."; _kernel_version2; }
 #echo $?
 #which vercmp || _kernel_version2
case $KERNELVER in
2.6.*)
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`

 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
   SFSSTR='squashfs, version 3'
   SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
 squashXZ=NOT
 fi
;;
*) _err "_kernel_version:UNHANDLED KERNELVER '$KERNELVER'";;
esac
fi 2>$ERR #if vercmp is not installed :P

#kVERSION="$K_VERSION"
#kPATCHLEVEL="$K_PATCHLEVEL"
#kSUBLEVEL="$K_SUBLEVEL"
#kEXTRAVERSION="$K_EXTRAVERSION"
#kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version:KERNELVER='$KERNELVER'"
_info "_kernel_version:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}








_kernel_version2()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION K_LOCALVERSION
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"

SFSSTR='squashfs, version 3'
SFSMAJOR=3
squashXZ=NOT

ifsv='.-_'
#ifsv='[[:punct:]]' # also [:punct:] does not work
ifsv='^°!"§$%&/()=?`¹²³¼½¬{[]}\ß´+*~#-_.:·,;'"'"  # '\' seems not to work , even as '\\' '\\\' '\\\\'

      K_VERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion localversion;echo $kversion; }` ##code from /usr/sbin/laptop_mode, Maintainer: Bart Samwel (bart@samwel.tk)
   K_PATCHLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel localversion;echo $patchlevel; }`
     K_SUBLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $sublevel; }`
   KERNELSUBVER="$K_SUBLEVEL"

 #test "$K_VERSION" || _err "_kernel_version2:Could not get K_VERSION"
 _check_content K_VERSION
 #test "${K_VERSION//[[:digit:]]/}" && _warn "_kernel_version2:Got '$K_VERSION' with other than :digit:"
 _check_content2 onlydigit "$K_VERSION"

 if test $K_VERSION = 3; then
  _info "Newer kernel 3 series"
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $localversion; }`
 elif
 test $K_VERSION = 2; then
  _info "Older Kernel 2 series"
  K_EXTRAVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $extraversion; }`
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $localversion; }`
 else
  _err "Unhandled K_VERSION '$K_VERSION'"
 fi

[ "$K_EXTRAVERSION" ] || K_EXTRAVERSION=0
[ "${K_EXTRAVERSION//[[:digit:]]/}" ] && { K_LOCALVERSION="$K_EXTRAVERSION $K_LOCALVERSION";K_EXTRAVERSION=0; }
KERNELSUBSUBVER="$K_EXTRAVERSION"

case $K_VERSION in
3) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
2)
        case $K_PATCHLEVEL in
        6)
                case $K_SUBLEVEL in
                29|30|31|32|33|34|35|36|37) SFSSTR='squashfs, version 4';SFSMAJOR=4;;
                38|39) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
                28)
                    case $K_EXTRAVERSION in
                    47) SFSSTR='squashfs, version 4';;
                    esac
                ;;
                *) _notice "Old 2.6 kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' sublevel '$K_SUBLEVEL' .";;
                esac;;
        0|1|2|3|4|5) _crit "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        *) _alert "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        esac;;
*) _emerg "Unhandled kernel version '$K_VERSION' .";;
esac

kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version2:KERNELVER='$KERNELVER'"
_info "_kernel_version2:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version2:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version2:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version2:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}
















_kernel_version3()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset VERSIONS LOCALVERSION K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

test -f /proc/config.gz || modprobe -v configs
test -f /proc/config.gz && {

 if test "$*"; then
 KERNELVER="$@"
 fi

 VERSIONS=`zcat /proc/config.gz | grep -m2 -iE '# Linux.*kernel.*|CONFIG_LOCALVERSION=".*"'`
 test "$KERNELVER" || KERNELVER=`echo "$VERSIONS" | grep -m1 -i '# Linux.*kernel.*' | awk '{print $3}'`
 LOCALVERSION=`echo "$VERSIONS" | grep -m1 -i 'CONFIG_LOCALVERSION=".*"' | cut -f2 -d=`
_debug "KERNELVER='$KERNELVER'"
_debug "LOCALVERSION='$LOCALVERSION'"
 test "$KERNELVER" || KERNELVER="`uname -r`"
 KERNVER="$KERNELVER"
 KERNEL="$KERNELVER"

 SFSSTR='squashfs, version 4'
 SFSMAJOR=4
 squashXZ=YES

 if test "`echo "$KERNELVER" | grep '^3\.[0-9]\.'`"; then #111016
 _info "Kernel 3. series"
 K_VERSION=${KERNELVER:0:1}
 K_PATCHLEVEL=${KERNELVER:2:1}
 K_SUBLEVEL=${KERNELVER:4:1}

 KERNELSUBVER=$K_SUBLEVEL
 KERNELSUBSUBVER=0

 elif echo "$KERNELVER" | grep $Q '^2\.6'; then
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi

 else # assume 2.6
 _warn "Assuming kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi
fi


kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version3:KERNELVER='$KERNELVER'"
_info "_kernel_version3:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version3:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version3:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version3:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
return 0
 } || _kernel_version
INFO=$oldINFO;DEBUG=$oldDEBUG
}


_kernel_version4()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

_process_kernel_2dotX()
{
squashXZ=NOT
case $kVERSION in
0|1) _crit "TODO: Unhandled kVERSION '$kVERSION'"; return 1;;
2)
  case $kPATCHLEVEL in
  0|2|4|5) _warn "TODO: Unhandled kVERSION '$kVERSION' kPATCHLEVEL '$kPATCHLEVEL'"; return 1;;
  6) test "$kSUBLEVEL" -ge 38 && squashXZ=YES
     test "$kSUBLEVEL" -gt 28 && return 0
     case $kSUBLEVEL in
      27) test "$kEXTRAVERSION" -eq 47 && return 0
          return 1;;
     esac
  ;;
  esac
;;
esac
return 1
}

_eval_sfsversion()
{
case $1 in
1) SFSSTR='squashfs, version 3';SFSMAJOR=3; test "$squashXZ" || squashXZ=NOT;;
*) SFSSTR='squashfs, version 4';SFSMAJOR=4; test "$squashXZ" || squashXZ=YES;;
esac
}

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi

_old(){
case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
esac
}

_new(){
_debug "case \"$KERNEL\" start"
oldIFS="$IFS"
#IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄä:;'"'"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"  #bash-3.2 does not like * as IFS in case
_debug "case \"$KERNEL\" start"
case "$KERNEL" in
0*|1*|2*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
;;
3*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
;;
*) _debug "UNHANDLED KERNEL='$KERNEL'"
;;
esac
_debug "case \"$KERNEL\" end"
IFS="$oldIFS"
}

#_old
_new

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

test "$kVERSION" -le 2 && { _process_kernel_2dotX; _eval_sfsversion $?; } || _eval_sfsversion 0
_debug "_kernel_version4:End"

_notice "_kernel_version4:KERNELVER='$KERNELVER'"
_info "_kernel_version4:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version4:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version4:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version4:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}











_kernel_version5()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi
KERNELVER="$KERNEL"
KERNVER="$KERNEL"

unset SFSSTR SFS_STR SFS_MAJOR SFSMAJOR squashXZ

if test ! "$*"; then
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
test "$SFS_STR" || { ( busybox modprobe -l | grep $Q '/squashfs.ko' ) && {
    test -f /proc/modules && {
    grep $Q 'squashfs' /proc/modules || { modprobe $VERB squashfs; sleep 1; }
    } || { modprobe $VERB squashfs; sleep 1; }
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
}; }
test "$SFS_STR" || { _warn "Could not determine squashfs in dmesg, assuming \"version 4.0\""; SFS_STR='version 4.0'; }

SFS_MAJOR=`echo ${SFS_STR##* } | cut -b 1`
test "${SFS_MAJOR//[[:digit:]]/}" && SFS_MAJOR='';
test "$SFS_MAJOR" || { _warn "Could not determine squashfs major version, assuming '4'"; SFS_MAJOR=4; }

SFS_STR="squashfs, $SFS_STR"

else
:
fi

squashXZ=NOT
case "$KERNEL" in
3.*) squashXZ=YES
test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
test "$SFS_MAJOR" || SFS_MAJOR=4
;;
2.6.*) case $KERNEL in
     2.6.38*|2.6.39*) squashXZ=YES
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.29*|2.6.3[0-7]*)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.28*)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     2.6.27.47)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     *)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     esac
;;
*) _warn "_kernel_version5:UNHANDLED kernel version '$KERNEL' , assuming squashXZ=$squashXZ";;
esac

SFSSTR="$SFS_STR"
SFSMAJOR="$SFS_MAJOR"

case "$KERNEL" in
0.*|1.*) _warn "Unhandled kernel version 0* and 1*";;
2.6*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI

    if ! test "$kEXTRAVERSION"; then
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
    fi

IFS="$oldIFS"
;;
2.[0-5].*) _warn "Unhandled kernel version 2.[0-5].*";;
3.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
esac

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

_notice "_kernel_version5:KERNELVER='$KERNELVER'"
_info "_kernel_version5:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version5:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version5:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version5:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}




#================ Make free loop device ======================================
_mk_free_loop()
{
  FREE_LOOP=`losetup -f`  # find free and create loop
  [ "$FREE_LOOP" ] || {   # for kernel 3.0 and earlier
  LOOPS_ALL=`ls -1v /dev/loop* |sed 's%[^[:digit:]]%%g'`
  LOOP_LAST=`echo "$LOOPS_ALL" | tail -n1`
  LOOP_NEW=$(( $LOOP_LAST + 1 )) && mknod /dev/loop${LOOP_NEW} b 7 $LOOP_NEW
  }
}

#================ Check GETTEXT ==============================================
_check_gettext()
{
_G=`which gettext`
test "$_G" && {
 test "`which gettext.sh`" && {
export TEXTDOMAIN=f4puppy5 #NOTE: rename to avoid clash with 'remasterpup2.mo' used by previous i18n method.
export OUTPUT_CHARSET=UTF-8
. gettext.sh
test "`type -t eval_gettext`"   &&  _eG=eval_gettext
if test "`which ngettext`"; then
 test "`type -t eval_ngettext`" && _eNG=eval_ngettext
fi
  }
 }

test "$_G"   ||   _G=echo
test "$_eG"  ||  _eG=echo
test "$_eNG" || _eNG=echo
#echo "_G='$_G'"
#echo "_eG='$_eG'"
#echo "_eNG='$_eNG'"
}
_check_gettext

_killzombies()
{
 ZOMBIES="`_command ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | awk '{print $1}'`"
 for oneZOMBIE in $ZOMBIES
 do
  _command ps --no-header -p $oneZOMBIE || continue
  echo " :Killing parentless zombie process $oneZOMBIE ..."
  kill $oneZOMBIE
 done
}

#===== XMESSAGE or SPLASH ====================================================
_get_yaf_args()
{
for exe in pupmessage gtkdialog-splash yaf-splash gxmessage xmessage; do
YAF=`which $exe`
test "$YAF" || continue
test -L "$YAF" && continue
case $YAF in

 pupmessage)yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#gtkdialog-splash

# an easy replacement for yaf-splash in Puppy (NOT Puppy <=4.x)
# mave 30.05.2010
# no warranty
# Thanks for Puppy!

# usage: gtkdialog-splash [OPTIONS] [-timeout SEC] -text TEXT | -kill [ PID ]

# -text EXPRESSION
# -timeout COUNT (in seconds)
# -icon GTK-XXX (for example: gtk-info all gtk-stock-symbols, default: none)
# OR path/to/pixmap.png|gif|jpeg
# -icon_width WIDTH in pixels
# -bg COLOR (background color red, blue, yellow..., default: grey)
# -bg_gradient true|false (default: true)
# -fg COLOR (font color, default: black)
# -placement center|mouse|top|bottom|top-left|bottom-left (default: center)
# -close never|mouseover|box (default is mouseover)
# -deco TITLE (shows windows decorations, with title)
# -font NAME
# -fontsize SIZE
# -align ALIGNMENT left, right or center -margin SIZE (default: 10)
# -border true|false (default: true)
# -kill [ PID ] ( When PID omitted, kills all GTKDIALOG_SPLASH found
# in ps output, PID must exist as /tmp/GTKDIALOG-SPLASHPID with PID content )

 gtkdialog-splash) yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#Usage: yaf-splash [ options ]
#Where options include:

#  -text                         Message to display.
#  -timeout                      How long to display the message before
#                                exiting. Default is 0, which means forever.
#  -clock                        Enable clock display.
#  -12                           Display twelve hour time (default).
#  -24                           Display twenty-four hour time.
#  -seconds                      Display seconds (default).
#  -noseconds                    Don't display seconds.
#  -countdown <date>             Display a countdown instead of a clock.
#                                Run `-countdown foo' to see date syntax.
#  -countdownquit                Quit after the countdown has reached
#                                zero (default).
#  -nocountdownquit              Keep counting after reaching zero.
#  -geometry <geometry>          Size and position of window.
#  -placement <placement name>   A screen location, one of center, top,
#                                bottom, right, left, top-right, top-left,
#                                bottom-left, bottom-right. Defaults to center.
#                                A specified placement will override -geometry.
#  -font <font>                  Name of an X font to use.
#  -transparent                  Make the window background be transparent,
#                                if possible.
#  -nontransparent               Don't (default).
#  -mirror                       Flip the text about the y axis. Useful for
#                                back projection.
#  -nomirror                     Don't (default).
#  -fg                           Set the forground text colour (default: black).
#  -bg                           Set the background colour (default: white).
#  -bd                           Set the border colour (default: black).
#  -bw                           Set the border width (default: 2).
#  -outline                      Set the text outline width (default: 1).
#  -margin                       Set the margin size (default: 0).

 yaf-splash) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg black"; yafFG="-fg orange"; yafPL="-placement center"; yafFONT="-font -*-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafFONT="-font -misc-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafEXTRA="-transparent"
  #yaf-splash: couldn't load font "'*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

 gxmessage)#yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;

#gxmessage - a GTK-based xmessage clone

#Usage: gxmessage [OPTIONS] message ...
#       gxmessage [OPTIONS] -file FILENAME

#xmessage options:
#  -file FILENAME         Get message text from file, '-' for stdin
#  -buttons BUTTON_LIST   List of "LABEL:EXIT_CODE", comma separated
#  -default LABEL         Give keyboard focus to the specified button
#  -print                 Send the selected button's LABEL to stdout
#  -center                Try to open window in the centre of the screen
#  -nearmouse             Try to open window near the mouse pointer
#  -timeout SECONDS       Exit with code 0 after SECONDS seconds

#X-like options:
#  -display DISPLAY       X display to use
#  -fn FONT | -font FONT  Set message font (works with GTK font names)
#  -fg COLOUR             Set message font colour
#  -bg COLOUR             Set message background colour
#  -geometry GEOMETRY     Set window size (position will be ignored)
#  -iconic                Start iconified
#  -name NAME             Program name as used by the window manager
#  -title TITLE           Set window title to TITLE

#gxmessage options:
#  -borderless            Try to open window without border decoration
#  -nofocus               Don't focus the window when it opens
#  -encoding CHARSET      Expect CHARSET as the message encoding
#  -entry                 Prompt for text to be sent to stdout
#  -entrytext TEXT        Same as -entry, but with TEXT as default text
#  -wrap                  Wrap lines of text to fit window width
#  -help | -?             Show this usage information
#  -version               Show gxmessage version information

 xmessage) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;
esac
break
done
_debug "Using '$YAF'"
}

_GTKdialog_remove_comments()
{

test "$*" || { _return 1 "No Input. Usage _GTKdialog_remove_comments DIALOG_GUI_CODE"; return 1; }
local sPATTERN1 sPATTERN2 sPATTERN3 sPATTERN4
sPATTERN1='s%<!--.*-->%%g'
sPATTERN2='/<!--/,/-->/d'
sPATTERN3='s%^#.*%%'
sPATTERN4='s%>.*#[^>]*$%%'

echo "$*" | sed -e "$sPATTERN1" -e "$sPATTERN2" -e "$sPATTERN3" -e "$sPATTERN4" || return 1
}

_GTKdialog_debug_gui()
{
test "$*" || { _return 2 "_GTKdialog_debug_gui: Usage: debugGUI=\`_GTKdialog_debug_gui \"$MAIN_DIALOG\"\`"; return $?; }

local lNR
lNR=0
echo "$*" | while read -r aLINE; do lNR=$((lNR+1)); echo "$lNR: $aLINE";done

}

_pidof()
{
local RV
case $1 in
-q) shift;
pidof $* >/dev/null; return $?
;;
*)
echo -n "pids of $*:"
pidof $*; RV=$?
test "$RV" = 0 || echo
return $RV
;;
esac
}

_add_header()
{
local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep $Q -viE 'perl|python|murgaLua_Dynamic|Pascal|C\+\+| C ' || continue

   grep $Q 'f4puppy5' "$file" && continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue

   SHELLBANG=`head -n1 "$file"`
   case "$SHELLBANG" in
   '#!'*) :;;
   *) continue;;
   esac

   echo "$file"

   cat >/tmp/${file##*/} <<EoI
$SHELLBANG
#
# New header by $_AUTHOR_, $_MONTH_ $_YEAR_
  _TITLE_="Puppy_${file##*/}"
_VERSION_=1.0omega
_COMMENT_="\$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/$file"
MY_PID=\$\$

test -f /etc/rc.d/f4puppy5 && {
source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

ADD_HELP_MSG="\$_COMMENT_"
_parse_basic_parameters "\$@"
[ "\$DO_SHIFT" ] && [ ! "\${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in \`seq 1 1 \$DO_SHIFT\`; do shift; done; }

_trap

}
# End new header
#
EoI

   cat "$file" | sed '1d' >>/tmp/${file##*/}

   if test ! "$DRY"; then
    rm "$file"
    mv $VERB /tmp/${file##*/} "$file"
    chmod $VERB $PERM "$file"
   fi

done
}

_remove_header()
{
 local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

 pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep $Q -viE 'perl|python' || continue

   grep $Q "# New header by $_AUTHOR_, $_MONTH_ $_YEAR_" "$file" || continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   sed '/# New header by Karl Reimer Godt, September 2014/,/# End new header/ d' "$file" >/tmp/${file##*/}
   sed -i '2,3 d' /tmp/${file##*/}

   mv $VERB /tmp/${file##*/} "$file"
   chmod $VERB $PERM "$file"
done
}

_batch_diff1()
{
local SIMPLE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2
_debug "_batch_diff1: '$*'" >&2

test "$*"    || { _err "Usage: _batch_diff [ -s ] DIR"; $EXIT 1; }

test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory";          $EXIT 1; }

cd "$@"      || { _err "Could not change into '$@'";    $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

#FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

#FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

     test "$oneF1" = "$oneF2" && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII
done <<EoI
`echo "$FILES1"`
EoI

}

_batch_diff2()
{
local SIMPLE INVERT FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff2 [ -s |& -i ] DIR"; $EXIT 1; }


test "$1" = '-s' && { SIMPLE=YES; shift; }
test "$1" = '-i' && { INVERT=YES; shift; }
test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory";  $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_batch_diff3()
{
DEBUG=1
local SIMPLE INVERT REMOVE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff3 [ -s -i | -r ] DIR"; $EXIT 1; }

while [ "$2" ]; do
case "$1" in
-s) SIMPLE=YES;;
-i) INVERT=YES;;
-r) REMOVE=YES;;
esac
shift
done

test -d "$@" || { _err "'$@' not a directory";  $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF2" "$oneF1" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF1" "$oneF2" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}



###END###
_HAVE_F4PUPPY5_=1  ## WARN : DO NOT EXPORT !!
  HAVE_F4PUPPY5=1
###END###
