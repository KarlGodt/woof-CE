#!/bin/ash

[ "$HAVE_F4PUPPY5" ] && return 0

_assign_version()
{
case $1 in
_VERSION_) VERSION=$_VERSION_; Version=$_VERSION_; version=$_VERSION_;;
VERSION) _VERSION_=$VERSION; Version=$VERSION; version=$VERSION;;
Version) _VERSION_=$Version; VERSION=$Version; version=$Version;;
version) _VERSION_=$version; VERSION=$version; Version=$version;;
esac
}

test "$_VERSION_" && _assign_version _VERSION_ || _VERSION_=0.0.2
test "$VERSION"   && _assign_version VERSION   ||   VERSION=0.0.2
test "$Version"   && _assign_version Version   ||   Version=0.0.2
test "$version"   && _assign_version version   ||   version=0.0.2
SCRIPT_NAME=f4puppy5 # short for functions for puppy 5
test "$MY_SELF" || MY_SELF="$0"


# colours
 Black0='\033[0;30m'
 Black1='\033[1;30m'
   Red0='\033[0;31m'
   Red1='\033[1;31m'
 Green0='\033[0;32m'
 Green1='\033[1;32m'
Yellow0='\033[0;33m'
Yellow1='\033[1;33m'
  Blue0='\033[0;34m'
  Blue1='\033[1;34m'
  Pink0='\033[0;35m'
  Pink1='\033[1;35m'
  Cyan0='\033[0;36m'
  Cyan1='\033[1;36m'
 White0='\033[0;37m'
 White1='\033[1;37m'
Normal0='\033[0;39m'

Inv_White0='\033[0;47m'
Inv_White1='\033[1;47m'
# /colours

_status(){
 _TTY_=`tty`
 [ "$_TTY_" = 'not a tty' ] && _TTY_=/dev/console

 _CHARS_=${1//[[:digit:]]/}
 if [ "$_CHARS_" ];then echo -e "\\033[60G\\033[1;36m${_CHARS_}$Normal0" >$_TTY_
 set -- 0
 elif [ "$1" = 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone$Normal0"   >$_TTY_ #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed$Normal0" >$_TTY_ #red [failed].
  STATUS=0
 fi

 return $1 #return with same status as entry param.
}

_cd_program_dir()
{
ME_PROG=`readlink -f "$0"`
ME_DIR=${ME_PROG%/*}
cd "$ME_DIR"
test $? = 0 || _exit 1 "Could not change into directory '$ME_DIR'"
return 0
}

_check_if_already_running()
{
pidof -o $$ -o %PPID "${0##*/}" && {
        echo "Already running."
        exit 1
 }
return $?
}

_run_status()
{
test "$*" || { _return 2 "_run_status: Usage: _run_status BASENAMEPROGRAM"; return $?; }
pidof "$*" >$OUT && { _info " '$*' running."; return 0; } || { _info " '$*' not running."; return 1; }
}

_check_for_terminal()
{
local MSG
MSG="Need a contolling terminal"
tty >/dev/null || {
echo -n "Pid of X server:"
pidof X && xmessage -br red "$MSG"; exit 2; } || {
echo "$MSG"; exit 2; }
return $?
}

_exit()
{
RV=$1
shift
echo "$*"
exit $RV
}

_trap()
{
trap "_exit 99 \"Caught Signal\"" INT KILL TERM
}

_version()
{
echo "$0:Version:$VERSION"

if [ "$TWO_VERSION" ]; then
 return 0
else
 exit 0
fi
}

_have_all_commands()
{

haveALL_COMMANDS=MAYBE

grep -I -oE -e '=`[^ ]*| \| [^ ]*' "$0" | grep -v '=.*=' | sort -u | sed 's@^=`@@;s@| @@' |
while read oneCOMMAND;
  do
#which $oneCOMMAND || haveALL_COMMANDS=NO;
test "`which "$oneCOMMAND"`" -o "`type "$oneCOMMAND"`" || { haveNOT_COMMAND="$haveNOT_COMMAND $oneCOMMAND"; haveALL_COMMANDS=NOT; }
done

[ "$haveALL_COMMANDS" = MAYBE ] && haveALL_COMMANDS=YES

  if test "$haveALL_COMMANDS" = YES; then
_debug "haveALL_COMMANDS=$haveALL_COMMANDS"
elif test "$haveALL_COMMANDS" = NOT; then
_warn "Don't have all needed commands! Here they are:
$haveNOT_COMMAND
"
else
_error "Unhandled haveALL_COMMANDS '$haveALL_COMMANDS'"
  fi
}

_usage()
{
local USAGE_MSG RV
RV=$1
shift
test "$PARAMETER_LIST" || PARAMETER_LIST=PARAMETERS
test "$PARAMETERS" || PARAMETERS="NONE YET"
USAGE_MSG="
$0 [ $PARAMETER_LIST ]

PARAMETERS :
$PARAMETERS
--
$*
"
echo "$USAGE_MSG"

if test "$TWO_HELP"; then
 return $RV
else
 if test "$RV" != 0; then
  _exit $RV "Try again. Good Luck!"
 else
  exit $RV
 fi
fi
return $?
}

_provide_basic_parameters()
{
test "$ADD_PARAMETER_LIST" && ADD_PARAMETER_LIST="|$ADD_PARAMETER_LIST"
PARAMETER_LIST="-help|-version|-verbose|-debug$ADD_PARAMETER_LIST"
PARAMETERS="
-h|--help    : Show this message and exit.
-V|--version : Show version information and exit.
-v|--verbose : Supress /dev/null and quiet options, verbose options to binaries.
-d|--debug   : Run program with set -x .
$ADD_PARAMETERS"
}

OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=$Q;DBG=''
[ "$DEBUG" ] && { OUT=/dev/stdout;ERR=/dev/stderr;Q='';QUIET=$Q;DBG=-d; }
[ "$DEBUG" = "2" ] && set -x
_parse_basic_parameters()
{
OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=$Q;DBG='';DO_SHIFT=0
case $1 in
-h|-H|-*help) _usage 0 "$ADD_HELP_MSG";;
-V|-*version) _version;;
-v|-*verbose) VERBOSE=1;VERB=-v;A_VERB=-verbose;L_VERB=--verbose;Q='';QUIET=$Q;DBG=-d;
              OUT=/proc/self/fd/1;ERR=/proc/self/fd/2; [ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1));;
-d|-*debug)   set -x; [ "$TWO_DEBUG" ] || DO_SHIFT=$((DO_SHIFT+1));;
esac
}

_parse_options()
{  ## MACRO kind of
local OPT_ OPTIONS_ aLINE
oldIFS="$IFS"
IFS=$'\n'

while getopts ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz- OPT_
 do
  _debugx "$OPT_='$OPT_' OPT_ARG='$OPTARG' OPT_IND='$OPTIND'"
  case $OPT_ in
  A):;;
  B):;;
  C):;;
  D):;;
  E):;;
  F):;;
  G):;;
  H):;;
  I):;;
  J):;;
  K):;;
  L):;;
  M):;;
  N):;;
  O):;;
  P):;;
  Q):;;
  R):;;
  S):;;
  T):;;
  U):;;
  V):;;
  W):;;
  X):;;
  Y):;;
  Z):;;
  a):;;
  b):;;
  c):;;
  d):;;
  e):;;
  f):;;
  g):;;
  h):;;
  i):;;
  j):;;
  k):;;
  l):;;
  m):;;
  n):;;
  o):;;
  p):;;
  q):;;
  r):;;
  s):;;
  t):;;
  u):;;
  v):;;
  w):;;
  x):;;
  y):;;
  z):;;
  -*) :;; # long option?
  esac
done

_debugx "\$#='$#' OPT_IND='$OPTIND'"
for i in `seq 1 1 $((OPTIND-1))`; do shift; done
_debugx "\$#='$#' OPT_IND='$OPTIND'"

while read -r aLINE
 do

  _debugx "aLINE='$aLINE'"

  case "$aLINE" in

### HANDLE OPTARG s ####
#    -x)              #example -x "ARG"
#      read anoLINE
#      echo "anoLINE='$anoLINE'"
#      OPTIONS_="$OPTIONS_
#$aLINE $anoLINE"
#      ;;
#    -x*)             #example -x"ARG"
#OPTIONS_="$OPTIONS_
#$aLINE";;
### HANDLE OPTARG s ####

  -*) OPTIONS_="$OPTIONS_
$aLINE";;
  *)  _PARAMETERS_="$_PARAMETERS_
$aLINE";;
  esac

 done <<EoI
`echo "$*"`
EoI

_debugx "OPTIONS_='$OPTIONS_' _PARAMETERS_='$_PARAMETERS_'"

set - $OPTIONS_ $_PARAMETERS_
_debug "\$*='$*'"
_debug "\$@='$@'"
_debugx "\$#='$#' OPT_IND='$OPTIND'"

while getopts ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz- OPT_
 do
  _debugx "$OPT_='$OPT_' OPT_ARG='$OPTARG' OPT_IND='$OPTIND'"
    case $OPT_ in
  A):;;
  B):;;
  C):;;
  D):;;
  E):;;
  F):;;
  G):;;
  H):;;
  I):;;
  J):;;
  K):;;
  L):;;
  M):;;
  N):;;
  O):;;
  P):;;
  Q):;;
  R):;;
  S):;;
  T):;;
  U):;;
  V):;;
  W):;;
  X):;;
  Y):;;
  Z):;;
  a):;;
  b):;;
  c):;;
  d):;;
  e):;;
  f):;;
  g):;;
  h):;;
  i):;;
  j):;;
  k):;;
  l):;;
  m):;;
  n):;;
  o):;;
  p):;;
  q):;;
  r):;;
  s):;;
  t):;;
  u):;;
  v):;;
  w):;;
  x):;;
  y):;;
  z):;;
  -*) :;; # long option?
  esac
done

_debugx "\$#='$#' OPT_IND='$OPTIND'"
for i in `seq 1 1 $((OPTIND-1))`; do shift; done
_debug "\$#='$#' OPT_IND='$OPTIND'"

_debug "\$*='$*'"
_debug "\$@='$@'"
_debugx "\$#='$#' OPT_IND='$OPTIND'"
}

_old_intro()
{

cat <<EoI

trap "exit 1" HUP INT QUIT KILL TERM

OUT=/dev/null;ERR=$OUT
[ "$DEBUG" ] && { OUT=/dev/stdout;ERR=/dev/stderr; }
[ "$DEBUG" = "2" ] && set -x

Version='1.1'

usage(){
USAGE_MSG="
$0 [ PARAMETERS ]

-V|--version : showing version information
-H|--help : show this usage information

*******  *******  *******  *******  *******  *******  *******  *******  *******
$2
"
exit $1
}

[ "`echo "$1" | grep -wiE "help|\-H"`" ] && usage 0
[ "`echo "$1" | grep -wiE "version|\-V"`" ] && { echo "$0 -version $Version"; exit 0; }

EoI

}

_string_to_octal()
{
_debug "_string_to_octal:$*" >&2
unset oSTRING
if test "$*"; then
STRING_ORIG="$*"

STRING=`echo "$STRING_ORIG" | sed 's!\(.\)!"\1"\n!g'`
_debug "_string_to_octal:STRING='$STRING'" >&2


while read -r oneCHAR
do
oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
oCHAR=`printf %o \'"$oneCHAR"`

oSTRING=$oSTRING"\\0$oCHAR"

done<<EoI
`echo "$STRING"`
EoI

else

while read -r oneLINE
do
#test "$oneLINE" || continue
 _debug "oneLINE='$oneLINE'" >&2
 STRING=`echo "$oneLINE" | sed 's!\(.\)!"\1"\n!g'`
 _debugx "STRING='$STRING'" >&2
 while read -r oneCHAR
 do
 _debugx "oneCHAR='$oneCHAR'" >&2
 oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
 _debug "oneCHAR='$oneCHAR'" >&2
 oCHAR=`printf %o \'"$oneCHAR"`
 _debug "oCHAR='$oCHAR'" >&2
 #test "$oCHAR" = 134 && oCHAR=0134

 oSTRING=$oSTRING"\\0$oCHAR"
 _debugx "oSTRING='$oSTRING'" >&2

 done<<EoI
`echo "$STRING"`
EoI

oSTRING=$oSTRING"\\012"
done

fi

echo "$oSTRING"

}

__getopt()
{

#POSIXLY_CORRECT=    ##
#GETOPT_COMPATIBLE=  ##

GET_OPT=`busybox getopt \
      -a -l help,version \
      -o h,V \
      -s sh \
      "$*"`
test $? = 0 || _usage 2 "Wrong option."

set - "`echo "$GET_OPT" | sed "s^' '^'\n'^g"`"

while read oneOPTION
do
test "$oneOPTION" || continue
case $oneOPTION
in
*) :;;
esac
done<<EoI
`set`
EoI
set -
return $?
}

_getopts()
{
local oneOPTION
allOPS=AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz-
#while getopts hV oneOPTION
while getopts $allOPS oneOPTION
do
case $oneOPTION
in
h) _usage 0;;
V) _version;;
*) _warn "Unsupported option '$oneOPTION'";;
esac
done
return $?
}

_test()
{
#test "$*"
test $*
case $? in
0)
echo "'$*'" OK
return 0
;;
1)
echo "! '$*'"
return 1
;;
2)
echo "'$*'" wrong input
return 1
;;
esac
return $?
}

_get_argv()
{
local oneARG
for oneARG in $*
do
case $oneARG
in
-*help|help) _usage 0;;
-*version|version) _version;;
*) :;;
esac
done
return $?
}

_logger()
{
local MESSAGE PRIORITY TAG
case $# in
1) MESSAGE="$*";;
2) PRIORITY=$1
   shift
   MESSAGE="$*";;
''|0) echo "$0:_logger [ PRRIORITY ] [[ TAG ]]:Need at least MESSAGE." >&2
      return 1;;
*)
PRIORITY=$1
shift
TAG="$1"
shift
MESSAGE="$*"
;;
esac

#_test "\"$PRIORITY\"" != '""' || PRIORITY=7
#_test "\"$TAG\"" != '""'      || TAG=${0##*/}

_check_content "$PRIORITY" || PRIORITY=7
_check_content "$TAG"      || TAG=${0##*/}

logger -p $PRIORITY -t "$TAG" "$MESSAGE"
return $?

#May 29 09:21:57 puppypc user.debug  /bin/sh: TESTING logger 7
#May 29 09:22:13 puppypc user.info   /bin/sh: TESTING logger 6
#May 29 09:22:19 puppypc user.notice /bin/sh: TESTING logger 5
#May 29 09:22:26 puppypc user.warn   /bin/sh: TESTING logger 4
#May 29 09:22:32 puppypc user.err    /bin/sh: TESTING logger 3
#May 29 09:22:37 puppypc user.crit   /bin/sh: TESTING logger 2
#May 29 09:22:43 puppypc user.alert  /bin/sh: TESTING logger 1
#May 29 09:22:48 puppypc user.emerg  /bin/sh: TESTING logger 0
#May 29 09:22:06 puppypc user.emerg  /bin/sh: TESTING logger 8

}

#======== Accumulate Errors and create Message Variable ====================
_basic_error_check()
{
local USAGE RV
USAGE="Usage: _basic_error_check \$? \"MESSAGE\""
RV=$1
test "$RV" || { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
test "${RV//[0-9]/}" && { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
shift
if test "$RV" != "0"; then
__ERRORS__="$__ERRORS__
'$*' returned '$RV'"
fi
return $RV
}

_check_content()
{
test "$*" || { _err "Usage: _check_content VARIABLE -- got '$*'"; return 0; }
ENOCONTENT=28
#test "$*" && return 0 || { _err "NO content."; return $ENOCONTENT; }
#echo "'`eval echo \\$$*`'"
test "`eval echo \\$$*`" && return 0 || { _err "$*:NO content."; return $ENOCONTENT; }
}

_check_content2()
{
test "$2" || { _err "Usage: _check_content2 PATTERN VARIABLE -- got '$*'"; return 0; }
EWRONGCONTENT=29
unset sPATTERN gPATTERN
local sPATTERN gPATTERN
#echo -n "`eval echo \\$$*`"' : '
#echo "`eval echo \\$\${*//[[:digit:]]/}`"

case $1 in
  digit) gPATTERN="[[:digit:]]";;
nodigit|onlydigit|digitonly) gOPT=-v;gPATTERN="[[:digit:]]";
test "`echo $(eval echo \\$\${*//[[:digit:]]/})`" && { _warn "$*:Other than :digit: content."; return $EWRONGCONTENT; } || return 0;;
  alpha) gPATTERN="[[:alpha:]]";;
noalpha|onlyalpha|alphaonly) gOPT=-v;gPATTERN="[[:alpha:]]";
test "`echo $(eval echo \${*//[[:alpha:]]/})`" && { _warn "$*:Other than :alpha: content."; return $EWRONGCONTENT; } || return 0;;
  alnum) gPATTERN="[[:alnum:]]";;
noalnum|onlyalnum|alnumonly) gOPT=-v;gPATTERN="[[:alnum:]]";
test "`echo $(eval echo \${*//[[:alnum:]]/})`" && { _warn "$*:Other than :alnum: content."; return $EWRONGCONTENT; } || return 0;;
  punct) gPATTERN="[[:punct:]]";;
nopunct|onlypunct|punctonly) gOPT=-v;gPATTERN="[[:punct:]]";
test "`echo $(eval echo \\$\${*//[[:punct:]]/})`" && { _warn "$*:Other than :punct: content."; return $EWRONGCONTENT; } || return 0;;
  space) gPATTERN="[[:space:]]";;
nospace|onlyspace|spaceonly) gOPT=-v;gPATTERN="[[:space:]]";
test "`echo $(eval echo \\$\${*//[[:space:]]/})`" && { _warn "$*:Other than :space: content."; return $EWRONGCONTENT; } || return 0;;
  blank) gPATTERN="[[:blank:]]";;
noblank|onlyblank|blankonly) gOPT=-v;gPATTERN="[[:blank:]]";
test "`echo $(eval echo \\$\${*//[[:blank:]]/})`" && { _warn "$*:Other than :blank: content."; return $EWRONGCONTENT; } || return 0;;
'') :;;
no*|only*|*only) gOPT=-v;gPATTERN="$*";;
*) gPATTERN="$*";;
esac
shift

#test "`echo "$*" | grep -E "$gPATTERN"`" && return 0 || return $EWRONGCONTENT
#echo "$*" | grep -q -E "$gPATTERN" && return 0 || return $EWRONGCONTENT
#echo "`eval echo \\$$*`"

#QUIET=-q
if test "$gOPT" = '-v'; then
echo "`eval echo \\$$*`" | grep $QUIET $gOPT -E "$gPATTERN" && { _warn "$*:Other than '$gPATTERN' content."; return $EWRONGCONTENT; } || return 0
else
echo "`eval echo \\$$*`" | grep $QUIET $gOPT -E "$gPATTERN" && return 0 || { _warn "$*:No '$gPATTERN' content."; return $EWRONGCONTENT; }
fi
}

#================= Check /tmp if read-write ==================================
_check_proc()
{
  mountpoint -q /proc && return $? || {
  busybox mount -o remount,rw /dev/root/ /
  test -d /proc || mkdir -p /proc
  busybox mount -t proc proc /proc
  return $?
 }
}

_check_tmp()
{
 test -d /tmp && return $? || {
 local STATUS_
 busybox mount -o remount,rw /dev/root/ /
 STATUS_=$((STATUS_+$?))
 mkdir -p /tmp
 STATUS_=$((STATUS_+$?))
 chmod 1777 /tmp
 STATUS_=$((STATUS_+$?))
 return $STATUS_
 }
}

_check_tmp_rw()
{
_check_proc || _crit "Difficulties with /proc  .."
_check_tmp  || _crit "Difficulties with /tmp  .."

mountpoint $Q /tmp && {
grep  ' /tmp ' /proc/mounts    | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount -o remount,rw tmpfs /tmp;   return $?; }
 } || {
grep '^/dev/root' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount -o remount,rw /dev/root/ /; return $?; }
 }
}

#============= Avoid multiple instances of sync ==============================
_sync()
{
pidof sync >$OUT || sync
}

#=
_grep_one_tail(){
test "$*" || { _return 2 "Usage:_grep_one_tail PATTERN [ FILENAME ]" >&2; return $?; }
if test ! "$2"; then
#piped
grep "$*" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | tail -n1
else
 local REV nREV FILENAME
 REV=`echo $* | rev`
 set - $REV
 _debug "\$*='$*'"             >&2
 FILENAME=`echo $* | awk '{print $1}' | rev`
 _debug "FILENAME='$FILENAME'" >&2
 shift
 nREV=`echo $* | rev`
 set - $nREV
 _debug "\$*='$*'"             >&2
 grep "$*" "$FILENAME" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | tail -n1
fi
}

_grep_one_head(){
test "$*" || { _return 2 "Usage:_grep_one_tail PATTERN [ FILENAME ]" >&2; return $?; }
if test ! "$2"; then
#piped
grep "$*" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | head -n1
else
 local REV nREV FILENAME
 REV=`echo $* | rev`
 set - $REV
 _debug "\$*='$*'"             >&2
 FILENAME=`echo $* | awk '{print $1}' | rev`
 _debug "FILENAME='$FILENAME'" >&2
 shift
 nREV=`echo $* | rev`
 set - $nREV
 _debug "\$*='$*'"             >&2
 grep "$*" "$FILENAME" | grep -vE '^[#!;]|^[[:blank:]]*[#!;]' | head -n1
fi
}

_get_screen_resolution(){
xwininfo -root | tac | grep -vE '^[#!;]|^[[:blank:]]*[#!;]|^[/\*][/\*]|^[[:blank:]]*[/\*][/\*]' | grep -m1 '\-geometry' | awk '{print $2}'
return $?
}
#=

#=============== LOGLEVEL / DEBUG MESSAGES ==================================
EMERGENCY=1
_emerg(){
test "$EMERGENCY" || return 1
echo -e "EMERGENGY:$*"
}

ALERT=1
_alert(){
test "$ALERT" || return 1
echo -e "$0:ALERT:$*"
}

CRIT=1
_crit(){
test "$CRIT" || return 1
echo -e "$0:CRITICAL:$*"
}

ERROR=1
_err(){
test "$ERROR" || return 1
echo -e "$0:ERROR:$*"
}

WARN=1
_warn(){
test "$WARN" || return 1
echo -e "$0:WARNING:$*"
}

NOTICE=1
_notice(){
test "$NOTICE" || return 1
echo -e "$0:NOTICE:$*"
}

INFO=1
_info(){
test "$INFO" || return 1
echo -e "$0:INFO:$*"
}

DEBUG=
_debug(){
test "$DEBUG" || return 1
echo -e "$0:DEBUG:$*"
}

DEBUGX=
_debugx(){
test "$DEBUGX" || return 1
echo -e "$0:DEBUGX:$@"
}

DEBUGT=
_debugt(){  #$1 label #$2 time

test "$DEBUGT" || return 1
#unset LANG LC_ALL
local _TIME_ LC_NUMERIC=C LANG= LC_ALL=
_DATE_=`date +%s.%N | sed 's:.*\(..\..*\):\1:'`
#_DATE_=`date +%s,%N | sed 's:.*\(..\,.*\):\1:'`
if test "$2"; then
_TIME_=`dc $_DATE_ $2 \- p`
echo "$0:TIME:$1:$_TIME_"
else
#echo "$0:TIME:$*:`date +%s.%N | sed 's:.*\(..\..*\):\1:'`"
echo "$0:TIME:$*:$_DATE_"
fi
}

#=================== Prefer Busybox applets ==================================
_use_busybox_applets()
{
[ "`which busybox`" ] && BBEXE=`which busybox`
[ "$BBEXE" ] || { [ -s /bin/busybox -a -x /bin/busybox ] && BBEXE='/bin/busybox'; }
[ "$BBEXE" ] || return 2  ##errno.h:define ENOENT 2 /* No such file or directory */

BBAPPLETS=`$BBEXE --list`

test "$BBAPPLETS" || BBAPPLETS='basename cat chmod chown clear cut
date dc dd dirname dmesg du ed expr false find free
head kill ln login ls lsmod mkdir mknod more mv nice pidof
readlink rev rm rmdir sleep sort stat su sync tail tar touch tr true
uname usleep waitmax wc which xargs'

for applet in $BBAPPLETS
do
#echo $applet
#file "`which $applet`" | grep 'link' | grep busybox || continue
eval "alias ${applet}=\"$BBEXE $applet\"";

done
}

#================ return with message, same as _exit =========================
_return()
{
local RV
RV=$1
 test "$RV" && shift || {
 false
 }
test "${RV//[0-9]/}" && RV=123
echo "$*" >&2
return $RV
}

#================== Use binary instead of busybox applet =====================
_command() # This is for busybox with internals first .
{          # sed -i and grep -w may not work as the regular binaries ,
           # especially if compiled without REGEX or not with GLIBC
#echo "$0:_command:$1:$*"
COM="$1"
shift
#echo "$0:_command:$1:$*"

typeCOM=`type -p "$COM"`
test "$typeCOM" ||{  _return 1 "No such type \"$COM\"" >&2;return $?; }

whichCOM=`which "$COM"`
test "$whichCOM" ||{  _return 1 "No such which \"$COM\"" >&2;return $?; }

_debug "_command:$COM:$@" >&2

test "$typeCOM" = "$whichCOM" && {
 "$typeCOM" "$@"    # "$*" does not work, so needs "$@"
 return $?
 } || {
 "$whichCOM" "$@"
 return $?
 }
}

#========= make nodes in /dev if /dev not mounted ============================
_mkdevices()
{
mountpoint -q /dev && return 0
test "`type mdev`" && { mdev -s; return $?; }
 while read maj min siz dev ; do
  [ "${maj//[[:digit:]]/}" ] && continue
  [ "$maj" -a "$min" -a "$dev" ] || continue
  test -b /dev/$dev || mknod /dev/$dev b $maj $min
 done</proc/partitions
}

#============ Test to filter out links =======================================
_test_f()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" && return 0
return 1
}

_test_fr(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -r "$*" && return 0
return 1
}

_test_fw(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -w "$*" && return 0
return 1
}

_test_frw(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -r "$*" -a -w "$*" && return 0
return 1
}

_test_fx(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -f "$*" -a -x "$*" && return 0
return 1
}

_test_d()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -d "$*" && return 0
return 1
}

_test_p()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -p "$*" && return 0
return 1
}

_test_S()
{
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -S "$*" && return 0
return 1
}

_test_c(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -c "$*" && return 0
return 1
}

_test_b(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 3
test -b "$*" && return 0
return 1
}

_test_L(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -L "$*" && return 0
return 1
}

_test_h(){
test -e "$*" || { _return 2 "'$*' does not exist"; return $?; }
test -h "$*" && return 0
return 1
}

_test_correct_device()
{
test "$*" || { _err "Usage: _test_correct_device /dev/DEVICE SPECIAL MAJOR MINOR - like mknod"; return 2; }
local thisDEVICE DEVICE thisSPECIAL SPECIAL thisMAJ MAJ thisMIN MIN RV=0
DEVICE="$1"
SPECIAL="$2"
MAJ="$3"
MIN="$4"
_debug "_test_correct_device:$*: '$DEVICE' '$SPECIAL' '$MAJ' '$MIN'"

 thisDEVICE=`LC_ALL=C ls -l "$DEVICE"`
 thisSPECIAL=`echo "$thisDEVICE" | cut -b 1`
 thisMAJ=`echo "$thisDEVICE" | awk '{print $5}' | tr -d ','`
 thisMIN=`echo "$thisDEVICE" | awk '{print $6}'`

if test "$thisSPECIAL" != "$SPECIAL"; then
  _err "Got '$SPECIAL' but found '$thisSPECIAL' for '$DEVICE'"; RV=1
fi
if test "$thisMAJ" != "$MAJ"; then
  _err "Got '$MAJ' but found '$thisMAJ' for '$DEVICE'"; RV=1
fi
if test "$thisMIN" != "$MIN"; then
  _err "Got '$MIN' but found '$thisMIN' for '$DEVICE'"; RV=1
fi
test "$RV" = 1 && return 1
return 0
}

_secure_remove()
{
test "$*"    || { _err "Usage: _remove /path/to/filename"; return 2; }
test -e "$@" || { _info "'$@' does not exist already";     return 0; }

  if test -L "$@"; then rm "$@"
elif test -p "$@"; then rm "$@"
elif test -S "$@"; then rm "$@"
elif test -f "$@"; then rm "$@"
elif test -c "$@"; then rm "$@"
elif test -b "$@"; then rm "$@"
elif test -d "$@"; then rm -r "$@"
else { _warn "Unknown filetype '$@' - neither Link, pipe, Socket, file nor directory"; return 1; }
  fi
  return $?
}

#=============== Rotate Logs =================================================
_log_rotate()
{
test "$*" || { _err "_log_rotate:Need filename to rotate"; return 1; }
test -f "$*" || { _err "_log_rotate: '$*' not a regular file"; return 1; }
nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
_debug "nrLOGS='$nrLOGS'"
while read oneLOG
do
test "$oneLOG" || continue
test -f "$oneLOG" || continue
_debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
mv "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))
nrLOGS=$((nrLOGS-1))
done<<EoI
`ls -1v "$*".[0-9]* | tac`
EoI
test -e "${*}.1" && { _err "Something went wrong"; return 1 ; }
_info "moving $* --> ${*}.1"
mv "$*" "${*}.1"
}



















































#================= KERNEL VERSION and SFS VERSION ============================

#VERSION = 3
#PATCHLEVEL = 13
#SUBLEVEL = 3
#EXTRAVERSION =
#Mounting Squashfs 1.x filesystems IS supported by the 2.0 kernel patch.
#Mounting 2.0 filesystems is supported by Squashfs 2.1.
#Squashfs 3.0 supports 2.x filesystems.  Support for 1.x filesystems
#will be added in the future.
#3.2: Unsquashfs now supports Squashfs 2.x filesystems.
#Welcome to Squashfs 4.0.  This is an initial tools only release to
#support users of the 2.6.29 kernel
#Later releases will probably contain kernel patches supporting 4.0
#layouts for earlier kernels.

_kernel_version()
{
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"

SFSSTR='squashfs, version 4'
SFSMAJOR=4
squashXZ=YES

if vercmp $KERNELVER ge 3.0;then #111016
:    # if vercmp not installed would run else
_info "Kernel 3.0 or greater"
else # assume 2.6
 #test $? = 127 && { _warn "_kernel_version:Is vercomp installed in PATH? -- using _kernel_version2 instead..."; _kernel_version2; }
 #echo $?
 #which vercmp || _kernel_version2
case $KERNELVER in
2.6.*)
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`

 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
   SFSSTR='squashfs, version 3'
   SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
 squashXZ=NOT
 fi
;;
*) _err "_kernel_version:UNHANDLED KERNELVER '$KERNELVER'";;
esac
fi 2>/dev/null #if vercmp is not installed :P

#kVERSION="$K_VERSION"
#kPATCHLEVEL="$K_PATCHLEVEL"
#kSUBLEVEL="$K_SUBLEVEL"
#kEXTRAVERSION="$K_EXTRAVERSION"
#kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version:KERNELVER='$KERNELVER'"
_info "_kernel_version:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version:squashXZ='$squashXZ'"
}







































_kernel_version2()
{
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION K_LOCALVERSION
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"

SFSSTR='squashfs, version 3'
SFSMAJOR=3
squashXZ=NOT

ifsv='.-_'
#ifsv='[[:punct:]]' # also [:punct:] does not work
ifsv='^°!"§$%&/()=?`¹²³¼½¬{[]}\ß´+*~#-_.:·,;'"'"  # '\' seems not to work , even as '\\' '\\\' '\\\\'

      K_VERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion localversion;echo $kversion; }` ##code from /usr/sbin/laptop_mode, Maintainer: Bart Samwel (bart@samwel.tk)
   K_PATCHLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel localversion;echo $patchlevel; }`
     K_SUBLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $sublevel; }`
   KERNELSUBVER="$K_SUBLEVEL"

 #test "$K_VERSION" || _err "_kernel_version2:Could not get K_VERSION"
 _check_content K_VERSION
 #test "${K_VERSION//[[:digit:]]/}" && _warn "_kernel_version2:Got '$K_VERSION' with other than :digit:"
 _check_content2 onlydigit "$K_VERSION"

 if test $K_VERSION = 3; then
  _info "Newer kernel 3 series"
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $localversion; }`
 elif
 test $K_VERSION = 2; then
  _info "Older Kernel 2 series"
  K_EXTRAVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $extraversion; }`
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $localversion; }`
 else
  _err "Unhandled K_VERSION '$K_VERSION'"
 fi

[ "$K_EXTRAVERSION" ] || K_EXTRAVERSION=0
[ "${K_EXTRAVERSION//[[:digit:]]/}" ] && { K_LOCALVERSION="$K_EXTRAVERSION $K_LOCALVERSION";K_EXTRAVERSION=0; }
KERNELSUBSUBVER="$K_EXTRAVERSION"

case $K_VERSION in
3) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
2)
        case $K_PATCHLEVEL in
        6)
                case $K_SUBLEVEL in
                29|30|31|32|33|34|35|36|37) SFSSTR='squashfs, version 4';SFSMAJOR=4;;
                38|39) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
                28)
                    case $K_EXTRAVERSION in
                    47) SFSSTR='squashfs, version 4';;
                    esac
                ;;
                *) _notice "Old 2.6 kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' sublevel '$K_SUBLEVEL' .";;
                esac;;
        0|1|2|3|4|5) _crit "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        *) _alert "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        esac;;
*) _emerg "Unhandled kernel version '$K_VERSION' .";;
esac

kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version2:KERNELVER='$KERNELVER'"
_info "_kernel_version2:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version2:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version2:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version2:squashXZ='$squashXZ'"
}

















_kernel_version3()
{
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset VERSIONS LOCALVERSION K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

test -f /proc/config.gz || modprobe -v configs
test -f /proc/config.gz && {

 if test "$*"; then
 KERNELVER="$@"
 fi

 VERSIONS=`zcat /proc/config.gz | grep -m2 -iE '# Linux.*kernel.*|CONFIG_LOCALVERSION=".*"'`
 test "$KERNELVER" || KERNELVER=`echo "$VERSIONS" | grep -m1 -i '# Linux.*kernel.*' | awk '{print $3}'`
 LOCALVERSION=`echo "$VERSIONS" | grep -m1 -i 'CONFIG_LOCALVERSION=".*"' | cut -f2 -d=`
_debug "KERNELVER='$KERNELVER'"
_debug "LOCALVERSION='$LOCALVERSION'"
 test "$KERNELVER" || KERNELVER="`uname -r`"
 KERNVER="$KERNELVER"
 KERNEL="$KERNELVER"

 SFSSTR='squashfs, version 4'
 SFSMAJOR=4
 squashXZ=YES

 if test "`echo "$KERNELVER" | grep '^3\.[0-9]\.'`"; then #111016
 _info "Kernel 3. series"
 K_VERSION=${KERNELVER:0:1}
 K_PATCHLEVEL=${KERNELVER:2:1}
 K_SUBLEVEL=${KERNELVER:4:1}

 KERNELSUBVER=$K_SUBLEVEL
 KERNELSUBSUBVER=0

 elif echo "$KERNELVER" | grep $Q '^2\.6'; then
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi

 else # assume 2.6
 _warn "Assuming kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi
fi


kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version3:KERNELVER='$KERNELVER'"
_info "_kernel_version3:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version3:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version3:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version3:squashXZ='$squashXZ'"
return 0
 } || _kernel_version
}













_kernel_version4()
{
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

_process_kernel_2dotX()
{
squashXZ=NOT
case $kVERSION in
0|1) _crit "TODO: Unhandled kVERSION '$kVERSION'"; return 1;;
2)
  case $kPATCHLEVEL in
  0|2|4|5) _warn "TODO: Unhandled kVERSION '$kVERSION' kPATCHLEVEL '$kPATCHLEVEL'"; return 1;;
  6) test "$kSUBLEVEL" -ge 38 && squashXZ=YES
     test "$kSUBLEVEL" -gt 28 && return 0
     case $kSUBLEVEL in
      27) test "$kEXTRAVERSION" -eq 47 && return 0
          return 1;;
     esac
  ;;
  esac
;;
esac
return 1
}

_eval_sfsversion()
{
case $1 in
1) SFSSTR='squashfs, version 3';SFSMAJOR=3; test "$squashXZ" || squashXZ=NOT;;
*) SFSSTR='squashfs, version 4';SFSMAJOR=4; test "$squashXZ" || squashXZ=YES;;
esac
}

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi

_old(){
case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
esac
}

_new(){
_debug "case \"$KERNEL\" start"
oldIFS="$IFS"
#IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄä:;'"'"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"  #bash-3.2 does not like * as IFS in case
_debug "case \"$KERNEL\" start"
case "$KERNEL" in
0*|1*|2*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
;;
3*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
;;
*) _debug "UNHANDLED KERNEL='$KERNEL'"
;;
esac
_debug "case \"$KERNEL\" end"
IFS="$oldIFS"
}

_old
#_new

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

test "$kVERSION" -le 2 && { _process_kernel_2dotX; _eval_sfsversion $?; } || _eval_sfsversion 0
_debug "_kernel_version4:End"

_notice "_kernel_version4:KERNELVER='$KERNELVER'"
_info "_kernel_version4:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version4:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version4:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version4:squashXZ='$squashXZ'"
}



















































































_kernel_version5()
{
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi
KERNELVER="$KERNEL"
KERNVER="$KERNEL"

unset SFSSTR SFS_STR SFS_MAJOR SFSMAJOR squashXZ

if test ! "$*"; then
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
test "$SFS_STR" || { ( busybox modprobe -l | grep $QUIET '/squashfs.ko' ) && {
grep $QUIET 'squashfs' /proc/modules || { modprobe $VERB squashfs; sleep 1; } ; }
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
}
test "$SFS_STR" || { _warn "Could not determine squashfs in dmesg, assuming \"version 4.0\""; SFS_STR='version 4.0'; }

SFS_MAJOR=`echo ${SFS_STR##* } | cut -b 1`
test "${SFS_MAJOR//[[:digit:]]/}" && SFS_MAJOR='';
test "$SFS_MAJOR" || { _warn "Could not determine squashfs major version, assuming '4'"; SFS_MAJOR=4; }

SFS_STR="squashfs, $SFS_STR"

else
:
fi

squashXZ=NOT
case "$KERNEL" in
3.*) squashXZ=YES
test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
test "$SFS_MAJOR" || SFS_MAJOR=4
;;
2.6.*) case $KERNEL in
     2.6.38*|2.6.39*) squashXZ=YES
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.29*|2.6.3[0-7]*)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.28*)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     2.6.27.47)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     *)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     esac
;;
*) _warn "_kernel_version5:UNHANDLED kernel version '$KERNEL' , assuming squashXZ=$squashXZ";;
esac

SFSSTR="$SFS_STR"
SFSMAJOR="$SFS_MAJOR"

case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
esac

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

_notice "_kernel_version5:KERNELVER='$KERNELVER'"
_info "_kernel_version5:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version5:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version5:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version5:squashXZ='$squashXZ'"
}




#================ Make free loop device ======================================
_mk_free_loop()
{
  FREE_LOOP=`losetup -f`  # find free and create loop
  [ "$FREE_LOOP" ] || {   # for kernel 3.0 and earlier
  LOOPS_ALL=`ls -1v /dev/loop* |sed 's%[^[:digit:]]%%g'`
  LOOP_LAST=`echo "$LOOPS_ALL" | tail -n1`
  LOOP_NEW=$(( $LOOP_LAST + 1 ))
  mknod /dev/loop${LOOP_NEW} b 7 $LOOP_NEW
  }
}

#================ Check GETTEXT ==============================================
_check_gettext()
{
_G=`which gettext`
test "$_G" && {
 test "`which gettext.sh`" && {
export TEXTDOMAIN=f4puppy5 #NOTE: rename to avoid clash with 'remasterpup2.mo' used by previous i18n method.
export OUTPUT_CHARSET=UTF-8
. gettext.sh
test "`type -t eval_gettext`"   &&  _eG=eval_gettext
if test "`which ngettext`"; then
 test "`type -t eval_ngettext`" && _eNG=eval_ngettext
fi
  }
 }

test "$_G"   ||   _G=echo
test "$_eG"  ||  _eG=echo
test "$_eNG" || _eNG='echo -n'
#echo "_G='$_G'"
#echo "_eG='$_eG'"
#echo "_eNG='$_eNG'"
alias g_="$_G"
alias eg_="$_eG"
alias eng_="$_eNG"
}
_check_gettext

_killzombies()
{
 ZOMBIES="`_command ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -vE 'grep|\|\|\|' | awk '{print $1}'`"
 ZOMBIES=`_command ps -H -A | awk '{if ($3 == "Z" || $3 == "Z+" || $3 == "Z<" || $3 == "ZL" || $3 == "Zl" || $3 == "ZN" || $3 == "Zs") print $1}'`
 ZOMBIES=`_command ps -H -A | awk '{if (match($3,"Z[+<LlNs]") || $3 == "Z") print $1}'`
 for oneZOMBIE in $ZOMBIES
 do
  _command ps --no-header -p $oneZOMBIE || continue
  _notice " :Killing (parentless) zombie process '$oneZOMBIE' ..."
  kill $oneZOMBIE
 done
}

#===== XMESSAGE or SPLASH ====================================================
_get_yaf_args()
{
for exe in pupmessage gtkdialog-splash yaf-splash gxmessage xmessage; do
YAF=`which $exe`
test "$YAF" || continue
test -L "$YAF" && continue
case $YAF in

 pupmessage)yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#gtkdialog-splash

# an easy replacement for yaf-splash in Puppy (NOT Puppy <=4.x)
# mave 30.05.2010
# no warranty
# Thanks for Puppy!

# usage: gtkdialog-splash [OPTIONS] [-timeout SEC] -text TEXT | -kill [ PID ]

# -text EXPRESSION
# -timeout COUNT (in seconds)
# -icon GTK-XXX (for example: gtk-info all gtk-stock-symbols, default: none)
# OR path/to/pixmap.png|gif|jpeg
# -icon_width WIDTH in pixels
# -bg COLOR (background color red, blue, yellow..., default: grey)
# -bg_gradient true|false (default: true)
# -fg COLOR (font color, default: black)
# -placement center|mouse|top|bottom|top-left|bottom-left (default: center)
# -close never|mouseover|box (default is mouseover)
# -deco TITLE (shows windows decorations, with title)
# -font NAME
# -fontsize SIZE
# -align ALIGNMENT left, right or center -margin SIZE (default: 10)
# -border true|false (default: true)
# -kill [ PID ] ( When PID omitted, kills all GTKDIALOG_SPLASH found
# in ps output, PID must exist as /tmp/GTKDIALOG-SPLASHPID with PID content )

 gtkdialog-splash) yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#Usage: yaf-splash [ options ]
#Where options include:

#  -text                         Message to display.
#  -timeout                      How long to display the message before
#                                exiting. Default is 0, which means forever.
#  -clock                        Enable clock display.
#  -12                           Display twelve hour time (default).
#  -24                           Display twenty-four hour time.
#  -seconds                      Display seconds (default).
#  -noseconds                    Don't display seconds.
#  -countdown <date>             Display a countdown instead of a clock.
#                                Run `-countdown foo' to see date syntax.
#  -countdownquit                Quit after the countdown has reached
#                                zero (default).
#  -nocountdownquit              Keep counting after reaching zero.
#  -geometry <geometry>          Size and position of window.
#  -placement <placement name>   A screen location, one of center, top,
#                                bottom, right, left, top-right, top-left,
#                                bottom-left, bottom-right. Defaults to center.
#                                A specified placement will override -geometry.
#  -font <font>                  Name of an X font to use.
#  -transparent                  Make the window background be transparent,
#                                if possible.
#  -nontransparent               Don't (default).
#  -mirror                       Flip the text about the y axis. Useful for
#                                back projection.
#  -nomirror                     Don't (default).
#  -fg                           Set the forground text colour (default: black).
#  -bg                           Set the background colour (default: white).
#  -bd                           Set the border colour (default: black).
#  -bw                           Set the border width (default: 2).
#  -outline                      Set the text outline width (default: 1).
#  -margin                       Set the margin size (default: 0).

 yaf-splash) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg black"; yafFG="-fg orange"; yafPL="-placement center"; yafFONT="-font -*-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafFONT="-font -misc-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafEXTRA="-transparent"
  #yaf-splash: couldn't load font "'*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

 gxmessage)#yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;

#gxmessage - a GTK-based xmessage clone

#Usage: gxmessage [OPTIONS] message ...
#       gxmessage [OPTIONS] -file FILENAME

#xmessage options:
#  -file FILENAME         Get message text from file, '-' for stdin
#  -buttons BUTTON_LIST   List of "LABEL:EXIT_CODE", comma separated
#  -default LABEL         Give keyboard focus to the specified button
#  -print                 Send the selected button's LABEL to stdout
#  -center                Try to open window in the centre of the screen
#  -nearmouse             Try to open window near the mouse pointer
#  -timeout SECONDS       Exit with code 0 after SECONDS seconds

#X-like options:
#  -display DISPLAY       X display to use
#  -fn FONT | -font FONT  Set message font (works with GTK font names)
#  -fg COLOUR             Set message font colour
#  -bg COLOUR             Set message background colour
#  -geometry GEOMETRY     Set window size (position will be ignored)
#  -iconic                Start iconified
#  -name NAME             Program name as used by the window manager
#  -title TITLE           Set window title to TITLE

#gxmessage options:
#  -borderless            Try to open window without border decoration
#  -nofocus               Don't focus the window when it opens
#  -encoding CHARSET      Expect CHARSET as the message encoding
#  -entry                 Prompt for text to be sent to stdout
#  -entrytext TEXT        Same as -entry, but with TEXT as default text
#  -wrap                  Wrap lines of text to fit window width
#  -help | -?             Show this usage information
#  -version               Show gxmessage version information

 xmessage) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;
esac
break
done
_debug "Using '$YAF'"
}

_GTKdialog_error()
{
local RV MSG
test "$1" && { RV="$1"; shift; } || RV=1
test "$*" && { MSG="$0:$*"; shift; }
test "$MSG" || MSG="$0:GTKdialog GUI crashed. Please run with -d option"

if _pidof -q X; then
xmessage -bg red "$MSG"
else
_err "$MSG"
fi

case $RV in
0) return 0;;
*) exit $RV;;
esac
}

_GTKdialog_remove_comments()
{

test "$*" || { _return 1 "No Input. Usage _GTKdialog_remove_comments DIALOG_GUI_CODE"; return 1; }
local sPATTERN1 sPATTERN2 sPATTERN3 sPATTERN4
sPATTERN1='s%<!--.*-->%%g'
sPATTERN2='/<!--/,/-->/d'
sPATTERN3='s%^#.*%%'
sPATTERN4='s%>.*#[^>]*$%%'

echo "$*" | sed -e "$sPATTERN1" -e "$sPATTERN2" -e "$sPATTERN3" -e "$sPATTERN4" || return 1
}

_GTKdialog_debug_gui()
{
test "$*" || { _return 2 "_GTKdialog_debug_gui: Usage: debugGUI=\`_GTKdialog_debug_gui \"$MAIN_DIALOG\"\`"; return $?; }

local lNR
lNR=0
echo "$*" | while read -r aLINE; do lNR=$((lNR+1)); echo "$lNR: $aLINE";done

}

_eval_error()
{
local RV MSG
test "$1" && { RV="$1"; shift; } || RV=1
test "$*" && { MSG="$0:$*"; shift; }
test "$MSG" || MSG="$0:eval failed. Probably due to faulty input."

if _pidof -q X; then
xmessage -bg red "$MSG"
else
_err "$MSG"
fi

case $RV in
0) return 0;;
*) exit $RV;;
esac
}

_pidof()
{
local RV
case $1 in
-q) shift;
pidof $* >/dev/null; return $?
;;
*)
echo -n "pids of $*:"
pidof $*; RV=$?
test "$RV" = 0 || echo
return $RV
;;
esac
}

_batch_diff1()
{
local SIMPLE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2
_debug "_batch_diff1: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff [ -s ] DIR"; return 1 2>$ERR || exit 1; }

test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory"; return 1 2>$ERR || exit 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>$ERR || exit 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

#FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

#FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

     test "$oneF1" = "$oneF2" && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII
done <<EoI
`echo "$FILES1"`
EoI

}

_batch_diff2()
{
local SIMPLE INVERT FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff2 [ -s |& -i ] DIR"; return 1 2>$ERR || exit 1; }


test "$1" = '-s' && { SIMPLE=YES; shift; }
test "$1" = '-i' && { INVERT=YES; shift; }
test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory"; return 1 2>$ERR || exit 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>$ERR || exit 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_batch_diff3()
{
DEBUG=1
local SIMPLE INVERT REMOVE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'" >&2

test "$*" || { _err "Usage: _batch_diff3 [ -s -i | -r ] DIR"; return 1 2>$ERR || exit 1; }

while [ "$2" ]; do
case "$1" in
-s) SIMPLE=YES;;
-i) INVERT=YES;;
-r) REMOVE=YES;;
esac
shift
done

test -d "$@" || { _err "'$@' not a directory"; return 1 2>$ERR || exit 1; }

cd "$@" || { _err "Could not change into '$@'"; return 1 2>$ERR || exit 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF2" "$oneF1" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF1" "$oneF2" && rm "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_add_header()
{
local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

test "$DRY" || DRY=  ##DRY RUN - don't change the original file

pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; exit 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep -viE 'perl|python|murgaLua_Dynamic' || continue

   grep 'f4puppy5' "$file" && continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   SHELLBANG=`head -n1 "$file"`

   case "$SHELLBANG" in
   \#\!*) :;;
   *) continue;;
   esac

   cat >/tmp/${file##*/} <<EoI
$SHELLBANG
#
# New header by $_AUTHOR_, $_MONTH_ $_YEAR_
  _TITLE_="Puppy_${file##*/}"
_VERSION_=1.0omega
_COMMENT_="\$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/$file"
MY_PID=\$\$

test -f /etc/rc.d/f4puppy5 && {
[ "\$HAVE_F4PUPPY5" ] || source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=''; TWO_VERSION=''; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="\$_COMMENT_"
_parse_basic_parameters "\$@"
[ "\$DO_SHIFT" ] && [ ! "\${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in \`seq 1 1 \$DO_SHIFT\`; do shift; done; }

_trap

}
# End new header
#
EoI

   cat "$file" | sed '1d' >>/tmp/${file##*/}
   [ "$?" = 0 ] || continue
   if test ! "$DRY"; then ## DRY RUN
    rm "$file"
    mv /tmp/${file##*/} "$file"
    chmod $PERM "$file"
   fi

done
}

_remove_header()
{
 local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

test "$DRY" || DRY=  ##DRY RUN - don't change the original file

 pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; exit 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep -viE 'perl|python|murgaLua_Dynamic' || continue

   grep "# New header by $_AUTHOR_, $_MONTH_ $_YEAR_" "$file" || continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   sed '/# New header by Karl Reimer Godt, September 2014/,/# End new header/ d' "$file" >/tmp/${file##*/}
   sed -i '2,3 d' /tmp/${file##*/}

   if test ! "$DRY"; then
   mv /tmp/${file##*/} "$file"
   chmod $PERM "$file"
   fi

done
}

###END###
_HAVE_F4PUPPY5_=1
  HAVE_F4PUPPY5=1
###END###
