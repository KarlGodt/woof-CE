#!/bin/ash

[ "$HAVE_F4PUPPY5" ] && return 0

# REM: Provide Version stubs
_assign_version()
{
case $1 in
_VERSION_) VERSION=$_VERSION_; Version=$_VERSION_; version=$_VERSION_;;
VERSION) _VERSION_=$VERSION; Version=$VERSION; version=$VERSION;;
Version) _VERSION_=$Version; VERSION=$Version; version=$Version;;
version) _VERSION_=$version; VERSION=$version; Version=$version;;
esac
}
# REM: if no *version* give a fallback version
test "$_VERSION_" && _assign_version _VERSION_ || _VERSION_=0.0.2
test "$VERSION"   && _assign_version VERSION   ||   VERSION=0.0.2
test "$Version"   && _assign_version Version   ||   Version=0.0.2
test "$version"   && _assign_version version   ||   version=0.0.2

# REM: $0 is always ok witch absolute path
#      but may be incorrect if link or called as ./exe
SCRIPT_NAME=f4puppy5 # short for functions for puppy 5

test "$MY_SELF" || MY_SELF="$0"
case ${MY_SELF##*/} in
ash|bash|sh) EXIT=return;;
*)           EXIT=exit;;
esac

# colours
 Black0='\033[0;30m'
 Black1='\033[1;30m'
   Red0='\033[0;31m'
   Red1='\033[1;31m'
 Green0='\033[0;32m'
 Green1='\033[1;32m'
Yellow0='\033[0;33m'
Yellow1='\033[1;33m'
  Blue0='\033[0;34m'
  Blue1='\033[1;34m'
  Pink0='\033[0;35m'
  Pink1='\033[1;35m'
  Cyan0='\033[0;36m'
  Cyan1='\033[1;36m'
 White0='\033[0;37m'
 White1='\033[1;37m'

  Back0='\033[0;39m'
 Reset0='\033[0;39m'
Normal0='\033[0;39m'

 BackBlack0='\033[0;40m'
 BackBlack1='\033[1;30m'
   BackRed0='\033[0;41m'
   BackRed1='\033[1;41m'
 BackGreen0='\033[0;42m'
 BackGreen1='\033[1;42m'
BackYellow0='\033[0;43m'
BackYellow1='\033[1;43m'
  BackBlue0='\033[0;44m'
  BackBlue1='\033[1;44m'
  BackPink0='\033[0;45m'
  BackPink1='\033[1;45m'
  BackCyan0='\033[0;46m'
  BackCyan1='\033[1;46m'
 BackWhite0='\033[0;47m'
 BackWhite1='\033[1;47m'

  BackBack0='\033[0;49m'
 BackReset0='\033[0;49m'
BackNormal0='\033[0;49m'

 UsBlack0='\033[4;30m'
 UsBlack1='\033[4;1;30m'
   UsRed0='\033[4;31m'
   UsRed1='\033[4;1;31m'
 UsGreen0='\033[4;32m'
 UsGreen1='\033[4;1;32m'
UsYellow0='\033[4;33m'
UsYellow1='\033[4;1;33m'
  UsBlue0='\033[4;34m'
  UsBlue1='\033[4;1;34m'
  UsPink0='\033[4;35m'
  UsPink1='\033[4;1;35m'
  UsCyan0='\033[4;36m'
  UsCyan1='\033[4;1;36m'
 UsWhite0='\033[4;37m'
 UsWhite1='\033[4;1;37m'

 BoldBlack0='\033[5;30m'
 BoldBlack1='\033[5;1;30m'
   BoldRed0='\033[5;31m'
   BoldRed1='\033[5;1;31m'
 BoldGreen0='\033[5;32m'
 BoldGreen1='\033[5;1;32m'
BoldYellow0='\033[5;33m'
BoldYellow1='\033[5;1;33m'
  BoldBlue0='\033[5;34m'
  BoldBlue1='\033[5;1;34m'
  BoldPink0='\033[5;35m'
  BoldPink1='\033[5;1;35m'
  BoldCyan0='\033[5;36m'
  BoldCyan1='\033[5;1;36m'
 BoldWhite0='\033[5;37m'
 BoldWhite1='\033[5;1;37m'

 InvBlack0='\033[7;30m'
 InvBlack1='\033[7;5;30m'
   InvRed0='\033[7;31m'
   InvRed1='\033[7;5;31m'
 InvGreen0='\033[7;32m'
 InvGreen1='\033[7;5;32m'
InvYellow0='\033[7;33m'
InvYellow1='\033[7;5;33m'
  InvBlue0='\033[7;34m'
  InvBlue1='\033[7;5;34m'
  InvPink0='\033[7;35m'
  InvPink1='\033[7;5;35m'
  InvCyan0='\033[7;36m'
  InvCyan1='\033[7;5;36m'
 InvWhite0='\033[7;37m'
 InvWhite1='\033[7;5;37m'
# /colours

# REM: Status is used in rc.sysinit,
#      but may be useful elsewhere
_status(){
 _TTY_=`tty`
 [ "$_TTY_" = 'not a tty' ] && _TTY_=/dev/console

 _CHARS_=${1//[[:digit:]]/}
 if [ "$_CHARS_" ];then echo -e "\\033[60G\\033[1;36m${_CHARS_}$Normal0" >$_TTY_
 set -- 0
 elif [ "$1" = 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone$Normal0"   >$_TTY_ #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed$Normal0" >$_TTY_ #red [failed].
  STATUS=0
 fi

 return $1 #return with same status as entry param.
}

# REM:
_cd_program_dir()
{
ME_PROG=`readlink -f "$0"`
ME_DIR=${ME_PROG%/*}
_debug "Changing into '$ME_DIR'"
cd "$ME_DIR"
return $?
}

# REM: using $0 (TODO)
_check_if_already_running()
{
pidof -o $$ -o %PPID "${0##*/}" && {
        echo "Already running."
        $EXIT 1
 }
return $?
}

# REM: tty functions ...
_check_for_terminal()
{
local MSG
MSG="Need a contolling terminal"
tty >>$OUT || {
echo -n "Pid of X server:"
pidof X && xmessage -br red "$MSG"; $EXIT 2; } || {
echo "$MSG"; $EXIT 2; }
return $?
}

__which_tty_is_X(){
#  2014-10-25
local ttyALL ttyX
#ps-FULL
ttyALL=`/bin/ps -A -o pid,ppid,tty,args | awk '{if (match($3, "tty[0-9]?")) print}'`
#busybox ps
#ttyALL=`busybox ps -A -o pid,ppid,tty,args | awk '{if (match($3, "4,[0-9]?")) print}'`
  _debugx "ttyALL='$ttyALL'"

#ps-FULL
   ttyX=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
#busybox ps
  #ttyX_=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  #ttyX=`stat -c %t','%T' '%n /dev/tty* | grep -w "^$ttyX_" | awk '{print $2}'`

  _info "X server found running on '$ttyX'"

#ps-FULL
  _DEV_TTY_X_="/dev/$ttyX"
      _TTY_X_="$ttyX"
#busybox ps
  #_DEV_TTY_X_="$ttyX"
  #    _TTY_X_=${ttyX##*/}

echo "$ttyX"
return 0
}

_which_tty_is_X(){
#  2014-10-25
local ttyALL ttyX
#ps-FULL
#ttyALL=`ps -A -o pid,ppid,tty,args | awk '{if (match($3, "tty[0-9]?")) print}'`
#busybox ps
ttyALL=`busybox ps -A -o pid,ppid,tty,args | awk '{if (match($3, "4,[0-9]?")) print}'`
  _debugx "ttyALL='$ttyALL'"
#ps-FULL
 #ttyX=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  ttyX_=`echo "$ttyALL" | awk '{if ($4 == "X" && $5 == ":0") print $3}' | head -n1`
  ttyX=`stat -c %t','%T' '%n /dev/tty* | grep -w "^$ttyX_" | awk '{print $2}'`
  _info "X server found running on '$ttyX'"
#ps-FULL
  #_DEV_TTY_X_="/dev/$ttyX"
  #    _TTY_X_="$ttyX"
#busybox ps
  _DEV_TTY_X_="$ttyX"
      _TTY_X_=${ttyX##*/}

echo "$ttyX"
return 0
}

_get_tty_X_nr(){
#  2014-10-25
local ttyX nrVT
ttyX=`_which_tty_is_X`
test "$ttyX" || return 1
nrVT=${ttyX##*[[:alpha:][:punct:]_]}
   case $nrVT in
    [1-9]|[1-9][0-9]) echo $nrVT; true;;
    *) _err "'$nrVT' not in range of 1-9 | 10-99"; false;;
   esac
return $?
}

_switch_to_tty_X(){
#  2014-10-25
local nrVT RV
nrVT=`_get_tty_X_nr`
   case $nrVT in
    [1-9]|[1-9][0-9]) chvt $nrVT
                      RV=$?;
    [ $RV = 0 ] && {
    _info "OK, switched to tty${nrVT}"
     return 0
     true; } || {
    _err "chvt '$nrVT' returned with '$RV' exitcode"
     return 1
     false; }
    ;;
    *) _err "'$nrVT' not in range of 1-9 | 10-99"; false;;
   esac
return $?
}

_logged_in_on_tty(){
local WHO_ RV USERS_ USERSm USERSs USERSa
WHO_=`_command who -a`
RV=$?
USERS_=`echo "$WHO_" | grep '^[[:alnum:][:punct:]_]'`
RV=$((RV+$?))
[ "$USERS_" ] || RV=$((RV+1))
USERSm=`echo "$USERS_" | tr -s ' '`
RV=$((RV+$?))
[ "$USERSm" ] || RV=$((RV+1))
USERSs=`echo "$USERSm"| sort -k4,5 -t' '`
RV=$((RV+$?))
[ "$USERSs" ] || RV=$((RV+1))
USERSa=`echo "$USERSs" | awk '{if (match($3, "tty[0-9]?")) print}'`
RV=$((RV+$?))
[ "$USERSa" ] || RV=$((RV+1))
echo "$USERSa"
RV=$((RV+$?))
return $RV
}

__logged_in_on_tty(){
###STUB### ##BB who does not show YEAR :(##
local WHO_ RV USERS_ USERSm USERSs USERSa
WHO_=`busybox who -a`
RV=$?
USERS_=`echo "$WHO_" | grep '^[[:alnum:][:punct:]_]'`
RV=$((RV+$?))
[ "$USERS_" ] || RV=$((RV+1))
USERSm=`echo "$USERS_" | tr -s ' '`
RV=$((RV+$?))
[ "$USERSm" ] || RV=$((RV+1))
USERSs=`echo "$USERSm"| sort -k4,5 -t' '`
RV=$((RV+$?))
[ "$USERSs" ] || RV=$((RV+1))
USERSa=`echo "$USERSs" | awk '{if (match($3, "tty[0-9]?")) print}'`
RV=$((RV+$?))
[ "$USERSa" ] || RV=$((RV+1))
echo "$USERSa"
RV=$((RV+$?))
return $RV
}

_last_logged_in_on_tty(){
local lastL RV
lastL=`_logged_in_on_tty | tail -n1`
RV=$?
[ "$lastL" ] || RV=$((RV+1))
echo "$lastL"
RV=$((RV+$?))
return $RV
}

# REM: use EXIT variable (either return or exit)
_exit()
{
RV=$1
shift
echo "$0:$*"
$EXIT $RV
}

# REM: trap stub
_trap()
{
trap "_exit 99 \"Caught Signal\"" INT KILL TERM
}

# REM: should be further up (TODO)
_version()
{
echo "$0:Version:$VERSION"
[ "$TWO_VERSION" ] && return 0
$EXIT 0
}

# REM:
_have_all_commands()
{

haveALL_COMMANDS=MAYBE

grep -I -oE -e '=`[^ ]*| \| [^ ]*' "$0" | grep -v '=.*=' | sort -u | sed 's@^=`@@;s@| @@' |
while read oneCOMMAND;
  do
#which $oneCOMMAND || haveALL_COMMANDS=NO;
test "`which "$oneCOMMAND"`" -o "`type "$oneCOMMAND"`" || { haveNOT_COMMAND="$haveNOT_COMMAND $oneCOMMAND"; haveALL_COMMANDS=NOT; }
done

[ "$haveALL_COMMANDS" = MAYBE ] && haveALL_COMMANDS=YES

  if test "$haveALL_COMMANDS" = YES; then
_debug "haveALL_COMMANDS=$haveALL_COMMANDS"
elif test "$haveALL_COMMANDS" = NOT; then
_warn "Don't have all needed commands! Here they are:
$haveNOT_COMMAND
"
else
_err "Unhandled haveALL_COMMANDS '$haveALL_COMMANDS'"
  fi
}

# REM: provide usage stub
_usage()
{
local USAGE_MSG RV
RV=$1
shift
test "$PARAMETER_LIST" || PARAMETER_LIST=PARAMETERS
test "$PARAMETERS" || PARAMETERS="NONE YET"
USAGE_MSG="
$0 [ $PARAMETER_LIST ]

PARAMETERS :
$PARAMETERS
--
$*
"
echo "$USAGE_MSG"

if [ "$TWO_HELP" ]; then
 return 0
else
 if test "$RV" != 0; then
   _exit $RV "Try again. Good Luck!"
 else
   $EXIT $RV
 fi
fi
return $?
}

#=============== OPTIONS ARGUMENTS PARAMETERS ================
# REM parameter option arguments processing function stubs ...
_provide_basic_parameters()
{
test "$ADD_PARAMETER_LIST" && ADD_PARAMETER_LIST="|$ADD_PARAMETER_LIST"
PARAMETER_LIST="-help|-version|-verbose|-debug$ADD_PARAMETER_LIST"
PARAMETERS="
-h|--help    : Show this message and exit.
-V|--version : Show version information and exit.
-v|--verbose : Supress /dev/null and quiet options, verbose options to binaries.
-d|--debug   : Run program with set -x .
$ADD_PARAMETERS
"
}

#Set defaults
_set_default_flags(){
OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=--quiet;DBG='';L_DBG='';A_DBG=''
export OUT ERR Q QUIET DBG L_DBG A_DBG
}
_set_default_flags

_set_verbose_flags(){
    _parse_cmdline_loglevel
    VERBOSE=1;
    EMERGENCY=1;ALERT=1;CRIT=1;ERROR=1;WARN=1;NOTICE=1;
    NOTICE2=1;INFO=1;
    VERB=-v;A_VERB=-verbose;L_VERB=--verbose;
    Q='';   QUIET='';
    DBG=-d;L_DBG=--debug;  A_DBG=-debug;
    OUT=/proc/self/fd/1;ERR=/proc/self/fd/2;
}

_parse_basic_parameters()
{

[ "$OUT" ]   || OUT=/dev/null;
[ "$ERR" ]   || ERR=$OUT;
[ "$Q" ]     || Q=-q;
[ "$QUIET" ] || QUIET=--quiet;
[ "$DBG" ]   || DBG=''   # -d
[ "$L_DBG" ] || L_DBG='' #--debug
[ "$A_DBG" ] || A_DBG='' # -debug

local OPT_ARG oldOPTIND=$OPTIND oldOPTERR=$OPTERR
OPTERR=0
OPTIND=0
#DEBUG=1
_debug "_parse_basic_parameters: \$*='$*' : \$#='$#'"

while :;
do
_debug "_parse_basic_parameters:\$1='$1'"
case $1 in

#HELP
-h|-H|-?help)

while getopts h:: option_ 2>>$ERR
do
 case $option_ in
  h) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done

#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR

#DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"

[ "$OPT_ARG" = elp ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

_usage 0 "$ADD_HELP_MSG";;
#VERSION
-V|-?version)

while getopts V:: option_ 2>>$ERR
do
 case $option_ in
  V) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done
#DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
[ "$OPT_ARG" = ersion ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

_version;;

#VERBOSE
-v*|-?verbose*)
_debug "HAVE verbose"
unset option_
_debug ERR=$ERR
ERR=/proc/self/fd/2
_debug ERR=$ERR
while getopts v:: option_ 2>>$ERR
do
 case $option_ in
  v) OPT_ARG="$OPTARG";;
  *) false;;
 esac
 sleep 0.1
echo "option_='$option_'" >&2
done
#DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
#[ "$OPT_ARG" = erbose ] && OPT_ARG='';
case $OPT_ARG in
erbose|cli|composeonly) OPT_ARG='';;
[v\-]*) _debug "GOT '$OPT_ARG'";OPT_ARG_="$OPT_ARG";OPT_ARG='';
esac
_debug "OPT_ARG='$OPT_ARG' OPT_ARG_='$OPT_ARG_'"
[ "$OPT_ARG" ] && return 0

#VERBOSE=1;VERB=-v;A_VERB=-verbose;L_VERB=--verbose;Q='';QUIET=$Q;DBG=-d;L_DBG=--debug;A_DBG=-debug
#INFO=1;OUT=/proc/self/fd/1;ERR=/proc/self/fd/2; [ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1));;
_set_verbose_flags
INFO=1

increaseV=0
for aCHAR in `echo "$OPT_ARG_" |sed -r 's%(.)% \1%g'`;
do
_debug "aCHAR='$aCHAR'"
case $aCHAR in
v) :;;
*) continue;;
esac
increaseV=$((increaseV+1));
done
VERBOSE=$increaseV

  if test $increaseV = 1; then
INFO2=1;DEBUG=1
elif test $increaseV -ge 2; then
INFO2=1;DEBUG=1;DEBUG2=1
fi

[ "$TWO_VERBOSE" ] || DO_SHIFT=$((DO_SHIFT+1))
_debug "DO_SHIFT='$DO_SHIFT'"
;;
#DEBUG
-d*|-?debug*)

while getopts d:: option_ 2>>$ERR
do
 case $option_ in
  d) OPT_ARG="$OPTARG";;
  *) false;;
 esac
done
#DEBUG=1
_debug "OPT_ARG='$OPT_ARG'"
#[ "$OPTIND" ] && [ "$OPTIND" -ge 1 ] && OPTIND=$((OPTIND-1))
OPTIND=$oldOPTIND;OPTERR=$oldOPTERR
[ "$OPT_ARG" = ebug ] && OPT_ARG='';
[ "$OPT_ARG" ] && return 0

set -x; [ "$TWO_DEBUG" ] || DO_SHIFT=$((DO_SHIFT+1));;

*) break;;
esac
shift
done

OPTERR=$oldOPTERR
export OUT ERR Q QUIET DBG VERB L_VERB A_VERB

}

__order_parameters()
{
oldIFS="$IFS"
IFS=$'\n'

while read -r aLINE
 do

  _debugx "aLINE='$aLINE'"

  case "$aLINE" in

## Example for option having OPTARG :
#  -X) read anoLINE
#      echo "anoLINE='$anoLINE'"
#      OPTIONS_="$OPTIONS_
#$aLINE $anoLINE";;

  -*)  OPTIONS_="$OPTIONS_
$aLINE";;
  *)   PARAMETERS_="$PARAMETERS_
$aLINE";;
  esac

 done <<EoI
`echo "$*"`
EoI

_debug "OPTIONS_='$OPTIONS_'"
_debug "PARAMETERS_='$PARAMETERS_'"

set - $OPTIONS_ $PARAMETERS_
_debug "\$*='$*'"
_debug "\$@='$@'"
_debug "\$#='$#' OPT_IND='$OPTIND'"
IFS="$oldIFS"
}

_order_parameters()
{
    _debug "\$*='$*'"
    _debug "\$@='$@'"
    _debug "\$#='$#'"
__order_parameters $*
                    if [ "$OPTIONS_" -a "$PARAMETERS_" ]; then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $OPTIONS_ $PARAMETERS_
                        IFS="$oldIFS"
                elif [ "$OPTIONS_" ];    then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $OPTIONS_
                        IFS="$oldIFS"
                elif [ "$PARAMETERS_" ]; then
                        oldIFS="$IFS"
                        IFS=$'\n'
                        set - $PARAMETERS_
                        IFS="$oldIFS"
                     fi
    _debug "\$*='$*'"
    _debug "\$@='$@'"
    _debug "\$#='$#'"
    unset OPTIONS_ PARAMETERS_
}

__getopt()
{

#POSIXLY_CORRECT=    ##
#GETOPT_COMPATIBLE=  ##

GET_OPT=`busybox getopt \
      -a -l help,version \
      -o h,V \
      -s sh \
      "$*"`
test $? = 0 || _usage 2 "Wrong option."

set - "`echo "$GET_OPT" | sed "s^' '^'\n'^g"`"

while read oneOPTION
do
test "$oneOPTION" || continue
case $oneOPTION
in
*) :;;
esac
done<<EoI
`set`
EoI
set -
return $?
}

_getopts()
{
    local DEBUG=1;DEBUG2=1
    _debug  "_getopts:'$*'"
    _debuge "_getopts:OPTIND=$OPTIND OPTERR=$OPTERR"
local oneOPTION
allOPS=AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz-
#while getopts hV oneOPTION
while getopts $allOPS oneOPTION
do
case $oneOPTION
in
d|h|V|v) _parse_basic_parameters $*; break;;
#h) _usage 0;;
#V) _version;;
#v) _parse_basic_parameters $*;;
#d) set -x;;
*) _warn -p "Unsupported option '$oneOPTION'";;
esac
sleep 0.1
done
return $?
}

_get_argv()
{
local oneARG
for oneARG in $*
do
case $oneARG
in
*help)    _usage 0;;
*version) _version;;
*) :;;
esac
done
return $?
}
#=============== OPTIONS ARGUMENTS PARAMETERS ================


# REM: _string_to_octal used in mount.sh
_string_to_octal()
{
_debug "_string_to_octal:$*"
unset oSTRING
if test "$*"; then
STRING_ORIG="$*"

STRING=`echo "$STRING_ORIG" | sed 's!\(.\)!"\1"\n!g'`
_debug "_string_to_octal:STRING='$STRING'"


while read -r oneCHAR
do

[ "$oneCHAR" ] && {
#oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
oneCHAR=${oneCHAR#\"}
oneCHAR=${oneCHAR%\"}
oCHAR=`printf %o \'"$oneCHAR"`
true; } || oCHAR=12

oSTRING=$oSTRING"\\0$oCHAR"

done<<EoI
`echo "$STRING"`
EoI

else

while read -r oneLINE
do
#test "$oneLINE" || continue
 _debug "oneLINE='$oneLINE'"
 STRING=`echo "$oneLINE" | sed 's!\(.\)!"\1"\n!g'`
 _debugx "STRING='$STRING'"

 while read -r oneCHAR
 do
 _debugx "oneCHAR='$oneCHAR'"

[ "$oneCHAR" ] && {
 #oneCHAR=`echo "$oneCHAR" | sed 's!^"!!;s!"$!!'`
 oneCHAR=${oneCHAR#\"}
 oneCHAR=${oneCHAR%\"}
 _debug "oneCHAR='$oneCHAR'"
 oCHAR=`printf %o \'"$oneCHAR"`
 true; } || oCHAR=12

 _debug "oCHAR='$oCHAR'"
 #test "$oCHAR" = 134 && oCHAR=0134

 oSTRING=$oSTRING"\\0$oCHAR"
 _debugx "oSTRING='$oSTRING'"

 done<<EoI
`echo "$STRING"`
EoI

oSTRING=$oSTRING"\\012"
done

fi

echo "$oSTRING"

}

# REM: could be further down (TODO)
_test()
{
#test "$*"
test $*
case $? in
0)
echo "'$*'" OK
return 0
;;
1)
echo "! '$*'"
return 1
;;
2)
echo "'$*'" wrong input
return 1
;;
esac
return $?
}

# REM: logging functions
_logger()
{
local MESSAGE PRIORITY TAG
case $# in
1) MESSAGE="$*";;
2) PRIORITY=$1
   shift
   MESSAGE="$*";;
''|0) echo "$0:_logger [ PRRIORITY ] [[ TAG ]]:Need at least MESSAGE." >&2
      return 1;;
*)
PRIORITY=$1
shift
TAG="$1"
shift
MESSAGE="$*"
;;
esac

#_test "\"$PRIORITY\"" != '""' || PRIORITY=7
#_test "\"$TAG\"" != '""'      || TAG=${0##*/}

_check_content "$PRIORITY" || PRIORITY=7
_check_content "$TAG"      || TAG=${0##*/}

logger -p $PRIORITY -t "$TAG" "$MESSAGE"
return $?

#May 29 09:21:57 puppypc user.debug  /bin/sh: TESTING logger 7
#May 29 09:22:13 puppypc user.info   /bin/sh: TESTING logger 6
#May 29 09:22:19 puppypc user.notice /bin/sh: TESTING logger 5
#May 29 09:22:26 puppypc user.warn   /bin/sh: TESTING logger 4
#May 29 09:22:32 puppypc user.err    /bin/sh: TESTING logger 3
#May 29 09:22:37 puppypc user.crit   /bin/sh: TESTING logger 2
#May 29 09:22:43 puppypc user.alert  /bin/sh: TESTING logger 1
#May 29 09:22:48 puppypc user.emerg  /bin/sh: TESTING logger 0
#May 29 09:22:06 puppypc user.emerg  /bin/sh: TESTING logger 8

}

#=============== Rotate Logs =================================================
_log_rotate()
{
test "$*" || { _err "_log_rotate:Need filename to rotate"; return 1; }
test -f "$*" || { _err "_log_rotate: '$*' not a regular file"; return 1; }

rm $VERB -f "$*".[1-9][0-9][0-9]* # limit to up to .99

if test "$DEBUG"; then
nrLOGS=`ls -1v "$*".[0-9]* | wc -l`
else
nrLOGS=`ls -1v "$*".[0-9]* 2>/dev/null | wc -l`
fi
#[ "$nrLOGS" ] || nrLOGS=0
#nrLOGS=$((nrLOGS-1))
_debug "nrLOGS='$nrLOGS'"

while read oneLOG
do
 test    "$oneLOG" || continue
 test -f "$oneLOG" || continue

 #nrLOGS=$((nrLOGS-1))
 # _debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS+1))"
 #mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS+1))

 #_debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$((nrLOGS))"
 #mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$((nrLOGS))
 _debug "oneLOG='$oneLOG' --> ${oneLOG%.[0-9]*}.$nrLOGS"
 mv $VERB "$oneLOG" "${oneLOG%.[0-9]*}".$nrLOGS
 nrLOGS=$((nrLOGS-1))

done <<EoI
`ls -1v "$*".[0-9]* | tac`
EoI

test -e "${*}.0" && { _err "Something went wrong"; return 1 ; }
 _info "moving $* --> ${*}.0"
mv $VERB "$*" "${*}.0"
}

_date(){
P="$1"
[ -z "$P" ] && P='s'

case $P in
s) date +%Y_%m_%d ;;
o) date +%d%b%Y ;;
*) date;;
esac
}

#======== Accumulating Errors and create Message Variable ====================
_basic_error_check()
{
local USAGE RV
USAGE="Usage: _basic_error_check \$? \"MESSAGE\""
RV=$1
test "$RV" || { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
test "${RV//[0-9]/}" && { RV=127; set - $USAGE $*; echo "$USAGE -- got '$*'" >&2; }
shift
if test "$RV" != "0"; then
__ERRORS__="$__ERRORS__
'$*' returned '$RV'"
fi
return $RV
}



_check_content()
{
test "$*" || { _err "Usage: _check_content VARIABLE -- got '$*'"; return 0; }
ENOCONTENT=28
#test "$*" && return 0 || { _err "NO content."; return $ENOCONTENT; }
#echo "'`eval echo \\$$*`'"
test "`eval echo \\$$*`" && return 0 || { _err "$*:NO content."; return $ENOCONTENT; }
}

_check_content2()
{
test "$2" || { _err "Usage: _check_content2 PATTERN VARIABLE -- got '$*'"; return 0; }
EWRONGCONTENT=29
unset sPATTERN gPATTERN
local sPATTERN gPATTERN
#echo -n "`eval echo \\$$*`"' : '
#echo "`eval echo \\$\${*//[[:digit:]]/}`"

case $1 in
  digit) gPATTERN="[[:digit:]]";;
nodigit|onlydigit|digitonly) gOPT=-v;gPATTERN="[[:digit:]]";
test "`echo $(eval echo \\$\${*//[[:digit:]]/})`" && { _warn "$*:Other than :digit: content."; return $EWRONGCONTENT; } || return 0;;
  alpha) gPATTERN="[[:alpha:]]";;
noalpha|onlyalpha|alphaonly) gOPT=-v;gPATTERN="[[:alpha:]]";
test "`echo $(eval echo \${*//[[:alpha:]]/})`" && { _warn "$*:Other than :alpha: content."; return $EWRONGCONTENT; } || return 0;;
  alnum) gPATTERN="[[:alnum:]]";;
noalnum|onlyalnum|alnumonly) gOPT=-v;gPATTERN="[[:alnum:]]";
test "`echo $(eval echo \${*//[[:alnum:]]/})`" && { _warn "$*:Other than :alnum: content."; return $EWRONGCONTENT; } || return 0;;
  punct) gPATTERN="[[:punct:]]";;
nopunct|onlypunct|punctonly) gOPT=-v;gPATTERN="[[:punct:]]";
test "`echo $(eval echo \\$\${*//[[:punct:]]/})`" && { _warn "$*:Other than :punct: content."; return $EWRONGCONTENT; } || return 0;;
  space) gPATTERN="[[:space:]]";;
nospace|onlyspace|spaceonly) gOPT=-v;gPATTERN="[[:space:]]";
test "`echo $(eval echo \\$\${*//[[:space:]]/})`" && { _warn "$*:Other than :space: content."; return $EWRONGCONTENT; } || return 0;;
  blank) gPATTERN="[[:blank:]]";;
noblank|onlyblank|blankonly) gOPT=-v;gPATTERN="[[:blank:]]";
test "`echo $(eval echo \\$\${*//[[:blank:]]/})`" && { _warn "$*:Other than :blank: content."; return $EWRONGCONTENT; } || return 0;;
'') :;;
no*|only*|*only) gOPT=-v;gPATTERN="$*";;
*) gPATTERN="$*";;
esac
shift

#test "`echo "$*" | grep -E "$gPATTERN"`" && return 0 || return $EWRONGCONTENT
#echo "$*" | grep -q -E "$gPATTERN" && return 0 || return $EWRONGCONTENT
#echo "`eval echo \\$$*`"

if test "$gOPT" = '-v'; then
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && { _warn "$*:Other than '$gPATTERN' content."; return $EWRONGCONTENT; } || return 0
else
echo "`eval echo \\$$*`" | grep $Q $gOPT -E "$gPATTERN" && return 0 || { _warn "$*:No '$gPATTERN' content."; return $EWRONGCONTENT; }
fi
}

#========= mountpoint related functions =====================================

_check_if_mountpoint(){

test "$*" || { _err "_check_if_mountpoint:Need mountpoint"; return 2; }

until [ "$#" = 1 ]; do
local PA1=$1
shift
done

case $1 in -*) local PA1=$*;shift;; esac

case $PA1 in --quiet) PA1=-q;;
--fs-devno) PA1=-d;;
--devno)    PA1=-x;;
--help)     PA1=-h;;
-d|-x)      :;;
-h|-q)      :;;
esac

case $PA1 in
-d|-x) _warn "_check_if_mountpoint:Currently unsupported option '$PA1'";;
-h|-q) :;;
'')    :;;
*) _err "_check_if_mountpoint:Unsupported option '$PA1'";;
esac

test "$PA1" = '-h' && { exec mountpoint $PA1 & return $?; }

local PARAM=`echo -e "$*"`
_debug "PA1=$PA1 PARAM=$PARAM"

while read _mntpt_
do
 test "$_mntpt_" || continue

 _mntpt_=`echo -e "$_mntpt_"`
 _debugx "_mntpt_=$_mntpt_"

 test "$_mntpt_" = "$PARAM" && {
  if test "$PA1" = '-q'; then :; else
  echo "$PARAM" is a mountpoint; fi;
 return 0; }

done <<EoI
`cut -f2 -d' ' /proc/mounts`
EoI

 if test "$PA1" = '-q'; then :; else
  echo "$PARAM" is not a mountpoint; fi;

return 1
}

__mountpoint(){

test "$*" || { _err "_mountpoint:Need mountpoint"; return 2; }

until [ "$#" = 1 ]; do
local PA1=$1
shift
done

case $1 in -*) local PA1=$*;shift;; esac

case $PA1 in --quiet) PA1=-q;;
--fs-devno) PA1=-d;;
--devno)    PA1=-x;;
--help)     PA1=-h;;
-d|-x)      :;;
-h|-q)      :;;
esac

case $PA1 in
-d|-x) _notice "_mountpoint:Currently unsupported option '$PA1'";;
-h|-q) :;;
'')    :;;
*) _warn "_mountpoint:Unsupported option '$PA1'";;
esac

test "$PA1" = '-h' && { exec mountpoint $PA1 & return $?; }
test "$*" || { _err "_mountpoint:Need mountpoint"; return 2; }

local PARAM=`echo -e "$*"`
_debug "PA1=$PA1 PARAM=$PARAM"

while read _mntpt_
do
 test "$_mntpt_" || continue

 _mntpt_=`echo -e "$_mntpt_"`
 _debugx "_mntpt_=$_mntpt_"

 test "$_mntpt_" = "$PARAM" && {
  if test "$PA1" = '-q'; then :; else
  echo "$PARAM" is a mountpoint; fi;
 return 0; }

done <<EoI
`cut -f2 -d' ' /proc/mounts`
EoI

 if test "$PA1" = '-q'; then :; else
  echo "$PARAM" is not a mountpoint; fi;

return 1
}

_mountpoint(){

test "$*" || { _err "_mountpoint:Need mountpoint"; return 2; }

until [ "$#" = 1 ]; do
local PA1=$1
shift
done

case $1 in -*) local PA1=$*;shift;; esac

case $PA1 in --quiet) PA1=-q;;
--fs-devno) PA1=-d;;
--devno)    PA1=-x;;
--help)     PA1=-h;;
-d|-x)      :;;
-h|-q)      :;;
esac

case $PA1 in
-d|-x) _notice "_mountpoint:Currently unsupported option '$PA1'";;
-h|-q) :;;
'')    :;;
*) _warn "_mountpoint:Unsupported option '$PA1'";;
esac

test "$PA1" = '-h' && { exec mountpoint $PA1 & return $?; }
test "$*" || { _err "_mountpoint:Need mountpoint"; return 2; }

local PARAM=`echo -e "$*"`
_debug "PA1=$PA1 PARAM=$PARAM"

case $PA1 in '-x')
test -b "$*" || { _err "_mountpoint:Not a block device"; return 2; }
MAJ=`stat -c %t "$*"`
MIN=`stat -c %T "$*"`
MAJ=`printf '%d' "0x$MAJ"`
MIN=`printf '%d' "0x$MIN"`
echo "$MAJ:$MIN"
return $?;;
esac

while read _mntpt_
do
 test "$_mntpt_" || continue

 _mntpt_=`echo -e "$_mntpt_"`
 _debugx "_mntpt_=$_mntpt_"

 test "$_mntpt_" = "$PARAM" && {
  case "$PA1" in '-q') return 0;;
  -d) :;;
  esac
  echo "$PARAM" is a mountpoint
 return 0; }

done <<EoI
`cut -f2 -d' ' /proc/mounts`
EoI

 case "$PA1" in '-q') return 1;;
 -d) :;;
 esac
  echo "$PARAM" is not a mountpoint

return 1
}

#================= Check /tmp if read-write ==================================
_check_proc()
{
  mountpoint $Q /proc && return $? || {
  busybox mount $VERB $VERB -o remount,rw /dev/root /
  test -d /proc || mkdir $VERB -p /proc
  busybox mount $VERB $VERB -t proc none /proc
  return $?
 }
}

_check_tmp()
{
 test -d /tmp && return $? || {
 busybox mount $VERB $VERB -o remount,rw /dev/root /
 mkdir $VERB -p /tmp
 chmod $VERB 1777 /tmp
 return $?
 }
}

_check_tmp_rw()
{
_check_proc || _crit "Difficulties with /proc  .."
_check_tmp  || _crit "Difficulties with /tmp  .."

mountpoint $Q /tmp && {
#grep -w '/tmp' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw tmpfs /tmp; return $?; }
# REM: use awk - grep -w would also grab '/tmp/something'
awk '{if ($2 == "/tmp") print $4}' /proc/mounts | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw tmpfs /tmp; return $?; }
 } || {
grep '^/dev/root' /proc/mounts | cut -f4 -d' ' | grep $Q -w 'rw' && return 0 || { busybox mount $VERB $VERB -o remount,rw /dev/root /; return $?; }
 }
}

#============= Avoid multiple instances of sync ==============================
# busybox NOFORK and SH_STANDALONE sync do not emit a PID
[ "`which sync`" ] && alias sync="`which sync`"
_sync()
{
#case "$1" in
#-q|-?quiet)
#shift
#;;
#esac
pidof sync >>$OUT || sync
}

#=============== LOGLEVEL / DEBUG MESSAGES ==================================
[ "$EMERGENCY" ] || EMERGENCY=1
[ "$ALERT" ]     || ALERT=1
[ "$CRIT" ]      || CRIT=1
[ "$ERROR" ]     || ERROR=1
[ "$WARN" ]      || WARN=1
[ "$NOTICE" ]    || NOTICE=1
[ "$NOTICE2" ]   || NOTICE2=1
[ "$INFO" ]      || INFO=
[ "$INFO2" ]     || INFO2=
[ "$DEBUG" ]     || DEBUG=
[ "$DEBUGX" ]    || DEBUGX=

# simple functions:
 _emerg(){ test "$EMERGENCY" || return 0; echo "$0:EMERGENGY:$*" >&2; }
 _alert(){ test "$ALERT"  || return 0; echo "$0:ALERT:$*"    >&2;     }
  _crit(){ test "$CRIT"   || return 0; echo "$0:CRITICAL:$*" >&2;  }
   _err(){ test "$ERROR"  || return 0; echo "$0:ERROR:$*"    >&2;  }
  _warn(){ test "$WARN"   || return 0; echo "$0:WARNING:$*"  >&2;  }
_notice(){ test "$NOTICE" || return 0; echo "$0:NOTICE:$*"   >&2;  }
  _info(){ test "$INFO"   || return 0; echo "$0:INFO:$*"     >&2;  }
 _debug(){ test "$DEBUG"  || return 0; echo "$0:DEBUG:$*"    >&2;  }
_debugx(){ test "$DEBUGX" || return 0; echo "$0:DEBUGX:$@"   >&2;  }

_parse_cmdline_loglevel(){

                            local LOG_LEVEL LOG_LEVEL_ aL

if test "$loglevel"; then
 LOG_LEVEL="$loglevel"
elif test "$LOGLEVEL"; then
 LOG_LEVEL="$LOGLEVEL"
fi

if test ! "$LOG_LEVEL"; then
 test -e /proc/cmdline || return 0
 LOG_LEVEL_=`grep -i -o 'loglevel=[^[:space:]]*' /proc/cmdline | tr '[:upper:]' '[:lower:]'`
 test "$LOG_LEVEL_" && { eval "$LOG_LEVEL_" && LOG_LEVEL=$loglevel; }
 test "$LOG_LEVEL" || { grep $Q -w debug /proc/cmdline >&2 && LOG_LEVEL=7; }
fi

#if test "$LOG_LEVEL" && [ ! "${LOG_LEVEL//[[:digit:]-]/}" ];
if test "$LOG_LEVEL"; then
if test ! "${LOG_LEVEL//[[:digit:]-]/}"; then
    # setting loglevel 8 to 0 and 9 to 1 ...
    while test "$LOG_LEVEL" -gt 7; do LOG_LEVEL=$((LOG_LEVEL-8)); done
    test "$LOG_LEVEL" -lt 0 && LOG_LEVEL=0

    for aL in `seq $LOG_LEVEL -1 0`; do
    case $aL in
    7) DEBUG=1;;
    6) INFO=1;;
    5) NOTICE=1;;
    4) WARN=1;;
    3) ERROR=1;;
    2) CRIT=1;;
    1) ALERT=1;;
    0) EMERGENCY=1;;
    *) false;;
    esac                        ; done
else
 _crit "CRITICAL WARNING: loglevel set to wrong '$LOG_LEVEL' parameter at the bootloader kernel commandline"
fi;else
 _notice "No loglevel specified at bootloader kernel commandline"
fi
}
#_parse_cmdline_loglevel


#advanced functions:
# simple functions with p postchar and or echo -n -e options as first parameter
_print_pretty(){
                # $1=LABEL ie ERROR, $2=Color for Label, $3=Color for EXE, $4 fg color for :, $5 bg color for :, $* MESSAGE
    if test "$PRETTY"; then
 echo -en "$3""$0""$4""$5"":""${Normal0}""$2""$1""$4""$5"":""${Normal0}"
    for i in `seq 1 1 5`; do shift; done
 echo -e "$*"

    else
 echo -n "$1:"
    for i in `seq 1 1 5`; do shift; done
 echo $echoOPT "$*"
    fi
   unset PRETTY echoOPT
}

_test_echo_opt(){
    unset echoOPT
    #DEBUG=1
    _debug "_test_echo_opt: \$1='$1' \$*='$*'"
    DO_SHIFT=0
    _debug "_test_echo_opt: \$1='$1' \$*='$*'"
        while test $# -gt 1 ; do
        _debugx "\$1='$1' \$#='$#'"

        {
        case $1 in -ne|-en|-n|-e) echoOPT="$echoOPT $1";DO_SHIFT=$((DO_SHIFT+1));; -p) PRETTY=1;DO_SHIFT=$((DO_SHIFT+1));; *) PRETTY=1;; esac; shift
        };                 done
}

_emergp(){
test "$EMERGENCY" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty "0* EMERGENCY" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_alertp(){
test "$ALERT" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "1*     ALERT" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"
}

_critp(){
test "$CRIT" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "2*  CRITICAL" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_errp(){
test "$ERROR" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty "3*        ERROR" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_warnp(){
test "$WARN" || return 0

  DO_SHIFT=0
 _debug "_warn:\$#=$# \$*='$*'"
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "4*   WARNING" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_noticep(){
test "$NOTICE" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "5*    NOTICE" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_notice2p(){
test "$NOTICE2" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**   NOTICE2" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_infop(){
test "$INFO" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "6*      INFO" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_info2p(){
test "$INFO2" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**     INFO2" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

_debugp(){
test "$DEBUG" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "7*     DEBUG" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

#[ "$DEBUGX" ] || DEBUGX=
#_debugx(){
#test "$DEBUGX" || return 0
#echo "$0:DEBUGX:$@"
#}

[ "$DEBUGE" ] || DEBUGE=
[ "$DEBUGX" ] && DEBUGE=$DEBUGX
[ "$DEBUG2" ] && DEBUGE=$DEBUG2
[ "$DEBUGA" ] && DEBUGE=$DEBUGA
_debugep()
{
[ "$DEBUGX" ] && DEBUGE=$DEBUGX
[ "$DEBUG2" ] && DEBUGE=$DEBUG2
[ "$DEBUGA" ] && DEBUGE=$DEBUGA
test "$DEBUGE" || return 0

  DO_SHIFT=0
 _test_echo_opt $*; for i in `seq 1 1 $DO_SHIFT`; do shift; done; unset DO_SHIFT;
 _debug "PRETTY='$PRETTY'"

_print_pretty    "**   EXTREME" "$Black1" "$Black0" "$White0" "$BackBlack0" "$*"

}

alias _debugap=_debugep
alias _debug2p=_debugep
alias _debugxp=_debugep
alias -p >>$OUT 2>>$ERR

# simple functions with date and timestamp:
_date_FT(){ _DATE_FT_=`date +%F-%T`; }

 _emergd(){ test "$EMERGENCY" || return 0; _date_FT ; echo "$0:$_DATE_FT_:EMERGENGY:$*"; unset _DATE_FT_; }
 _alertd(){ test "$ALERT"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ALERT:$*";    unset _DATE_FT_;     }
  _critd(){ test "$CRIT"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:CRITICAL:$*"; unset _DATE_FT_;     }
   _errd(){ test "$ERROR"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:ERROR:$*";    unset _DATE_FT_;     }
  _warnd(){ test "$WARN"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:WARNING:$*";  unset _DATE_FT_;     }
_noticed(){ test "$NOTICE" || return 0; _date_FT ; echo "$0:$_DATE_FT_:NOTICE:$*";   unset _DATE_FT_;     }
  _infod(){ test "$INFO"   || return 0; _date_FT ; echo "$0:$_DATE_FT_:INFO:$*";     unset _DATE_FT_;     }
 _debugd(){ test "$DEBUG"  || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUG:$*";    unset _DATE_FT_;     }
_debugxd(){ test "$DEBUGX" || return 0; _date_FT ; echo "$0:$_DATE_FT_:DEBUGX:$@";   unset _DATE_FT_;     }

[ "$DEBUGT" ] || DEBUGT=
_debugt()
{  #$1 label #$2 time

test "$DEBUGT" || return 0
    #unset LANG LC_ALL
    local _TIME_ LC_NUMERIC=C LANG= LC_ALL=
    _DATE_=`date +%s.%N | sed 's:.*\(..\..*\):\1:'`
    #_DATE_=`date +%s,%N | sed 's:.*\(..\,.*\):\1:'`
    if test "$2"; then
    _TIME_=`dc $_DATE_ $2 \- p`
    echo "$0:TIME:$1:$_TIME_"
    else
    #echo "$0:TIME:$*:`date +%s.%N | sed 's:.*\(..\..*\):\1:'`"
    echo "$0:TIME:$*:$_DATE_"
    fi
}

#=================== Prefer Busybox applets ==================================
_use_busybox_applets()
{
[ "`which busybox`" ] && BBEXE=`which busybox`
[ "$BBEXE" ] || { [ -s /bin/busybox -a -x /bin/busybox ] && BBEXE='/bin/busybox'; }
[ "$BBEXE" ] || return 2  ##errno.h:define ENOENT 2 /* No such file or directory */

BBAPPLETS=`$BBEXE --list`

test "$BBAPPLETS" || BBAPPLETS='basename cat chmod chown clear cut
date dc dd dirname dmesg du ed expr false find free
head kill ln login ls lsmod mkdir mknod more mv nice pidof
readlink rev rm rmdir sleep sort stat su sync tail tar touch tr true
uname usleep waitmax wc which xargs'

for applet in $BBAPPLETS
do
#echo $applet
#file "`which $applet`" | grep 'link' | grep busybox || continue
eval "alias ${applet}=\"$BBEXE $applet\"";

done
}

#================ return with message, same as _exit =========================
_return()
{
RV=$1
 test "$RV" && shift || {
 false
 }
test "${RV//[0-9]/}" && RV=123
echo "$*"
[ "$RV" ] || RV=124
return $RV
}

#================== Use binary instead of busybox applet =====================
_command() # This is for busybox with internals first .
{          # sed -i and grep -w may not work as the regular binaries ,
           # especially if compiled without REGEX or not with GLIBC
#echo "$0:_command:$1:$*"
COM="$1"
shift
#echo "$0:_command:$1:$*"

typeCOM=`type -p "$COM"`
test "$typeCOM"  ||  { _return 1 "No such type \"$COM\"" >&2;return $?; }

whichCOM=`which "$COM"`
test "$whichCOM" || { _return 1 "No such which \"$COM\"" >&2;return $?; }

_debug "_command:$COM:$@"

test "$typeCOM" = "$whichCOM" && {
 "$typeCOM" "$@"    # "$*" does not work, so needs "$@"
 return $?
 } || {
 "$whichCOM" "$@"
 return $?
 }
}

#========= make nodes in /dev if /dev not mounted ============================
_mkdevices()
{
mountpoint $Q /dev && return 0
test "`type mdev`" && { mdev -s; return $?; }
 while read maj min siz dev ; do
  [ "${maj//[[:digit:]]/}" ] && continue
  [ "$maj" -a "$min" -a "$dev" ] || continue
  test -b /dev/$dev || mknod /dev/$dev b $maj $min
 done</proc/partitions
}

#============ Tests =======================================

# REM: shell test ignores permissions for root somehow...??
_ami_root(){
if [ "$VERBOSE" -o "$DEBUG" -o "$DEBUGX" ]; then
  whoami | grep -w root && return 0
    else
[ "`whoami`" = 'root' ] && return 0
fi
return 1
}

_test_e(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
return 0
# _return 0 "$* exists"; return $?
}

_test_L(){
test -L "$*" && { _return 0 "$* is a link"; return $?; }
return 3
# _return 3 "$* is not a link"; return $?
}

_test_f()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -f "$*" && return 0
return 1
}

#= readable to source
_test_fr(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep '^\-r' && return 0
else
test -f "$*" -a -r "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

#= writable to write to
_test_fw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^\-.w' && return 0
else
test -f "$*" -a -w "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

_test_frw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^\-rw' && return 0
else
test -f "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

#= file and xecutable
_test_fx(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -f "$*" -a -x "$*" && return 0
test -f "$*" || return 4
return 1
}

#= file and has size
_test_fs(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -f "$*" -a -s "$*" && return 0
test -f "$*" || return 4
return 1
}

#= file readable and size
_test_frs(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 [ "`ls -dl "$*" | grep '^\-r'`" -a -s "$*" ] && return 0
else
test -f "$*" -a -r "$*" -a -s "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

_test_d()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -d "$*" && return 0
return 1
}

_test_drwx()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^drwx' && return 0
else
test -d "$*" -a -r "$*" -a -w "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4

return 1
}

_test_drx()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^dr.x' && return 0
else
test -d "$*" -a -r "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_dwx()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d.wx' && return 0
else
test -d "$*" -a -w "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_drw()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^drw' && return 0
else
test -d "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_dr()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^dr' && return 0
else
test -d "$*" -a -r "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_dw()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d.w' && return 0
else
test -d "$*" -a -w "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_dx()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d..x' && return 0
else
 test -d "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_test_p()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -p "$*" && return 0
return 1
}

_test_S()
{
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -S "$*" && return 0
return 1
}

_test_c(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -c "$*" && return 0
return 1
}

_test_crw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^crw' && return 0
else
test -c "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -c "$*" || return 4
return 1
}

_test_cr(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^cr' && return 0
else
test -c "$*" -a -r "$*" && return 0
fi
test -c "$*" || return 4
return 1
}

_test_cw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^c.w' && return 0
else
test -c "$*" -a -w "$*" && return 0
fi
test -c "$*" || return 4
return 1
}


_test_b(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"
test -b "$*" && return 0
return 1
}

_test_brw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^brw' && return 0
else
test -b "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

_test_br(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^br' && return 0
else
test -b "$*" -a -r "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

_test_bw(){
test -e "$*" || { _return 2 "$* does not exist"; return $?; }
test -L "$*" && _notice "$* is a link"

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^b.w' && return 0
else
test -b "$*" -a -w "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

#============ Secure tests to filter out links =======================================
_stest_f()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" && return 0
return 1
}

#= readable to source
_stest_fr(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep '^\-r' && return 0
else
test -f "$*" -a -r "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

#= writable to write to
_stest_fw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^\-.w' && return 0
else
test -f "$*" -a -w "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

_stest_frw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^\-rw' && return 0
else
test -f "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

#= file and xecutable
_stest_fx(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -x "$*" && return 0
test -f "$*" || return 4
return 1
}

#= file and has size
_tsest_fs(){
test -e "$*" || return 2
test -L "$*" && return 3
test -f "$*" -a -s "$*" && return 0
test -f "$*" || return 4
return 1
}

#= file readable and size
_stest_frs(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 [ "`ls -dl "$*" | grep '^\-r'`" -a -s "$*" ] && return 0
else
test -f "$*" -a -r "$*" -a -s "$*" && return 0
fi
test -f "$*" || return 4
return 1
}

_stest_d()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -d "$*" && return 0
return 1
}

_stest_drwx()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^drwx' && return 0
else
test -d "$*" -a -r "$*" -a -w "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4

return 1
}

_stest_drx()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^dr.x' && return 0
else
test -d "$*" -a -r "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_dwx()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d.wx' && return 0
else
test -d "$*" -a -w "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_drw()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^drw' && return 0
else
test -d "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_dr()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^dr' && return 0
else
test -d "$*" -a -r "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_dw()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d.w' && return 0
else
test -d "$*" -a -w "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_dx()
{
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using ls -dl
if [ "`whoami`" = "root" ]; then
 ls -dl "$*" | grep $Q '^d..x' && return 0
else
 test -d "$*" -a -x "$*" && return 0
fi
test -d "$*" || return 4
return 1
}

_stest_p()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -p "$*" && return 0
return 1
}

_stest_S()
{
test -e "$*" || return 2
test -L "$*" && return 3
test -S "$*" && return 0
return 1
}

_stest_c(){
test -e "$*" || return 2
test -L "$*" && return 3
test -c "$*" && return 0
return 1
}

_stest_crw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^crw' && return 0
else
test -c "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -c "$*" || return 4
return 1
}

_stest_cr(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^cr' && return 0
else
test -c "$*" -a -r "$*" && return 0
fi
test -c "$*" || return 4
return 1
}

_stest_cw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^c.w' && return 0
else
test -c "$*" -a -w "$*" && return 0
fi
test -c "$*" || return 4
return 1
}


_stest_b(){
test -e "$*" || return 2
test -L "$*" && return 3
test -b "$*" && return 0
return 1
}

_stest_brw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^brw' && return 0
else
test -b "$*" -a -r "$*" -a -w "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

_stest_br(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^br' && return 0
else
test -b "$*" -a -r "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

_stest_bw(){
test -e "$*" || return 2
test -L "$*" && return 3

# REM: shell test ignores permissions for root somehow,
# so using stat -c %A
if [ "`whoami`" = "root" ]; then
 stat -c %A "$*" | grep $Q '^b.w' && return 0
else
test -b "$*" -a -w "$*" && return 0
fi
test -b "$*" || return 4
return 1
}

#================= KERNEL VERSION and SFS VERSION ============================

#VERSION = 3
#PATCHLEVEL = 13
#SUBLEVEL = 3
#EXTRAVERSION =
#Mounting Squashfs 1.x filesystems IS supported by the 2.0 kernel patch.
#Mounting 2.0 filesystems is supported by Squashfs 2.1.
#Squashfs 3.0 supports 2.x filesystems.  Support for 1.x filesystems
#will be added in the future.
#3.2: Unsquashfs now supports Squashfs 2.x filesystems.
#Welcome to Squashfs 4.0.  This is an initial tools only release to
#support users of the 2.6.29 kernel
#Later releases will probably contain kernel patches supporting 4.0
#layouts for earlier kernels.

_kernel_version()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"
KERNEL_RELEASE="$KERNELVER"

SFSSTR='squashfs, version 4'
SFSMAJOR=4
squashXZ=YES

if vercmp $KERNELVER ge 3.0;then #111016
:    # if vercmp not installed would run else
_info "Kernel 3.0 or greater"
else # assume 2.6
 #test $? = 127 && { _warn "_kernel_version:Is vercomp installed in PATH? -- using _kernel_version2 instead..."; _kernel_version2; }
 #echo $?
 #which vercmp || _kernel_version2
case $KERNELVER in
2.6.*)
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`

 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
   SFSSTR='squashfs, version 3'
   SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
 squashXZ=NOT
 fi
;;
*) _err "_kernel_version:UNHANDLED KERNELVER '$KERNELVER'";;
esac
fi 2>>$ERR #if vercmp is not installed :P

#kVERSION="$K_VERSION"
#kPATCHLEVEL="$K_PATCHLEVEL"
#kSUBLEVEL="$K_SUBLEVEL"
#kEXTRAVERSION="$K_EXTRAVERSION"
#kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version:KERNELVER='$KERNELVER'"
_info "_kernel_version:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}








_kernel_version2()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
#INFO=1
#DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION K_LOCALVERSION
unset SFSSTR SFSMAJOR squashXZ

if test "$*"; then
KERNELVER="$@"
else
KERNELVER=`uname -r`
fi
KERNEL="$KERNELVER"
KERNVER="$KERNELVER"
KERNEL_RELEASE="$KERNELVER"

SFSSTR='squashfs, version 3'
SFSMAJOR=3
squashXZ=NOT

ifsv='.-_'
#ifsv='[[:punct:]]' # also [:punct:] does not work
ifsv='^°!"§$%&/()=?`¹²³¼½¬{[]}\ß´+*~#-_.:·,;'"'"  # '\' seems not to work , even as '\\' '\\\' '\\\\'

      K_VERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion localversion;echo $kversion; }` ##code from /usr/sbin/laptop_mode, Maintainer: Bart Samwel (bart@samwel.tk)
   K_PATCHLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel localversion;echo $patchlevel; }`
     K_SUBLEVEL=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $sublevel; }`
   KERNELSUBVER="$K_SUBLEVEL"

 #test "$K_VERSION" || _err "_kernel_version2:Could not get K_VERSION"
 _check_content K_VERSION
 #test "${K_VERSION//[[:digit:]]/}" && _warn "_kernel_version2:Got '$K_VERSION' with other than :digit:"
 _check_content2 onlydigit "$K_VERSION"

 if test $K_VERSION = 3; then
  _info "Newer kernel 3 series"
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel localversion;echo $localversion; }`
 elif
 test $K_VERSION = 2; then
  _info "Older Kernel 2 series"
  K_EXTRAVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $extraversion; }`
  K_LOCALVERSION=`echo "$KERNVER" | { IFS="$ifsv" read kversion patchlevel sublevel extraversion localversion;echo $localversion; }`
 else
  _err "Unhandled K_VERSION '$K_VERSION'"
 fi

[ "$K_EXTRAVERSION" ] || K_EXTRAVERSION=0
[ "${K_EXTRAVERSION//[[:digit:]]/}" ] && { K_LOCALVERSION="$K_EXTRAVERSION $K_LOCALVERSION";K_EXTRAVERSION=0; }
KERNELSUBSUBVER="$K_EXTRAVERSION"

case $K_VERSION in
[3-9]) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
2)
        case $K_PATCHLEVEL in
        6)
                case $K_SUBLEVEL in
                29|30|31|32|33|34|35|36|37) SFSSTR='squashfs, version 4';SFSMAJOR=4;;
                38|39) SFSSTR='squashfs, version 4';SFSMAJOR=4;squashXZ=YES;;
                28)
                    case $K_EXTRAVERSION in
                    47) SFSSTR='squashfs, version 4';;
                    esac
                ;;
                *) _notice "Old 2.6 kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' sublevel '$K_SUBLEVEL' .";;
                esac;;
        0|1|2|3|4|5) _crit "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        *) _alert "Unhandled kernel version '$K_VERSION' patchlevel '$K_PATCHLEVEL' .";;
        esac;;
*) _emerg "Unhandled kernel version '$K_VERSION' .";;
esac

kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version2:KERNELVER='$KERNELVER'"
_info "_kernel_version2:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version2:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version2:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version2:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}
















_kernel_version3()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset VERSIONS LOCALVERSION K_VERSION K_PATCHLEVEL K_SUBLEVEL K_EXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

test -f /proc/config.gz || modprobe $Q $VERB configs
test -f /proc/config.gz && {

 if test "$*"; then
 KERNELVER="$@"
 fi

 VERSIONS=`zcat /proc/config.gz | grep -m2 -iE '# Linux.*kernel.*|CONFIG_LOCALVERSION=".*"'`

# k 2.6.31.14:
# # Linux kernel version: 2.6.31.14
# CONFIG_LOCALVERSION="-KRG-i586-pae-300Hz-slub-flatmem-8cpu"
 test "$KERNELVER" || KERNELVER=`echo "$VERSIONS" | grep -m1 -i '# Linux.*kernel version:.*' | awk '{print $NF}'`


 test "$KERNELVER" || KERNELVER=`echo "$VERSIONS" | grep -m1 -i '# Linux.*kernel.*' | awk '{print $3}'`


 LOCALVERSION=`echo "$VERSIONS" | grep -m1 -i 'CONFIG_LOCALVERSION=".*"' | cut -f2 -d=`
_debug "KERNELVER='$KERNELVER'"
_debug "LOCALVERSION='$LOCALVERSION'"
 test "$KERNELVER" || KERNELVER="`uname -r`"
 KERNEL_RELEASE="$KERNELVER"
 KERNVER="$KERNELVER"
 KERNEL="$KERNELVER"

 SFSSTR='squashfs, version 4'
 SFSMAJOR=4
 squashXZ=YES

 if test "`echo "$KERNELVER" | grep '^3\.[0-9]\.'`"; then #111016
 _info "Kernel 3. series"
 K_VERSION=${KERNELVER:0:1}
 K_PATCHLEVEL=${KERNELVER:2:1}
 K_SUBLEVEL=${KERNELVER:4:1}

 KERNELSUBVER=$K_SUBLEVEL
 KERNELSUBSUBVER=0

 elif echo "$KERNELVER" | grep $Q '^2\.6'; then
 _info "Kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi

 else # assume 2.6
 _warn "Assuming kernel 2.6 series"
 KERNELSUBVER=`echo -n "$KERNELVER" | cut -f 3 -d '.' | cut -f 1 -d '-' | cut -f 1 -d '_'` #100831
 KERNELSUBSUBVER=`echo -n "$KERNELVER" | cut -f 4 -d '.' | cut -f 1 -d '-'`
 test "$KERNELSUBVER" || KERNELSUBVER=0
 test "${KERNELSUBVER//[[:digit:]]/}" && KERNELSUBVER=0
 test "$KERNELSUBSUBVER" || KERNELSUBSUBVER=0
 test "${KERNELSUBSUBVER//[[:digit:]]/}" && KERNELSUBSUBVER=0

 if [ $KERNELSUBVER -eq 27 -a ! $KERNELSUBSUBVER -eq 47 ] || [ $KERNELSUBVER -le 26 ] || [ $KERNELSUBVER -eq 28 ];then
  SFSSTR='squashfs, version 3'
  SFSMAJOR=3
 fi
 if test $KERNELSUBVER -le 37; then
  squashXZ=NOT
 fi
fi


kVERSION="$K_VERSION"
kPATCHLEVEL="$K_PATCHLEVEL"
kSUBLEVEL="$K_SUBLEVEL"
kEXTRAVERSION="$K_EXTRAVERSION"
kLOCALVERSION="$K_LOCALVERSION"

_notice "_kernel_version3:KERNELVER='$KERNELVER'"
_info "_kernel_version3:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version3:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version3:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version3:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
return 0
 } || _kernel_version
INFO=$oldINFO;DEBUG=$oldDEBUG
}


_kernel_version4()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION
unset SFSSTR SFSMAJOR squashXZ

_process_kernel_2dotX()
{
squashXZ=NOT
case $kVERSION in
0|1) _crit "TODO: Unhandled kVERSION '$kVERSION'"; return 1;;
2)
  case $kPATCHLEVEL in
  0|2|4|5) _warn "TODO: Unhandled kVERSION '$kVERSION' kPATCHLEVEL '$kPATCHLEVEL'"; return 1;;
  6) test "$kSUBLEVEL" -ge 38 && squashXZ=YES
     test "$kSUBLEVEL" -gt 28 && return 0
     case $kSUBLEVEL in
      27) test "$kEXTRAVERSION" -eq 47 && return 0
          return 1;;
     esac
  ;;
  esac
;;
esac
return 1
}

_eval_sfsversion()
{
case $1 in
1) SFSSTR='squashfs, version 3';SFSMAJOR=3; test "$squashXZ" || squashXZ=NOT;;
*) SFSSTR='squashfs, version 4';SFSMAJOR=4; test "$squashXZ" || squashXZ=YES;;
esac
}

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi

_old(){
case "$KERNEL" in
0.*|1.*|2.*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
echo kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION
;;
esac
}

_new(){
_debug "case \"$KERNEL\" start"
oldIFS="$IFS"
#IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄä:;'"'"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"  #bash-3.2 does not like * as IFS in case
_debug "case \"$KERNEL\" start"
case "$KERNEL" in
0*|1*|2*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
;;
[3-9]*) _debug "HANDLED KERNEL='$KERNEL'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION <<EoI
`echo "$KERNEL"`
EoI
;;
*) _debug "UNHANDLED KERNEL='$KERNEL'"
;;
esac
_debug "case \"$KERNEL\" end"
IFS="$oldIFS"
}

#_old
_new

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"
KERNEL_RELEASE="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

test "$kVERSION" -le 2 && { _process_kernel_2dotX; _eval_sfsversion $?; } || _eval_sfsversion 0
_debug "_kernel_version4:End"

_notice "_kernel_version4:KERNELVER='$KERNELVER'"
_info "_kernel_version4:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version4:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version4:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version4:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}











_kernel_version5()
{
local oldINFO=$INFO oldDEBUG=$DEBUG
INFO=1
DEBUG=1

unset KERNEL KERNVER KERNELVER KERNELSUBVER KERNELSUBSUBVER
unset kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION

if test "$*"; then
KERNEL="$@"
else
KERNEL=`uname -r`
fi
KERNEL_RELEASE="$KERNEL"
KERNELVER="$KERNEL"
KERNVER="$KERNEL"

unset SFSSTR SFS_STR SFS_MAJOR SFSMAJOR squashXZ

if test ! "$*"; then
SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`
test "$SFS_STR" || { ( busybox modprobe -l | grep $Q '/squashfs.ko' ) && {
    test -f /proc/modules && {
    grep $Q 'squashfs' /proc/modules || { modprobe $VERB squashfs; sleep 1; }
    } || { modprobe $VERB squashfs; sleep 1; }
if _test_fr /var/log/bootkernel-${KERNEL_RELEASE}.log; then
SFS_STR=`grep -i squash /var/log/bootkernel-${KERNEL_RELEASE}.log | grep -o -i 'version.*' | cut -f1,2 -d' '`
fi
test "$SFS_STR" || { SFS_STR=`dmesg | grep -i squash | grep -o -i 'version.*' | cut -f1,2 -d' '`; }
test "$SFS_STR" || { SFS_STR=`modinfo squashfs | grep -o 'description:.*squashfs [0-9]\.[0-9],' | awk '{print $NF}' | sed 's!,$!!'`
  test "$SFS_STR" && SFS_STR="version $SFS_STR"; }
}; }
test "$SFS_STR" || { _warn "Could not determine squashfs in dmesg or modinfo, assuming \"version 4.0\""; SFS_STR='version 4.0'; }

SFS_MAJOR=`echo ${SFS_STR##* } | cut -b 1`
test "${SFS_MAJOR//[[:digit:]]/}" && SFS_MAJOR='';
test "$SFS_MAJOR" || { _warn "Could not determine squashfs major version, assuming '4'"; SFS_MAJOR=4; }

test "$SFS_STR" && SFS_STR="squashfs, $SFS_STR"

else
:
fi

squashXZ=NOT
case "$KERNEL" in
[3-9].*) squashXZ=YES
test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
test "$SFS_MAJOR" || SFS_MAJOR=4
;;
2.6.*) case $KERNEL in
     2.6.38*|2.6.39*) squashXZ=YES
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.29*|2.6.3[0-7]*)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     2.6.28*)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     2.6.27.47)
     test "$SFS_STR" || SFS_STR="squashfs, version 4.0"
     test "$SFS_MAJOR" || SFS_MAJOR=4
     ;;
     *)
     test "$SFS_STR" || SFS_STR="squashfs, version 3.0"
     test "$SFS_MAJOR" || SFS_MAJOR=3
     ;;
     esac
;;
*) _warn "_kernel_version5:UNHANDLED kernel version '$KERNEL' , assuming squashXZ=$squashXZ";;
esac

SFSSTR="$SFS_STR"
SFSMAJOR="$SFS_MAJOR"

case "$KERNEL" in
0.*|1.*) _warn "Unhandled kernel version 0* and 1*";;
2.6*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kEXTRAVERSION kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI

    if ! test "$kEXTRAVERSION"; then
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
    fi

IFS="$oldIFS"
;;
2.[0-5].*) _warn "Unhandled kernel version 2.[0-5].*";;
[3-9].*)
oldIFS="$IFS"
IFS='.+-_AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz(){}[]&%$!?=#*~@€^"°¹²³¼½ßÜüÖöÄäÆæØøÅåÁáÀàÂâÉéÈèÊêÍíÌìÎîÓóÒòÔôÚúÙùÛû£:;'"'"
read kVERSION kPATCHLEVEL kSUBLEVEL kLOCALVERSION<<EoI
`echo "$KERNEL"`
EoI
IFS="$oldIFS"
;;
esac

_info kVERSION=$kVERSION kPATCHLEVEL=$kPATCHLEVEL kSUBLEVEL=$kSUBLEVEL kEXTRAVERSION=$kEXTRAVERSION kLOCALVERSION=$kLOCALVERSION

test "$kSUBLEVEL" || kSUBLEVEL=0
test "$kEXTRAVERSION" || kEXTRAVERSION=0
KERNVER="$KERNEL"
KERNELVER="$KERNEL"
KERNEL_RELEASE="$KERNEL"

KERNELSUBVER="$kSUBLEVEL"
KERNELSUBSUBVER="$kEXTRAVERSION"

K_VERSION="$kVERSION"
K_PATCHLEVEL="$kPATCHLEVEL"
K_SUBLEVEL="$kSUBLEVEL"
K_EXTRAVERSION="$kEXTRAVERSION"
K_LOCALVERSION="$kLOCALVERSION"

_notice "_kernel_version5:KERNELVER='$KERNELVER'"
_info "_kernel_version5:KERNELSUBVER='$KERNELSUBVER'"
_info "_kernel_version5:KERNELSUBSUBVER='$KERNELSUBSUBVER'"
_notice "_kernel_version5:SFSSTR='$SFSSTR' SFSMAJOR='$SFSMAJOR'"
_notice "_kernel_version5:squashXZ='$squashXZ'"
INFO=$oldINFO;DEBUG=$oldDEBUG
}


_find_swap_devices(){
    local device
    # REM: variable would be like '/sys/class/block/sda1'
    #      so needs basename
    #      could use `ls -1d /sys/class/block/*` - which would be similar
    #      or `ls /sys/class/block`
    #      or `ls -1v /sys/class/block`
    #      or ..?
    for device in /sys/class/block/*
    do
    device=${device##*/}
    _debugx $device >>$ERR
    [ -b /dev/$device ] || continue
    case $device in
    *ram*|*loop*|*mtd*|*fd*|*sr*|*scd*) continue;;
    esac
    #guess_fstype /dev/$device 2>>$ERR | grep $Q -i swap >>$ERR || continue
    blkid /dev/$device | grep -w "^/dev/$device" | grep $Q -i ' TYPE="swap"' >>$ERR || continue
    echo "/dev/$device"
    done
    # REM: guess_fsype has problems with device major 259
    #      for partition numbers >15 (SCSI)
    #          partition numbers >63 (IDE) <?? not tested>
    # REM: older busybox blkid had no /dev/<device> argument processing ...
}

__find_swap_devices__(){
    local device
    for device in /sys/class/block/*
    do
    # REM: variable would be like '/sys/class/block/sda1'
    #      so needs basename
    #      could use `ls -1d /sys/class/block/*` - which would be similar
    #      or `ls /sys/class/block`
    #      or `ls -1v /sys/class/block`
    #      or ..?
    device=${device##*/}
    [ -b /dev/$device ] || continue
    case $device in
    *ram*|*loop*|*mtd*|*fd*|*sr*|*scd*) continue;;
    esac
    # REM: guess_fsype has problems with device major 259
    #      for partition numbers >15 (SCSI)
    #          partition numbers >63 (IDE) <?? not tested>
    #guess_fstype /dev/$device | grep $Q -i swap >>$ERR || continue
    # REM: older busybox blkid had no /dev/<device> argument processing ...
    blkid /dev/$device | grep -w "^/dev/$device" | grep $Q -i ' Type="swap"' >>$ERR || continue
    echo "/dev/$device"
    done
}

# REM: want to unload all unused kernel drivers
#      to find out if that helps with reboot problems
_unload_all_modules(){

# REM: leave function if FORCE
[ "$FORCE" ] && return 0
# REM: sanity check
_test_fr /proc/modules || return 4

# REM: big fat unload loop
# REM: 'c' is emergeny break count to prevent never ending loop - currently set to '9'
c=0
while [ unloading ];
do

 sleep 1
[ "`awk '{ if ($3 == 0) print}' /proc/modules`" ] ||  { echo "Only used drivers remain";break; }

  #while [ 1 ];                 #does not work
  #do                           #or if it works
  #read module vms users rest   #prints empty lines to screen

  # REM : /proc/modules gets updated by the kernel,
  #       so better to use a procMODULES list variable...
  sleep 1
  procMODULES=`cat /proc/modules`

  while
  read module vms users rest
  do

   [ "$module" ]    || { echo "No module";break; }
   [ "$users" = 0 ] || { echo "'$module' in use by '$rest'";continue; }

   # REM: keep usb and hid drivers if USB input devices (keyboard) input needed later on
   #      also keep unix module - it reloads anyways all the time
   case $module in
    *usb*|*hci*|*hcd*|*hid*|evdev|unix) echo "Skipping unloading of '$module'";continue;;
   esac

   # REM: use modprobe -r instead of rmmod
   #      because it removes also drivers that the driver depends on
   #      fork it to prevent hangs
   echo -e "\\033[1;33m"
   /sbin/modprobe $VERB -r $module & #>/dev/console 2>&1
   sleep 1
   echo -e "\\033[0;39m"

  # REM : /proc/modules gets updated by the kernel,
  #       so better use a LIST variable...
  #done</proc/modules
  done<<EoI
`echo "$procMODULES"`
EoI

[ "`awk '{ if ($3 == 0) print}' /proc/modules | grep -vE '*usb*|*hci*|*hcd*|*hid*|evdev|unix'`" ] || \
                             { echo "Only used or ^unused hid|usb drivers remain"; break; }

 c=$((c+1))
case $c in 9) echo "_unload_all_modules:BREAKING for ninth loop";break;; esac

done
}

#================ Make free loop device ======================================
_mk_free_loop()
{
  FREE_LOOP=`losetup -f`  # find free and create loop
  [ "$FREE_LOOP" ] || {   # for kernel 3.0 and earlier
  LOOPS_ALL=`ls -1v /dev/loop* |sed 's%[^[:digit:]]%%g'`
  LOOP_LAST=`echo "$LOOPS_ALL" | tail -n1`
  LOOP_NEW=$(( $LOOP_LAST + 1 )) && mknod /dev/loop${LOOP_NEW} b 7 $LOOP_NEW
  }
}

#================ Check GETTEXT ==============================================
_check_gettext()
{
_G=`which gettext`
test "$_G" && {
 test "`which gettext.sh`" && {
export TEXTDOMAIN=f4puppy5 #NOTE: rename to avoid clash with 'remasterpup2.mo' used by previous i18n method.
export OUTPUT_CHARSET=UTF-8
. gettext.sh
test "`type -t eval_gettext`"   &&  _eG=eval_gettext
if test "`which ngettext`"; then
 test "`type -t eval_ngettext`" && _eNG=eval_ngettext
fi
  }
 }

test "$_G"   ||   _G=echo
test "$_eG"  ||  _eG=echo
test "$_eNG" || _eNG=echo
#echo "_G='$_G'"
#echo "_eG='$_eG'"
#echo "_eNG='$_eNG'"
}
_check_gettext

_killzombies()
{
 # REM: original code by BK BUGs: leading space handling missing,        tty '?' gets four '|' and would be filtered
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | cut -f 1 -d ' ' | tr '\n' ' '`"

 # REM: use awk to try to handle leading space BUG: will print ||123 BUG:tty '?' gets four '|' and would be filtered
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | awk '{print $1}'`"

 # REM: reworked 2014-11-17                                          BUG:tty '?' gets four '|' and would be filtered
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g;s/^|*//' | grep -v '|||' | awk '{print $1}'`"

 # REM: using sed to delete leading space                            BUG:tty '?' gets four '|' and would be filtered
 #ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | grep -v 'grep' | sed 's/^[[:blank:]]*//g;s/  /|/g' | grep -v '|||' | cut -f 1 -d ' '`

 # REM: using awk to omit sed and cut showing all defuncts...
 #ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | grep -v 'grep' | awk '{print $1} '`

 # REM: using ps -o stat and awk match Z instead grep defunct
_say_ps_stat_help(){
cat >&1 <<EoI
PROCESS STATE CODES
Here are the different values that the s, stat and state output specifiers
(header "STAT" or "S") will display to describe the state of a process.
D    Uninterruptible sleep (usually IO)
R    Running or runnable (on run queue)
S    Interruptible sleep (waiting for an event to complete)
T    Stopped, either by a job control signal or because it is being traced.
W    paging (not valid since the 2.6.xx kernel)
X    dead (should never be seen)
Z    Defunct ("zombie") process, terminated but not reaped by its parent.

For BSD formats and when the stat keyword is used, additional characters may
be displayed:
<    high-priority (not nice to other users)
N    low-priority (nice to other users)
L    has pages locked into memory (for real-time and custom IO)
s    is a session leader
l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
+    is in the foreground process group
EoI
}
 # REM: all Z
 #ZOMBIES=`ps -A -o pid,stat,args | awk '{if ( match($2, "Z[<NLsl+]*") || $2 == "Z" ) print $1}'`

 # REM: all Z except s
 ZOMBIES=`ps -A -o pid,stat,args | awk '{if ( match($2, "Z[<NLl+]*") || $2 == "Z" ) print $1}'`

 for oneZOMBIE in $ZOMBIES
 do
  _command ps --no-header -p $oneZOMBIE || continue
  echo " :Killing (?parentless?) zombie process $oneZOMBIE ..."
  kill $oneZOMBIE
 done
}

#===== XMESSAGE or SPLASH ====================================================
_get_yaf_args()
{
for exe in pupmessage gtkdialog-splash yaf-splash gxmessage xmessage; do
YAF=`which $exe`
test "$YAF" || continue
test -L "$YAF" && continue
case $YAF in

 pupmessage)yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#gtkdialog-splash

# an easy replacement for yaf-splash in Puppy (NOT Puppy <=4.x)
# mave 30.05.2010
# no warranty
# Thanks for Puppy!

# usage: gtkdialog-splash [OPTIONS] [-timeout SEC] -text TEXT | -kill [ PID ]

# -text EXPRESSION
# -timeout COUNT (in seconds)
# -icon GTK-XXX (for example: gtk-info all gtk-stock-symbols, default: none)
# OR path/to/pixmap.png|gif|jpeg
# -icon_width WIDTH in pixels
# -bg COLOR (background color red, blue, yellow..., default: grey)
# -bg_gradient true|false (default: true)
# -fg COLOR (font color, default: black)
# -placement center|mouse|top|bottom|top-left|bottom-left (default: center)
# -close never|mouseover|box (default is mouseover)
# -deco TITLE (shows windows decorations, with title)
# -font NAME
# -fontsize SIZE
# -align ALIGNMENT left, right or center -margin SIZE (default: 10)
# -border true|false (default: true)
# -kill [ PID ] ( When PID omitted, kills all GTKDIALOG_SPLASH found
# in ps output, PID must exist as /tmp/GTKDIALOG-SPLASHPID with PID content )

 gtkdialog-splash) yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-placement center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

#Usage: yaf-splash [ options ]
#Where options include:

#  -text                         Message to display.
#  -timeout                      How long to display the message before
#                                exiting. Default is 0, which means forever.
#  -clock                        Enable clock display.
#  -12                           Display twelve hour time (default).
#  -24                           Display twenty-four hour time.
#  -seconds                      Display seconds (default).
#  -noseconds                    Don't display seconds.
#  -countdown <date>             Display a countdown instead of a clock.
#                                Run `-countdown foo' to see date syntax.
#  -countdownquit                Quit after the countdown has reached
#                                zero (default).
#  -nocountdownquit              Keep counting after reaching zero.
#  -geometry <geometry>          Size and position of window.
#  -placement <placement name>   A screen location, one of center, top,
#                                bottom, right, left, top-right, top-left,
#                                bottom-left, bottom-right. Defaults to center.
#                                A specified placement will override -geometry.
#  -font <font>                  Name of an X font to use.
#  -transparent                  Make the window background be transparent,
#                                if possible.
#  -nontransparent               Don't (default).
#  -mirror                       Flip the text about the y axis. Useful for
#                                back projection.
#  -nomirror                     Don't (default).
#  -fg                           Set the forground text colour (default: black).
#  -bg                           Set the background colour (default: white).
#  -bd                           Set the border colour (default: black).
#  -bw                           Set the border width (default: 2).
#  -outline                      Set the text outline width (default: 1).
#  -margin                       Set the margin size (default: 0).

 yaf-splash) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg black"; yafFG="-fg orange"; yafPL="-placement center"; yafFONT="-font -*-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafFONT="-font -misc-*-*-*-*-*-*-*-*-*-*-*-*-*"
  yafEXTRA="-transparent"
  #yaf-splash: couldn't load font "'*-*-*-*-*-*-*-*-*-*-*-*-*'"
  yafTXT="-text"
 ;;

 gxmessage)#yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;

#gxmessage - a GTK-based xmessage clone

#Usage: gxmessage [OPTIONS] message ...
#       gxmessage [OPTIONS] -file FILENAME

#xmessage options:
#  -file FILENAME         Get message text from file, '-' for stdin
#  -buttons BUTTON_LIST   List of "LABEL:EXIT_CODE", comma separated
#  -default LABEL         Give keyboard focus to the specified button
#  -print                 Send the selected button's LABEL to stdout
#  -center                Try to open window in the centre of the screen
#  -nearmouse             Try to open window near the mouse pointer
#  -timeout SECONDS       Exit with code 0 after SECONDS seconds

#X-like options:
#  -display DISPLAY       X display to use
#  -fn FONT | -font FONT  Set message font (works with GTK font names)
#  -fg COLOUR             Set message font colour
#  -bg COLOUR             Set message background colour
#  -geometry GEOMETRY     Set window size (position will be ignored)
#  -iconic                Start iconified
#  -name NAME             Program name as used by the window manager
#  -title TITLE           Set window title to TITLE

#gxmessage options:
#  -borderless            Try to open window without border decoration
#  -nofocus               Don't focus the window when it opens
#  -encoding CHARSET      Expect CHARSET as the message encoding
#  -entry                 Prompt for text to be sent to stdout
#  -entrytext TEXT        Same as -entry, but with TEXT as default text
#  -wrap                  Wrap lines of text to fit window width
#  -help | -?             Show this usage information
#  -version               Show gxmessage version information

 xmessage) #yafFSIZE="-fontsize large"; yafICON="-icon /usr/share/doc/puppylogo96.png"
  yafBG="-bg orange"; yafFG="-fg black"; yafPL="-center"; yafFONT="-font '-*-*-*-*-*-*-*-*-*-*-*-*-*-*'"
 ;;
esac
break
done
_debug "Using '$YAF'"
}

_GTKdialog_remove_comments()
{

test "$*" || { _return 1 "No Input. Usage _GTKdialog_remove_comments DIALOG_GUI_CODE"; return 1; }
local sPATTERN1 sPATTERN2 sPATTERN3 sPATTERN4
sPATTERN1='s%<!--.*-->%%g'
sPATTERN2='/<!--/,/-->/d'
sPATTERN3='s%^#.*%%'
sPATTERN4='s%>.*#[^>]*$%%'

echo "$*" | sed -e "$sPATTERN1" -e "$sPATTERN2" -e "$sPATTERN3" -e "$sPATTERN4" || return 1
}

_GTKdialog_debug_gui()
{
test "$*" || { _return 2 "_GTKdialog_debug_gui: Usage: debugGUI=\`_GTKdialog_debug_gui \"$MAIN_DIALOG\"\`"; return $?; }

local lNR
lNR=0
echo "$*" | while read -r aLINE; do lNR=$((lNR+1)); echo "$lNR: $aLINE";done

}

_pidof()
{
local RV
case $1 in
-q|-?quiet|quiet) shift;
pidof $* >/dev/null; return $?
;;
*)
echo -n "pids of $*:"
pidof $*; RV=$?
test "$RV" = 0 || echo
return $RV
;;
esac
}

_add_header()
{
local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep $Q -viE 'perl|python|murgaLua_Dynamic|Pascal|C\+\+| C ' || continue

   grep $Q 'f4puppy5' "$file" && continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue

   SHELLBANG=`head -n1 "$file"`
   case "$SHELLBANG" in
   '#!'*) :;;
   *) continue;;
   esac

   echo "$file"

   cat >/tmp/${file##*/} <<EoI
$SHELLBANG
#
# New header by $_AUTHOR_, $_MONTH_ $_YEAR_
  _TITLE_="Puppy_${file##*/}"
_VERSION_=1.0omega
_COMMENT_="\$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/$file"
MY_PID=\$\$

test -f /etc/rc.d/f4puppy5 && {
source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

ADD_HELP_MSG="\$_COMMENT_"
_parse_basic_parameters "\$@"
[ "\$DO_SHIFT" ] && [ ! "\${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in \`seq 1 1 \$DO_SHIFT\`; do shift; done; }

_trap

}
# End new header
#
EoI

   cat "$file" | sed '1d' >>/tmp/${file##*/}

   if test ! "$DRY"; then
    rm $VERB "$file"
    mv $VERB /tmp/${file##*/} "$file"
    chmod $VERB $PERM "$file"
   fi

done
}

_remove_header()
{
 local _AUTHOR_ _MONTH_ _YEAR_ file PERM
_AUTHOR_="Karl Reimer Godt"
_MONTH_="September"
_YEAR_="2014"

 pwd

cd `pwd`/woof-code/rootfs-skeleton/ || { echo "Could not change into `pwd`/woof-code/rootfs-skeleton/"; $EXIT 1; }

for file in bin/* sbin/* usr/bin/* usr/sbin/* usr/local/*/*
do
   [ -L "$file" ] && continue
   [ -f "$file" ] || continue
   file "$file" | grep -i text | grep $Q -viE 'perl|python' || continue

   grep $Q "# New header by $_AUTHOR_, $_MONTH_ $_YEAR_" "$file" || continue

   PERM=`stat -c %a "$file"`
   [ "${PERM//[0-6]/}" ] || continue
   echo "$file"

   sed '/# New header by Karl Reimer Godt, September 2014/,/# End new header/ d' "$file" >/tmp/${file##*/}
   sed -i '2,3 d' /tmp/${file##*/}

   mv $VERB /tmp/${file##*/} "$file"
   chmod $VERB $PERM "$file"
done
}

_batch_diff1()
{
local SIMPLE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2
_debug "_batch_diff1: '$*'"

test "$*"    || { _err "Usage: _batch_diff [ -s ] DIR"; $EXIT 1; }

test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory";          $EXIT 1; }

cd "$@"      || { _err "Could not change into '$@'";    $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

#FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

#FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

     test "$oneF1" = "$oneF2" && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII
done <<EoI
`echo "$FILES1"`
EoI

}

_batch_diff2()
{
local SIMPLE INVERT FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'"

test "$*" || { _err "Usage: _batch_diff2 [ -s |& -i ] DIR"; $EXIT 1; }


test "$1" = '-s' && { SIMPLE=YES; shift; }
test "$1" = '-i' && { INVERT=YES; shift; }
test "$1" = '-s' && { SIMPLE=YES; shift; }

test -d "$@" || { _err "'$@' not a directory";  $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_batch_diff3()
{
#DEBUG=1
local SIMPLE INVERT REMOVE FILES1_ FILES1 FILES2_ FILES2 aF oneF1 oneF2 alreadyDONE
_debug "_batch_diff2: '$*'"

test "$*" || { _err "Usage: _batch_diff3 [ -s -i | -r ] DIR"; $EXIT 1; }

while [ "$2" ]; do
case "$1" in
-s) SIMPLE=YES;;
-i) INVERT=YES;;
-r) REMOVE=YES;;
esac
shift
done

test -d "$@" || { _err "'$@' not a directory";  $EXIT 1; }

cd "$@" || { _err "Could not change into '$@'"; $EXIT 1; }

FILES1_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES1_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES1="$FILES1
$aF"
done
IFS="$oldIFS"

FILES1=`echo "$FILES1" | tac | sed "1 d" | sed '/^$/d' | tac`
_debug "$FILES1"

FILES2_=`ls -1dv *`

oldIFS="$IFS"
IFS=$'\n'
for aF in $FILES2_
do
[ -p "$aF" -o -S "$aF" -o -L "$aF" -o -d "$aF" ] && continue
[ -f "$aF" ] || continue
FILES2="$FILES2
$aF"
done
IFS="$oldIFS"

FILES2=`echo "$FILES2" | sed "1 d" | sed '/^$/d'`
_debug "$FILES2"

if test "$INVERT"; then

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do
    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF2" "$oneF1" && rm $VERB "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF2" "$oneF1"

     else
      diff -up "$oneF2" "$oneF1"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

else

while read -r oneF1
do
  [ "$oneF1" ] || continue

  while read -r oneF2
  do

    [ "$oneF2" ] || continue

    [ -e "$oneF2" ] || continue
    [ "$oneF1" = "$oneF2" ] && continue
    [ "`echo "$oneF2" | _command grep -w "$alreadyDONE"`" ] && continue

     if test "$REMOVE"; then
      diff -q "$oneF1" "$oneF2" && rm $VERB "$oneF2"

     elif test "$SIMPLE"; then
      diff -q -s "$oneF1" "$oneF2"

     else
      diff -up "$oneF1" "$oneF2"

     fi

  done << EoII
`echo "$FILES2"`
EoII

[ "$alreadyDONE" ] && alreadyDONE="$alreadyDONE
$oneF1" || alreadyDONE="$oneF1"

done <<EoI
`echo "$FILES1"`
EoI

fi

}

_make_board_id(){

    DMIDECODE_OUT=`dmidecode`
    MANU=`echo "$DMIDECODE_OUT" | grep -m1 -i 'Manufacturer' |cut -f2 -d':'`
    PROD=`echo "$DMIDECODE_OUT" | grep -m1 -i 'Product' |cut -f2 -d':'`
    NUMB=`echo "$DMIDECODE_OUT" | grep -m1 -i 'Number' |cut -f2 -d':'`
if test "$MANU" -o "$PROD" -o "$NUMB"; then
   echo "${MANU}-${PROD}-${NUMB}" | tr -d '[[:blank:]]'
else
   echo "$DMIDECODE_OUT" | grep -m1 -i 'UUID'
fi
}

# REM: attempt to echo escaped pre- and post-fixes
#      only to controlling shells,
#      otherwise strip the escapes to unclutter logfiles
_echo_e(){
#local TTY
[ "$TTY" ] || TTY=`tty`
if [ "$TTY" = 'not a tty' ]; then
# strip escape sequences \e and \\033 ...
noESC=`echo "$*"     | sed   's/\\e\[[^m]*//g;s/^m//;s/m$//'`
noESC=`echo "$noESC" | sed 's/\\033\[[^m]*//g;s/^m//;s/m$//'`
echo -e "$noESC"
else
echo -e "$*"
fi
}

# REM: _pidof_pid : replacement for regular ps -p option
#      busybox ps has no -p option, also pidof .
_pidof_pid(){
    test "$*" || { _return 4 "_pidof_pid: Usage: _pidof_pid PID"; return $?; }
    ls -d /proc/$* >>$OUT 2>>$ERR
    return $?
}

#=============== MATH functions =============================================
_dig2hex(){
printf '%x\n' "$*"
}

_dig2oct(){
printf '%o\n' "$*"
}

_hex2dig(){
case $* in 0x*) printf '%d\n' "$*"  ;;
             *) printf '%d\n' "0x$*";;
esac
}

_oct2dig(){
case $* in 0*) printf '%d\n' "$*"  ;;
            *) printf '%d\n' "0$*"
esac
}

_hex2oct(){
case $* in 0x*) printf '%o\n' "$*"  ;;
             *) printf '%o\n' "0x$*";;
esac
}

_oct2hex(){
case $* in 0*) printf '%x\n' "$*"  ;;
            *) printf '%x\n' "0$*" ;;
esac
}

###END###
_HAVE_F4PUPPY5_=1  ## WARN : DO NOT EXPORT !!
  HAVE_F4PUPPY5=1
###END###
