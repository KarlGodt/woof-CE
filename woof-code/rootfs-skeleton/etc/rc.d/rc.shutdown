#!/bin/sh
#(c) Copyright bkauler 2006,2007 www.puppylinux.com
#2007 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#updated aug 2007 for v2.20, save in a folder.
#BK updated 20,22 sept 2007 v2.22, multisession bugfix.
#v3.01 BK 10 oct 2007, attempted bugfixes for funny CD drive.
#v3.01 BK 11 oct 2007, removed multisavefunc() to functions4puppy.
#v3.02 BK 1 nov 2007, can change folder of pup_save file.
#v3.97 BK feb 2008: restore support for pcmcia-cs package.
#v3.97 BK 5 mar 2008, handle PSAVEMARK, see /etc/rc.d/PUPSTATE, init script.
#REMOVEDv3.98 BK 2 apr 2008: 'mke2fs -O none' for encrypted pup_save, fix mntg bug.
#v3.99 7apr2008: fix zombie process prevents partition unmount.
#v411 run rc.alsa as it also unloads modules (if not done, prevents shutdown some systems).
#v411 bring down network interfaces, as sometimes prevent poweroff.
#v412 /etc/DISTRO_SPECS, renamed pup_xxx.sfs, pup_save.2fs etc.
#w002 pup files renamed to format upup-555.sfs, upupsave.2fs.
#w468 alsa shutdown now handled in /etc/init.d/alsa.
#w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create swapfile.
#w482 use xorriso instead of cdrtools/cdrkit if installed.
#v431 tulindo: fix saving to ext4 partition.

########################################################################
#
#
#
#
#
# /dev/hda8:
# LABEL="MacPup431_O2"
# UUID="6d9a8e91-c301-4ff8-9875-97ec708cbee8"
# TYPE="ext3"
# DISTRO_NAME='Puppy'
# DISTRO_VERSION=431
# DISTRO_BINARY_COMPAT='puppy'
# DISTRO_FILE_PREFIX='pup'
# DISTRO_COMPAT_VERSION='4'
# PUPMODE=2
# KERNVER=2.6.30.9-i586-dpup005-Celeron2G
# PUP_HOME='/'
# SATADRIVES='·'
# USBDRIVES='·'
# Linux·puppypc·2.6.30.9-i586-dpup005-Celeron2G·#6·SMP·Sat·Jan·15·13:35:51·GMT-8·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xorg
# $LANG=de_DE@euro
# today=Do·27.·Okt·22:45:16·GMT-1·2011
# TODO1 : fix the missing doubblequotes for STRAYPARTS , dont kill fuser -c
#
#
#
#
########################################################################

PATH='/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin'  ##2011-11-18 added local for rox@umount

### INFO ###
Version='1.1-q Macpup_O2-Puppy_Linux_431 KRG'

_set_debugging_variables(){
ERR=/dev/null;OUT=$ERR;VERB='';L_VERB='';A_VERB='';Q=-q;QUIET=--quiet;DBG='';SILENCE='-s' ##+++2012-03-10
[ "$VERBOSE" ] && { OUT=/dev/stdout;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;Q='';QUIET='';DBG=-d;SILENCE=''; }
[ "$DEBUG" ]   && { ERR=/dev/stderr;OUT=/dev/stdout;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;Q='';QUIET='';DBG=-d;SILENCE=''; }
[ "$QUIET" ]   && { ERR=/dev/stderr; }
}
_set_debugging_variables

usage(){
MSG=`gettext "
$0 [C D v s q F]

Puppy Linux 431 script to
1.) create a pupsave file at shutdown.
2.) umount everything, tidy up, unload drivers,
    closing service daemons and other

Parameters :
C) check this code by set -n
D) like v, without any error output to /dev/null
v) more verbose output and passing verbose options to commands
s) silent shutdown with suppressing most non-interactive
   regular and error messages from commands (default)
q) like s with error messages to stdout (/dev/console)
F) Force shutdown, omitting some cleanup code that may hang
"`
echo "$MSG"
[ "$DISPLAY" -a "`tty`" = 'not a tty' ] && xmessage -bg white2 "$MSG"
exit $1
}
### INFO ###

### PERSONAL ###
[ "$FORCE" ] || {
[ -r /etc/rc.d/rc.shutdown.local.0 ] && . /etc/rc.d/rc.shutdown.local.0
### PERSONAL ###
}

__old_parameter_func__(){  #BEGIN
##err=/dev/console;out=/dev/null
#err=/dev/null; out=$err

PARAMETERS="$@"
[ "$PARAMETERS" ] || PARAMETERS='-q'

for param in $PARAMETERS ; do
case $param in
h|-h|*help|*usage) usage 0;;
v|-v|*verbose) VERBOSE=1
VERB=-v;L_VERB=--verbose;A_VERB=-verbose
;;
D|-D|*debug) DEBUG=1
ERR=/dev/console;OUT=/dev/console
;;
s|-s|*silent) SILENT=1
ERR=/dev/null;OUT=/dev/null
;;
q|-q|*quiet) QUIET=1
#ERR=/dev/console;OUT=/dev/null
;;
C|-C|*check*) set -n;;
*) ME_UNUSED="$ME_UNUSED $param";;
esac
shift
done
}  ###__old_parameter_func__(){  #END

echo "$@" | grep $Q -iEw '\-h|help|usage' && usage 0
echo "$@" | grep $Q -iEw 'v|verbose' && { VERBOSE=Y;_set_debugging_variables; }
echo "$@" | grep $Q -iEw 'D|debug'   && { DEBUG=Y;_set_debugging_variables; }
echo "$@" | grep $Q -iEw 'C|T|test|check' && { DEBUG=Y;_set_debugging_variables;set -n; }
echo "$@" | grep $Q -iEw 's|silent'  && :
echo "$@" | grep $Q -iEw 'q|quiet'   && { QUIET=Y;_set_debugging_variables; }
echo "$@" | grep $Q -iEw 'F|Force'   && FORCE=On

### PRECAUTION ###
###<KRG 2011-12-04>
if [ -n "$DISPLAY" ] ; then
echo "DISPLAY='$DISPLAY'" >&2
usage 1
fi
###</KRG 2011-12-04>
### PRECAUTION ###

### debug ###
__debug(){ echo "$*" 1>>$OUT 2>>$ERR; }
_interactive(){
    [ "$FORCE" ] && return 0
        #modprobe -v usbhid;modprobe -v ehci_hcd;sleep 5
        modprobe $VERB ehci_hcd >>$OUT 2>>$ERR && {
        modprobe $VERB uhci_hcd >>$OUT 2>>$ERR;modprobe $VERB usbhid >>$OUT 2>>$ERR
        sleep 5
        }
        TTY=`tty`
        [ "$TTY" = 'not a tty' ] && TTY=/dev/console
        FD=/proc/self/fd
        #exec 1>$TTY 2>$TTY
        echo -n "Proceed to $SHUT_HOW2 [n|y=AnyOtherKey] ? " #>/dev/console;
        read $SILENCE -t30 -n1 PK  #<$FD/0 >$FD/1;
        #PKorig="$PK"
        #[ "$PK" ] || PK=y;
        #[ "$PKorig" = "$PK" ] || ADD_MSG="-> Assuming ${PK}."
        #echo "Pressed Key : '$PKorig' $ADD_MSG" >/dev/console
        #[ "$PK" = 'y' ] || exit 199;
        #echo "$PK" | grep $Q -i 'y' || exit 199
        echo "$PK" | grep $Q -i 'n'  && exit 199
        echo;
}
### debug ###

[ "$FORCE" ] || {
### PERSONAL ###
[ -r /etc/rc.d/rc.shutdown.local.1 ] && . /etc/rc.d/rc.shutdown.local.1
[ -r /etc/rc.d/rc.shutdown.local   ] && . /etc/rc.d/rc.shutdown.local
### PERSONAL ###
}


### CD/DVD ###
#w482 use xorriso if it is installed (see also functions4puppy)...
CDRECORD='cdrecord'
MKISOFS='mkisofs'
if [ "`which xorriso`" ];then
 CDRECORD='xorrecord'
  MKISOFS='xorrisofs' #growisofs reads this variable.
fi
export CDRECORD MKISOFS
### CD/DVD ###

### source ###
#variables created at bootup by init script in initrd...
[ -f /etc/rc.d/PUPSTATE ] && . /etc/rc.d/PUPSTATE #v2.02
[ -z "$PUPMODE" ] && [ -n "`rdev`" ] && PUPMODE=2
. /etc/DISTRO_SPECS #v412
[ "$SHUT_HOW" ] || SHUT_HOW='shutting down'  ##+++2013-03-10
SHUT_HOW2="${SHUT_HOW/ing/}"   ##+++2013-04-09
SHUT_HOW2="${SHUT_HOW2/tt/t}"  ##+++2013-04-09
echo -e "\\033[1;33m${DISTRO_NAME} ${DISTRO_VERSION} is now ${SHUT_HOW}...\\033[0;39m" > /dev/console

ORIGPUPMODE=$PUPMODE #v2.22

echo "Executing /etc/rc.d/rc.shutdown..."

[ "$OUT" == '/dev/console' ] && __debug "$( echo -e "\033[1;34m"`which rox`"\033[0;39m" )"

#PUPPYVERSION=`cat /etc/puppyversion`

#v2.20 if ${DISTRO_FILE_PREFIX}rxxx.sfs is in a subdirectory, default to saving in it...
puppySFS_FILE=`echo "$PUPSFS" | cut -f 3 -d ','`
PSUBDIR=`dirname "$puppySFS_FILE"`
[ "$PSUBDIR" = "/" ] && PSUBDIR=""

#for a full hd install, only setting PUPMODE (=2). no /initrd, no initrd.gz.

. /etc/rc.d/functions4puppy #v3.01
test -f /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5
### source ###


### kill ###
_killzombies(){
 [ "$FORCE" ] && return 0
 # REM: original code by BK
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | cut -f 1 -d ' ' | tr '\n' ' '`"

 # REM: use awk to try to handle leading space BUG: will print ||123
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | awk '{print $1}'`"

 # REM: reworked 2014-11-17
 #ZOMBIES="`ps -H -A | grep '<defunct>' | sed -e 's/  /|/g;s/^|*//' | grep -v '|||' | awk '{print $1}'`

 # REM use sed to eliminate leading space
 #ZOMBIES=`ps -H -A | grep '<defunct>' | sed 's/^[[:blank:]]*//g;s/  /|/g' | grep -v '|||' | cut -f 1 -d ' ' | tr '\n' ' '`

 # REM: use /bin/ps in case $0 ash and configured SH_STANDALONE || NOFORK
 #ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | grep -v 'grep' | sed 's/^[[:blank:]]*//g;s/  /|/g' | grep -v '|||' | cut -f 1 -d ' '`

 # REM: 2014-11-17
 # using ps -o stat and awk match Z instead grep defunct
 ZOMBIES=`ps -A -o pid,stat,args | awk '{if ( match($2, "Z[<NLsl+]*") || $2 == "Z" ) print $1}'`

 for oneZOMBIE in $ZOMBIES
 do
  case $oneZOMBIE in
  1) continue;;
  esac
  #[ "$OUT" == '/dev/console' ] && __debug "$( echo "Killing parentless zombie process $ONEZOMBIE" )"
  __debug "$( echo "Killing (?parentless?) zombie process $oneZOMBIE" )"
  __debug "$( ps |grep -w $oneZOMBIE |grep -v grep )"
  /bin/ps --no-header -p $oneZOMBIE && kill $oneZOMBIE
  __debug "$( ps |grep -w $oneZOMBIE |grep -v grep )"
 done
}
### kill ###

### SESSION SAVE ###
#v2.02 dougal contributed this...
choosesizefunc(){
 local kFREE SIZELIST NUM CHOICES fLABEL sLABEL aCHOICE kSIZE
 kFREE=$1 ; SIZELIST="" ; NUM=1 ; CHOICES=""
 fLABEL=$(( kFREE / 1024 ))"MB"
 [ $kFREE -ge 1048576 ] && fLABEL="`dc $kFREE 1048576 \/ p`GB"
 for aCHOICE in 32 64 128 256 512 768 1024 1280
 do
  kSIZE=$(( aCHOICE * 1024 ))
  sLABEL="${aCHOICE}MB"
  [ $aCHOICE -ge 1024 ] && sLABEL="`dc $aCHOICE 1024 \/ p`GB"
  if [ $kSIZE -lt $kFREE ];then
   SIZELIST="$SIZELIST$NUM $sLABEL "
   CHOICES="$CHOICES$kSIZE "
  else
   SIZELIST="$SIZELIST$NUM fill_partition(${fLABEL}) "
   CHOICES="$CHOICES$kFREE "
   break
  fi
  NUM=$(( NUM + 1 ))
 done
 dialog --no-collapse --no-cancel --default-item "5" --menu "Please choose the size you would like for the personal save file.\nNote, 512M is good choice, or highest if that not available.\nSelect choice, then press ENTER key..." 0 0 0 $SIZELIST >/dev/console 2>/tmp/sizetag.txt
 NUM=`tail -n1 /tmp/sizetag.txt`
 [ "$NUM" ] || return 1
 [ "${NUM//[[:digit:]]/}" ] && return 1
 aCHOICE=`echo $CHOICES | cut -f $NUM -d ' '`
 #return $ACHOICE
 SIZEPFILE=$aCHOICE #global variable.
} # end of choosesizefunc()

pupsavefunc(){
 #v2.02 ntfs uses /dev/fuse so '/dev/$SAVEPART' no good for grep...
 #saveMOUNT_POINT=`mount | grep -w "/dev/$SAVEPART" |awk -F '"' '{print $4}'` #| tr -s " " | cut -f 3 -d " "`"
 saveMOUNT_POINT=`grep -w "^/dev/$SAVEPART" /proc/mounts |awk '{print $2}'`
 saveMOUNT_POINT=`busybox echo -e "$saveMOUNT_POINT"`
 #[ "$SMNTPT" = "" ] && SMNTPT=`mount | grep "/mnt/$SAVEPART" | tr -s " " | cut -f 3 -d " "`
 [ "$saveMOUNT_POINT" = "" ] && saveMOUNT_POINT=`/bin/ps -e | grep -o 'ntfs\-3g.*' | grep "/dev/$SAVEPART" | tr '\t' ' ' | tr -s ' ' | tr ' ' "\n" | grep '^/mnt/'`

 if [ "$saveMOUNT_POINT" = "" ];then
  #v2.02 was mntg on /tmp/savepup, but if error and not unmounted, contents
  #of /tmp gets deleted, wiping entire partition!!!
  mkdir $VERB -p /mnt/$SAVEPART 1>>$OUT 2>>$ERR #2>/dev/null #/tmp/savepup
  mount $VERB $VERB -t $SAVEFS /dev/$SAVEPART /mnt/$SAVEPART #/tmp/savepup
  saveMOUNT_POINT="/mnt/$SAVEPART" #"/tmp/savepup"
 fi

 #v2.15 after forum discussion, trying this. if SAVEFS is ext3 or reiserfs (journalled f.s.)
 # then make our ${DISTRO_FILE_PREFIX}save also an ext3 f.s...
 #v2.16exp3 now have writable compressed ext2, not work ext3, so always use ext2...
 #v2.16exp4 no, e2compr unreliable. only seems to work for usbflash, so allow ext3...
 #v2.17 quick hack, kirk reported if save-part is ext3 then save-file has ex3 while
 # still named ${DISTRO_FILE_PREFIX}save.2fs. so for now keep it all consistent ext2, comment-out...
 #SFEXT="3fs"
 #if [ "`echo -n "$SAVEFS" | grep --extended-regexp 'ext3|reiserfs'`" = "" ];then
  SAVEFILE=`echo -n "$SAVEFILE" | sed -e 's/3fs$/2fs/g'`
  SFEXT="2fs"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 #fi
 NAMEONLY=`basename $SAVEFILE`

 #v2.21 customise the name of the ${DISTRO_FILE_PREFIX}save file...
 MYUSERNAME="`dialog --stdout --nocancel --inputbox "Would you like to customise the name
of the '${DISTRO_FILE_PREFIX}save.${SFEXT}' file?
This is optional, but it is convenient
if you have lots of '${DISTRO_FILE_PREFIX}save' files
and you want to choose the right one
at startup. For example, if you enter
'john' here, the file will become
'${DISTRO_FILE_PREFIX}save-john.${SFEXT}'.
Type any characters you wish,
then press ENTER key:" 0 0 ""`"
 if [ "$MYUSERNAME" != "" ];then
  MYUSERNAME=`echo -n "$MYUSERNAME" | tr ' ' '_' | tr '-' '_' | sed -e 's/[^a-zA-Z0-9_]//g'`
  NAMEONLY="${DISTRO_FILE_PREFIX}save-${MYUSERNAME}.${SFEXT}"
  SAVEFILE="$PSUBDIR/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 fi

 CRYPTO=""
 dialog --extra-button --ok-label "NORMAL (no encryp.)" --cancel-label "Heavy encrypted" --extra-label "Light encrypted" --yesno "Do you want to encrypt the $NAMEONLY file?
If the '${DISTRO_FILE_PREFIX}save' is encrypted, then a password will have to be entered
at every bootup. The reason for doing this is security, as noone else
will be able to see what is inside the ${DISTRO_FILE_PREFIX}save. Encryption does slow
${DISTRO_NAME} down slightly, the 'heavy' encryption the most. Two scenarios:

1. If the ${DISTRO_FILE_PREFIX}save file is on a Flash drive, encryption is protection
   in case the drive is mislaid. Heavy encryption is recommended, as
   ${DISTRO_NAME} minimises writes to the save file (to prolong life of the
   Flash drive, but this also minimises encryption slowdown).
2. If the ${DISTRO_FILE_PREFIX}save file is on a hard drive, 'light' encryption is
   recommended to minimise slowdown, particularly on older PCs.

Encrypted ${DISTRO_FILE_PREFIX}save files have another advantage, they allow multiple
users. Recommended if spouse and kids are going to be using the same
${DISTRO_NAME} installation.

Unless you have a good reason to use encryption, it is recommended not
to, to avoid the overhead. Recommend choose <NORMAL>..." 0 0 >/dev/console
 RETVAL=$?
 if [ $RETVAL -eq 1 -o $RETVAL -eq 3 ];then
  while [ 1 ];do
  MYPASSWORD="`dialog --stdout --insecure --nocancel --passwordbox "Please choose a password.
This must be remembered and
entered at every bootup." 0 0`"
   [ "$MYPASSWORD" ] && break
  done
  modprobe $Q $VERB cryptoloop
  if [ $RETVAL -eq 1 ];then
   DENSITY="a" #heavy aes encryption
   CRYPTO='-e aes'
   modprobe $Q $VERB aes_generic #v407 aes name change.
   #v407 did not explicitly load these two before, but do so in init script...
   modprobe $Q $VERB crypto_blkcipher #v407 blkcipher name change.
   modprobe $Q $VERB cbc
  else
   DENSITY="x" #light xor encryption.
   CRYPTO='-E 1' #v2.16final '-e xor' --bug, loads xor.ko which is something else.
  fi
  if [ "$MYUSERNAME" != "" ];then
   NAMEONLY="${DISTRO_FILE_PREFIX}save_crypt${DENSITY}-${MYUSERNAME}.${SFEXT}"
  else
   NAMEONLY="${DISTRO_FILE_PREFIX}save_crypt${DENSITY}.${SFEXT}"
  fi
  SAVEFILE="$PSUBDIR/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 fi
 MNAMEONLY=`basename $SAVEFILE .${SFEXT}`

 #fitzhugh found this problem...
 #v2.10 Dougal provided code to save with different name...
 if [ -f $saveMOUNT_POINT$SAVEFILE ]; then
  dialog --yes-label "SAVE" --yesno "
There already exists a ${NAMEONLY} file on the partition you
chose. To create another one, with a slightly different name
(such as ${MNAMEONLY}-1.${SFEXT}), select <SAVE>...
To quit without saving, select <No>..." 0 0 >/dev/console
  [ ! $? -eq 0 ] && return 1
  local BLA=1 #; local SFFIX=`echo "$SAVEFILE" | tail -c 5`
  while [ -f $saveMOUNT_POINT$SAVEFILE ]; do
   SAVEFILE="$PSUBDIR/${MNAMEONLY}-${BLA}.${SFEXT}"
   BLA=$(( BLA + 1 ))
  done
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  NAMEONLY=`basename $SAVEFILE`
 fi

 #we should check to see that there is enough space on the partition...
 PARTFREE=`/bin/df | grep "$saveMOUNT_POINT" | tr -s " " | head -n 1 | cut -f 4 -d " "`
 [ $PARTFREE ] || PARTFREE=0
 [ $PARTFREE -lt 32768 ] && PARTFREE=$(( PARTFREE - 1024 )) #leave some slack space.
 [ $PARTFREE -gt 32768 ] && PARTFREE=$(( PARTFREE - 8192 )) #leave some slack space.
 SIZEPFILE=524288 #512M = 524288K
 [ $SIZEPFILE -gt  $PARTFREE ] && SIZEPFILE=$PARTFREE
 #v2.02 dougal has code to choose size of save file...
 [ $PARTFREE -gt 32768 ] && choosesizefunc $PARTFREE #sets SIZEPFILE
 if [ "`echo -n $SAVEFILE | grep '\.3fs'`" ];then #ext3 f.s. needs minimum size.
  [ $SIZEPFILE -lt 5000 ] && return 1 #precaution. rerwin discovered this.
 fi

 #v2.20
 SAVEPATH=`dirname $SAVEFILE`
 if [ ! -d ${saveMOUNT_POINT}${SAVEPATH} ];then
  SAVEFILE="/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  SAVEPATH="/"
 fi

 #v2.02,v2.13 final sanity check...
 aAAFS="ext3"
 [ "$SFEXT" = "2fs" ] && aAAFS="ext2"
 aAAMB=$(( SIZEPFILE / 1024 ))
 while [ 1 ];do
  dialog --colors --no-collapse --extra-button --ok-label "YES, SAVE"  --extra-label "CHANGE FOLDER" --cancel-label "DO NOT SAVE" --yesno "\Z1FINAL SANITY CHECK:
 Partition you are saving to:      $SAVEPART
 The filesystem of $SAVEPART partition: $SAVEFS
 Name of the save file:            $NAMEONLY
 Path (folder) of the save file:   $SAVEPATH
 Size of save file:                ${SIZEPFILE}KB (${aAAMB}MB)
 Filesystem inside save file:      $aAAFS

 If they definitely look right, choose <YES, SAVE>...
 Looks ok, but you want to change the folder, <CHANGE FOLDER>...
 If anything looks wrong, choose <DO NOT SAVE>...\Zn" 0 0 >/dev/console
  SANITYRET=$?
  [ $SANITYRET -ne 0 -a $SANITYRET -ne 3 ] && return 1
  [ $SANITYRET -eq 0 ] && break
  if [ $SANITYRET -eq 3 ];then #change folder.
   NEWSAVEPATH=`dialog --stdout --no-cancel --inputbox "Edit path. '/' means top-level of partition. You are only allowed to save one-deep, for example: '/puppy300'. If folder does not exist, it will be created. Spaces are not allowed. If uncertain, just press the ENTER key." 0 0 "$SAVEPATH"`
   [ "$NEWSAVEPATH" = "" ] && NEWSAVEPATH="$SAVEPATH"
   [ "`echo -n "$NEWSAVEPATH" | cut -b 1`" != "/" ] && NEWSAVEPATH="/${NEWSAVEPATH}"
   [ "$NEWSAVEPATH" != "/" ] && NEWSAVEPATH=`echo -n "$NEWSAVEPATH" | sed -e 's%/$%%'`
   NEWSAVEPATH=`echo -n "$NEWSAVEPATH" | sed -e 's/ //g'`
   SAVEPATH="$NEWSAVEPATH"
   SAVEPATHs="$SAVEPATH"
   [ "$SAVEPATH" != "/" ] && SAVEPATHs="${SAVEPATH}/"
   SAVEFILE="${SAVEPATHs}${NAMEONLY}"
   PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  fi
 done
 [ -f ${saveMOUNT_POINT}${SAVEPATH} ] && return 1 #abort. must be a directory.
 [ -d ${saveMOUNT_POINT}${SAVEPATH} ] || mkdir $VERB -p ${saveMOUNT_POINT}${SAVEPATH}
 [ -d ${saveMOUNT_POINT}${SAVEPATH} ] || return 1 #some kind of error, abort.

 JOPT=""
 [ "$SAVEPART" = "fd0" ] && SIZEPFILE=$(( SIZEPFILE - 16 ))
 [ "$SFEXT" = "3fs" ] && JOPT='-j'
 echo "Creating '$NAMEONLY' in '/dev/$SAVEPART', please wait awhile..." >/dev/console
 dd if=/dev/zero of=${saveMOUNT_POINT}$SAVEFILE bs=1k count=$SIZEPFILE
 _sync
 echo "Creating a '$aAAFS' filesystem in '$NAMEONLY'..." >/dev/console
 if [ "$CRYPTO" = "" ];then
  mke2fs $Q $JOPT -m 0 -F ${saveMOUNT_POINT}$SAVEFILE
  #...default is f.s. auto checked every 26 mounts or 180 days. tune2fs to change.
 else
  #note: loop2 is kept available for scripts to use. but, find which is free...
  DEVLOOP=`losetup-FULL -f`
  [ "$DEVLOOP" = "" ] && return 1
  #'-p 0' means read password from stdin...
  #v2.17 crap, '-p 0' works for aes, not for xor encryption....
  if [ "$CRYPTO" = '-E 1' ];then #light xor encr.
   echo "Note, a bug in one of the Linux utility programs requires you to reenter" >/dev/console
   echo "the password in the case of light encryption..." >/dev/console
  fi
  echo "$MYPASSWORD" | losetup-FULL -p 0 $CRYPTO $DEVLOOP ${saveMOUNT_POINT}$SAVEFILE >/dev/console
  [ $? = 0 ] || return 1
  mke2fs $Q $JOPT -m 0 $DEVLOOP #REMOVEDv3.98 added '-O none', fix mntg fail at boot.
  _sync
  losetup -d $DEVLOOP
 fi
 _sync
 return 0
} #end pupsavefunc

choosepartfunc(){
 #dialog to choose what partition to create ${DISTRO_FILE_PREFIX}save.2fs on...
 [ "$PMEDIA" ]            || PCHOOSE="yes"
 [ "$PMEDIA" = "cd" ]     && PCHOOSE="yes"
 [ "$PMEDIA" = "scsicd" ] && PCHOOSE="yes"
 [ "$PMEDIA" = "satacd" ] && PCHOOSE="yes"
 [ "$PMEDIA" = "idecd" ]  && PCHOOSE="yes"
 [ "$PMEDIA" = "atacd" ]  && PCHOOSE="yes" #v3.97
 [ "$PMEDIA" = "usbcd" ]  && PCHOOSE="yes"
 [ "$DEV1FS" = "ntfs" ]   && PCHOOSE="yes"
 [ "$DEV1FS" = "msdos" ]  && DEV1FS="vfat" #v2.14
 [ "$DEV1FS" = "xxx" ]    && PCHOOSE="yes" #v2.16.1

 if [ "$PSAVEMARK" != "" ];then #v3.97 see /etc/rc.d/PUPSTATE
  devnameonly=`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`
  SAVEPART="${devnameonly}${PSAVEMARK}" #partition that will-have ${DISTRO_FILE_PREFIX}save.
  spPATTERN='/dev/'"$SAVEPART"'|'
  SAVEFS=`probepart -m | grep "$spPATTERN" | cut -f 2 -d '|'`
  SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  return 0
 fi

 if [ "$PCHOOSE" != "yes" ];then
  SAVEFS="$DEV1FS"
  SAVEPART="$PDEV1"
  SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs" #v2.13 was .3fs
  PUPSAVE="$PDEV1,$DEV1FS,$SAVEFILE" #v2.13 was .3fs
  return 0
 fi

 if [ "`lsmod | grep '^usb'`" != "" ];then
  FDMSG1="NOTE: cannot save to floppy disk on this PC, USB allowed."
 else
  FDMSG1="NOTE: no USB interface this PC, but can save to floppy disk."
 fi

 dialog --colors --msgbox "\Z1WARNING: If you want to create a save-file (${DISTRO_FILE_PREFIX}save.2fs) in a NTFS
partition (Windows XP), it is strongly recommended that you defragment
the partition first. Press ESC key to abort this save, start Windows
and choose Start->All Programs->Accessories->System Tools->Defragment.\Zn

\Z5Make sure any required USB, floppy, etc. is PLUGGED IN NOW!
$FDMSG1\Zn
Press ENTER key to continue..." 0 0 >/dev/console
 [ $? = 0 ] || return 1 #v2.02 abort.
 #v2.14 change msdos to vfat... v431 add ext4...
 PARTSLIST=`probepart -m 2>/dev/null | grep '^/dev/' | grep -E 'ext[2-4]|xfs|jfs|btrfs|reiserfs|minix|msdos|vfat|ntfs' | cut -f 1-3 -d '|' | sed -e 's/msdos/vfat/g'`

 #only support save session to floppy if pc is non-usb...
 if [ "`lsmod | grep '^usb_storage'`" = "" ];then #k2.6 note the underscore.
  #problem using dmesg here as it is a fifo buffer, stuff at bootup gets deleted
  #while puppy is being used, prior to shutdown... so, use /var/log/messages...
  if [ "`grep "Floppy drive" /var/log/messages | grep "fd0"`" ];then
   if [ "`disktype /dev/fd0 | grep 'file system' | grep '^FAT'`" ];then
    if [ "$PARTSLIST" = "" ];then
     PARTSLIST="/dev/fd0|vfat|1.4" #v2.14 change msdos to vfat.
    else #v2.14 ditto...
     PARTSLIST="${PARTSLIST}
/dev/fd0|vfat|1.4"
    fi
   fi
  fi
 fi

 #v2.02 nothing to save to...
 if [ "$PARTSLIST" = "" ];then
  #clear
  #[ "$OUT" == '/dev/null' ] && clear
  echo "No suitable partitions to save to." >/dev/console
  sleep 5
  return 1
 fi

 saveCHOICES=""
 rm $VERB -f /tmp/savechoices.txt
 DEFTAG=""
 echo "$PARTSLIST" |
 while read aPART
 do
   aTAG=`echo -n "$aPART" | cut -f 1 -d '|' | cut -f 3 -d '/'`
  aSIZE=`echo -n "$aPART" | cut -f 3 -d '|'`
    aFS=`echo -n "$aPART" | cut -f 2 -d '|'`
  aFREE=`/bin/df -m "/dev/$aTAG" | tail -n1 | tr -s " " | cut -f 4 -d " "`
  if [ ! "$aFREE" ];then
   mount $VERB $VERB -t $aFS /dev/$aTAG /mnt/data
   #v2.10 need to put in a check that it is not mounted ro. the
   #mount script will fallback to ro for ntfs if rw mnt fails...
   RETMNTVAL=$?
   if [ $RETMNTVAL -eq 0 ];then
    if [ "`mount | grep '(rw' | grep ' /mnt/data '`" = "" ];then
     umount $VERB $VERB /mnt/data
     RETMNTVAL=1
    else
     #v2.12 if the ntfs rw mount was forced (see /bin/mount script) it is unwise to use...
     ERRMSG1=""
     [ -s /tmp/ntfsmnterr.txt ] && ERRMSG1=`grep 'Dirty volume mount' /tmp/ntfsmnterr.txt`
     if [ "$ERRMSG1" != "" ];then
      dialog --colors --msgbox "\Z1WARNING:
The ntfs-3g driver has determined that the NTFS filesystem
in partition /dev/$aTAG is 'dirty'. It will display in the
next dialog box in the list of partitions to save to, but
it is recommended that you do not use it. Instead, you should
first run Windows -- most often this problem is due to Windows
not being shut down properly the last time it was used, leaving
the filesystem in a 'dirty' state.
\Zn
Press ENTER key to continue..." 0 0 >/dev/console
     fi
    fi
   fi
   [ -f /tmp/ntfsmnterr.txt ] && rm $VERB -f /tmp/ntfsmnterr.txt
   if [ $RETMNTVAL -eq 0 ];then
    if [ "$aTAG" = "fd0" ];then
     dFREE=`/bin/df -k | grep -w "/dev/$aTAG" | tr -s " " | cut -f 4 -d " "`
     aFREE=`LC_ALL=C dc $dFREE 1000 \/ p`
    else
     #v2.02 for ntfs cannot use /dev/$ATAG, use mnt point in grep...
     aFREE=`/bin/df -m | grep "/mnt/data" | tr -s " " | cut -f 4 -d " "`
    fi
    #umount /dev/$ATAG  v2.02 must use mnt point for ntfs...
    umount $VERB $VERB /mnt/data
   fi
  fi
  [ "$aTAG" = "$PDEV1" ] && DEFTAG=" --default-item $aTAG" #v2.13
  [ "$aFREE" != "0" ]    && echo "${aTAG} \"Filesystem: $aFS  Size: ${aSIZE}M  Free: ${aFREE}M\" \\" >> /tmp/savechoices.txt
 done

 saveCHOICES=`cat /tmp/savechoices.txt 2>>$ERR`
 if [ "$saveCHOICES" = "" ];then
  #clear
  #[ "$OUT" == '/dev/null' ] && clear
  echo "No suitable partitions to save to." >/dev/console
  sleep 5
  return 1
 fi

 echo '#!/bin/sh' > /tmp/savedialog
 echo -n 'dialog --no-collapse --no-cancel ${DEFTAG} --menu "Please choose a partition to create a pup_save.2fs file on.
It can be any of the partitions listed. It is recommended that you
choose a partition with over 512M free, but Puppy can create a
smaller save file if there is less space. The file will contain a
Linux ext2 filesystem.

Note, next time Puppy boots, this file, with all saved personal data,
will be automatically loaded.

UP/DOWN ARROW keys to highlight desired choice, then press ENTER key..." 0 0 0 ' >> /tmp/savedialog
 echo "$SCHOICES"  >> /tmp/savedialog
 echo ' 2>/tmp/tag.txt' >> /tmp/savedialog
 chmod 755 /tmp/savedialog

 #seems some people have problem, do not select anything...
 while :;do
  /tmp/savedialog >/dev/console
  #SAVEPART=`cat /tmp/tag.txt | head -n 1` #head is in case of errs in output.
  SAVEPART=`tail -n1 /tmp/tag.txt`
  if [ "`echo -n "$SAVEPART" | grep -E '^hd|^sd|^sc|^fd'`" = "" ];then
   dialog --colors --msgbox "\Zb\Z1ERROR: you did not choose any partition.
   Press ENTER key to try again...
   Press ESC key to shutdown without saving...\Zn" 0 0 >/dev/console
   [ $? = 0 ] || return 1 #v2.02 abort.
   continue
  fi
  break
 done

 SAVEFS=`echo "$saveCHOICES" | grep "^${SAVEPART} " | tr -s " " | cut -f 2 -d ':' | cut -f 2 -d " "`
 SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs"  #v2.13 was .3fs
 [ "$SAVEPART" = "fd0" ] && SAVEFILE="/${DISTRO_FILE_PREFIX}save.2fs"
 PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 return 0
} #end choosepartfunc
### SESSION SAVE ###


###snapmergepuppy ###
#v2.0.0 there could be a save tmpfs->persistent-storage running...
while [ "`pidof snapmergepuppy`" ];do
 echo -en "\rWaiting for snapmergepuppy to finish .." >/dev/console
 sleep 1
done
pidof savepuppyd >>$OUT && killall savepuppyd 1>>$OUT 2>>$ERR
###snapmergepuppy ###

### old rc.local0 ###
__old_rc_local0__(){  #BEGIN
##rc.local0 can read this...
setvol 0 | tr "\n" " " > /etc/.mixervolume
##v2.10 instead, probably do it this way...
/usr/sbin/alsactl store
#v4.00 ...yes, using 'alsactl restore' in rc.sysinit (fast boot) and rc.local0.
#v411 run rc.alsa as it also unloads modules (if not done, prevents shutdown some systems)...
/etc/rc.d/rc.alsa stop
### old rc.local0 ###

### bring down network ###
#v411 bring down network interfaces (prevents shutdown sometimes)...
for oneNETIF in `ifconfig | grep -E '^wifi[0-9]|^wlan[0-9]|^eth[0-9]' | cut -f 1 -d ' ' | tr '\n' ' '`
do
 ifconfig $oneNETIF down 2>>$ERR
done
}  ###__old_rc_local0__(){  ##END
#no, dougal has code for doing this...
/etc/rc.d/rc.network stop
# quick hack, maybe shutdown problem if ath_pci left loaded...
[ "`lsmod | grep '^ath_pci'`" ] && rmmod ath_pci
### bring down network ###

cd /
_sync
#just a precaution...

### KILL ###
pidof X &>$OUT && {
echo "Killing X and all X apps..."
killall -9 X 1>>$OUT 2>>$ERR
sleep 1
killall -3 X 1>>$OUT 2>>$ERR
_sync
}

which dillo &>$OUT && {
#MU warns may need to do this for dillo...
killall file.dpi      1>>$OUT 2>>$ERR
killall bookmarks.dpi 1>>$OUT 2>>$ERR
killall dpid          1>>$OUT 2>>$ERR
### KILL ###
}

__deprecated_init_stop__(){  #BEGIN
### init.d ###
#v2.16 some packages have a service script that requires stopping...
for service_script in `ls -1v /etc/init.d/* |tac`
do
 if [ -f $service_script -a -x $service_script ];then
 echo "Stopping $service_script ..." >/dev/console
 DEBUG=$DEBUG VERBOSE=$VERBOSE $service_script stop
 fi
done
#note, /etc/rc.d/rc.local0 does same, with 'start' parameter.
### init.d ###
}  ###__deprecated_init_stop__(){  #END
echo "Stopping init scripts .. " >/dev/console
/etc/rc.d/rc.services stop       >/dev/console
_status DONE

### PCMCIA ###
#v3.97 deprecated, for pcmcia-cs package...
if [ -f /sbin/cardmgr ];then #pcmcia-cs package installed.
 if [ "`lsmod | grep -E '^i82092|^tcic|^i82365|^yenta_socket'`" ];then
  #got this out of rc.pcmcia, modified...
  echo -n "Shutting down PCMCIA services: "
  if [ -s /var/run/cardmgr.pid ] ; then
   PID=`cat /var/run/cardmgr.pid`
   kill $PID
   for N in 1 2 3 4 ; do
    #kill -0 $PID 2>/dev/null || break #-0 is test only.
    kill -0 $PID 1>>$OUT 2>>$ERR || break
    sleep 1
   done
  fi
  if [ -s /var/lib/pcmcia/cardmgr.pid ] ; then
   PID=`cat /var/lib/pcmcia/cardmgr.pid`
   kill $PID
   for N in 1 2 3 4 ; do
    #kill -0 $PID 2>/dev/null || break #-0 is test only.
    kill -0 $PID 1>>$OUT 2>>$ERR || break
    sleep 1
   done
  fi
  killall -3 "CardBus Watcher" #BK bug, changed $Q to -3.
  #/sbin/rmmod tcic 2>/dev/null || /sbin/rmmod i82365 2>/dev/null || /sbin/rmmod yenta_socket 2>/dev/null || /sbin/rmmod i82092 2>/dev/null
  rmmod tcic 1>>$OUT 2>>$ERR || rmmod i82365 1>>$OUT 2>>$ERR || rmmod yenta_socket 1>>$OUT 2>>$ERR || rmmod i82092 1>>$OUT 2>>$ERR
  #echo "done."
  _status DONE
  rm $VERB -f /var/lock/subsys/pcmcia
 fi
fi
### PCMCIA ###

### PUPMODE 5 ###
#KRG goes till 617
#first time booted puppy, there may not have been any persistent storage.
if [ $PUPMODE -eq 5 ];then #ifpupmode5
 #v2.16.1 pxe boot, humongous initrd, have PDEV1='' DEV1FS=''...

 #3.97...
 xDEVFS="$DEV1FS"
 xPDEV="$PDEV1"
 if [ "$PSAVEMARK" != "" -a "$PDEV1" != "" ];then #v3.97 see /etc/rc.d/PUPSTATE
  devnameonly=`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`
  SAVEPART="${devnameonly}${PSAVEMARK}" #partition that will-have ${DISTRO_FILE_PREFIX}save.
  spPATTERN='/dev/'"$SAVEPART"'|'
  SAVEFS=`probepart -m | grep "$spPATTERN" | cut -f 2 -d '|'`
  xDEVFS="$SAVEFS"
  xPDEV="$SAVEPART"
 fi

 [ "$DEV1FS" ] || DEV1FS='xxx' #this will enable choice of create a save-file.
  #if it is a linux partition, can offer to save to PDEV1 or create a ${DISTRO_FILE_PREFIX}save.2fs file...
  #if vfat, create a ${DISTRO_FILE_PREFIX}save.2fs file...
  if [ "`echo -n "$xDEVFS" | grep -E "ext[2-4]|reiserfs|minix|jfs|xfs|btrfs"`" ];then #v431
   dialog --extra-button --ok-label "SAVE TO A FILE"  --extra-label "SAVE TO ${xPDEV}" --cancel-label "DO NOT SAVE" --yesno "You can now choose to save the personal session files to file, named ${DISTRO_FILE_PREFIX}save.2fs. Or, if $xPDEV partition is not being used by anything else (no other operating system) then you can choose to save the session files direct to the partition. Either way, your choice will be remembered at next bootup.

Which to choose? Partition: you immediately get the entire partition available for saving. File: having everything in a single file is convenient for archiving, but the file cannot be made bigger than 4GB (even if partition has more free space). If in doubt, just press ENTER to accept the default.

Select <SAVE TO A FILE> (just press ENTER key) to create a ${DISTRO_FILE_PREFIX}save.2fs file, select <SAVE TO ${PDEV1}> (TAB then ENTER) to save direct to partition, or <DO NOT SAVE> to shutdown with saving session..." 0 0 >/dev/console
   SAVECHOICE=$?
   if [ "$SAVECHOICE" = "0" ];then
    choosepartfunc && { pupsavefunc && PUPMODE=128 || exit 124; } || exit 123  #v2.02 128=yes, save it.
   else
    #dialog --yes-label "SAVE_TO_${PDEV1}" --no-label "QUIT" --yesno "Press ENTER key to save session files direct to $PDEV1 partition, else press TAB then ENTER to not save session..." 0 0
    #[ $? -eq 0 ] && PUPMODE=32
    [ "$SAVECHOICE" = "3" ] && PUPMODE=32 #v2.13 3=save to partition.
   fi
  fi
  #handle other f.s. types...
  case $xDEVFS in
   vfat|msdos|ntfs|xxx) #v2.02 ntfs allowed. v2.16.1
    dialog --yes-label "SAVE" --yesno "You can save the session (all of your personal data and settings) to a file, named ${DISTRO_FILE_PREFIX}save.2fs (that has a ext2 filesystem inside it). Note, your answer to this question will be remembered at next boot.

Do you want to create a ${DISTRO_FILE_PREFIX}save.2fs file?

Select <SAVE> (just press ENTER key) to create ${DISTRO_FILE_PREFIX}save.2fs and save to it, or select <No> (TAB then ENTER) to not save session..." 0 0 >/dev/console
    SAVECHOICE=$?
    if [ "$SAVECHOICE" = "0" ];then
     choosepartfunc && { pupsavefunc && PUPMODE=128 || exit 124; } || exit 123 #v2.02 128=yes, save it.
    fi
    ;;
#   ntfs) #v2.02 see above case.
#    dialog --yes-label "SAVE" --yesno "Partition $PDEV1 that ${DISTRO_NAME} booted off, is a ntfs filesystem, and ${DISTRO_NAME} can only save a session to it if there is a pre-existing ${DISTRO_FILE_PREFIX}save.3fs file. Alternatively, you can save to a different partition, including USB Flash drive, Zip drive, floppy disk, or any non-ntfs hard drive partition.
#
#Do you want to create a ${DISTRO_FILE_PREFIX}save.3fs file on a non-NTFS partition?
#
#Select <SAVE> (just press ENTER key) to chose where to save the session, else select <No> (TAB then ENTER) to not save session..." 0 0
#    SAVECHOICE=$?
#    if [ "$SAVECHOICE" = "0" ];then
#     choosepartfunc && pupsavefunc && PUPMODE=128 #v2.02 yes, save it.
#    fi
#    ;;
   iso9660)
    dialog --extra-button --ok-label "SAVE TO FILE"  --extra-label "SAVE TO CD" --cancel-label "DO NOT SAVE" --yesno "You have booted off a live-CD or DVD, and you can now save your personal settings and files to a USB Flash drive, Zip drive, floppy disk, or any hard drive partition (including NTFS). The session will be saved as a single file, named ${DISTRO_FILE_PREFIX}save.2fs, which has a ext2 filesystem inside it.

However, if you have burnt the CD/DVD as multisession (not closed), then sessions can be saved as additional tracks to the CD/DVD -- each saved session will appear on the CD/DVD as a directory with all the saved files in it, not as a single file. THIS IS STILL EXPERIMENTAL

Select <SAVE TO FILE> (just press ENTER key) to choose a partition to save the session as file ${DISTRO_FILE_PREFIX}save.2fs...
Select <SAVE TO CD> (TAB then ENTER) to save session to CD/DVD (multisession) (EXPERIMENTAL)...
Select <DO NOT SAVE> to shutdown without saving session..." 0 0 >/dev/console
    SAVECHOICE=$?
    if [ "$SAVECHOICE" = "0" ];then
     choosepartfunc && { pupsavefunc && PUPMODE=128 || exit 124; } || exit 123 #v2.02 yes, save it.
    else
     #dialog --no-label "NO_SAVE" --yes-label "SAVE_TO_CD" --yesno "Press ENTER key to save session back to multisession CD/DVD (the iso must have been burnt to CD/DVD in multisession mode), else press TAB then ENTER keys to shut down without saving session..." 0 0
     if [ "$SAVECHOICE" = "3" ];then #v2.13 3=save session to cd.
      PUPMODE=77
      SAVEPART="$PDEV1"
     else
      echo "Shutting down without saving..." >/dev/console
     fi
    fi
    ;;
  esac
fi #end ifpupmode5
#### PUPMODE 5 ###

### SWAP FILE ###
#w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
#note, rc.sysinit in puppy 3.01 had code to create a pupswap.swp, not in 4.x series.
_create_swapfile(){

 localSMNTPT="$1"    #/mnt/sda1
 localSAVEPART="$2"  #sda1

 [ -f ${localSMNTPT}/pupswap.swp ] && return
 [ "$FASTPARTS" ] || return #see /etc/rc.d/PUPSTATE
   TOTALRAM=`free | grep 'Mem:' | tr -s ' ' | cut -f 3 -d ' '`
   [ $TOTALRAM -lt 262145 ] || return #was 128000, bump up 256MB.
    TOTALSWAP=`free | grep 'Swap:' | tr -s ' ' | cut -f 3 -d ' '`
    [ $TOTALSWAP -eq 0 ] || return
     spPATTERN="$localSAVEPART"'|'
     if [ "`echo "$FASTPARTS" | grep "$spPATTERN"`" ];then
      #smPATTERN=' '"$localSMNTPT"'$'
      FREESAVEM=`/bin/df -m  "$localSMNTPT" | tail -n1 | tr -s ' ' | cut -f 4 -d ' '`
      SWPSIZE=""
      [ $FREESAVEM -gt 100 ] && SWPSIZE="50"
      [ $FREESAVEM -gt 200 ] && SWPSIZE="100"
      [ $FREESAVEM -gt 500 ] && SWPSIZE="200"
      if [ "$SWPSIZE" ];then
       echo  >/dev/console
       echo "A swapfile named 'pupswap.swp' is being created in partition ${localSAVEPART}," >/dev/console
       echo "of size ${SWPSIZE}MB. This will be loaded at next boot, to ease the low-RAM" >/dev/console
       echo "situation of your PC. Creating now..." >/dev/console
       dd if=/dev/zero of=${localSMNTPT}/pupswap.swp bs=1048576 count=$SWPSIZE
       if [ $? -eq 0 ];then
        _sync
        mkswap ${localSMNTPT}/pupswap.swp
       fi
       if [ $? -ne 0 ];then

        rm $VERB -f ${localSMNTPT}/pupswap.swp 1>>$OUT 2>>$ERR
        echo "...error, unable to create swapfile." >/dev/console
       fi
       _sync
      fi
     fi
} #end _create_swapfile
### SWAP FILE ###

if [ "$PUPSAVE" ];then
 #f.s. and partition where ${DISTRO_FILE_PREFIX}save.2fs is located...
   SAVEFS=`echo -n "$PUPSAVE" | cut -f 2 -d ','`
 SAVEPART=`echo -n "$PUPSAVE" | cut -f 1 -d ','`
 SAVEFILE=`echo -n "$PUPSAVE" | cut -f 3 -d ','`
fi


#clear >/dev/console
#[ "$OUT" == '/dev/null' ] && clear >/dev/console

#save session...
case $PUPMODE in
### fill save-file ###
 3) #PDEV1.
   echo "Saving session to $PDEV1..." >/dev/console
   /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
### fill save-file ###

### fill save-file ###
 32) #first shutdown, save back to PDEV1. v3.97: xPDEV
  DEV1MNT=`grep -w "/dev/$xPDEV" /proc/mounts | cut -f2 -d ' '`
  if [ "$DEV1MNT" = "" ];then
   mkdir $VERB -p /mnt/$xPDEV
   mount $VERB $VERB -t $xDEVFS /dev/$xPDEV /mnt/$xPDEV
   if [ ! $? -eq 0 ];then
    echo -e "\\033[0;31mERROR: unable to mount /dev/$xPDEV, cannot save...\\033[0;39m" >/dev/console
    exit  ##TODO
   fi
   DEV1MNT="/mnt/$xPDEV"
  fi
  RDIRS=`find /initrd/pup_rw/ -maxdepth 1 -xdev -type d | grep -vE "/$|/mnt|/tmp|/proc|/sys|/var|/dev|/lost"`
  for oneDIR in $RDIRS
  do
   cp $VERB -a "$oneDIR" "${DEV1MNT}/"
  done
  #DISTRO_SPECS must be saved, init script looks for it to determine if
  #there is a saved session...
  cp $VERB -af /etc/DISTRO_SPECS "${DEV1MNT}/etc/"
  _sync
### fill save-file ###

### SWAP FILE ###
  #w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
  _create_swapfile "$DEV1MNT" "$xPDEV"
  /bin/umount $VERB $VERB "$DEV1MNT" 1>>$OUT 2>>$ERR
### SWAP FILE ###
  ;;

### fill save-file ###
 7) #PDEV1 and PUPSFS.
   echo "Saving session to '$PDEV1'..." >/dev/console
   /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
### fill save-file ###

### fill save-file ###
 13) #PDEV1 and PUPSFS and PUPSAVE
  #/initrd/pup_rw has tmpfs, pup_ro1 has ${DISTRO_FILE_PREFIX}save.2fs file (PUPSAVE), pup_ro2 has PUPSFS file.
  #the above are in unionfs at /.
  echo "Saving session to '$SAVEFILE' (${SAVEPART})..." >/dev/console
  /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
### fill save-file ###

### fill save-file ###
 128) #1st shutdown, save to ${DISTRO_FILE_PREFIX}save.2fs.
  #partition already mounted on $SMNTPT.
  echo "Saving session to '$SAVEFILE' file on '$SAVEPART' partition..." >/dev/console
  mkdir $VERB -p /tmp/save1stpup
  echo -n "Mounting '${SAVEFILE}'..."
  fileFS="ext3"
  [ "`echo -n "$SAVEFILE" | grep "2fs"`" ] && fileFS="ext2"

  if [ "$CRYPTO" = "" ];then
   mount $VERB $VERB -t $fileFS -o noatime,rw,loop $saveMOUNT_POINT$SAVEFILE /tmp/save1stpup
  else
   #note: loop2 is kept available for scripts to use. but, do this to find free one...
   DEV_LOOP=`losetup-FULL -f`
   #'-p 0' means read password from stdin...
   #v2.17 crap, '-p 0' works for aes, not for xor encryption....
   if [ "$CRYPTO" = '-E 1' ];then #light xor encr.
    echo "Note, a bug in one of the Linux utility programs requires you to reenter" >/dev/console
    echo "the password in the case of light encryption..." >/dev/console
   fi
   echo "$MYPASSWORD" | losetup-FULL -p 0 $CRYPTO $DEV_LOOP ${saveMOUNT_POINT}$SAVEFILE >/dev/console
   [ $? = 0 ] || exit 1
   mount $VERB $VERB -t $fileFS -o noatime,rw $DEV_LOOP /tmp/save1stpup
  fi

  #floppy disk has little space. snapmergepuppy handles this for subsequent saves, but for now,
  #be radical, only save /etc...
  if [ "$SAVEPART" = "fd0" ];then
   RDIRS="/initrd/pup_rw/etc"
  else
   RDIRS=`find /initrd/pup_rw/ -maxdepth 1 -xdev -type d | grep -vE "/$|/dev|/lost|/mnt|/proc|/sys|/tmp|/var"`
  fi
  for oneDIR in $RDIRS
  do
   #basenameDIR=`basename $oneDIR` #v2.16exp3
   basenameDIR="${oneDIR##*/}"
   mkdir $VERB -p /tmp/save1stpup/${basenameDIR} #v2.16exp3 likely already created above.
   cp $VERB -a "$oneDIR"/* /tmp/save1stpup/"${basenameDIR}"/ #v2.16exp3
   [ "$basenameDIR" = "root" ] && cp $VERB -a "$oneDIR"/.[0-9a-zA-Z]* /tmp/save1stpup/"${basenameDIR}"/ #v2.16exp4
  done
  _sync
  umount $VERB $VERB /tmp/save1stpup
### fill save-file ###

### copy sfs to hdd menu ###
  #v2.20b offer to copy ${DISTRO_FILE_PREFIX}-xxx.sfs and ${ZDRVSFS} off the cd...
  if [ "$DEV1FS" = "iso9660" ];then #test if booted off cd.
   if [ ! -f "${saveMOUNT_POINT}"/${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}*.sfs ];then
    NAMEONLY=`basename "$SAVEFILE"`
    dialog --yesno "The CD has '${DISTRO_FILE_PREFIX}-$DISTRO_VERSION.sfs' and maybe other .sfs files on it.
It will speed startup considerably if these are on the hard drive.
Also, for PCs with less than 256MB of RAM, ${DISTRO_NAME} does not copy the
${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs file to RAM so the CD drive remains mounted,
meaning that the drive cannot be used for other purposes -- however,
if you reply 'YES' here then it will be copied to the same place
as the '${DISTRO_FILE_PREFIX}save' file and loaded from there at startup,
thus freeing the CD drive for other uses.
Even if you have heaps of RAM, it is still good to answer 'YES'
to get the faster startup.

Note: If a CD has extra .sfs files on it, by copying them to the
same place as the '${DISTRO_FILE_PREFIX}save' file, they are then available to
be loaded at startup, which is configurable by the BootManager
(the BootManager is in the System menu)

If you answer 'Yes' here, please FIRST, RIGHT NOW, put the ${DISTRO_NAME}
CD into the $PDEV1 drive (the same one that the CD was in at
startup), if it isn't already, THEN select the 'Yes' button..." 0 0 >/dev/console
    RETVAL=$?
    #clear >/dev/console
    #[ "$OUT" == '/dev/null' ] && clear >/dev/console
    if [ $RETVAL -eq 0 ];then
     echo "Please wait, accessing CD drive..." >/dev/console
     gPATTERN="^/dev/$PDEV1 "
     CDMNTPT=`mount | grep "$gPATTERN" |awk '{print $2}'` # cut -f 3 -d ' '`"
     mkdir $VERB -p /mnt/$PDEV1
     if [ "$CDMNTPT" = "" ];then
      mount $VERB $VERB -t iso9660 /dev/$PDEV1 /mnt/$PDEV1
      CDMNTPT="/mnt/$PDEV1"
     fi
     for oneSFS in `find "$CDMNTPT" -maxdepth 1 -type f -name \*.sfs | grep -v ' '`
     do
      #BASESFS=`basename $oneSFS`
      BASESFS="${oneSFS##*/}"
      FILESIZEB=`stat -c %s "$oneSFS"`
      FILESIZEK=$(( (FILESIZEB / 1024) + 2048 )) #2MB slack.
      BPATTERN=" $saveMOUNT_POINT"'$'
      DRVFREEK=`/bin/df -k | tr -s ' ' | grep "$BPATTERN" | cut -f 4 -d ' '`
      if [ $DRVFREEK -gt $FILESIZEK ];then
       echo "Copying $BASESFS..." >/dev/console
       cp $VERB -f "$oneSFS" "$saveMOUNT_POINT"/
       [ "$FORCE" ] || { pidof sync >>$OUT || sync; }
      else
       echo -e "\\033[1;31mInsufficient space! Cannot copy '$BASESFS'\\033[0;39m" >/dev/console
       break
      fi
     done
     busybox umount $VERB $VERB "$CDMNTPT"
    fi
   fi
  fi
### copy sfs to hdd ###

### SWAP FILE ###
  #w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
  _create_swapfile "$saveMOUNT_POINT" "$SAVEPART"
  /bin/umount $VERB $VERB "$saveMOUNT_POINT" 1>>$OUT 2>>$ERR
### SWAP FILE IF PUPMODE 128 ONLY ?? ###
  ;;
 69) #save to folder on multisession CD/DVD (including 1st shutdown). (5+64=69) NOT used
  multisavefunc
  ;;
 77) #save to folder on multisession CD/DVD (including 1st shutdown). (13+64=77)
  multisavefunc
  ;;
 2)
  echo -e "\\033[0;32m$PDEV1 mounted directly, session already saved.\\033[0;39m" >/dev/console
  ;;
 12)
  echo -e "\\033[0;32m`basename $SAVEFILE` mounted directly top layer, session already saved.\\033[0;39m" >/dev/console
  ;;
 6)
  echo -e "\\033[0;32m$PDEV1 mounted directly top layer, session already saved.\\033[0;39m" >/dev/console
  ;;
 5) #v2.02 first boot.
  echo -e "\\033[0;35mSession not saved\\033[0;39m" >/dev/console
  _sync
  #ha ha, before had this, if aborted save after choosing save-partition, code
  #further down wiped all of the partition (it was mntd on /tmp/savepup)...
  #[ ! "$SMNTPT" = "" ] && umount $VERB $VERB "$SMNTPT" 2>>$ERR
  [ ! "$saveMOUNT_POINT" = "" ] && /bin/umount $VERB $VERB "$saveMOUNT_POINT" 1>>$OUT 2>>$ERR
  #...well, fixed it, changed mntpt so not in /tmp. Leave above line here.
  ;;
 *)
  echo -e "\\033[0;31mUnhandled PUPMODE '$PUPMODE' :Session not saved ...\\033[0;39m" >/dev/console
  sleep 2
  ;;
esac

if [ "$OUT" == '/dev/console' ]; then
 if test -d /dev/.udev; then
D="ABOUT udev :
`ps | grep udev`
ABOUT klogd :
`ps | grep klogd`
ABOUT syslogd :
`ps | grep syslogd`"
__debug "$D" >/dev/console
 fi
fi

##+++2011-12-02

# When the working files run in tmpfs in ram, they are saved above
# and /tmp and /var are screened out.
#
# However, some PUPMODES mount ${DISTRO_FILE_PREFIX}save.2fs
# directly on /initrd/pup_rw, the top unionfs layer,
# meaning that there is no intermediary tmpfs in ram for working files,
# hence everything is saved directly, ditto for PUPMODE=2 a full h.d. install.
#
# Hence need to do some explicit wiping here...

###+++2011-12-04
mkdir $VERB -p   /root/my-documents/boot
rm $VERB -rf     /root/my-documents/boot/tmp.old
cp $VERB -a /tmp /root/my-documents/boot/tmp.old

###+++2011-12-04
rm $VERB -f  /var/lock/LCK*
rm $VERB -f  /var/run/*.pid
rm $VERB -rf /root/tmp/* /root/tmp/.[[:alnum:]]* 1>>$OUT 2>>$ERR  #...note, not screening this out in any of above save modes.

if [ "$PUPMODE" != "2" ]; then
    echo -e "\\033[0;33mRemoving thumbnails...\\033[0;39m" > /dev/console
    rm $VERB -rf /root/.thumbnails/* 1>>$OUT 2>>$ERR

else #KRG
FP=`/bin/df | grep -m1 -Fw '/' | tr -s ' ' | cut -f5 -d ' ' | tr -d '%'`
 if test "$FP" -lt 5; then
  echo -e "\\033[0;31mFull install , free space lesser than 5%; removing thumbnails\\033[0;39m" >/dev/console
  rm $VERB -rf /root/.thumbnails/* 1>>$OUT 2>>$ERR
 else
  echo -e "\\033[0;32mFull install , free space more than 5%; leaving thumbnails ok\\033[0;39m" >/dev/console
 fi
fi
[ -f /etc/rc.d/MORESFS ] && rm $VERB /etc/rc.d/MORESFS

[ "$FORCE" ] || { pidof sync >>$OUT || sync; }

_status(){
 _CHAR=${1//[[:digit:]]/}
 if [ "$_CHAR" ];then echo -e "\\033[32G\\033[1;36m${_CHAR}$Black0" >/dev/console
 set -- 0
 elif [ "$1" = 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone$Black0" >/dev/console #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed$Black0" >/dev/console #red [failed].
  STATUS=0
 fi
 return $1 #return with same status as entry param.
}


#======================= UNMOUNT block devices =================================

swapoff -a  #busybox swapoff -a works only if swaps are in mtab or ftab
#v2.13 menno suggests this improvement...
STRAYPARTD=`grep "^/" /proc/swaps | grep -v 'deleted' | cut -f 1 -d " "`
for oneSTRAY in $STRAYPARTD
do
 echo -e "\\033[0;34mSwapoff $oneSTRAY\\033[0;39m " >/dev/console
 swapoff $VERB "$oneSTRAY" &
 sleep 0.1
done
[ "$FORCE" ] || { pidof sync >>$OUT || sync; }

__old_unmount__(){

# REM: original adapted to use output of mount command ..
mountedPARTS=`mount`
# REM: revert order: last mount first
mountedPARTS=`echo $mountedPARTS |rev|sed 's% )%\n)%g'|rev`  ##+++2012-01-22
#echo #KRG
# REM: tell whats going on
echo "Unmounting stray filesystems:"

# REM: filter out /dev/root, pseudo file-systems and frugal layer mounts in /initrd ...
#STRAYPARTitionsList=`echo "$MNTDPARTitionS" |grep -v "/dev/pts" |grep -v "/proc" |grep -v "/sys" |grep -v "tmpfs" |grep -v "rootfs" |grep -v 'on / ' | grep -v "/dev/root" | grep -v "usbfs" | grep -v "unionfs" | grep -v "/initrd"`
strayPART_List=`echo "$mountedPARTS" |grep -vE '/dev/pts|/proc|/sys|tmpfs|ramfs|rootfs|usbfs|unionfs| on / type | on "/" type |/dev/root| on /initrd | on /initrd/| /dev '`
# REM: We just need device and or mountpoint
#strayPART_And_MountPoints=`echo "$strayPART_List" |awk -F '"' '{print $2" "$4}'` #| cut -f 1,3 -d " "`" # | tr "\n" " "`"  ##+2011-10-27 doublequotes for $STRAYPARTitionsList
strayPART_And_MountPoints=`echo "$strayPART_List" |awk '{print $1" "$3}'`
# REM:mount point directories:
strayMOUNT=`echo "$strayPART_And_MountPoints" | cut -f 2 -d ' '`   ##2011-10-27 doubblequotes for $STRAYPARTitionsAndMountpoints
# REM: device block special files
strayDISKS=`echo "$strayPART_And_MountPoints" | cut -f 1 -d ' '`   ##2011-10-27 doubblequotes for $STRAYPARTitionsAndMountpoints

# REM: now process the data and unmount...
for oneSTRAY in $strayMOUNT
do

 echo -ne "\\033[1;34mUnmounting $oneSTRAY...\\033[0;39m " >/dev/console
 #sleep 3s  ##DEBUG

 # REM: Unneeded - should be for oneMOUNT in $strayMOUNT
 oneDISK=`echo "$strayPART_And_MountPoints" | grep -w "$oneSTRAY" | cut -f 1 -d ' '`
oneMOUNT=`echo "$strayPART_And_MountPoints" | grep -w "$oneSTRAY" | cut -f 2- -d ' '`

 # kill fusers of mountpoint
 [ "$oneMOUNT" ] && fuser -k -m "$oneMOUNT"
 _killzombies #v3.99
 # sync if no force option...
 [ "$FORCE" ] || { pidof sync >>$OUT || sync; }

 # sanity check if root drive ...
 [ "`rdev`" = "${oneDISK} /" ] && continue

# REM: play around if some pseudo file systems were left over...
if test "$oneDISK" = none; then
 # need to use mountpoint
 /bin/umount $VERB $VERB -lr "$oneMOUNT"
 _status $?
else
 # REM: could unmount device...
 # umount $VERB $VERB -lr "$oneDISK"
 # REM: but device could be mounted elsewhere another time
 #      so need to unmount mountpoint ...
  /bin/umount $VERB $VERB -lr "$oneMOUNT"
 # REM: using -l lazy and -r read-only option to force success
 #      by -l or remount read-only as last resort
 #      to prevent possible file-system corruption
 _status $?
fi
done
}  ###__old_unmount__(){

### 2014-11-15 ###

# REM: _unmount_all_devices :
#      Function to unmount all devices
#      Usually at shutdown one of the last steps
#      Accepts <device=comma,separated,list,of,device,types> parameter
#      where device types are ad,fd,hd,loop,mmcblk,*ram,sd,scd,sr,xd,...,and so on
#      fd: floopy, loop: file mounts, sd: todays hdds, sr: todays cdrom drives
#      See linux kernel source Documentation/devices.txt for more info
#      Other parameters are passed as they are to umount line
_unmount_all_devices(){

test -f /proc/mounts || return 4

local DEV_CHOICE dev_ mountpoint_ fstyp_ mountops_

# REM: choice filter option
#      device=ad|fd|hd|loop|mmcblk|*ram|sd|scd|sr|xd
#      comma separated list of device types to unmount
case "$1" in
device=*)
 DEV_CHOICE=`echo "${1#*=}" | sed 's!,!\*|!g;s!$!\*!' | tr -s '\*' | tr -s '|' | sed 's!^|*!!;s!|*$!!'`
 # REM: get rid of leading devices=;translate ',' '|', add wildcards, clean up
shift
;;
esac

[ "$DEV_CHOICE" ] && echo "DEBUG: DEV_CHOICE='$DEV_CHOICE'" ##DEBUG

while read dev_ mountpoint_ fstyp_ mountops_
do

 # REM: skip /dev/root and pseudo-file-systems
 case "$dev_" in
 *root*) continue;;
 /dev/*):;;
 *) continue;;
 esac

 # REM: skip /initrd in frugal mode
 case $mountpoint_ in
 *initrd*) continue;;
 esac

 # REM: apply DEV_CHOICE
 if test "$DEV_CHOICE"; then

  case "$dev_" in
  /dev/${DEV_CHOICE}) :;;
  *) continue;;
  esac

 fi

 # REM: sync only if no other sync is running
 #      to prevent hangs
 pidof sync >>$OUT || sync

 ## REM: translate \0octal entries
 mountpoint_=`echo -e "$mountpoint_"`

 # REM: handle fuse mounts
 case $fstyp_ in
 *fuse*)
  echo -ne "\\033[1;33mUnmounting $mountpoint_...\\033[0;39m " >/dev/console
  fusermount -zu "$mountpoint_" &
  sleep 2
  continue
  ;;
 esac

 # REM: fuser checking done in /bin/umount script
 #      but we are in non-X environment in rc.shutdown, so use it
 _check_fusers(){
 echo "checking for users of $mountpoint_ :"
 fuser -m "$mountpoint_" && continue
 ## fuser returns 0 if users, 1 if no users

 ## busybox lsof does show all open files on system
 #lsof "$mountpoint_"
  }
 _check_fusers

 ## REM: device could be mounted on other mountpoints,
 ##      so do not unmount /dev/<device>
 #umount $VERB $* "$dev_"
 echo -ne "\\033[1;34mUnmounting $mountpoint_...\\033[0;39m " >/dev/console
 /bin/umount $VERB $VERB $* "$mountpoint_"

  if test $? != 0; then
  #give some message
   :
   :
  #no idea what to say today ...
  fi

sleep 0.1
# REM: Use tac to unmount submounts first
done <<EoI
`tac /proc/mounts`
EoI
}

_unmount_all_devices -lr
#======================= UNMOUNT block devices =================================


### kill ###
#Note, there is a problem with unmounting,
# especially ntfs as it cannot be remounted ro (?).
# A ntfs part with ${DISTRO_FILE_PREFIX}save.2fs cannot be unmounted because of the mounted
# ${DISTRO_FILE_PREFIX}save.2fs.
# At least, attempt to kill anything running in the ntfs partition...
# (i don't think anything will be, only /dev/loop1 (${DISTRO_FILE_PREFIX}save.2fs), but just in case)
[ "$PUP_HOME" ]    && absPUP_HOME="/initrd${PUP_HOME}"   #v2.16rc
[ "$absPUP_HOME" ] || absPUP_HOME="/initrd/mnt/dev_save" #v2.16rc
if [ "`busybox mount | grep "$absPUP_HOME"`" != "" ];then
 BADPIDS=`fuser -v -m "$absPUP_HOME" 2>&1 | grep -v -E 'kernel|COMMAND|^$' | tr -s ' ' | cut -f 3 -d ' '`
 for oneBAD in $BADPIDS
 do
  echo "Killing process $oneBAD..."
  kill $oneBAD || {
  sleep 1
  kill -9 $oneBAD 1>>$OUT 2>>$ERR
  }
  [ "$FORCE" ] || { pidof sync >>$OUT || sync; }
  sleep 0.1
 done
 _killzombies #v3.99
fi
### kill ###


### unmounting frugal save file or partition ###
#v2.16rc try this too... SAVE_LAYER defined in /etc/rc.d/PUPSTATE...
if [ "$SAVE_LAYER" ];then
 [ "$FORCE" ] || { pidof sync >>$OUT || sync; }
 SAVEDEV=`mount | grep " /initrd${SAVE_LAYER} " | cut -f 1 -d ' '`
  SAVEFS=`mount | grep " /initrd${SAVE_LAYER} " | cut -f 5 -d ' '`

 echo -en "\\033[1;33mAttempting to remount $SAVEDEV /initrd${SAVE_LAYER} type $SAVEFS read-only..\\033[0;39m" >/dev/console
 busybox mount $VERB $VERB -t $SAVEFS -o remount,ro $SAVEDEV /initrd${SAVE_LAYER} 2>>$ERR
 _status $?

 echo -en "\\033[1;33mAttempting to unmount /initrd/${SAVE_LAYER} ..\\033[0;39m." >/dev/console
 umount-FULL $VERB -i -n -l /initrd/${SAVE_LAYER} 2>>$ERR  #-l is lazy unmount.
 _status $?

fi
### unmounting frugal save file or partition ###


### unmounting evtl ntfs ###
#v2.16 try one more thing for ntfs... lazy unmount, suggested by GuestToo...
MNTFUSE=`grep 'fuse' /proc/mounts | head -n 1 |awk '{print $2}'`
if [ "$MNTFUSE" ];then
 MNTFUSE=`echo -e "$MNTFUSE"`
 #v2.17 hairywill found the -u is required with -z...
 echo -en "\\033[1;33mAttempting to unmount $MNTFUSE ...\\033[0;39m" >/dev/console
 fusermount -z -u "$MNTFUSE"
 _status $?
fi
### unmounting evtl ntfs ###


###+++2011-12-04
[ "$FORCE" ] || {
if [ "$OUT" == '/dev/console' ]; then
 if test -d /dev/.udev; then
D="ABOUT udev :
`ps | grep udev`
ABOUT klogd :
`ps | grep klogd`
ABOUT syslogd :
`ps | grep syslogd`
"
__debug "$D" >/dev/console 2>71
sleep 5s
 fi
fi
}



[ "$FORCE" ] || {
##+++2013-04-29
pidof freememapplet >>$OUT && kill -9 `pidof freememapplet`
pidof inotifywait   >>$OUT && kill -9 `pidof inotifywait`

WM=`cut -b 1-6 /etc/windowmanager | tr -d ' '`
WMpids=`ps |grep "$WM" |grep -v grep |awk '{print $1}'`
for w in $WMpids;do kill -4 $w;done

FTPs=`ps |grep ftp |grep -v grep |awk '{print $1}'`
for s in $FTPs;do kill -4 $s;done
}

# REM: kill some daemons that escaped /etc/init.d/* stop ...
[ "`pidof hiawatha`" ] && killall hiawatha
   [ "`pidof acpid`" ] && killall acpid

   [ "`pidof udevd`" ] && { killall udevd;cd /dev/.udev;rm $VERB -r `ls -1A /dev/.udev/`;cd $HOME; }

   dmesg >/tmp/shutdownkernel.log
   [ "`pidof klogd`" ] && killall klogd

# REM: did killing succeed ??
   [ "`pidof acpid`" ] && kill -4 `pidof acpid`
   [ "`pidof klogd`" ] && kill -4 `pidof klogd`

# REM: want syslogd shutdown last to catch exit messages of other daemons incl klogd
 cp -a /var/log/messages /tmp/shutdownmessages.log
 [ "`pidof syslogd`" ] && killall syslogd

##+++2011-12-02
__debug "`ls -l / | head -n10`"
#_interactive


(
echo
date
uptime
echo
) >>/var/log/uptime.log

#/mnt/dev_save/pupsaveresize.txt
#[ -f /mnt/dev_ro2${ZFILE} ] && MNT_ZFILE="dev_ro2"

#modprobe $VERB -r e1000e
#modprobe $VERB -r shpchp
#modprobe $VERB -r speedstep_lib
#modprobe $VERB -r acpi_cpufreq
#modprobe $VERB -r iptable_mangle
#modprobe $VERB -r nf_conntrack_ftp
#modprobe $VERB -r fan
#modprobe $VERB -r ac
#modprobe $VERB -r thermal_sys
#modprobe $VERB -r coretemp
#modprobe $VERB -r battery
#modprobe $VERB -r hwmon

#oldDEBUG=$DEBUG
#DEBUG=1
if [ "$DEBUG" ]; then
 DATE_=`date +%Y-%m-%d-%H-%M`
 cp $VERB -a /tmp /var/tmp-"$DATE_"
 mksquashfs /var/tmp-"$DATE_" /var/tmp-"$DATE_".sfs 1>>$OUT 2>>$ERR
 [ $? = 0 ] && rm $VERB -r /var/tmp-"$DATE_"
fi
#DEBUG=$oldDEBUG

#unmount mother partition
[ "$FORCE" ] || { pidof sync >>$OUT || { sync; sleep 2; }; }
case $PUPMODE in
2)
_mount_root_ro_pupmode_2(){
echo -e "\\033[1;33mAttempting to mount '/' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/root /
MAIN_RET_VAL=$?
_status $MAIN_RET_VAL
}
MAIN_RET_VAL=0
;;
3)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
;;
5)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ... " >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
_status $MAIN_RET_VAL
;;
6)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
_status $MAIN_RET_VAL
;;
7)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
_status $MAIN_RET_VAL
;;
12)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
 case $MAIN_RET_VAL in
 0) :;;
 *) mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
    MAIN_RET_VAL=$?
 ;;
 esac
;;
13)
echo -e "\\033[1;33mAttempting to mount '/dev/$PDEV1' read-only ...\\033[0;39m" >/dev/console
mount $VERB $VERB -s -o remount,ro /dev/$PDEV1
MAIN_RET_VAL=$?
_status $MAIN_RET_VAL
;;
77)  ## Multi Session DVD
:
;;
32)  #from 5 to whole partition
:
;;
128)  #from 5 to pup-save.3fs
:
;;
'')
:
;;
*)  ## UNI-PUPS
:
;;
esac

# REM: want to unload all unused kernel drivers
#      to find out if that helps with reboot problems
_unload_all_modules(){

# REM: leave function if FORCE
[ "$FORCE" ] && return 0
# REM: sanity check
_test_fr /proc/modules || return 4

echo -e "\nUnloding kernel drivers..."
# REM: big fat unload loop
# REM: 'c' is emergeny break count to prevent never ending loop - currently set to '9'
c=0
while [ unloading ];
do

 sleep 1
[ "`awk '{ if ($3 == 0) print}' /proc/modules`" ] || { [ "$DEBUG" ] && echo "Only used drivers remain";break; }

  #while [ 1 ];                 #does not work
  #do                           #or if it works
  #read module vms users rest   #prints empty lines to screen

  # REM : /proc/modules gets updated by the kernel,
  #       so better to use a procMODULES list variable...
  sleep 1
  procMODULES=`cat /proc/modules`

  while
  read module vms nr_users users state address
  do

   [ "$module" ]    || { [ "$DEBUG" ] && echo "No module";break; }
   [ "$nr_users" = 0 ] || { [ "$DEBUG" ] && echo "'$module' in use by '$users'";continue; }

   # REM: keep usb and hid drivers if USB input devices (keyboard) input needed later on
   #      also keep unix module - it reloads anyways all the time
   case $module in
    *usb*|*hci*|*hcd*|*hid*|evdev|unix) [ "$DEBUG" ] && echo "Skipping unloading of '$module'";continue;;
   esac

   # REM: use modprobe -r instead of rmmod
   #      because it removes also drivers that the driver depends on
   #      fork it to prevent hangs
   echo -en "\\033[1;33m"
   /sbin/modprobe $VERB -r $module &
   sleep 1
   echo -en "\\033[0;39m"

  # REM : /proc/modules gets updated by the kernel,
  #       so better use a LIST variable...
  #done</proc/modules
  done<<EoI
`echo "$procMODULES"`
EoI

[ "`awk '{ if ($3 == 0) print}' /proc/modules | grep -vE '*usb*|*hci*|*hcd*|*hid*|evdev|unix'`" ] || \
                             { [ "$VERBOSE" ] && echo "Only used or ^unused hid|usb^ drivers remain"; break; }

 c=$((c+1))
case $c in 9) echo "_unload_all_modules:BREAKING for ninth loop";break;; esac

done
}
[ "$FORCE" ] || _unload_all_modules >/dev/console 2>&1

##DBG
[ "$FORCE" ] || {
if [ "$DEBUG" -o "$VERBOSE" ]; then
echo  >/dev/console
mount >/dev/console 2>&1
echo  >/dev/console
ps | grep -vE '\[|grep' >/dev/console 2>&1
echo  >/dev/console
sleep 10
fi
##DBG

if [ "$DEBUG" -o "$VERBOSE" ]; then
 [ "$MAIN_RET_VAL" = 0 ] || exit $MAIN_RET_VAL
fi
}

busybox umount $VERB $VERB -lar 1>>$OUT 2>>$ERR
 UMOUNT_RET_VAL=$?
#sleep 5 #10
[ "$FORCE" ] && { exit 0; true; } || {
if [ "$DEBUG" -o "$VERBOSE" ];then
 exit $UMOUNT_RET_VAL
else
 exit 0
fi
}

### the END ### -- returning  to /sbin/reboot or /sbin/poweroff, executed normaly from xwin
