#!/bin/ash
#(c) Copyright bkauler 2006,2007 www.puppylinux.com
#2007 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#updated aug 2007 for v2.20, save in a folder.
#BK updated 20,22 sept 2007 v2.22, multisession bugfix.
#v3.01 BK 10 oct 2007, attempted bugfixes for funny CD drive.
#v3.01 BK 11 oct 2007, removed multisavefunc() to functions4puppy.
#v3.02 BK 1 nov 2007, can change folder of pup_save file.
#v3.97 BK feb 2008: restore support for pcmcia-cs package.
#v3.97 BK 5 mar 2008, handle PSAVEMARK, see /etc/rc.d/PUPSTATE, init script.
#REMOVEDv3.98 BK 2 apr 2008: 'mke2fs -O none' for encrypted pup_save, fix mntg bug.
#v3.99 7apr2008: fix zombie process prevents partition unmount.
#v411 run rc.alsa as it also unloads modules (if not done, prevents shutdown some systems).
#v411 bring down network interfaces, as sometimes prevent poweroff.
#v412 /etc/DISTRO_SPECS, renamed pup_xxx.sfs, pup_save.2fs etc.
#w002 pup files renamed to format upup-555.sfs, upupsave.2fs.
#w468 alsa shutdown now handled in /etc/init.d/alsa.
#w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create swapfile.
#w482 use xorriso instead of cdrtools/cdrkit if installed.
#v431 tulindo: fix saving to ext4 partition.
#091117 weird shutdown bug. would not shutdown when a partition mounted, x restarted.
#091222 added support for saving to /dev/mmcblk* devices.
#100107 would not shutdown if ntfs partition mounted. Added timeout in shutdown dlg.
#100301 brought code to stop network interfaces further down, also consider 'defaultconnect'.
#100309 network shutdown improvement.
#100315 improper shutdown f.s. check.
#100401 choose ext2/3/4 for pupsave file. 100410 offer ext2/3 only.
#100604 shel: Unload the Ethernet drivers on shutdown to prevent battery drain.
#100615 Patriot: suggested code to enable save-layer to remount ro.
#100719 cannot save session to entire partition if puppy installed in a subdirectory.
#100814 log the cumulative bytes transmitted on network.
#100820 delete /var/tmp/* (apparently filled by opera crashes).

  _TITLE_="Puppy_rc.shutdown"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/etc/rc.d/rc.shutdown"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP=1
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in 1; do shift; done; }

_trap

}

for p_ in $@
do
case $p_ in
-?help|-?usage|-h|-H)
:
return 0 2>>$ERR || exit 0
;;
-?version|-V)
:
return 0 2>>$ERR || exit 0
;;
-?force|-f)
FORCE=1
;;
-?debug|-d)
set -x
;;
-?verbose|-v)
VERBOSE=1;VERB=-v;L_VERB=--verbose;A_VERB=-verbose;QUIET='';OUT=/dev/stdout;ERR=/dev/stderr
;;
esac
done

[ -f /etc/rc.d/rc.shutdown.local.start ] && . /etc/rc.d/rc.shutdown.local.start

#v2.20b make shutdown less verbose...
#clear
#exec 1> /dev/null 2>&1


########################################################################
#
# Changes by Karl Reimer Godt
# 01.0 : for debugging puprposes : commented exec 1> /dev/null 2>&1 AND clear
#        one clear still left after dialog to save .sfs to disk to speedup boot
# 02.0 : Handling of fsckme.err file
# 03.0 : added /etc/rc.d/rc.shutdown.local.start
# 04.0 : changed dialog to choose also ext4 fs for save-file
# 04.1 : changed the text a little : no ext2 for encryption anymore , key for TAB
# 05.0 : changed <if [ "$CRYPTO" = "" ];then> part ( put up before mkfs.ext[2-4])
#       to <if [ "$CRYPTO" != "" ];then>
# 06.0 : case PUPMODE=128      FILEFS="ext4"
#      [ ! "`echo -n "$SAVEFILE" | grep "3fs"`" = "" ] && FILEFS="ext3"
#      [ ! "`echo -n "$SAVEFILE" | grep "2fs"`" = "" ] && FILEFS="ext2"
#
#
# 09.0 : added check before rm $VERB -rf /root/.thumbnails/* 2>>$ERR ,
#        if enough space , dont remove
# 10.0 : rm $VERB /dev/.udev
#        ##/root/my-applications/sbin/MkMissingDev.sh
#        cp -f /etc/rc.d/PUPSTATE /etc/rc.d/PUPSTATE.prev
#
#        ##fsckme_func
#        #rm $VERB -f /tmp/wmexitmode.txt
#
# /dev/hda7
# /dev/hda7:
# LABEL="/"
# UUID="429ee1ed-70a4-43a5-89f8-33496c489260"
# TYPE="ext4"
# DISTRO_NAME='LucidÂPuppy'
# DISTRO_VERSION=218
# DISTRO_MINOR_VERSION=00
# DISTRO_BINARY_COMPAT='ubuntu'
# DISTRO_FILE_PREFIX='luci'
# DISTRO_COMPAT_VERSION='lucid'
# DISTRO_KERNEL_PET='linux_kernel-2.6.33.2-tickless_smp_patched-L3.pet'
# PUPMODE=2
# SATADRIVES=''
# PUP_HOME='/'
# PDEV1='hda7'
# DEV1FS='ext4'
# LinuxÂpuppypcÂ2.6.31.14Â#1ÂMonÂJanÂ24Â21:03:21ÂGMT-8Â2011Âi686ÂGNU/Linux
# Xserver=/usr/bin/Xorg
# $LANG=en_US
# today=TueÂOctÂ25Â12:47:30ÂGMT+1Â2011
#
# TODO1 : force pupsaveresize.txt if low space in pupsave
# TODO2 : fuser -m $oneSTRAY still is /dev/ not /mnt/
# TODO3 : 366 unexpected fi 2011-11-07 K7
#
########################################################################

OUT=/dev/console;ERR=$OUT

debug(){
echo "$1" >>$OUT
}

_ask_to_quit(){
[ "$FORCE" ] && return 0
exec 1>/dev/console 2>&1
echo -e "\\033[1;33m
$1
\\033[0;39m" >$OUT
echo -en "\\033[1;35m""Want to stop the shutdown process ? Press 'q' if you want to :""\\033[0;39m" #>$OUT
read -t 5 -n1 Q_K
echo
case $Q_K in q|Q) exit 199;; esac
exec 1>$OUT 2>$ERR
}

#w482 use xorriso if it is installed (see also functions4puppy)...
CDRECORD='cdrecord'
MKISOFS='mkisofs'
if [ "`which xorriso`" != "" ];then
 CDRECORD='xorrecord'
 MKISOFS='xorrisofs' #growisofs reads this variable.
fi
export CDRECORD MKISOFS

#variables created at bootup by init script in initrd...
. /etc/rc.d/PUPSTATE #v2.02
. /etc/DISTRO_SPECS #v412
[ "$SHUT_HOW" ] || SHUT_HOW='shutting down'  ##+++2013-03-10
SHUT_HOW2=`echo "${SHUT_HOW//ing/}" | tr -s 't'`
echo "${DISTRO_NAME} is now ${SHUT_HOW}..." > /dev/console

fsckme_func(){ ###krg Mar11-2011:turned into func to call at end of script
#100315 improper shutdown check. see /etc/rc.d/rc.sysinit, /init in initramfs, and /sbin/init...
#[ -f /boot/.fsckme.err ] && rm $VERB -f /boot/.fsckme.err
#[ -f /initrd${PUP_HOME}/boot/.fsckme.err ] && rm $VERB -f /initrd${PUP_HOME}/boot/.fsckme.err
case $PUPMODE in
''|2)
ErrFlag=`/bin/busybox find / -maxdepth 3 -type f -iname '*fsckme*'`
for i in $ErrFlag ; do
rm $VERB $i
done
;;
*)
fsckmeFILES=`ls -A /initrd/${PUP_HOME#/}/*fsckme*`
for i in $fsckmeFILES ; do
rm $VERB $i
done
;;
esac
}

ORIGPUPMODE=$PUPMODE #v2.22

echo "Executing /etc/rc.d/rc.shutdown..."

PATH=/bin:/sbin:/usr/bin:/usr/sbin
#PUPPYVERSION="`cat /etc/puppyversion`"

#v2.20 if ${DISTRO_FILE_PREFIX}rxxx.sfs is in a subdirectory, default to saving in it...
PUPSFSFILE="`echo "$PUPSFS" | cut -f 3 -d ','`"
PSUBDIR="`dirname "$PUPSFSFILE"`"
[ "$PSUBDIR" = "/" ] && PSUBDIR=""

#for a full hd install, only setting PUPMODE (=2). no /initrd, no initrd.gz.

. /etc/rc.d/functions4puppy #v3.01

killzombies(){

 [ "$FORCE" ] && return 0

 #while read pid tty status rest ; do
while read pid status; do
 [ "$pid" -a "$status" ] || continue
 #[ "$status" = 'Z' ] || continue
 case $status in
  Z*) :;;
  *) continue;;
 esac
 kill $pid
done<< EoI
$(ps -o pid,stat | grep -w Z)
EoI
#done << EOI
#$(/bin/ps -A -H -o pid,s | grep -w Z)
#EOI

}

#v2.02 dougal contributed this...
choosesizefunc(){
 local KFREE SIZELIST NUM CHOICES FLABEL SLABEL aCHOICE KSIZE
 KFREE=$1 ; SIZELIST="" ; NUM=1 ; CHOICES=""
 FLABEL="$(( KFREE / 1024))MB"
 [ $KFREE -ge 1048576 ] && FLABEL="`dc $KFREE 1048576 \/ p`GB"
 for aCHOICE in 32 64 128 256 512 768 1024 1280
 do
  KSIZE=$(( aCHOICE * 1024 ))
  SLABEL="${aCHOICE}MB"
  [ $ACHOICE -ge 1024 ] && SLABEL="`dc $aCHOICE 1024 \/ p`GB"
  if [ $KSIZE -lt $KFREE ];then
   SIZELIST="$SIZELIST$NUM $SLABEL "
   CHOICES="$CHOICES$KSIZE "
  else
   SIZELIST="$SIZELIST$NUM fill_partition(${FLABEL}) "
   CHOICES="$CHOICES$KFREE "
   break
  fi
  NUM=$(( NUM + 1 ))
 done
 dialog --no-collapse --no-cancel --default-item "5" --menu "Please choose the size you would like for the personal save file.\nNote, 512M is good choice, or highest if that not available.\nSelect choice, then press ENTER key..." 0 0 0 $SIZELIST >/dev/console 2>/tmp/sizetag.txt
 NUM=`cat /tmp/sizetag.txt`
 aCHOICE=`echo -n "$CHOICES" | cut -f $NUM -d ' '`
 #return $ACHOICE
 SIZEPFILE=$aCHOICE #global variable.
} # end of choosesizefunc()

pupsavefunc(){
 #v2.02 ntfs uses /dev/fuse so '/dev/$SAVEPART' no good for grep...
 SMNTPT="`mount | grep "/dev/$SAVEPART" | tr -s " " | cut -f 3 -d " "`"
 #[ "$SMNTPT" = "" ] && SMNTPT="`mount | grep "/mnt/$SAVEPART" | tr -s " " | cut -f 3 -d " "`"
 [ "$SMNTPT" = "" ] && SMNTPT="`/bin/ps -e | grep -o 'ntfs\-3g.*' | grep "/dev/$SAVEPART" | tr '\t' ' ' | tr -s ' ' | tr ' ' "\n" | grep '^/mnt/'`"

 if [ "$SMNTPT" = "" ];then
  mkdir $VERB -p /mnt/$SAVEPART #2>>$ERR #/tmp/savepup
  mount $VERB $VERB -t $SAVEFS /dev/$SAVEPART /mnt/$SAVEPART #/tmp/savepup
  SMNTPT="/mnt/$SAVEPART" #"/tmp/savepup"
 fi

 #100401 choose f.s. of save-file... 100410 for now, leave out ext4, doesn't work...
 dialog --no-cancel --title "Choose filesystem of save-file" --menu "Previously, Puppy has only used 'ext2', now there is a choice. Regarding power-failure, note that Puppy will do a f.s. check at next boot so ext2 can recover, however journalled filesystems can recover even without a f.s. check. If in doubt, just press ENTER to choose 'ext2', otherwise key down then ENTER..." 0 0 0 ext2 "Maximum storage space" ext3 "Journalled f.s., safest if power failure etc." ext4 "Journalled f.s., safest if power failure etc."  >/dev/console 2>/tmp/rc.shutdown_pupsave_fs
 #dialog --no-cancel --title "Choose filesystem of save-file" --menu "Previously, Puppy has only used 'ext2', now there is a choice. Regarding power-failure, note that Puppy will do a f.s. check at next boot so ext2 can recover, however journalled filesystems can recover even without a f.s. check. If in doubt, just press ENTER to choose 'ext2', otherwise TAB down then ENTER..." 0 0 0 ext2 "Maximum storage space, encrypted save-file must use ext2" ext3 "Journalled f.s., safest if power failure etc."  >/dev/console 2>/tmp/rc.shutdown_pupsave_fs
 SFFS="`cat /tmp/rc.shutdown_pupsave_fs`"
 [ "$SFFS" = "" ] && SFFS='ext2'
 SFEXTNUM="`echo -n "$SFFS" | cut -c 4`"
 SFEXT="${SFEXTNUM}fs" #ex: 2fs
 sfPATTERN="s%[234]fs$%${SFEXTNUM}fs%"
 SAVEFILE="`echo -n "$SAVEFILE" | sed -e "$sfPATTERN"`"
 PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"

 NAMEONLY="`basename $SAVEFILE`"

 #v2.21 customise the name of the ${DISTRO_FILE_PREFIX}save file...
 MYUSERNAME="`dialog --stdout --nocancel --inputbox "Would you like to customise the name
of the '${DISTRO_FILE_PREFIX}save.${SFEXT}' file?
This is optional, but it is convenient
if you have lots of '${DISTRO_FILE_PREFIX}save' files
and you want to choose the right one
at startup. For example, if you enter
'john' here, the file will become
'${DISTRO_FILE_PREFIX}save-john.${SFEXT}'.
Type any characters you wish,
then press ENTER key:" 0 0 ""`"
 if [ "$MYUSERNAME" != "" ];then
  MYUSERNAME="`echo -n "$MYUSERNAME" | tr ' ' '_' | tr '-' '_' | sed -e 's/[^a-zA-Z0-9_]//g'`"
  NAMEONLY="${DISTRO_FILE_PREFIX}save-${MYUSERNAME}.${SFEXT}"
  SAVEFILE="$PSUBDIR/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 fi

 CRYPTO=""
 dialog --extra-button --ok-label "NORMAL (no encryp.)" --cancel-label "Heavy encrypted" --extra-label "Light encrypted" --yesno "Do you want to encrypt the $NAMEONLY file?
If the '${DISTRO_FILE_PREFIX}save' is encrypted, then a password will have to be entered
at every bootup. The reason for doing this is security, as noone else
will be able to see what is inside the ${DISTRO_FILE_PREFIX}save. Encryption does slow
${DISTRO_NAME} down slightly, the 'heavy' encryption the most. Two scenarios:

1. If the ${DISTRO_FILE_PREFIX}save file is on a Flash drive, encryption is protection
   in case the drive is mislaid. Heavy encryption is recommended, as
   ${DISTRO_NAME} minimises writes to the save file (to prolong life of the
   Flash drive, but this also minimises encryption slowdown).
2. If the ${DISTRO_FILE_PREFIX}save file is on a hard drive, 'light' encryption is
   recommended to minimise slowdown, particularly on older PCs.

Encrypted ${DISTRO_FILE_PREFIX}save files have another advantage, they allow multiple
users. Recommended if spouse and kids are going to be using the same
${DISTRO_NAME} installation.

Unless you have a good reason to use encryption, it is recommended not
to, to avoid the overhead. Recommend choose <NORMAL>..." 0 0 >/dev/console
 RETVAL=$?
 if [ $RETVAL -eq 1 -o $RETVAL -eq 3 ];then
  while [ 1 ];do
  MYPASSWORD="`dialog --stdout --insecure --nocancel --passwordbox "Please choose a password.
This must be remembered and
entered at every bootup." 0 0`"
   [ "$MYPASSWORD" ] && break
  done
  modprobe $VERB cryptoloop
  if [ $RETVAL -eq 1 ];then
   DENSITY="a" #heavy aes encryption
   CRYPTO='-e aes'
   modprobe $VERB aes_generic #v407 aes name change.
   #v407 did not explicitly load these two before, but do so in init script...
   modprobe $VERB crypto_blkcipher #v407 blkcipher name change.
   modprobe $VERB cbc
  else
   DENSITY="x" #light xor encryption.
   CRYPTO='-E 1' #v2.16final '-e xor' --bug, loads xor.ko which is something else.
  fi
  if [ "$MYUSERNAME" != "" ];then
   NAMEONLY="${DISTRO_FILE_PREFIX}save_crypt${DENSITY}-${MYUSERNAME}.${SFEXT}"
  else
   NAMEONLY="${DISTRO_FILE_PREFIX}save_crypt${DENSITY}.${SFEXT}"
  fi
  SAVEFILE="$PSUBDIR/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 fi
 MNAMEONLY="`basename $SAVEFILE .${SFEXT}`"

 #fitzhugh found this problem...
 #v2.10 Dougal provided code to save with different name...
 if [ -f $SMNTPT$SAVEFILE ]; then
  dialog --yes-label "SAVE" --yesno "
There already exists a ${NAMEONLY} file on the partition you
chose. To create another one, with a slightly different name
(such as ${MNAMEONLY}-1.${SFEXT}), select <SAVE>...
To quit without saving, select <No>..." 0 0 >/dev/console
  [ ! $? -eq 0 ] && return 1
  local BLA=1 #; local SFFIX=`echo "$SAVEFILE" | tail -c 5`
  while [ -f $SMNTPT$SAVEFILE ]; do
   SAVEFILE="$PSUBDIR/${MNAMEONLY}-${BLA}.${SFEXT}"
   BLA=$(( BLA + 1 ))
  done
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  NAMEONLY="`basename $SAVEFILE`"
 fi

 #we should check to see that there is enough space on the partition...
 PARTFREE=`/bin/df | grep "$SMNTPT" | tr -s " " | head -n 1 | cut -f 4 -d " "`
 [ ! $PARTFREE ] && PARTFREE=0
 [ $PARTFREE -lt 32768 ] && PARTFREE=$(( PARTFREE - 1024 )) #leave some slack space.
 [ $PARTFREE -gt 32768 ] && PARTFREE=$(( PARTFREE - 8192 )) #leave some slack space.
 SIZEPFILE=524288 #512M = 524288K
 [ $SIZEPFILE -gt  $PARTFREE ] && SIZEPFILE=$PARTFREE
 #v2.02 dougal has code to choose size of save file...
 [ $PARTFREE -gt 32768 ] && choosesizefunc $PARTFREE #sets SIZEPFILE
 if [ "`echo -n $SAVEFILE | grep '\.[34]fs$'`" != "" ];then #ext3 f.s. needs minimum size.
  [ $SIZEPFILE -lt 5000 ] && return 1 #precaution. rerwin discovered this.
 fi

 #v2.20
 SAVEPATH="`dirname $SAVEFILE`"
 if [ ! -d ${SMNTPT}${SAVEPATH} ];then
  SAVEFILE="/$NAMEONLY"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  SAVEPATH="/"
 fi

 #v2.02,v2.13 final sanity check...
 AAAMB=$((SIZEPFILE / 1024))
 while [ 1 ];do
  dialog --colors --no-collapse --extra-button --ok-label "YES, SAVE"  --extra-label "CHANGE FOLDER" --cancel-label "DO NOT SAVE" --yesno "\Z1FINAL SANITY CHECK:
 Partition you are saving to:      $SAVEPART
 The filesystem of $SAVEPART partition: $SAVEFS
 Name of the save file:            $NAMEONLY
 Path (folder) of the save file:   $SAVEPATH
 Size of save file:                ${SIZEPFILE}KB (${AAAMB}MB)
 Filesystem inside save file:      $SFFS

 If they definitely look right, choose <YES, SAVE>...
 Looks ok, but you want to change the folder, <CHANGE FOLDER>...
 If anything looks wrong, choose <DO NOT SAVE>...\Zn" 0 0 >/dev/console
  SANITYRET=$?
  [ $SANITYRET -ne 0 -a $SANITYRET -ne 3 ] && return 1
  [ $SANITYRET -eq 0 ] && break
  if [ $SANITYRET -eq 3 ];then #change folder.
   NEWSAVEPATH="`dialog --stdout --no-cancel --inputbox "Edit path. '/' means top-level of partition. You are only allowed to save one-deep, for example: '/puppy300'. If folder does not exist, it will be created. Spaces are not allowed. If uncertain, just press the ENTER key." 0 0 "$SAVEPATH"`"
   [ "$NEWSAVEPATH" = "" ] && NEWSAVEPATH="$SAVEPATH"
   [ "`echo -n "$NEWSAVEPATH" | cut -b 1`" != "/" ] && NEWSAVEPATH="/${NEWSAVEPATH}"
   [ "$NEWSAVEPATH" != "/" ] && NEWSAVEPATH="`echo -n "$NEWSAVEPATH" | sed -e 's%/$%%'`"
   NEWSAVEPATH="`echo -n "$NEWSAVEPATH" | sed -e 's/ //g'`"
   SAVEPATH="$NEWSAVEPATH"
   SAVEPATHs="$SAVEPATH"
   [ "$SAVEPATH" != "/" ] && SAVEPATHs="${SAVEPATH}/"
   SAVEFILE="${SAVEPATHs}${NAMEONLY}"
   PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  fi
 done
 [ -f ${SMNTPT}${SAVEPATH} ] && return 1 #abort. must be a directory.
 [ ! -d ${SMNTPT}${SAVEPATH} ] && mkdir $VERB ${SMNTPT}${SAVEPATH}
 [ ! -d ${SMNTPT}${SAVEPATH} ] && return 1 #some kind of error, abort.

 #JOPT=""
 [ "$SAVEPART" = "fd0" ] && SIZEPFILE=`expr $SIZEPFILE - 16`
 #[ "$SFEXT" = "3fs" ] && JOPT='-j'
 echo "Creating $NAMEONLY in /dev/$SAVEPART, please wait awhile..." >/dev/console
 dd if=/dev/zero of=${SMNTPT}$SAVEFILE bs=1k count=$SIZEPFILE
 [ "$FORCE" ] || _sync
 if [ "$CRYPTO" != "" ];then
  #note: loop2 is kept available for scripts to use. but, find which is free...
  DEVLOOP="`losetup-FULL -f`"
  [ "$DEVLOOP" = "" ] && return 1
  #'-p 0' means read password from stdin...
  #v2.17 crap, '-p 0' works for aes, not for xor encryption....
  if [ "$CRYPTO" = '-E 1' ];then #light xor encr.
   echo "Note, a bug in one of the Linux utility programs requires you to reenter" >/dev/console
   echo "the password in the case of light encryption..." >/dev/console
  fi
  echo "$MYPASSWORD" | losetup-FULL -p 0 $CRYPTO $DEVLOOP ${SMNTPT}$SAVEFILE >/dev/console
  [ ! $? -eq 0 ] && return 1
 fi
 echo "Creating a $SFFS filesystem in $NAMEONLY..." >/dev/console
  case $SFFS in
   ext2) mkfs.ext2 $Q -m 0 -F ${SMNTPT}$SAVEFILE ;;
   ext3) mkfs.ext3 $Q -m 0 -F ${SMNTPT}$SAVEFILE ;;
   ext4) mkfs.ext4 $Q -m 0 -F ${SMNTPT}$SAVEFILE ;;
  esac
  [ "$FORCE" ] || _sync
  losetup -d $DEVLOOP
## fi ##-2011-11-06
 [ "$FORCE" ] || _sync
 return 0
} #end pupsavefunc

choosepartfunc(){
 #dialog to choose what partition to create ${DISTRO_FILE_PREFIX}save.2fs on...
 [ ! "$PMEDIA" ]      && PCHOOSE="yes"
 [ "$PMEDIA" = "cd" ]  && PCHOOSE="yes"
 [ "$PMEDIA" = "scsicd" ] && PCHOOSE="yes"
 [ "$PMEDIA" = "satacd" ] && PCHOOSE="yes"
 [ "$PMEDIA" = "idecd" ]  && PCHOOSE="yes"
 [ "$PMEDIA" = "atacd" ]  && PCHOOSE="yes" #v3.97
 [ "$PMEDIA" = "usbcd" ]  && PCHOOSE="yes"
 [ "$DEV1FS" = "ntfs" ]  && PCHOOSE="yes"
 [ "$DEV1FS" = "msdos" ] && DEV1FS="vfat" #v2.14
 [ "$DEV1FS" = "xxx" ]  && PCHOOSE="yes" #v2.16.1
 if [ "$PSAVEMARK" != "" ];then #v3.97 see /etc/rc.d/PUPSTATE
  devnameonly="`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`"
  SAVEPART="${devnameonly}${PSAVEMARK}" #partition that will-have ${DISTRO_FILE_PREFIX}save.
  spPATTERN='/dev/'"$SAVEPART"'|'
  SAVEFS="`probepart -m | grep "$spPATTERN" | cut -f 2 -d '|'`"
  SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs"
  PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
  return 0
 fi
 if [ "$PCHOOSE" != "yes" ];then
  SAVEFS="$DEV1FS"
  SAVEPART="$PDEV1"
  SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs" #v2.13 was .3fs
  PUPSAVE="$PDEV1,$DEV1FS,$SAVEFILE" #v2.13 was .3fs
  return 0
 fi
 if [ ! "`lsmod | grep '^usb'`" = "" ];then
  FDMSG1="NOTE: cannot save to floppy disk on this PC, USB allowed."
 else
  FDMSG1="NOTE: no USB interface this PC, but can save to floppy disk."
 fi
 dialog --colors --msgbox "\Z1WARNING: If you want to create a save-file (${DISTRO_FILE_PREFIX}save.2fs) in a NTFS
partition (Windows XP), it is strongly recommended that you defragment
the partition first. Press ESC key to abort this save, start Windows
and choose Start->All Programs->Accessories->System Tools->Defragment.\Zn

\Z5Make sure any required USB, floppy, etc. is PLUGGED IN NOW!
$FDMSG1\Zn
Press ENTER key to continue..." 0 0 >/dev/console
 [ ! $? -eq 0 ] && return 1 #v2.02 abort.
 #v2.14 change msdos to vfat... v431 add ext4...
 PARTSLIST="`probepart -m 2> /dev/null | grep '^/dev/' | grep -E 'ext[2-4]|reiserfs|msdos|vfat|minix|ntfs' | cut -f 1-3 -d '|' | sed -e 's/msdos/vfat/g'`"

 #only support save session to floppy if pc is non-usb...
 if [ "`lsmod | grep '^usb_storage'`" = "" ];then #k2.6 note the underscore.
  #problem using dmesg here as it is a fifo buffer, stuff at bootup gets deleted
  #while puppy is being used, prior to shutdown... so, use /var/log/messages...
  if [ "`cat /var/log/messages | grep "Floppy drive" | grep "fd0"`" != "" ];then
   if [ "`disktype /dev/fd0 | grep 'file system' | grep '^FAT'`" != "" ];then
    if [ "$PARTSLIST" = "" ];then
     PARTSLIST="/dev/fd0|vfat|1.4" #v2.14 change msdos to vfat.
    else #v2.14 ditto...
     PARTSLIST="${PARTSLIST}
/dev/fd0|vfat|1.4"
    fi
   fi
  fi
 fi

 #v2.02 nothing to save to...
 if [ "$PARTSLIST" = "" ];then
  #clear
  echo "No suitable partitions to save to." >/dev/console
  sleep 5
  return 1
 fi

 SCHOICES=""
 rm $VERB -f /tmp/schoices.txt
 DEFTAG=""
 echo "$PARTSLIST" |
 while read APART
 do
   ATAG="`echo -n "$APART" | cut -f 1 -d '|' | cut -f 3 -d '/'`"
    AFS="`echo -n "$APART" | cut -f 2 -d '|'`"
  ASIZE="`echo -n "$APART" | cut -f 3 -d '|'`"

  AFREE="`/bin/df -m /dev/$ATAG | tail -n1 | tr -s " " | cut -f 4 -d " "`"
  if [ ! "$AFREE" ];then
   mount $VERB $VERB -t $AFS /dev/$ATAG /mnt/data >$OUT 2>$ERR
   #v2.10 need to put in a check that it is not mounted ro. the
   #mount script will fallback to ro for ntfs if rw mnt fails...
   RETMNTVAL=$?
   if [ $RETMNTVAL -eq 0 ];then
    if [ "`mount | grep '(rw' | grep '/mnt/data'`" = "" ];then
     umount $VERB $VERB /mnt/data
     RETMNTVAL=1
    else
     #v2.12 if the ntfs rw mount was forced (see /bin/mount script) it is unwise to use...
     ERRMSG1=""
     [ -s /tmp/ntfsmnterr.txt ] && ERRMSG1="`cat /tmp/ntfsmnterr.txt | grep 'Dirty volume mount'`"
     if [ "$ERRMSG1" != "" ];then
      dialog --colors --msgbox "\Z1WARNING:
The ntfs-3g driver has determined that the NTFS filesystem
in partition /dev/$ATAG is 'dirty'. It will display in the
next dialog box in the list of partitions to save to, but
it is recommended that you do not use it. Instead, you should
first run Windows -- most often this problem is due to Windows
not being shut down properly the last time it was used, leaving
the filesystem in a 'dirty' state.
\Zn
Press ENTER key to continue..." 0 0 >/dev/console
     fi
    fi
   fi
   [ -f /tmp/ntfsmnterr.txt ] && rm $VERB -f /tmp/ntfsmnterr.txt
   if [ $RETMNTVAL -eq 0 ];then
    if [ "$ATAG" = "fd0" ];then
     FFREE=`/bin/df -k | grep "/dev/$ATAG" | tr -s " " | cut -f 4 -d " "`
     AFREE="`dc $FFREE 1000 \/ p`"
    else
     #v2.02 for ntfs cannot use /dev/$ATAG, use mnt point in grep...
     AFREE="`/bin/df -m | grep "/mnt/data" | tr -s " " | cut -f 4 -d " "`"
    fi
    #umount /dev/$ATAG  v2.02 must use mnt point for ntfs...
    umount $VERB $VERB /mnt/data
   fi
  fi
  [ "$ATAG" = "$PDEV1" ] && DEFTAG=" --default-item $ATAG" #v2.13
  [ ! "$AFREE" = "0" ] && echo "${ATAG} \"Filesystem: $AFS  Size: ${ASIZE}M  Free: ${AFREE}M\" \\" >> /tmp/schoices.txt
 done

 SCHOICES="`cat /tmp/schoices.txt 2>/dev/null`"
 if [ "$SCHOICES" = "" ];then
  #clear
  echo "No suitable partitions to save to." >/dev/console
  sleep 5
  return 1
 fi

 echo '#!/bin/sh' > /tmp/savedlg
 echo -n 'dialog --no-collapse --no-cancel ${DEFTAG} --menu "Please choose a partition to create a pup_save.2fs file on.
It can be any of the partitions listed. It is recommended that you
choose a partition with over 512M free, but Puppy can create a
smaller save file if there is less space. The file will contain a
Linux ext2 filesystem.

Note, next time Puppy boots, this file, with all saved personal data,
will be automatically loaded.

UP/DOWN ARROW keys to highlight desired choice, then press ENTER key..." 0 0 0 ' >> /tmp/savedlg
 echo "$SCHOICES"  >> /tmp/savedlg
 echo ' 2>/tmp/tag.txt' >> /tmp/savedlg
 chmod 755 /tmp/savedlg

 #seems some people have problem, do not select anything...
 while :;do
  /tmp/savedlg >/dev/console
  SAVEPART="`cat /tmp/tag.txt | head -n 1`" #head is in case of errs in output.
  if [ "`echo -n "$SAVEPART" | grep -E '^hd|^sd|^sc|^fd|^mmcblk'`" = "" ];then #091222 added mmcblk
   dialog --colors --msgbox "\Zb\Z1ERROR: you did not choose any partition.
   Press ENTER key to try again...
   Press ESC key to $SHUT_HOW2 without saving...\Zn" 0 0 >/dev/console
   [ ! $? -eq 0 ] && return 1 #v2.02 abort.
   continue
  fi
  break
 done

 SAVEFS="`echo "$SCHOICES" | grep "^${SAVEPART} " | tr -s " " | cut -f 2 -d ':' | cut -f 2 -d " "`"
 SAVEFILE="$PSUBDIR/${DISTRO_FILE_PREFIX}save.2fs"  #v2.13 was .3fs
 [ "$SAVEPART" = "fd0" ] && SAVEFILE="/${DISTRO_FILE_PREFIX}save.2fs"
 PUPSAVE="$SAVEPART,$SAVEFS,$SAVEFILE"
 return 0
} #end choosepartfunc

#v2.0.0 there could be a save tmpfs->persistent-storage running...
while [ "`pidof snapmergepuppy`" ];do
 sleep 1
done
killall savepuppyd 2>>$ERR

##rc.local0 can read this...
#setvol 0 | tr "\n" " " > /etc/.mixervolume
##v2.10 instead, probably do it this way...
#/usr/sbin/alsactl store
#v4.00 ...yes, using 'alsactl restore' in rc.sysinit (fast boot) and rc.local0.
#v411 run rc.alsa as it also unloads modules (if not done, prevents shutdown some systems)...
#/etc/rc.d/rc.alsa stop

cd /

[ "$FORCE" ] || _sync

_kill_xapps(){
pidof X >>$OUT && {
 # REM: Should be handled by wmreboot/wmpoweroff,
 #      just a precaution...
 echo -e "\\033[0;31mKilling X and all X apps...\\033[0;39m"  ##DEBUG
 killall $Q -9 X >>$OUT 2>&1
 sleep 1
 killall $Q -3 X >>$OUT 2>&1
}

test "`which dillo`" && {
#MU warns may need to do this for dillo...
 killall $Q file.dpi      2>>$ERR
 killall $Q bookmarks.dpi 2>>$ERR
 killall $Q dpid          2>>$ERR
 }
}

[ "$FORCE" ] || _kill_xapps

[ "$FORCE" ] || _sync
[ "$FORCE" ] || {
#100814 log the cumulative bytes transmitted on network...
# (see also /etc/rc.d/rc.sysinit and network_tray)
mkdir $VERB -p /var/local/sns
UPDATE_MONTH="`LC_ALL=C date +%b`"
CURRENT_MONTH="`cat /var/local/sns/current_month`"
[ ! "$CURRENT_MONTH" ] && CURRENT_MONTH=0
if [ "$UPDATE_MONTH" != "$CURRENT_MONTH" ];then
 echo "$UPDATE_MONTH" > /var/local/sns/current_month
 for oneCOUNT in sns/r sns/t pupdial/isp1/r pupdial/isp1/t pupdial/isp2/r pupdial/isp2/t ppp0/r ppp0/t;do
  echo 0 > /var/local/${oneCOUNT}x_bytes_month
 done
fi

ACTIVE_INTERFACE="ppp0"
#mkdir $VERB -p /var/local/sns
[ -f /tmp/sns_interface_success ] && ACTIVE_INTERFACE="`cat /tmp/sns_interface_success`" #SNS
[ ! "$ACTIVE_INTERFACE" ] && ACTIVE_INTERFACE="`ifconfig | grep '^[a-z]' | grep -v '^lo' | grep 'Link encap:Ethernet' | cut -f 1 -d ' ' | head -n 1`"
if [ "$ACTIVE_INTERFACE" ];then
 mkdir $VERB -p /var/local/$ACTIVE_INTERFACE
 if [ -d /sys/class/net/${ACTIVE_INTERFACE}/statistics ];then
  read RX_BYTES </sys/class/net/${ACTIVE_INTERFACE}/statistics/rx_bytes
  read TX_BYTES </sys/class/net/${ACTIVE_INTERFACE}/statistics/tx_bytes
  echo "$RX_BYTES" > /var/local/$ACTIVE_INTERFACE/rx_bytes_session
  echo "$TX_BYTES" > /var/local/$ACTIVE_INTERFACE/tx_bytes_session
  read RX_BYTES_MONTH </var/local/$ACTIVE_INTERFACE/rx_bytes_month
  [ "$RX_BYTES_MONTH" ] || RX_BYTES_MONTH=0
  RX_BYTES_MONTH=$((RX_BYTES_MONTH + RX_BYTES))
  echo "$RX_BYTES_MONTH" > /var/local/$ACTIVE_INTERFACE/rx_bytes_month
  read TX_BYTES_MONTH </var/local/$ACTIVE_INTERFACE/tx_bytes_month
  [ "$TX_BYTES_MONTH" ] || TX_BYTES_MONTH=0
  TX_BYTES_MONTH=$((TX_BYTES_MONTH + TX_BYTES))
  echo "$TX_BYTES_MONTH" > /var/local/$ACTIVE_INTERFACE/tx_bytes_month
 fi
fi
}

[ "$FORCE" ] || {
#v2.16 some packages have a service script that requires stopping...
#for service_script in /etc/init.d/*
for service_script in `ls -1v /etc/init.d/* | sort -r`
do
  [ -f "$service_script" ] || continue
  [ -x $service_script ] && {
   $service_script stop &
   sleep 1; }
done
#note, /etc/rc.d/rc.services does same, with 'start' parameter.
}

#100301 brought down below call to 'stop' service scripts, needed for lamesmbxplorer.
#bring down network interfaces (prevents shutdown sometimes)...
[ "`pidof wpa_supplicant`" != "" ] && wpa_cli terminate #100309 kills any running wpa_supplicant.
if [ "`grep 'net-setup.sh' /usr/local/bin/defaultconnect`" = "" ];then #see connectwizard and connectwizard_2nd.
 for oneNETIF in `ifconfig | grep -E '^wifi[0-9]|^wlan[0-9]|^eth[0-9]' | cut -f 1 -d ' ' | tr '\n' ' '`
 do
  ifconfig $oneNETIF down 2>>$ERR
  [ "`iwconfig | grep "^${oneNETIF}" | grep "ESSID"`" != "" ] && iwconfig $oneNETIF essid off #100309
  dhcpcd --release $oneNETIF 2>>$ERR #100309
 done
else
 /etc/rc.d/rc.network stop
fi

_shutdown_ath(){
## quick hack, maybe shutdown problem if ath_pci left loaded...
[ "`lsmod | grep '^ath_pci'`" != "" ] && rmmod ath_pci
}

_unload_ethernet_drivers(){
#100604 reported by shel: http://murga-linux.com/puppy/viewtopic.php?t=56238
# Unload the Ethernet drivers on shutdown to prevent battery drain.
if test -f /etc/networkmodules ; then #KRG
for i in `lsmod | cut -d' ' -f1 | tr '\n' ' '`
do
 if grep $Q "^$i " /etc/networkmodules; then
  modprobe $VERB -r "$i"
 fi
done
fi
}

_shutdown_pcmcia(){
#v3.97 deprecated, for pcmcia-cs package...
if [ -f /sbin/cardmgr ];then #pcmcia-cs package installed.
 if [ "`lsmod | grep -E '^i82092|^tcic|^i82365|^yenta_socket'`" != "" ];then
  #got this out of rc.pcmcia, modified...
  echo -n "Shutting down PCMCIA services: "
  if [ -s /var/run/cardmgr.pid ] ; then
   PID=`cat /var/run/cardmgr.pid`
   kill $PID
   for N in 1 2 3 4 ; do
    kill -0 $PID 2>>$ERR || break #-0 is test only.
    sleep 1
   done
  fi
  if [ -s /var/lib/pcmcia/cardmgr.pid ] ; then
   PID=`cat /var/lib/pcmcia/cardmgr.pid`
   kill $PID
   for N in 1 2 3 4 ; do
    kill -0 $PID 2>>$ERR || break #-0 is test only.
    sleep 1
   done
  fi
  killall -3 "CardBus Watcher" #BK bug, changed -q to -3.
  /sbin/rmmod tcic 2>>$ERR || /sbin/rmmod i82365 2>>$ERR || /sbin/rmmod yenta_socket 2>>$ERR || /sbin/rmmod i82092 2>>$ERR
  echo "done."
  rm $VERB -f /var/lock/subsys/pcmcia
 fi
fi
}
_shutdown_pcmcia

pidof pup_event_backend_modprobe_protect >>$OUT && pup_event_backend_modprobe_protect --stop & ##2012-06-22
killall $Q acpid >>$OUT 2>&1   ##2012-06-22
killall $Q udevd >>$OUT 2>&1   #100615
killall $Q klogd >>$OUT 2>&1   ##+++2011-11-27
killall $Q syslogd >>$OUT 2>&1 ##+++2011-11-27


#first time booted puppy, there may not have been any persistent storage.
if [ $PUPMODE -eq 5 ];then #ifpupmode5
 #v2.16.1 pxe boot, humongous initrd, have PDEV1='' DEV1FS=''...

 #3.97...
 xDEVFS="$DEV1FS"
 xPDEV="$PDEV1"
 if [ "$PSAVEMARK" != "" -a "$PDEV1" != "" ];then #v3.97 see /etc/rc.d/PUPSTATE
  devnameonly="`echo -n "$PDEV1" | sed -e 's/[0-9]*$//'`"
  SAVEPART="${devnameonly}${PSAVEMARK}" #partition that will-have ${DISTRO_FILE_PREFIX}save.
  spPATTERN='/dev/'"$SAVEPART"'|'
  SAVEFS="`probepart -m | grep "$spPATTERN" | cut -f 2 -d '|'`"
  xDEVFS="$SAVEFS"
  xPDEV="$SAVEPART"
 fi

 [ ! "$DEV1FS" ] && DEV1FS='xxx' #this will enable choice of create a save-file.
  #if it is a linux partition, can offer to save to PDEV1 or create a ${DISTRO_FILE_PREFIX}save.2fs file...
  #if vfat, create a ${DISTRO_FILE_PREFIX}save.2fs file...
  if [ "`echo -n "$xDEVFS" | grep -E "ext[2-4]|reiserfs|minix"`" != "" ];then #v431

   #100719 do not allow save to entire partition if pup installed in a subdirectory...
   xPSUBDIR="`echo -n "$PUPSFS" | cut -f 3 -d ',' | sed -e 's%/[^/]*$%%'`" #ex: sda3,ext2,/pup220/spup-040.sfs will return /pup220
   SAVECHOICE=1
   if [ "$xPSUBDIR" = "" ];then
    dialog --timeout 60 --extra-button --ok-label "SAVE TO A FILE"  --extra-label "SAVE TO ${xPDEV}" --cancel-label "DO NOT SAVE" --yesno "You can now choose to save the personal session files to a file, named ${DISTRO_FILE_PREFIX}save.2fs. Or, if ${xPDEV} partition is not being used by anything else (no other operating system) then you can choose to save the session files direct to the partition. Either way, your choice will be remembered at next bootup.

Which to choose? Partition: you immediately get the entire partition available for saving. File: having everything in a single file is convenient for archiving, but the file cannot be made bigger than 4GB (even if partition has more free space). If in doubt, just press ENTER to accept the default.

Select <SAVE TO A FILE> (just press ENTER key) to create a ${DISTRO_FILE_PREFIX}save.2fs file, select <SAVE TO ${PDEV1}> (TAB then ENTER) to save direct to partition, or <DO NOT SAVE> to $SHUT_HOW2 without saving session...
Or, wait 60 seconds to $SHUT_HOW2 without saving session..." 0 0 >/dev/console
    SAVECHOICE=$?
   else #100719
    dialog --timeout 60 --ok-label "SAVE TO A FILE" --cancel-label "DO NOT SAVE" --yesno "You can now choose to save the personal session files to a file, named ${DISTRO_FILE_PREFIX}save.2fs. Your choice will be remembered at next bootup.

NOTE: You cannot choose to save the session to the entire partition ${xPDEV}, as Puppy is installed into a sub-directory ${xPSUBDIR}. If Puppy had been installed at '/', not in a folder, then you would have the option of saving the session to the entire partition (assuming that the partition does not have any other distro installed in it) which has the advantage of all the free space in the partition available for your session files.

Select <SAVE TO A FILE> (just press ENTER key) to create a ${DISTRO_FILE_PREFIX}save.2fs file, or press TAB key then ENTER to $SHUT_HOW2 without saving session...
Or, wait 60 seconds to $SHUT_HOW2 without saving session..." 0 0 >/dev/console
    SAVECHOICE=$?
   fi
   if [ "$SAVECHOICE" = "0" ];then
    choosepartfunc && pupsavefunc && PUPMODE=128 #v2.02 128=yes, save it.
   else
    #dialog --yes-label "SAVE_TO_${PDEV1}" --no-label "QUIT" --yesno "Press ENTER key to save session files direct to $PDEV1 partition, else press TAB then ENTER to not save session..." 0 0
    #[ $? -eq 0 ] && PUPMODE=32
    [ "$SAVECHOICE" = "3" ] && PUPMODE=32 #v2.13 3=save to partition.
   fi
  fi
  #handle other f.s. types...
  case $xDEVFS in
   vfat|msdos|ntfs|xxx) #v2.02 ntfs allowed. v2.16.1
    dialog --timeout 60 --yes-label "SAVE" --yesno "You can save the session (all of your personal data and settings) to a file, named ${DISTRO_FILE_PREFIX}save.2fs (that has a ext2 filesystem inside it). Note, your answer to this question will be remembered at next boot.

Do you want to create a ${DISTRO_FILE_PREFIX}save.2fs file?

Select <SAVE> (just press ENTER key) to create ${DISTRO_FILE_PREFIX}save.2fs and save to it, or select <No> (TAB then ENTER) to not save session...
Or, wait 60 seconds to $SHUT_HOW2 without saving session..." 0 0 >/dev/console
    SAVECHOICE=$?
    if [ "$SAVECHOICE" = "0" ];then
     choosepartfunc && pupsavefunc && PUPMODE=128 #v2.02 128=yes, save it.
    fi
    ;;
#   ntfs) #v2.02 see above case.
#    dialog --yes-label "SAVE" --yesno "Partition $PDEV1 that ${DISTRO_NAME} booted off, is a ntfs filesystem, and ${DISTRO_NAME} can only save a session to it if there is a pre-existing ${DISTRO_FILE_PREFIX}save.3fs file. Alternatively, you can save to a different partition, including USB Flash drive, Zip drive, floppy disk, or any non-ntfs hard drive partition.
#
#Do you want to create a ${DISTRO_FILE_PREFIX}save.3fs file on a non-NTFS partition?
#
#Select <SAVE> (just press ENTER key) to chose where to save the session, else select <No> (TAB then ENTER) to not save session..." 0 0
#    SAVECHOICE=$?
#    if [ "$SAVECHOICE" = "0" ];then
#     choosepartfunc && pupsavefunc && PUPMODE=128 #v2.02 yes, save it.
#    fi
#    ;;
   iso9660) #100107 added timeout...
    dialog --timeout 60 --extra-button --ok-label "SAVE TO FILE"  --extra-label "SAVE TO CD" --cancel-label "DO NOT SAVE" --yesno "You have booted off a live-CD or DVD, and you can now save your personal settings and files to a USB Flash drive, Zip drive, floppy disk, or any hard drive partition (including NTFS). The session will be saved as a single file, named ${DISTRO_FILE_PREFIX}save.2fs, which has a ext2 filesystem inside it.

However, if you have burnt the CD/DVD as multisession (not closed), then sessions can be saved as additional tracks to the CD/DVD -- each saved session will appear on the CD/DVD as a directory with all the saved files in it, not as a single file. THIS IS STILL EXPERIMENTAL

Select <SAVE TO FILE> (just press ENTER key) to choose a partition to save the session as file ${DISTRO_FILE_PREFIX}save.2fs...
Select <SAVE TO CD> (TAB then ENTER) to save session to CD/DVD (multisession) (EXPERIMENTAL)...
Select <DO NOT SAVE> to $SHUT_HOW2 without saving session...
Or, wait 60 seconds to $SHUT_HOW2 without saving session..." 0 0 >/dev/console
    SAVECHOICE=$?
    if [ "$SAVECHOICE" = "0" ];then
     choosepartfunc && pupsavefunc && PUPMODE=128 #v2.02 yes, save it.
    else
     #dialog --no-label "NO_SAVE" --yes-label "SAVE_TO_CD" --yesno "Press ENTER key to save session back to multisession CD/DVD (the iso must have been burnt to CD/DVD in multisession mode), else press TAB then ENTER keys to shut down without saving session..." 0 0
     if [ "$SAVECHOICE" = "3" ];then #v2.13 3=save session to cd.
      PUPMODE=77
      SAVEPART="$PDEV1"
     else
      echo "$SHUT_HOW without saving..." >/dev/console
     fi
    fi
    ;;
  esac
fi #end ifpupmode5

#w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
#note, rc.sysinit in puppy 3.01 had code to create a pupswap.swp, not in 4.x series.
swapfile_func() {
 localSMNTPT="$1"
 localSAVEPART="$2"
 [ -f ${localSMNTPT}/pupswap.swp ] && return
 [ "$FASTPARTS" ] || return #see /etc/rc.d/PUPSTATE
   TOTALRAM=`free | grep -o 'Mem:.*' | tr -s ' ' | cut -f 3 -d ' '`
   if [ $TOTALRAM -lt 262145 ];then #was 128000, bump up <=256MB.
    TOTALSWAP=`free | grep -o 'Swap:.*' | tr -s ' ' | cut -f 3 -d ' '`
    if [ $TOTALSWAP -eq 0 ];then
     spPATTERN="$localSAVEPART"'|'
     if [ "`echo "$FASTPARTS" | grep "$spPATTERN"`" != "" ];then
      #smPATTERN=' '"$localSMNTPT"'$'
      FREESAVEM=`/bin/df -m "$localSMNTPT" | tail -n1 | tr -s ' ' | cut -f 4 -d ' '`
      SWPSIZE=""
      [ $FREESAVEM -gt 100 ] && SWPSIZE="50"
      [ $FREESAVEM -gt 200 ] && SWPSIZE="100"
      [ $FREESAVEM -gt 500 ] && SWPSIZE="200"
      if [ "$SWPSIZE" ];then
       echo  >/dev/console
       echo "A swapfile named 'pupswap.swp' is being created in partition ${localSAVEPART}," >/dev/console
       echo "of size ${SWPSIZE}MB. This will be loaded at next boot, to ease the low-RAM" >/dev/console
       echo "situation of your PC. Creating now..." >/dev/console
       dd if=/dev/zero of=${localSMNTPT}/pupswap.swp bs=1048576 count=$SWPSIZE
       if [ $? -eq 0 ];then
        [ "$FORCE" ] || _sync
        mkswap ${localSMNTPT}/pupswap.swp
       fi
       if [ $? -ne 0 ];then
        rm $VERB -f ${localSMNTPT}/pupswap.swp 2>>$ERR
        echo "...error, unable to create swapfile." >/dev/console
       fi
       [ "$FORCE" ] || _sync
      fi
     fi
    fi
   fi
} #end swapfile_func

if [ "$PUPSAVE" ];then
 #f.s. and partition where ${DISTRO_FILE_PREFIX}save.2fs is located...
 SAVEPART="`echo -n "$PUPSAVE" | cut -f 1 -d ','`"
   SAVEFS="`echo -n "$PUPSAVE" | cut -f 2 -d ','`"
 SAVEFILE="`echo -n "$PUPSAVE" | cut -f 3 -d ','`"
fi

#v3.02 ask about serial devices... v404 removed...
#if [ $PUPMODE -eq 32 -o $PUPMODE -eq 128 ];then #saving
# dialog --yesno "Just before the session is saved, a quick question:
#${DISTRO_NAME} probes for serial mouse and serial modem at startup,
#but this does slow the bootup-time. If you have neither of
#these, and never will, answer no here to speedup startup.

#clear >/dev/console

#save session...
case $PUPMODE in
 3) #PDEV1.
   echo "Saving session to $PDEV1..." >/dev/console
   /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
 32) #first shutdown, save back to PDEV1. v3.97: xPDEV
  DEV1MNT="`mount | grep "/dev/$xPDEV" | tr -s " " | cut -f 3 -d " "`"
  if [ "$DEV1MNT" = "" ];then
   mkdir $VERB -p /mnt/$xPDEV
   mount $VERB $VERB -t $xDEVFS /dev/$xPDEV /mnt/$xPDEV
   if [ ! $? -eq 0 ];then
    echo "ERROR: unable to mount /dev/$xPDEV, cannot save." >/dev/console
    exit
   fi
   DEV1MNT="/mnt/$xPDEV"
  fi
  RDIRS="`find /initrd/pup_rw/ -maxdepth 1 -xdev -type d | grep -vE "/$|/mnt|/tmp|/proc|/sys|/var|/dev|/lost"`"
  for oneDIR in $RDIRS
  do
   cp $VERB -a $oneDIR ${DEV1MNT}/
  done
  #DISTRO_SPECS must be saved, init script looks for it to determine if
  #there is a saved session...
  cp $VERB -af /etc/DISTRO_SPECS ${DEV1MNT}/etc/
  [ "$FORCE" ] || _sync

  #w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
  swapfile_func $DEV1MNT $xPDEV

  umount $VERB $VERB $DEV1MNT 2>>$ERR
  ;;
 7) #PDEV1 and PUPSFS.
   echo "Saving session to $PDEV1..." >/dev/console
   /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
 13) #PDEV1 and PUPSFS and PUPSAVE
  #/initrd/pup_rw has tmpfs, pup_ro1 has ${DISTRO_FILE_PREFIX}save.2fs file (PUPSAVE), pup_ro2 has PUPSFS file.
  #the above are in unionfs at /.
  echo "Saving session to $SAVEFILE (${SAVEPART})..." >/dev/console
  /usr/sbin/snapmergepuppy /initrd/pup_ro1 /initrd/pup_rw
  ;;
 128) #1st shutdown, save to ${DISTRO_FILE_PREFIX}save.2fs.
  #partition already mounted on $SMNTPT.
  echo "Saving session to $SAVEFILE file on $SAVEPART partition..." >/dev/console
  mkdir $VERB /tmp/save1stpup
  echo -n "Mounting ${SAVEFILE}..."
  FILEFS="ext4"
  [ ! "`echo -n "$SAVEFILE" | grep "3fs"`" = "" ] && FILEFS="ext3"
  [ ! "`echo -n "$SAVEFILE" | grep "2fs"`" = "" ] && FILEFS="ext2"

  if [ "$CRYPTO" = "" ];then
   mount $VERB $VERB -t $FILEFS -o noatime,rw,loop $SMNTPT$SAVEFILE /tmp/save1stpup
  else
   #note: loop2 is kept available for scripts to use. but, do this to find free one...
   DEVLOOP="`losetup-FULL -f`"
   #'-p 0' means read password from stdin...
   #v2.17 crap, '-p 0' works for aes, not for xor encryption....
   if [ "$CRYPTO" = '-E 1' ];then #light xor encr.
    echo "Note, a bug in one of the Linux utility programs requires you to reenter" >/dev/console
    echo "the password in the case of light encryption..." >/dev/console
   fi
   echo "$MYPASSWORD" | losetup-FULL -p 0 $CRYPTO $DEVLOOP ${SMNTPT}$SAVEFILE >/dev/console
   [ ! $? -eq 0 ] && exit 1
   mount $VERB $VERB -t $FILEFS -o noatime,rw $DEVLOOP /tmp/save1stpup
  fi

  #floppy disk has little space. snapmergepuppy handles this for subsequent saves, but for now,
  #be radical, only save /etc...
  if [ "$SAVEPART" = "fd0" ];then
   RDIRS="/initrd/pup_rw/etc"
  else
   RDIRS="`find /initrd/pup_rw/ -maxdepth 1 -xdev -type d | grep -vE "/$|/mnt|/tmp|/proc|/sys|/var|/dev|/lost"`"
  fi
  for oneDIR in $RDIRS
  do
   BASENAME="`basename $oneDIR`" #v2.16exp3
   mkdir $VERB -p /tmp/save1stpup/${BASENAME} #v2.16exp3 likely already created above.
   cp $VERB -a $oneDIR/* /tmp/save1stpup/${BASENAME}/ #v2.16exp3
   [ "$BASENAME" = "root" ] && cp $VERB -a $oneDIR/.[0-9a-zA-Z]* /tmp/save1stpup/${BASENAME}/ #v2.16exp4
  done
  [ "$FORCE" ] || _sync
  umount $VERB $VERB /tmp/save1stpup

  #v2.20b offer to copy ${DISTRO_FILE_PREFIX}-xxx.sfs and ${ZDRVSFS} off the cd...
  if [ "$DEV1FS" = "iso9660" ];then #test if booted off cd.
   if [ ! -f ${SMNTPT}/${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}*.sfs ];then
    NAMEONLY="`basename $SAVEFILE`"
    dialog --yesno "The CD has '${DISTRO_FILE_PREFIX}-$DISTRO_VERSION.sfs' and maybe other .sfs files on it.
It will speed startup considerably if these are on the hard drive.
Also, for PCs with less than 256MB of RAM, ${DISTRO_NAME} does not copy the
${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.sfs file to RAM so the CD drive remains mounted,
meaning that the drive cannot be used for other purposes -- however,
if you reply 'YES' here then it will be copied to the same place
as the '${DISTRO_FILE_PREFIX}save' file and loaded from there at startup,
thus freeing the CD drive for other uses.
Even if you have heaps of RAM, it is still good to answer 'YES'
to get the faster startup.

Note: if a CD has extra .sfs files on it, by copying them to the
same place as the '${DISTRO_FILE_PREFIX}save' file, they are then available to
be loaded at startup, which is configurable by the BootManager
(the BootManager is in the System menu)

If you answer 'Yes' here, please FIRST, RIGHT NOW, put the ${DISTRO_NAME}
CD into the $PDEV1 drive (the same one that the CD was in at
startup), if it isn't already, THEN select the 'Yes' button..." 0 0 >/dev/console
    RETVAL=$?
    clear >/dev/console
    if [ $RETVAL -eq 0 ];then
     echo "Please wait, accessing CD drive..." >/dev/console
     APATTERN="/dev/$PDEV1 "
     CDMNTPT="`mount | grep "$APATTERN" | cut -f 3 -d ' '`"
     mkdir $VERB -p /mnt/$PDEV1
     if [ "$CDMNTPT" = "" ];then
      mount $VERB $VERB -t iso9660 /dev/$PDEV1 /mnt/$PDEV1
      CDMNTPT="/mnt/$PDEV1"
     fi
     for oneSFS in `find $CDMNTPT -maxdepth 1 -type f -name \*.sfs | grep -v ' ' | tr '\n' ' '`
     do
      BASESFS="`basename $oneSFS`"
      FILESIZEB=`stat -c %s $oneSFS`
      FILESIZEK=$(( (FILESIZEB / 1024) + 2048)) #2MB slack.
      BPATTERN=" $SMNTPT"'$'
      DRVFREEK=`/bin/df -k | tr -s ' ' | grep "$BPATTERN" | cut -f 4 -d ' '`
      if [ $DRVFREEK -gt $FILESIZEK ];then
       echo "Copying $BASESFS..." >/dev/console
       cp $VERB -f $oneSFS $SMNTPT/
       [ "$FORCE" ] || _sync
      else
       echo "Insufficient space! Cannot copy $BASESFS" >/dev/console
       break
      fi
     done
     busybox umount $VERB $VERB $CDMNTPT
    fi
   fi
  fi

  #w481 if low-ram, save-file is on a fast media, and no swap file/partition, then create one...
  swapfile_func $SMNTPT $SAVEPART

  umount $VERB $VERB $SMNTPT 2>>$ERR
  ;;
 69) #save to folder on multisession CD/DVD (including 1st shutdown). (5+64=69) NOT used
  multisavefunc
  ;;
 77) #save to folder on multisession CD/DVD (including 1st shutdown). (13+64=77)
  multisavefunc
  ;;
 2)
  echo -e "\\033[1;32m$PDEV1 mounted directly, session already saved.\\033[0;39m" >/dev/console
  ;;
 12)
  echo -e "\\033[1;32m`basename $SAVEFILE` mounted directly top layer, session already saved.\\033[0;39m" >/dev/console
  ;;
 6)
  echo -e "\\033[1;32m$PDEV1 mounted directly top layer, session already saved.\\033[0;39m" >/dev/console
  ;;
 5) #v2.02 first boot. User has choosen not to save, so PUPMODE not changed from 5 to 32 or 128
  echo -e "\\033[0;35mSession not saved\\033[0;39m" >/dev/console
  [ "$FORCE" ] || _sync
  #ha ha, before had this, if aborted save after choosing save-partition, code
  #further down wiped all of the partition (it was mntd on /tmp/savepup)...
  [ "$SMNTPT" ] && umount $VERB $VERB $SMNTPT 2>>$ERR
  #...well, fixed it, changed mntpt so not in /tmp. Leave above line here.
  ;;
 *)
  echo -e "\\033[0;31mUnhandled PUPMODE '$PUPMODE' , session not saved\\033[0;39m" >/dev/console
  sleep 2
  ;;
esac

#when the working files run in tmpfs in ram, they are saved above and /tmp and /var
#are screened out. however, some PUPMODES mount ${DISTRO_FILE_PREFIX}save.2fs directly on /initrd/pup_rw,
#the top unionfs layer, meaning that there is no intermediary tmpfs in ram for working
#files, hence everything is saved directly, ditto for PUPMODE=2 a full h.d. install.
#hence need to do some explicit wiping here...
#echo -n "" > /var/log/messages #delete, as it keeps growing.(note choosepartfunc uses this)

rm $VERB -f /var/lock/LCK*

for pidf in /var/run/*.pid; do
[ -f $pidf ] || continue
[ -s $pidf ] || continue
read procID <$pidf
[ "$procID" ] || continue
/bin/ps --no-header -p $procID >$OUT && kill $procID
done
rm $VERB -f /var/run/*.pid

rm $VERB -rf /root/tmp/* 2>>$ERR #...note, not screening this out in any of above save modes.

echo "PUPMODE='$PUPMODE'" >/dev/console  ##DEBUG
if [ "$PUPMODE" != "2" ]; then
echo -e "\\033[0;33mremoving thumbnails\\033[0;39m" >/dev/console
rm $VERB -rf /root/.thumbnails/*
else
FP=`/bin/df | grep -m1 -Fw '/' | tr -s ' ' | cut -f5 -d ' ' | tr -d '%'`
if test "$FP" -lt 5; then
echo -e "\\033[0;33mFull install , free space lesser than 5%; removing thumbnails\\033[0;39m" >/dev/console
rm $VERB -rf /root/.thumbnails/*
else
echo -e "\\033[0;32mFull install , free space more than 5%; leaving thumbnails ok\\033[0;39m"
fi
fi

echo
echo "UDEV:"  #DEBUG
UDEV=`find /dev/.udev/ -type f -o -type l`
echo "$UDEV
" |tail -n10

rm $VERB -rf /dev/.udev/*
echo "END UDEV"  #DEBUG
echo

[ -f /etc/profile.d/firstun ] && rm $VERB -f /etc/profile.d/firstun

#cp $VERB -f /etc/rc.d/PUPSTATE /etc/rc.d/PUPSTATE.prev
fsckme_func
[ "$DEBUG" ] && sleep 10

[ -d /var/tmp ] && rm $VERB -rf /var/tmp/* 2>>$ERR #100820
[ "$FORCE" ] || _sync

[ -f /etc/rc.d/MORESFS ] && rm $VERB /etc/rc.d/MORESFS

MNTDPARTS="`mount`"
MNTDPARTS=`echo $MNTDPARTS |rev|sed 's# )#\n)#g' |rev`
#echo
echo -e "\\033[0;33mUnmounting stray filesystems:\\033[0;39m" >/dev/console

STRAYPARTL=`echo "$MNTDPARTS" |grep -vE '/dev/pts|/proc|/sys|*tmpfs|*ramfs|rootfs| on / |/dev/root|usbfs|unionfs|/initrd'`
#STRAYPARTD="`echo "$STRAYPARTL" | cut -f 1 -d " " | tr "\n" " "`"
#STRAYPARTD="`echo "$STRAYPARTL" | cut -f 3 -d " " | tr "\n" " "`"
STRAYPARTD=`echo "$STRAYPARTL" |sed -r 's,.* on (.*) type .*,\1,'`
#for oneSTRAY in $STRAYPARTD
while read oneSTRAY
do
 [ "$oneSTRAY" ] || continue
 echo "Unmounting $oneSTRAY..." >/dev/console
 #091117 weird bug, no processes but when run this, x restarts...
 xFUSER="`fuser -m "$oneSTRAY" 2>/dev/null |tr ' ' '|' |tr -s '|' |sed 's#^|*##;s#|*$##'`" #091117 do this first, seems to fix it.
 #[ "$xFUSER" != "" ] && fuser -k -m $oneSTRAY
 #100107 if ntfs partition mntd, then process 'ntfs-3g' will be running in it, try to kill it, X restarts...
 if [ "$xFUSER" != "" ];then
 sleep 1
  PSALL=`busybox ps |grep -vEw "ntfs\-3g|$$|$PPID|1" |awk '{print $1}'`
   XFUSER=`echo "$PSALL" | grep -Ew "$xFUSER"`
  for onePROCESS in $XFUSER
  do
   #onPATTERN='^'"$onePROCESS"' '
   #[ "`echo "$PSALL" | grep "$onPATTERN" | grep ' ntfs\-3g '`" != "" ] && continue
   kill $onePROCESS
  done
 fi
 [ "$FORCE" ] || killzombies #v3.99
 [ "$FORCE" ] || _sync
 umount $VERB $VERB -lr "$oneSTRAY"
done << EOI
$(echo "$STRAYPARTD")
EOI

swapoff -a #busybox swapoff -a works only if swaps are in mtab or ftab
#v2.13 menno suggests this improvement...
STRAYPARTD="`cat /proc/swaps | grep "^/dev/"  | grep -v 'deleted' | cut -f 1 -d " "`"
for oneSTRAY in $STRAYPARTD
do
 echo -e "\\033[0;36mSwapoff $oneSTRAY\\033[0;39m" >/dev/console
 swapoff $VERB $oneSTRAY
done
[ "$FORCE" ] || _sync

#rm $VERB -f /tmp/wmexitmode.txt

#note, there is a problem with unmounting, especially ntfs as it cannot be remounted
#ro (?). A ntfs part with ${DISTRO_FILE_PREFIX}save.2fs cannot be unmounted because of the mounted
#${DISTRO_FILE_PREFIX}save.2fs.
#at least, attempt to kill anything running in the ntfs partition...
#(i don't think anything will be, only /dev/loop1 (${DISTRO_FILE_PREFIX}save.2fs), but just in case)
ABSPUPHOME="" #100107
[ "$PUP_HOME" ] && ABSPUPHOME="/initrd${PUP_HOME}" #v2.16rc
[ -d "$ABSPUPHOME" ] || ABSPUPHOME="/initrd/mnt/dev_save" #v2.16rc
if [ "`busybox mount | grep "$ABSPUPHOME"`" != "" ];then
 #BADPIDS="`fuser -v -m $ABSPUPHOME | grep -v --extended-regexp 'kernel|COMMAND|^$' | tr -s ' ' | cut -f 3 -d ' ' | tr '\n' ' '`"
 BADPIDS="`fuser -m $ABSPUPHOME 2>/dev/null`" #100107
 for oneBAD in $BADPIDS
 do
 case $oneBAD in
  1|$$|$PPID) continue;;
 esac
  echo "Killing process pid $oneBAD..."
  kill $oneBAD
  [ $? = 0 ] && continue
  sleep 1
  kill -9 $oneBAD 2>>$ERR
  [ "$FORCE" ] || _sync
 done
 [ "$FORCE" ] || killzombies #v3.99
fi

_unmount_save_layer(){
#v2.16rc try this too... SAVE_LAYER defined in /etc/rc.d/PUPSTATE...
test -f /proc/mounts || return 1
if [ "$SAVE_LAYER" ];then
 [ "$FORCE" ] || _sync
 SAVEDEV="`mount | grep " /initrd${SAVE_LAYER} " | cut -f 1 -d ' '`"
  SAVEFS="`mount | grep " /initrd${SAVE_LAYER} " | cut -f 5 -d ' '`"
 #100615 Patriot: suggested this code to enable save-layer to remount ro...
 uniFS=$(awk '/unionfs/ {print $3}' /proc/mounts) #ex: aufs
 if [ "$uniFS" == "aufs" -a "$SAVE_LAYER" == "/pup_rw" ]; then
  #i think only work if prepended dir is a separate f.s...
  if [ "`mount | grep '^tmpfs on /tmp '`" != "" ];then #created in initrd.

   echo -en "\\033[1;36mAttempting to remount '/' type '$uniFS' on '/tmp/unrootfs' ...\\033[0;39m" >/dev/console
   mkdir $VERB -p /tmp/unrootfs

   busybox mount $VERB $VERB -o remount,prepend:/tmp/unrootfs,xino=/tmp/unrootfs/xino -t $uniFS / /
   _status $?

   [ "$FORCE" ] || _sync
  fi
 fi
 [ "$SAVEFS" -a "$SAVEDEV" ] || return 1

 echo -en "\\033[1;36mAttempting to remount '$SAVEDEV' on /initrd'$SAVE_LAYER' type '$SAVEFS' read-only ...\\033[0;39m" >/dev/console
 busybox mount $VERB $VERB -t $SAVEFS -o remount,ro $SAVEDEV /initrd${SAVE_LAYER} 2>>$ERR
 _status $?

 grep $Q " /initrd${SAVE_LAYER} " /proc/mounts || return 1

 echo -en "\\033[1;36mAttempting to unmount /initrd'$SAVE_LAYER' ...\\033[0;39m" >/dev/console
 umount-FULL -i -n -l /initrd${SAVE_LAYER} 2>>$ERR #-l is lazy unmount.
 _status $?
fi
}
_unmount_save_layer

#v2.16 try one more thing for ntfs... lazy unmount, suggested by GuestToo...
MNTFUSE="`busybox mount | grep 'fuse' | head -n 1 | cut -f 3 -d ' '`"
if [ "$MNTFUSE" != "" ];then
 #v2.17 hairywill found the -u is required with -z...
 echo -en "\\033[1;33mAttempting to unmount '$MNTFUSE' .." >/dev/console
 fusermount -z -u $MNTFUSE
 _status $?
else
 _not_used_unmount_pdev1(){
  if [ "$PDEV1" ];then #from PUPSTATE
   APATTERN="^/dev/${PDEV1} "
   if [ "`busybox mount | grep "$APATTERN"`" != "" ];then
   #[ "$PUP_HOME" ] && busybox mount -t $DEV1FS -o remount,ro /dev/$PDEV1 /initrd${PUP_HOME}
   #...no, do not attempt ro remount, will prevent ${DISTRO_FILE_PREFIX}save clean shutdown if it didn't above.
   echo -en "\\033[1;33mAttempting to unmount /dev/'$PDEV1' ..." >/dev/console
   umount-FULL $VERB -i -n -l /dev/$PDEV1
   _status $?
   fi
  fi
 }
 :
fi

_ask_to_quit "
Mounts before _my_final_umount() :
`mount`"

_my_final_unmount(){
[ "$FORCE" ] || _sync
case $PUPMODE in
2|3) /bin/mount $VERB $VERB -o remount,ro /dev/root /;;
*) :;;
esac
}
_my_final_unmount

_ask_to_quit "
Mounts before umount -ar
and exit 0 :
`mount`"

busybox umount $VERB $VERB -ar #> /dev/null 2>&1

# REM: umount -ar returns non-zero
#      if remounted read-only
#      so force exitcode 0 now
#      to not confuse poweroff and reboot scripts
#       if they handle return codes
exit 0
# REM: Now /sbin/poweroff or /sbin/reboot
#      should handle further
###the end###
