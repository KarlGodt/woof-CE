#!/bin/ash
#(c) copyright Barry Kauler 2008, puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#v404 first release. rewritten from scratch, aiming for simplicity and speed.
#v405 fix for alsa.
#v406 load apm.ko if no acpi.
#v408 explicitly load battery, ac, thermal, fan modules.
#v409 gparted create ext3 part. failed, fixed by making /etc/mtab a symlink.
#v411 fix mouse detection logic.
#v411 can use old network wizard (from 403, based on 400)
#v411 return of 'puppyserialdetect', for usb/ps2 mouse detection only. now 'puppyinputdetect'.
#v411 extra 'sleep 1' as rerwin reports usb mouse may need it some hardware.
#v411 choosemousefunc().
#v412 /etc/DISTRO_SPECS, renamed pup_xxx.sfs, pup_save.2fs etc.
#v412 bugfix usb-storage wait loop.
#w001 ubuntu module-init-tools not configured to support gzipped modules.
#w004 LANG=C, faster. /bin/ash, even faster.
#w463 rerwin: special mwave modem handling.
#w463 mouse scrollwheel fix.
#w468 full-hd-install, write to PUPSTATE after remount r/w.
#w478 moved depmod code up above call to rc.update.
#w481 fix crappy depmod, 'out of memory' in first boot 64MB RAM (no swap).
#v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid.
#v424 fix LAYERFS variable.
#v424 fix secondary uevent replay. now finds ssb devices.
#v431 secondary uevent replay, fix for old kernels < 2.6.24
#100126 move syslogd, klogd to /etc/init.d/00sys_logger
#100127 anticipate bug gunzip modules from initrd.
#100131 bugfix detect multiple cd/dvd drives.
#100214 one config of 2.6.33 has base floppy and ps/2 mouse support not builtin.
#100216 jemimah's Pwireless2 now supported. 100217 slight modification.
#100227 integrate /usr/local/bin/defaultconnect for setup tool choice.
#100228 rerwin: make alsa-card-number generation multithread-safe; start modprobe protection/serialization daemon
#100304 modify pwireless choice. 100306 added Simple Network Setup.
#100316 perform f.s. check if improper shutdown. 100319 unset TZ, always load /dev/shm.
#100513 test to prevent msg on stderr.
#100611 UDEV_LOG=2 to prevent non-critical o/p to screen at bootup and shutdown.
#100628 shinobar: launch rc.network if eth0 is usable.
#100703 load fbcon module: needed by some xorg drivers when exit to console (ex: nouveau).

#unset TZ #100319 busybox hwclock gives priority to this (rather than /etc/localtime) and 'init' has set it wrong.

########################################################################
#
#
#
#
#
# /dev/hda7
# /dev/hda7:
# LABEL="/"
# UUID="429ee1ed-70a4-43a5-89f8-33496c489260"
# TYPE="ext4"
# DISTRO_NAME='LucidÂPuppy'
# DISTRO_VERSION=218
# DISTRO_MINOR_VERSION=00
# DISTRO_BINARY_COMPAT='ubuntu'
# DISTRO_FILE_PREFIX='luci'
# DISTRO_COMPAT_VERSION='lucid'
# DISTRO_KERNEL_PET='linux_kernel-2.6.33.2-tickless_smp_patched-L3.pet'
# PUPMODE=2
# SATADRIVES=''
# PUP_HOME='/'
# PDEV1='hda7'
# DEV1FS='ext4'
# LinuxÂpuppypcÂ2.6.31.14Â#1ÂMonÂJanÂ24Â21:03:21ÂGMT-8Â2011Âi686ÂGNU/Linux
# Xserver=/usr/bin/Xorg
# $LANG=en_US
# today=TueÂOctÂ25Â12:47:45ÂGMT+1Â2011
# TODO1 : rm -r /tmp/* not implemented here #done in /sbin/init ##2011-11-07
# ##NO , /sbin/init rm -r /tmp in udev func _> implemented again
#
# toto :protect --daemon quits too early
#
#
########################################################################

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin

[ "$CODECHECK" -o "$CHECKCODE" ] && set -n
. /etc/rc.d/f4puppy5

#...comment-out for now. note, TZ now set in rc.country.
export LANG=C

_wait_load_average(){
WAITLOAD=$1
[ "$WAITLOAD" ] || WAITLOAD=3
[ "${WAITLOAD//[0-9]/}" ] && WAITLOAD=3
c=0
until [ "`cut -f 1 -d '.' /proc/loadavg`" -lt $WAITLOAD ];do
LOAD=`cat /proc/loadavg`;c=$((c+1))
#echo -ne "\rWaiting for load average to drop below 3 :`cat /proc/loadavg` ";
echo -e "Waiting for load average to drop below '$WAITLOAD' : $LOAD ";
#echo -ne "\rWaiting for load average to drop below 3 :`cat /proc/loadavg` " >/dev/console
echo -ne "\rWaiting for load average to drop below '$WAITLOAD' : $LOAD " >/dev/console
sleep 2s;done  ###+++2011-11-30
[ "$c" -gt 0 ] && echo >/dev/console
c=0
}

_say_load(){ echo "Uptime: `uptime`"; }

status_func(){
 if [ $1 -eq 0 ];then
  /bin/echo -e "\\033[72G\\033[1;32mdone\\033[0;39m" >/dev/console #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed\\033[0;39m" >/dev/console #red [failed].
  STATUS=0
 fi
 return $1 #return with same status as entry param.
}

loadswap_func(){ #w481 made into a function.
 echo "Activating SWAP"
 #load a swap partition...
 for oneSWAP in `fdisk -l | grep -i ' Linux swap' | cut -f 1 -d ' ' | tr '\n' ' '`
 do
  [ "`blkid $oneSWAP |grep -Ei 'hiber|resume|winter|deep'`" ] && continue
  echo -n "Activating swap partition $oneSWAP..." >/dev/console
  swapon $oneSWAP
  status_func $?
  [ $? -eq 0 ] && SWAPON="yes"
 done
 #if no go, try for a swap file...
 if [ "$SWAPON" != "yes" ];then
  SWAPFILE="/pupswap.swp"
  [ "$PSWAPFILE" ] && SWAPFILE="`echo -n "$PSWAPFILE" | cut -f 3 -d ','`"  #/etc/rc.d/PUPSTATE
  if [ -f /initrd${PUP_HOME}${SWAPFILE} ];then
   echo -n "Loading swap file ${SWAPFILE}..." >/dev/console
   swapon /initrd${PUP_HOME}${SWAPFILE}
   status_func $?
   [ $? -eq 0 ] && SWAPON="yes"
  fi
  if [ -f $SWAPFILE ];then
   echo -n "Loading swap file ${SWAPFILE}..." >/dev/console
   swapon $SWAPFILE
   status_func $?
   [ $? -eq 0 ] && SWAPON="yes"
  fi
 fi
 [ "$SWAPON" = 'yes' ] || echo -e "\\033[1;31m""WARNING : NO SWAP could be activated.\n""\\033[0;39m""`free`\n" >/dev/console
}

#if have just done a switch_root, output a 'done' message...
[ -d /initrd ] && status_func 0 #note, /initrd does not exist when a full-hd installation.


test -f /etc/rc.d/PUPSTATE && source /etc/rc.d/PUPSTATE || PUPMODE=2
STATUS=0

##############MAKE FILESYSTEM USABLE################
#echo "MAKE FILESYSTEM USABLE"
#echo -n "Making the filesystem usable..." >/dev/console #need this redirection!
busybox mount $VERB $VERB -t proc proc /proc;STATUS=$(( STATUS + $? ))

if test "$PUPMODE" = 2; then #w468
 busybox mount $VERB $VERB -o remount,rw /dev/root /;STATUS=$(( STATUS + $? ))
 echo 'PUPMODE=2' > /etc/rc.d/PUPSTATE
 unset SATADRIVES ATADRIVES PUP_HOME PDEV1 DEV1FS
else
[ -d /initrd -a "`which chattr`" ] && chattr +i /initrd
fi

##+++2012-01-29
mkdir $VERB -p /dev/vc;rm -f /dev/vc/11;mknod /dev/vc/11 c 4 11
openvt -c 11 autologinroot
##+++2012-01-29

echo -n "Making the filesystem usable..." >/dev/console #need this redirection!
#if [ ! "$DISPLAY" ];then
rm -rf /tmp/*  ##+++2011-11-30 implemented again
rm -rf /tmp/.[[:alnum:]_-]*  ##+++2012-05-28
#fi
#redirect all output to a log file (must do after remount rw)...
#[ ! "$LOGLEVEL" ] && exec 1>/tmp/bootsysinit.log 2>&1
exec 1>/tmp/bootsysinit.log 2>&1 ####KRG

#v409 mount/umount scripts no longer write to /etc/mtab, as gparted failed to create a
#ext3 partition -- dunno why. Instead, now have /etc/mtab a symlink to /proc/mounts...
rm -f /etc/mtab
ln $VERB -s /proc/mounts /etc/mtab

mkdir $VERB -p /dev/pts ####KRG for DEVTMPFS KERNEL
busybox mount $VERB $VERB /dev/pts ;STATUS=$(( STATUS + $? ))
mkdir $VERB -p /sys
busybox mount $VERB $VERB -t sysfs sysfs /sys ;STATUS=$(( STATUS + $? ))

##v2.20 some apps need shm (shared memory) (ex: xfdiff)... 100319 do this always...
FREERAM=`free | grep -o 'Mem:.*' | tr -s ' ' | cut -f 4 -d ' '` #w481 ####KRG changed -f 5 to -f 4
QTRFREERAM=$(( FREERAM / 4 ))
[ -d /dev/shm ] || mkdir $VERB -p /dev/shm ####KRG for DEVTMPFS KERNEL
mount $VERB $VERB -t tmpfs -o size=${QTRFREERAM}k shmfs /dev/shm ;STATUS=$(( STATUS + $? ))

mountpointDEV='';
haveMDEV=YES;
mountpoint /dev && mountpointDEV=YES
#if test ! "$mountpointDEV"; then
mdev -s >>$OUT 2>>$ERR || haveMDEV='';
#fi

status_func $STATUS


#w478 moved this code above call to rc.update...
KERNVER="`uname -r`"
KERNMAJ=`echo -n "$KERNVER" | cut -f 3 -d '.' | cut -f 1 -d '-'` #v431
. /etc/rc.d/MODULESCONFIG #modules loading configuration.
[ -f /etc/rc.d/rc.sysinit.local.start ] && . /etc/rc.d/rc.sysinit.local.start

. /etc/rc.d/functions4puppy4
. /etc/DISTRO_SPECS
. /etc/rc.d/PUPSTATE #variables created at bootup by init script in initrd.

[ $loglevel ] && LOGLEVEL=$loglevel #boot param.
[ $pmedia ]  && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $pdev1 ]  && PDEV1=$pdev1    #boot parameter, partition have booted off. ex: hda3

#w469 may need to run 'depmod'...
#live-cd may have been built without the modules.* files.
#initrd init script copied modules to /lib/modules/<kernver>/initrd/.
if [ ! -f /lib/modules/${KERNVER}/modules.dep ];then
 NEEDDEPMOD="yes" #w469 files may not be there to save space.
 [ -d /lib/modules/${KERNVER}/initrd ] && NEEDGUNZIP="yes" || true
elif [ -d /lib/modules/${KERNVER}/initrd ];then
  #100127 remove leading '/' from '/initrd/' for comaptibility with depmod-FULL...
  if [ "`cat /lib/modules/${KERNVER}/modules.dep | cut -f 1 -d ':' | grep  'initrd/'`" = "" ];then
   NEEDDEPMOD="yes" #w469 files may not be there to save space.
   NEEDGUNZIP="yes"
  else true
  fi
else true
fi
STATUS=$((STATUS+$?))
if [ "$NEEDGUNZIP" = "yes" ];then
 #w001 ubuntu module-init-tools not configured to support gzipped modules...
 #for oneMOD in `find /lib/modules/${KERNVER}/initrd/* -type f -name *.gz | tr '\n' ' '`
 #do
 # gunzip $oneMOD
 #done
 gunzip -f -r /lib/modules/${KERNVER}/initrd #w482 shinobar.
else true
fi
STATUS=$((STATUS+$?))
if [ "$NEEDDEPMOD" = "yes" ];then
 echo -n ' depmod' >/dev/console
 depmod
else true
fi
STATUS=$((STATUS+$?))
###+++2013-03-22
playbootnoise(){
    [ -e /etc/rc.d/haileyharly.wav ] || return 0
    modprobe $VERB snd-card-0 && {
    alsactl -f /etc/asound.state restore && {
    until pidof X; do
    aplay /etc/rc.d/haileyharly.wav || return 0
    sleep 0.1
    done
  } || return 0
 } || return 0
}
playbootnoise &

###+++2013-03-22
[ $layerfs ] && LAYERFS=$layerfs #boot param.
[ $LAYERFS ] || LAYERFS=aufs     #aufs or unionfs
[ "`modinfo aufs 2>/dev/null`" = "" ] && LAYERFS=unionfs #precaution.

#######################VERSION UPDATE##########################
echo "VERSION UPDATE"
#force update when new version of ${DISTRO_NAME}...
echo -n "Updating..." >/dev/console

/etc/rc.d/rc.update $PUPMODE
pidof sync || sync
status_func $STATUS

#################LOAD KERNEL MODULES################
echo "LOAD KERNEL MODULES"
echo -n "Loading kernel modules..." >/dev/console
#100126 moved to /etc/init.d/00sys_logger...
# REM: want it here in case modprobe  -L  --syslog option...
syslogd -l 7 -s 1024 -b 99 -O /var/log/syslog-7
syslogd -m 0
klogd
#MODALIASES="`ls /sys/bus/*/devices/*/modalias`"
MODALIASES=`ls -1v /sys/*/*/*/*/modalias`

BLACKLISTVARS="`echo "$SKIPLIST" | tr '\-' '_' | tr ' ' '\n' | sed -e 's/^/blacklist /' | grep -v ' $'`"
echo "$BLACKLISTVARS" > /tmp/pup_event_modprobe.conf
grep '^blacklist' /etc/modprobe.conf >>/tmp/pup_event_modprobe.conf
grep -h '^blacklist' /etc/modprobe.d/* >>/tmp/pup_event_modprobe.conf

#...read in /sbin/pup_event_backend_d, and pup_event_backend_modprobe (for udevd).

if test "$PUPMODE" = 2; then #v423 full hd install.
#if [ -n "`grep 'KRG version' /sbin/init`" ] ; then

 #100214 one config of 2.6.33 has base floppy and ps/2 mouse support not builtin. have this in 'init' also...
 [ "`modinfo floppy 2>/dev/null`" ]  && modprobe $VERB floppy
 [ "`modinfo psmouse 2>/dev/null`" ] && modprobe $VERB psmouse
 #v423 have this in 'init', probably need here too...
 if [ "`echo "$MODALIASES" | grep 'bc0Csc03i10'`" != "" ];then
  /sbin/modprobe $VERB --config /tmp/pup_event_modprobe.conf yenta-socket
  [ $? -eq 0 ] && sleep 2
 fi
 #v423 k2.6.29.6 dmesg has warning that ehci-hcd should load before uhci-hcd and ohci-hid
 # this is contrary to my understanding all these years, but oh well, let's do it...
 ELSPCI="`elspci -l`" #jesses great little utility.
 [ "`echo "$ELSPCI" | grep '0C0320'`" ] && /sbin/modprobe $VERB --config /tmp/pup_event_modprobe.conf ehci-hcd
 [ "`echo "$ELSPCI" | grep '0C0310'`" ] && /sbin/modprobe $VERB --config /tmp/pup_event_modprobe.conf ohci-hcd ####KRG
 [ "`echo "$ELSPCI" | grep '0C0300'`" ] && /sbin/modprobe $VERB --config /tmp/pup_event_modprobe.conf uhci-hcd ####KRG
 #...perhaps a udev rule could have done this?
 fi
[ "`lsmod | grep -E 'ehci|ohci|uhci|xhci'`" != "" ] && modprobe $VERB usbhid ####KRG
#091221 rerwin: not required anymore...
##v405 udevd calls /sbin/pup_event_backend_modprobe, which needs this...
#echo -n '0' > /tmp/pup_event_alsa_cnt
#100228 udevd calls /sbin/pup_event_backend_modprobe, which uses its 'access protection' service to serialize concurrent access to shared resources.
_say_load
INITSTATE=`find /sys -name "initstate"`
for i in $INITSTATE ; do echo -n "$i " ; cat "$i" ; done
[ -z "$INITSTATE" ] && echo 'No initstate files in /sys ...'
WC=`echo "$INITSTATE" | wc -l`

_daemons(){ ##+++2012-01-28
if [ -x "`which pup_event_backend_modprobe_protect`" ] ; then
if [ ! "`pidof pup_event_backend_modprobe_protect`" ];then
nice -n -3 pup_event_backend_modprobe_protect --daemon &
fi;fi

#my intention is for puppy to work with either of these...
if [ -f /sbin/udevd ];then
 if [ ! "`pidof udevd`" ];then
 #100611 UDEV_LOG=2 to prevent non-critical o/p to screen at bootup and shutdown...
 UDEVVER=`udevd --version`  ##124
 if [ $UDEVVER -gt 150 ];then
  #100611 v151 is recommended for kernel 2.6.27+.
  UDEV_LOG=7 /sbin/udevd --daemon --resolve-names=early #never ###KRG ; orig LOG=2
#--daemon    Detach and run in the background.
#--debug-trace
#    Run all events completely serialized. This may be useful if udev triggers actions or loads kernel modules which cause problems and a slow but continuous operation is needed, where no events are processed in parallel.
#--debug        Print debug messages to stderr.
#--resolve-names
#    Specify when udevd should resolve names of users and groups. When set to early (the default) names will be resolved when the rules are parsed. When set to late names will be resolved for every event. When set to never names will never be resolved and all devices will be owned by root.
#--version    Print version number.
#--help   Print help text.
#UDEV_LOG       Overrides the syslog priority specified in the config file /etc/udev/udev.conf.
 else
  UDEV_LOG=7 /sbin/udevd --daemon ###KRG ; orig LOG=2
 fi;fi
else
 if [ -x "`which pup_event_backend_d`" ];then
 if [ ! "`pidof pup_event_backend_d`" ];then
  pup_event_backend_d >/tmp/pup_event_backend_errors 2>&1 & #hotplug daemon. my homebrew replacement for udevd.
 fi;fi
fi
sleep 0.1
}

if [ "$WC" -lt 20 ] ; then  ###Modules not loaded yet ?

_daemons ##+++2012-01-28

#replay uevents from /sys...
c=0;d=0;e='module'  ##+++2011-11-08
oldIFS="$IFS"
IFS=$'\n'
for oneMODALIAS in $MODALIASES
do
 #onePATH="`dirname $oneMODALIAS`"
 onePATH="${oneMODALIAS%/*}"
 if [ -e "${onePATH}/uevent" ]; then
  echo add > "${onePATH}/uevent" #generates an 'add' uevent.
  sleep 0.02
   ##+++2011-11-08
   c=$((c+1));d=$((d+1));e="$d"
   [ "$d" -lt 10 ] && e="$e "
   echo -n '.'"$e" >/dev/console
    if [ "$c" == 10 ] ; then
    echo >/dev/console
    echo -n "Loading kernel modules..." >/dev/console
    c=0
   fi
  ##+++2011-11-08
 fi
done
IFS="$oldIFS"
_say_load
fi ###Modules not loaded yet ?

#if [ ! -d /initrd ];then #full hd installation.
if test "$PUPMODE" = 2; then
 modprobe $VERB nls_cp437 #these needed by vfat/ntfs/ext2 f.s.'s.
 modprobe $VERB nls_iso8859-1 # "
 modprobe $VERB fuse
 modprobe $VERB $LAYERFS #unionfs or aufs.
 modprobe $VERB squashfs
 #we can determine ide/sata drives at this point (drivers builtin to kernel)...
 #ATADRIVES="`ls -1 /sys/block | grep '^sd' | tr '\n' ' '`"
 #ATADRIVES="`cat /proc/partitions | grep "sd[a-z]$" | tr -s " " | cut -f 5 -d " "`"
  ATADRIVES=`grep -o 'sd[a-z]$' /proc/partitions | tr '\n' ' '`  ##+-+2014-11-05
 if [ -e /proc/ide ];then
  echo "SATADRIVES='${ATADRIVES}'" >> /etc/rc.d/PUPSTATE #kernel supports /dev/hd*.
 else
  echo "ATADRIVES='${ATADRIVES}'" >> /etc/rc.d/PUPSTATE
 fi
fi

[ -d /proc/acpi ] || modprobe $VERB apm #v406

##modprobe fbcon #100703 needed by some xorg drivers when exit to console (ex: nouveau).

status_func 0
_wait_load_average
######################LOAD SWAP#####################
[ "$SWAPON" != "yes" ] && loadswap_func

#################MISC. SYSTEM SETUP#################
echo "MISC. SYSTEM SETUP"
#100126 moved to /etc/init.d/00sys_logger...
#syslogd -m 0
#klogd

if [ ! -f /etc/issue ];then  ##+-+2012-01-25
echo -e "${DISTRO_NAME} Linux\n`uname -s` `uname -r` [`uname -m` arch]\n\n" > /etc/issue
fi

echo "1" > /proc/sys/net/ipv4/ip_dynaddr
hostname -F /etc/hostname

rm -f /mnt/home 2>>$ERR
if [ ! -d /initrd ];then
 PUP_HOME='/'
 echo "PUP_HOME='/'" >> /etc/rc.d/PUPSTATE
 ln $VERB -s / /mnt/home
elif [ "$PUP_HOME" ];then #see /etc/rc.d/PUPSTATE
  if [ "$PUP_HOME" = "/pup_ro1" -o "$PUP_HOME" = "/pup_rw" ];then
   #note, PUPMODE=6 will have PUP_HOME=/pup_rw.
   #in the case of the persistent storage being the partition itself, this will be mounted
   #on /initrd/pup_ro1 (tmpfs on pup_rw for restricted writes) or directly on /initrd/pup_rw
   #and we do not really want users to access it as it is a unionfs layer. Instead, they are
   #already accessing it as "/".
   ln $VERB -s / /mnt/home
  else
   ln $VERB -s /initrd${PUP_HOME} /mnt/home
  fi
fi

_wait_load_average
#################MISC. SYSTEM SETUP#################


################WAIT MODULES LOADED##################
echo "WAIT MODULES LOADED"
#previous module loading may not have completed...
echo -n "Waiting for modules to complete loading..." >/dev/console
WAITCNT=0
PCIPCMCIA="`elspci -l | grep -o '060700'`"
PCIUSB="`elspci -l | grep -o -E '0C0300|0C0310|0C0320'`"
if [ "$PCIPCMCIA" != "" ];then #this may be slow to respond.
 echo -n " pcmcia"  >/dev/console
 while [ $WAITCNT -lt 10 ];do
  [ "`lsmod | grep -E '^yenta_socket |^tcic |^i82092 |^i82365 |^pd6729 '`" != "" ] && break
  WAITCNT=$(( WAITCNT + 1 ))
  sleep 1
  echo -n " $WAITCNT" >/dev/console
 done
fi
#note, if initrd then usb-storage will have already loaded...
if [ "$PCIUSB" != "" ];then #this may be slow to respond.
 echo -n " usb"  >/dev/console
 PCIUSBNUM=`echo "$PCIUSB" | sort -u | wc -l`
 while [ $WAITCNT -lt 10 ];do
  [ `lsmod | grep -o -E '^ehci_hcd|^ohci_hcd|^uhci_hcd|^xhci_hcd' | wc -l` -ge $PCIUSBNUM ] && break
  WAITCNT=$(( WAITCNT + 1 ))
  sleep 1
  echo -n " $WAITCNT" >/dev/console
 done
fi

#replay uevents from /sys (more interfaces as a consequence of above drivers loaded)...
#note, this also a workaround for kernel 'bug' where entries appear in /sys but no uevent
#gets generated (yes it happens in 2.6.25.x kernel!)

if [ $KERNMAJ -lt 24 ];then #v431
 [ -e /sys/bus/pcmcia/devices ] && NEWPCMCIA="`ls /sys/bus/pcmcia/devices/*/modalias | tr '\n' ' '`"
 [ -e /sys/bus/usb/devices ] && NEWUSB="`ls /sys/bus/usb/devices/*/modalias | tr '\n' ' '`"
 for oneMODALIAS in ${NEWPCMCIA}${NEWUSB}
 do
  onePATH="`dirname $oneMODALIAS`"
  if [ -e ${onePATH}/uevent ];then
   echo add > ${onePATH}/uevent #generates an 'add' uevent.
   sleep 0.02
  fi
 done
else
 #v424 try it a different way, this also fixes ssb devices (such as b43.ko)...
 [ -e /sys/bus/pcmcia/devices ] && NEWPCMCIA="`ls /sys/bus/pcmcia/devices/*/uevent 2>/dev/null | tr '\n' ' '`"
 [ -e /sys/bus/usb/devices ] && NEWUSB="`ls /sys/bus/usb/devices/*/uevent 2>/dev/null | tr '\n' ' '`"
 [ -e /sys/bus/ssb/devices ] && NEWSSB="`ls /sys/bus/ssb/devices/*/uevent 2>/dev/null | tr '\n' ' '`"
 for oneUEVENT in ${NEWPCMCIA}${NEWUSB}${NEWSSB}
 do
  onePATH="`dirname $oneUEVENT`"
  #the check for 'modalias' file is maybe needed for old kernel?...
  [ ! -e "${onePATH}/modalias" ] && [ "`grep 'MODALIAS' "$oneUEVENT"`" = "" ] && continue
  echo add > $oneUEVENT
  sleep 0.02
 done
fi

#wait for usb-storage drives to become available...(already done if initrd)
#note, pup_event_backend_d and udevd both log to this file when load modules
# (the latter via udev handler script /sbin/pup_event_backend_modprobe)...
if [ "`grep 'usb_storage' /tmp/pup_event_module_devpath.log`" != "" ];then #see pup_event_backend_d
 echo -n " usb-storage"  >/dev/console
 while [ $WAITCNT -lt 15 ];do
  [ "`dmesg | grep 'usb-storage: device scan complete'`" != "" ] && break
  sleep 1
  WAITCNT=$(( WAITCNT + 1 ))
  echo -n " $WAITCNT" >/dev/console
 done
 #precaution, make sure have got them all... v412 need sort -u...
 USBSTORAGES=`/bin/dmesg | grep "usb-storage: device found at" | sort -u | wc -l`
 while [ $WAITCNT -lt 15 ];do
  AVAILABLEUSBSTORAGES=`/bin/dmesg | grep "usb-storage: device scan complete" | wc -l`
  [ $AVAILABLEUSBSTORAGES -ge $USBSTORAGES ] && break
  sleep 1
  WAITCNT=$(( WAITCNT + 1 ))
  echo -n " $WAITCNT" >/dev/console
 done
fi

sleep 1 #v411 a bit extra. rerwin reports usb mouse detection problem some hardware.
        #(delay before usb mouse info appears in /proc/bus/input/devices)

status_func 0

_wait_load_average
################WAIT MODULES LOADED##################

##############USER SELECTED MODULES##################
echo "USER SELECTED MODULES"
_daemons  ##+++2012-01-28
while [ "`pidof pup_event_backend_modprobe`" ];do sleep 2;done
#the user can select extra modules to load in the BootManager...
if [ "$ADDLIST" != "" ];then #variable is in /etc/rc.d/MODULESCONFIG
 echo -n "Loading user-selected modules..." >/dev/console
 for MODULE in $ADDLIST
 do
  MPARAMS=""
  if [ `echo -n "$MODULE" | tr ':' ' ' | wc -w` -gt 1 ];then
   MPARAMS="`echo -n "$MODULE" | cut -f 2-9 -d ':' | tr ':' ' '`"
   MODULE="`echo -n "$MODULE" | cut -f 1 -d ':'`"
  fi
  echo -n " $MODULE" >/dev/console
  echo "Loading module $MODULE $MPARAMS"
  firmware_module_func #install firmware tarball. see functions4puppy4.
  #w463 for mwave.ko (modem), do not load module, just the firmware, which has script that correctly loads mwave.ko.
  ###+-+2011-11-06
  #[ "$MODULE" != "mwave" ] && pup_event_backend_modprobe_protect --module=$MODULE && modprobe $MODULE $MPARAMS #v432
  if [ "$MODULE" != "mwave" ] ; then
  [ -r /tmp/pup_event_backend_modprobe_protect_pipe ] || continue
  timeout -t 10 pup_event_backend_modprobe_protect --module=$MODULE  ##timeout does not work with passing DEBUG=1 command parameter before command
  prot=$?
  echo "returnvalue of modprobe_protect='$prot'"
  [ "$prot" = 0 ] && modprobe $VERB $MODULE $MPARAMS
  fi
  ###+-+2011-11-06
 done
 status_func 0
fi

if [ ! "$NO_FBCON" -a ! "$FBCON_FIRST" ];then
modprobe $VERB fbcon #100703 needed by some xorg drivers when exit to console (ex: nouveau).
fi
##############USER SELECTED MODULES##################

###################SETUP SERVICES################
echo "SETUP SERVICES"
echo -n "Setting up services (network, printing, etc.)..." >/dev/console
if [ -h /dev/modem ];then
 DEVM="`readlink /dev/modem`"
 case $DEVM in
  modem) #error, circular link.
   rm -f /dev/modem
   DEVM=""
  ;;
  /dev/*) #wrong format.
   DEVM="`echo -n "$DEVM" | cut -f 3,4 -d '/'`"
   ln $VERB -snf $DEVM /dev/modem
  ;;
 esac
 case $DEVM in
  ttyS[0-9]) #apparently setserial can crash with other modems.
   setserial $VERB -b /dev/modem auto_irq skip_test autoconfig
  ;;
 esac
fi

#had hoped to retire this, but HardInfo needs it...
case $KERNVER in
2.*|3.[0-4].*)
#[ "`lsmod | grep '^usbcore'`" != "" ] &&
mkdir $VERB -p /proc/bus/usb  ##+++2013-03-22 changed to default to
busybox mount $VERB $VERB -t usbfs none /proc/bus/usb
;;
esac

#v408 only needed for 2.6.21.7, as 2.6.25.x loads these automatically...
#v408 kirk: Check for laptop battery...
modprobe $VERB battery
if [ -d /proc/acpi/battery ]; then
 results="`find /proc/acpi/battery -mindepth 1 -type d`"
 if [ ! -z "$results" ]; then
  modprobe $VERB ac
  modprobe $VERB thermal
  modprobe $VERB fan
 else
  rmmod battery
 fi
fi

#100814 100903 record cumulative tx/rx, see also network_tray and rc.shutdown...
UPDATE_MONTH="`LC_TIME=C date +%b`"
read CURRENT_MONTH </var/local/sns/current_month
[ ! "$CURRENT_MONTH" ] && CURRENT_MONTH='none'
if [ "$UPDATE_MONTH" != "$CURRENT_MONTH" ];then
 echo "$UPDATE_MONTH" > /var/local/sns/current_month
 for oneCOUNT in sns/r sns/t pupdial/isp1/r pupdial/isp1/t pupdial/isp2/r pupdial/isp2/t ppp0/r ppp0/t;do
  echo 0 > /var/local/${oneCOUNT}x_bytes_month
 done
fi

#100227 choose default network tool...
NETCHOICE='other' #100304
DEFAULTCONNECT="`cat /usr/local/bin/defaultconnect | tail -n 1 | tr -s " " | cut -f 2 -d " "`"
[ "`grep 'gprs' /usr/local/bin/defaultconnect`" != "" ] && DEFAULTCONNECT='pgprs-connect'
[ "$DEFAULTCONNECT" = "gkdial" ] && DEFAULTCONNECT="pupdial" #for older pups.
case $DEFAULTCONNECT in
 Pwireless2)
  NETCHOICE='Pwireless2'
 ;;
 net-setup.sh)
  NETCHOICE='net-setup.sh'
 ;;
 net_wiz_classic)
  NETCHOICE='net_wiz_classic'
 ;;
 sns)
  NETCHOICE='sns'
 ;;
 *) #try determine which tool was used to setup networking...
  if [ -s /etc/simple_network_setup/connections ];then #100306
   NETCHOICE='sns'
  else
   CHECKOLDWIZ="`ls -1 /etc/*[0-9]mode 2>/dev/null`" #ex: eth0mode, wlan0mode.
   if [ "$CHECKOLDWIZ" != "" -a -d /usr/local/net_setup ];then
    NETCHOICE='net_wiz_classic'
   else
    CHECKNEWWIZ="`ls -1 /etc/network-wizard/network/interfaces 2>/dev/null`"
    if [ "$CHECKNEWWIZ" != "" ];then
     NETCHOICE='net-setup.sh'
    else
     [ -f /usr/local/Pwireless2/interface ] && NETCHOICE='Pwireless2' #100304
    fi
   fi
  fi
 ;;
esac
[ -f /etc/init.d/Pwireless2 ] && chmod 644 /etc/init.d/Pwireless2 #prevent jemimah's script from running. 100304 100513
case $NETCHOICE in
 Pwireless2)
  #this only sets up interface 'lo'...
  /etc/rc.d/rc.network_basic
  #jemimah's script is in /etc/init.d/Pwireless2
  chmod 755 /etc/init.d/Pwireless2 #make executable so it will run.
  #i want to run it right now, as a separate process (rc.services will ignore it)...
  /etc/init.d/Pwireless2 start &
 ;;
 net-setup.sh)
  /etc/rc.d/rc.network &
 ;;
 net_wiz_classic)
  #note, old wizard is located in /usr/local/net_setup.
  /usr/local/net_setup/etc/rc.d/rc.network &
 ;;
 sns) #100306
  /etc/rc.d/rc.network_basic #this only sets up interface 'lo'.
  /usr/local/simple_network_setup/rc.network &
 ;;
 *)
  #100628 shinobar: launch rc.network if eth0 is usable
  #this only sets up interface 'lo'...
  RCNETWORK=/etc/rc.d/rc.network_basic
  # eth0 usable?
  /sbin/ifconfig eth0 >$OUT 2>&1 && [ -x /etc/rc.d/rc.network ] && RCNETWORK=/etc/rc.d/rc.network
  $RCNETWORK &
 ;;
esac

/etc/rc.d/rc.services & #run scripts in /etc/rc.d/init.d

echo -e "\\033[62G\\033[1;33m[backgrounded]\\033[0;39m" >/dev/console #column 62, yellow.
###################SETUP SERVICES################

############RECOGNISE MEDIA DEVICES################
echo "RECOGNISE MEDIA DEVICES"
STATUS=0
echo -n "Recognising media devices..." >/dev/console
#recognise optical drives...
echo -n ' optical' >/dev/console
OPTCNT=1;CDTYPE="";DVDTYPE="";CDBURNERTYPE=""
OPTICALS="`grep '^drive name:' /proc/sys/dev/cdrom/info | grep -o -E 'sr.*|hd.*' | tr '\t' ' '`"
[ -L /dev/cdrom ] && CDTYPE="`readlink /dev/cdrom | cut -f 3 -d '/'`"
[ -L /dev/dvd ] && DVDTYPE="`readlink /dev/dvd | cut -f 3 -d '/'`"
[ -f /etc/cdburnerdevice ] && CDBURNERTYPE="`cat /etc/cdburnerdevice`"
[ "`echo "$OPTICALS" | grep "$CDTYPE"`" ] || CDTYPE="" #no longer exists.
#[[ "$OPTICALS" =~ "$CDTYPE" ]] || CDTYPE=""
[ "`echo "$OPTICALS" | grep "$DVDTYPE"`" ] || DVDTYPE="" #no longer exists.
#[[ "$OPTICALS" =~ "$DVDTYPE" ]] || DVDTYPE=""
[ "`echo "$OPTICALS" | grep "$CDBURNERTYPE"`" ] || CDBURNERTYPE="" #no longer exists.
#[[ "$OPTICALS" =~ "$CDBURNERTYPE" ]] || CDBURNERTYPE=""
for oneOPTICAL in $OPTICALS
do
 oneNUM="`echo -n "$oneOPTICAL" | cut -c 3`"
 [ "$CDTYPE" = "" ]  && CDTYPE="$oneOPTICAL"
 [ "$DVDTYPE" = "" ] && [ "`grep '^Can read DVD' /proc/sys/dev/cdrom/info | head -n 1 | grep -o '[01].*' | sed -e 's/[^01]//g' | cut -c $OPTCNT`" = "1" ] && DVDTYPE="$oneOPTICAL" #100131
 [ "$CDBURNERTYPE" = "" ] && [ "`grep '^Can write CD' /proc/sys/dev/cdrom/info | head -n 1 | grep -o '[01].*' | sed -e 's/[^01]//g' | cut -c $OPTCNT`" = "1" ] && CDBURNERTYPE="$oneOPTICAL" #100131
 OPTCNT=$((OPTCNT + 1))
done
rm -f /dev/cdrom; rm -f /dev/dvd; rm -f /etc/cdburnerdevice
[ "$CDTYPE" ]  && ln $VERB -sf /dev/$CDTYPE /dev/cdrom
[ "$DVDTYPE" ] && ln $VERB -sf /dev/$DVDTYPE /dev/dvd
[ "$CDBURNERTYPE" ] && echo "$CDBURNERTYPE" > /etc/cdburnerdevice
[ "$DVDTYPE" -a "`echo "$DVDTYPE" |grep 'scd'`" ] && hdparm -d1 /dev/$DVDTYPE

echo -n ' input' >/dev/console #100131

test -d /dev/input || mkdir $VERB -p /dev/input
test -c /dev/input/mice || { rm -rf /dev/input/mice; mknod /dev/input/mice c 13 63; }
if [ ! -f /etc/mousedevice ];then
 echo "input/mice" > /etc/mousedevice
 #ln $VERB -snf input/mice /dev/mouse
else
 [ "`cat /etc/mousedevice`" = "psaux" ] && echo "input/mice" > /etc/mousedevice
fi
read MOUSEDEVICE_ </etc/mousedevice
ln $VERB -snf $MOUSEDEVICE_ /dev/mouse


#recognise keyboard...moved into xorgwizard
echo -n ' keyboard' >/dev/console
f=/etc/rc.d/rc.country
[ -f "$f" -a -x "$f" -a -s "$f" ] && { /etc/rc.d/rc.country;STATUS=$((STATUS+$?)); } #this asks for keyboard layout.

status_func $STATUS
############RECOGNISE MEDIA DEVICES################

############MISC DESKTOP STUFF##################
echo "MISC. DESKTOP STUFF"
if [ "$PUPMODE" = "77" ];then #77=multisession cd/dvd.
 if [ "`cat /root/Choices/ROX-Filer/PuppyPin | grep "savesession"`" = "" ];then
  echo '<icon x="768" y="128" label="save">/usr/sbin/savesession-dvd</icon>' >> /root/Choices/ROX-Filer/PuppyPin
  cat /root/Choices/ROX-Filer/PuppyPin | grep -v '/pinboard' > /tmp/PuppyPin-CPY
  sync
  cp -f /tmp/PuppyPin-CPY /root/Choices/ROX-Filer/PuppyPin
  echo '</pinboard>'   >> /root/Choices/ROX-Filer/PuppyPin
 fi
fi

#save button on desktop when booted from flash drive...
if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then #pup_rw is tmpfs.
 if [ "`cat /root/Choices/ROX-Filer/PuppyPin | grep "save2flash"`" = "" ];then
  echo '<icon x="768" y="128" label="save">/usr/sbin/save2flash</icon>' >> /root/Choices/ROX-Filer/PuppyPin
  cat /root/Choices/ROX-Filer/PuppyPin | grep -v '/pinboard' > /tmp/PuppyPin-CPY
  sync
  cp -f /tmp/PuppyPin-CPY /root/Choices/ROX-Filer/PuppyPin
  echo '</pinboard>'   >> /root/Choices/ROX-Filer/PuppyPin
 fi
fi
############MISC DESKTOP STUFF##################
_wait_load_average

###################PERSONAL BOOT SCRIPT######################
echo "PERSONAL BOOT SCRIPT"
#personal boot script here...
if [ ! -f /etc/rc.d/rc.local ];then
 echo '#this file called from rc.sysinit' > /etc/rc.d/rc.local
 echo '#you can edit this file' >> /etc/rc.d/rc.local
 echo '#When firewall is installed, will append lines to this file...' >> /etc/rc.d/rc.local
fi
. /etc/rc.d/rc.local
###################PERSONAL BOOT SCRIPT######################

##### fsckme.flg
#100316 improper shutdown check. see above, also rc.shutdown and /sbin/init...
if test "$PUPMODE" = 2; then #if no /initrd, full hd install.
 [ $PDEV1 ] || PDEV1="`/bin/df | grep ' /$' | grep -m1 '^/dev/' | cut -f 1 -d ' ' | cut -f 3 -d '/'`"
 #[ $DEV1FS ] || DEV1FS="`mount | grep ' on / ' | grep -m1 '^/dev/' | cut -f 5 -d ' '`"
  [ $DEV1FS ] || DEV1FS=`awk '/^\/dev\/root \/ / { print $3 }' /proc/mounts`
if [ "$PDEV1" -a "$DEV1FS" ];then
  [ "`grep '^PDEV1' /etc/rc.d/PUPSTATE`" = "" ]  && echo "PDEV1='$PDEV1'"   >> /etc/rc.d/PUPSTATE
  [ "`grep '^DEV1FS' /etc/rc.d/PUPSTATE`" = "" ] && echo "DEV1FS='$DEV1FS'" >> /etc/rc.d/PUPSTATE
  #this file gets removed by rc.shutdown if a proper shutdown...
  echo "${PDEV1},${DEV1FS}," > /fsckme.err #ex: sda7,ext3,
 fi
else
 [ "$PUPSAVE" ] && echo "$PUPSAVE" > /initrd${PUP_HOME}/fsckme.err #ex: sda7,ext3,/pupsave-10MAR2010.2fs
fi

fsckme_func_rc_shutdown(){ ###krg Mar112011:turned into func to call at end of script
#100315 improper shutdown check. see /etc/rc.d/rc.sysinit, /init in initramfs, and /sbin/init...
[ -f /boot/.fsckme.err ] && rm -f /boot/.fsckme.err
[ -f /initrd${PUP_HOME}/boot/.fsckme.err ] && rm -f /initrd${PUP_HOME}/boot/.fsckme.err
}
##### fsckme.flg

dmesg > /tmp/bootkernel.log.`date +%d%b%Y`
echo >> /tmp/bootkernel.log.`date +%d%b%Y`
date >> /tmp/bootkernel.log.`date +%d%b%Y`
cp /var/log/messages /tmp/boot.messages
cp /var/log/messages.0 /tmp/boot.messages.0

__previous_X_status__(){
if [ -z "`cat /proc/cmdline | grep -i 'nox'`" ]; then
echo 'X' > /tmp/X.status
else
echo 'nox' > /tmp/X.status
fi
}

if [ -z "`grep -iE 'pfix=nox|pfix=.*,nox' /proc/cmdline`" ]; then
# REM: 2014-12-12
#      Reverse the existance of /tmp/bootcnt.touch
#      Formerly if the file did not exist, /etc/profile would
#      create it and start xwin
#      Now create it here and if it exist,
#      remove it by /etc/profile and start xwin
# TODO: handle multiple autologinroot in /etc/inittab to prevent
#        races of several xwin executions ( also here for F11 console )
# TODO: handle /init in initrd.gz
touch /tmp/bootcnt.touch
fi

[ -c /dev/ppp ]   || mknod /dev/ppp c 108 0
[ -L /dev/mouse ] || ln $VERB -s /dev/input/mice /dev/mouse
[ -c /dev/mem ]   || mknod /dev/mem c 1 1



#that's it. next stop is /etc/profile...
###END###
