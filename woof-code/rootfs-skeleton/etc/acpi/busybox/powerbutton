#!/bin/ash +e
# Karl Reimer Godt in June 2012
# usual Puppy license
Version='1.1 Puppy_Macpup-Foxy3 KRG'
echo "$0:$Version:$*"
. /etc/rc.d/f4puppy5

# Power button pressed 5 times in 10 seconds : poweroff force
_check_if_already_running ${0##*/} || {
 [ -f /tmp/acpi_button_count ] && {
     read BUTTONcnt </tmp/acpi_button_count
     BUTTONcnt=$((BUTTONcnt+1))
     echo $BUTTONcnt >/tmp/acpi_button_count
     true
    } || echo 2 >/tmp/acpi_button_count
  [ "$BUTTONcnt" = 5 ] && {
      ( sleep 2; killall -9 ${0##*/} ) &
      exec /sbin/poweroff force
  }
  sleep 10
  rm -f /tmp/acpi_button_count
  exit 1
}

test "$DISPLAY" || export DISPLAY=':0'

aplay /usr/share/audio/2barks.au
xmessage -title "POWERBUTTON ACKNOWLEDGE" -timeout 10 "HELLO from `pwd`/$0"

_usage(){
MSG="
$0 [help|version]
Script to suspend or hibernate
called by busybox applet 'acpid'.
Busybox acpid since version 1.18 needs
the 'evdev' kernelmodule loaded , but
seems not to need the 'button' module.
Works only with the Powerbutton,
not with closing the lid.
Please don't call busybox applets with
'busybox appletname' . Closing commands like
kill could accidentaly kill busybox init, which
would result in immedeate reboot. Always call it with
the [/path/to/link/]appletname.

Uses acpitool if installed, otherwise the
simple 'echo \"\$state\" >/sys/power/state' .

Full acpid pkg available : unknown.
"
if [ "$2" ];then
MSG="$MSG

$2
"
fi
echo "$MSG"
[ "$DISPLAY" ] && xmessage -title "POWERBUTTON HELP" -bg blue3 -fg white "$MSG"
rm -f /tmp/acpi_button_count
exit $1
}

case $1 in
*help) _usage 0;;
*version) echo -e "$0: Version '$Version'\nTry help for more info.\n";rm -f /tmp/acpi_button_count;exit 0;;
"") :;;
*force) :;; #from enlightenment Bereitschaftsmodus
*) _usage 1 "Unknown Parameter '$1'";;
esac
echo 52
pidof sync >>$OUT || sync
echo 54

_loop_umount_func(){
                    local M_LOOP mloop_ yPID

M_LOOP=`mount | grep -E '^/dev/loop[0-9]? ' |grep -v '/initrd'`
M_LOOP=`echo $M_LOOP |rev|sed 's! )!\n)!g'|rev`
M_LOOP=`echo "$M_LOOP" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`

for mloop_ in $M_LOOP;
do
    yaf-splash -bg pink1 -text "Unmounting $mloop_ ..." & yPID=$!
    /bin/umount $VERB -r "$mloop_"
[ $? -ne 0 ] && { xmessage -title "POWERBUTTON LOOP UMOUNT FAIL" -bg red2 "Please umount '$mloop_' manually and try again";rm -f /tmp/acpi_button_count;exit 0; }
    sleep 1
    kill $yPID
done
}
echo 64

rootSCREEN_XY=`_get_screen_resolution`    || rootSCREEN_XY=800x600+0+0
 rootCENTER_X=$((${rootSCREEN_XY%%x*}/2))
 rootCENTER_Y=`expr $(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}') / 2`

_part_umount_func(){
                    local M_POI M_OPS mpart_ yPID
#M_DEV=`mount | grep -E '^/dev/[shfmdr][^ ]*[0-9]? ' |grep -vE '/initrd|^/dev/root|rootfs|^/dev/ram|^/dev/md|^/dev/mtd|^/dev/nbd'`
#M_DEV=`echo $M_DEV |rev|sed 's! )!)\n!g'|rev`
#M_DEV=`awk '{if (match($1, "/dev/[fhms][dmr][[:alnum:]].*[0-9]?$")) print $1}' /proc/mounts`
##M_DEV=`grep -E "^/dev/[fhms][dmr][[:alnum:]].*[0-9]?$" /proc/mounts`
#M_DEV=`grep -E "^/dev/[fhms][dmr][[:alnum:]][^ ]*[0-9]? " /proc/mounts`
 MOUNTED=`tac /proc/mounts |grep -E "^/dev/[fhms][dmr][[:alnum:]][^ ]*[0-9]? "`
#M_POI=`echo "$M_DEV" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`
 M_POI=`echo "$MOUNTED" | awk '{print $2}'`
 M_POI=`echo -e "$M_POI"`
 M_OPS=`echo "$MOUNTED" | awk '{print $4}'`
 M_OPS=`echo -e "$M_OPS"`
#M_DEV=`echo "$M_DEV" |grep -o '.* on ' |sed -r 's!(.*)( on )!\1!'`
 M_DEV=`echo "$MOUNTED" | awk '{print $1}'`
 M_DEV=`echo -e "$M_DEV"`

for mpart_ in $M_POI;
do

    ## BIG PROBLEM un-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/umount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 5 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 1 Exit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # xmessage -bg orange "Slow drive '$mpart_' is mounted ..!
    # Please un-mount it manually,
    # and try to put the machine to sleep again !!"
    # exit 1
    #;;
    #esac

    ## Solution Nr. 3 Omit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    yaf-splash -bg pink -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Unmounting $mpart_ ..." & yPID=$!

    ##Solution Nr. 2 and 4 Reasonable and BIG sleep :
    case $mpart_ in
    */sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    esac

    /bin/umount $VERB -r "$mpart_"
[ $? -ne 0 ] && { xmessage -title "POWERBUTTON UMOUNT FAIL" -bg red2 "Please umount '$mpart_' manually and try again";rm -f /tmp/acpi_button_count;exit 0; }

    ## Solution Nr. 2 Reasonable sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 15 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 15 seconds.." &
    # sleep 15;;
    #esac

    ## Solution Nr. 4 BIG sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to stop the drive
    case $mpart_ in
     */sr[0-9]*|*/scd[0-9]*)
      hdparm $L_VERB -C /dev/${mpart_##*/} | grep $Q 'active' && {
           MSG="ERROR: Drive '/dev/${mpart_##*/}' still recognized as active.
           Exiting ${PWD}/${0}."
           MSG=`echo "$MSG" | sed 's%^[[:blank:]]*%%'`
           xmessage -bg red -title "$MY_SELF" "$MSG"
           rm -f /tmp/acpi_button_count
           exit 5
      }
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C stop /dev/${mpart_##*/}
      sleep 17
     ;;

     */hd[a-d])
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB -Y /dev/${mpart_##*/}
      sleep 17
     ;;

     */fd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

    sleep 1
    kill $yPID
done
}
echo 87

_restore_mounts(){
                    local part_ basn FS_TYPE reMOUNT mntOPS yPID
for part_ in $M_DEV;
do

    ## BIG PROBLEM re-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/mount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 4 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 2 and 3 Omit to un- and or re-mount :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    yaf-splash -bg purple -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Restoring mount of $part_ ..." & yPID=$!

        grep $Q -w "$part_" /proc/mounts && reMOUNT='remount,'
        mntOPS=`echo "$MOUNTED" | grep -m1 -w "^$part_" | awk '{print $4}'`
            [ "$mntOPS" ] || mntOPS=rw
        FS_TYPE=`guess_fstype $part_`

    ##Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to wake-up the drive
    case $part_ in
     */sr[0-9]*|*/scd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C start $part_
      sleep 17
     ;;

     */hd[a-d])
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB --idle-immediate $part_
      sleep 17
     ;;

     */fd[0-9]*)
      yaf-splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

        basn=${part_##*/}
        mkdir -p /mnt/$basn

[ "$FS_TYPE" = unknown -o "$FS_TYPE" = "" ] && {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS             $part_ /mnt/$basn || true
} || {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS -t $FS_TYPE $part_ /mnt/$basn || false
}

    ## Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg purple3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    sleep 1
    kill $yPID
    unset reMOUNT mntOPS FS_TYPE
done
}
echo 96

_set_usb_power_sysfs_values(){

local KBD_WAKEUP_ENABLED MOU_WAKEUP_ENABLED OTH_WAKEUP_ENABLED
KBD_WAKEUP_ENABLED=1
MOU_WAKEUP_ENABLED=
OTH_WAKEUP_ENABLED=1

local KBD_CONTROL MOU_CONTROL OTH_CONTROL
KBD_CONTROL=on
MOU_CONTROL=auto
OTH_CONTROL=auto

local KBD_DELAY KBD_DELAY_MS MOU_DELAY MOU_DELAY_MS OTH_DELAY OTH_DELAY_MS
KBD_DELAY=360  # seconds
KBD_DELAY_MS=$((KBD_DELAY*1000))
MOU_DELAY=360  # seconds
MOU_DELAY_MS=$((MOU_DELAY*1000))
OTH_DELAY=360  # seconds
OTH_DELAY_MS=$((OTH_DELAY*1000))


ls -1d /sys/bus/usb/devices/*/power/ | while read oneD;
do
  [ -f "$oneD"/control ] || continue  #+++2.6.34
  [ -f "$oneD"/level   ] || continue  #+++2.6.22 level and control same
  [ -f "$oneD"/wakeup  ] || continue  #
     #2.6.21/2.6.22            #2.6.37/2.6.38
  [ -f "$oneD"/autosuspend -o -f "$oneD"/autosuspend_delay_ms ] || continue

 _debug "oneD='$oneD'"

 if [ -f "$oneD/../uevent" ]; then
  _debug "`cat "$oneD"/../uevent`"
  source "$oneD/../uevent"
 fi
 if [ -f "$oneD/../product" ]; then
  _debug "`cat "$oneD"/../product`"
  grep $Q -Ei 'Keyboard'          "$oneD/../product" && IS_KBD=YES
  grep $Q -Ei 'Mouse|Transceiver' "$oneD/../product" && IS_MOU=YES
 fi
 if [ -f "$oneD/../interface" ]; then
  _debug "`cat "$oneD"/../interface`"
  grep $Q -Ei 'Keyboard'          "$oneD/../interface" && IS_KBD=YES
  grep $Q -Ei 'Mouse|Transceiver' "$oneD/../interface" && IS_MOU=YES
 fi

 _debugx "$(ls -1v "$oneD"/* | while read oneF; do [ -f "$oneF" ] || continue; echo -n "$oneF"':';cat "$oneF"; done)"


  read HAVE_WAKEUP <"$oneD"/wakeup

   if [ "$IS_KBD" ]; then
  case $HAVE_WAKEUP in
  enabled)   [ "$KBD_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$KBD_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for kbd '$oneD'";;
  esac

 elif [ "$IS_MOU" ]; then
  case $HAVE_WAKEUP in
  enabled)   [ "$MOU_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$MOU_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for '$oneD'";;
  esac

 else
  case $HAVE_WAKEUP in
  enabled)   [ "$OTH_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$OTH_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for '$oneD'";;
  esac
  fi

  read HAVE_CONTROL <"$oneD"/control

    if [ "$IS_KBD" ]; then
   case $HAVE_CONTROL in
   on)    [ "$KBD_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$KBD_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac

  elif [ "$IS_MOU" ]; then
   case $HAVE_CONTROL in
   on)    [ "$MOU_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$MOU_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac

  else
   case $HAVE_CONTROL in
   on)    [ "$OTH_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$OTH_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac
  fi

  read HAVE_LEVEL <"$oneD"/level
  _debug "HAVE_LEVEL='$HAVE_LEVEL'"

  if [ -f "$oneD"/autosuspend ] ; then
   read HAVE_DELAY <"$oneD"/autosuspend
   _debug "HAVE_DELAY='$HAVE_DELAY'"

   if [ "$IS_KBD" ]; then
    [ "$KBD_DELAY" = $HAVE_DELAY ] || echo $KBD_DELAY >"$oneD"/autosuspend
   elif [ "$IS_MOU" ]; then
    [ "$MOU_DELAY" = $HAVE_DELAY ] || echo $MOU_DELAY >"$oneD"/autosuspend
   else
    [ "$OTH_DELAY" = $HAVE_DELAY ] || echo $OTH_DELAY >"$oneD"/autosuspend
   fi

  elif [ -f "$oneD"/autosuspend_delay_ms ]; then
   read HAVE_DELAY <"$oneD"/autosuspend_delay_ms
   _debug "HAVE_DELAY='$HAVE_DELAY'"

   if [ "$IS_KBD" ]; then
    [ "$KBD_DELAY_MS" = $HAVE_DELAY ] || echo $KBD_DELAY_MS >"$oneD"/autosuspend_delay_ms
   elif [ "$IS_MOU" ]; then
    [ "$MOU_DELAY_MS" = $HAVE_DELAY ] || echo $MOU_DELAY_MS >"$oneD"/autosuspend_delay_ms
   else
    [ "$OTH_DELAY_MS" = $HAVE_DELAY ] || echo $OTH_DELAY_MS >"$oneD"/autosuspend_delay_ms
   fi
  fi

  unset HAVE_WAKEUP HAVE_CONTROL HAVE_LEVEL HAVE_DELAY IS_KBD IS_MOU

 echo
done

local HAVE_WAKEUP HAVE_CONTROL HAVE_LEVEL HAVE_DELAY IS_KBD IS_MOU
}
_set_usb_power_sysfs_values

ACPITOOL=`which acpitool`
states_avail=`cat /sys/power/state`
states_avail_=`echo "$states_avail" |tr ' ' '\n'|sed 's!disk!S4 Hibernation on disk!;s!mem!S3 PM_SLEEP in mem!;s!standby!S1 Stand By!'`
echo 102

aplay /usr/share/audio/2barks.au
xmessage -title "POWERBUTTON STATES" -timeout 20 -bg red1 "$0
Available states:
$states_avail_
"
echo 108

for st_ in $states_avail
do
    case $st_ in
    *freeze*)   BUTTON_FREEZE=freeze:190;;
    *standby*)  BUTTON_STANDBY=standby:188;;
    *mem*)      BUTTON_MEM="RAM sleep:203";;
    *disk*)     BUTTON_DISK="hibernate on swap partition:204";;
        *)          _warn "Unhandled ACPI state '$st_'";;
    esac
done


test "$BUTTON_DISK"    && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_DISK"
test "$BUTTON_MEM"     && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_MEM"
test "$BUTTON_STANDBY" && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_STANDBY"
test "$BUTTON_FREEZE"  && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_FREEZE"

BUTTONS_GUI="${BUTTONS_GUI},DO NOTHING:200"
BUTTONS_GUI=`echo "$BUTTONS_GUI" | sed 's%^,*%%;s%,*$%%'`

#xmessage -timeout 30 -buttons "HIBERNATE On DISK:204,RAM SLEEP:203,ESCAPE GUI:200" -bg blue3 -fg white "Busybox acpid :
 xmessage -timeout 30 -buttons "$BUTTONS_GUI" -title "POWERBUTTON MENU" -bg blue3 -fg white "Busybox acpid :
Do you want to go into one of the ACPI PM SLEEP modes ?
Note : Timesout in 30 seconds to poweroff normally."
ANSWER=$?
echo 113
if [ "$ANSWER" = 200 ];then
rm -f /tmp/acpi_button_count
exit 0

elif [ "$ANSWER" = 203 ];then

_handle_no_console_suspend(){    ##2014-10-18
test -f  /sys/module/printk/parameters/console_suspend || { _notice "File
/sys/module/printk/parameters/console_suspend
not in sysfs."; return 1; }

grep $Q -w no_console_suspend /proc/cmdline && {
 if [ "$VERBOSE" ]; then
  echo -n 'Content of sysfs file
     /sys/module/printk/parameters/console_suspend:'
 cat /sys/module/printk/parameters/console_suspend
 fi
echo N >/sys/module/printk/parameters/console_suspend
return $?
 }
return $?
}
_handle_no_console_suspend    ##2014-10-18

pidof sync >>$OUT || sync
_loop_umount_func
_part_umount_func
pidof sync >>$OUT || sync
sleep 1

   if [ "$ACPITOOL" ];then
    acpitool -s
   else
    echo 'mem' >/sys/power/state
   fi

sleep 5
_restore_mounts



elif [ "$ANSWER" = 204 ];then
pidof sync >>$OUT || sync
_loop_umount_func
_part_umount_func
pidof sync >>$OUT || sync
sleep 1

   #if [ "$ACPITOOL" ];then
   PROC_SWAPS=`cat /proc/swaps |sed '1d'|awk '{print $1}'`
      for swap in $PROC_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    if [ ! "$RESUME" ];then
    FDISK_SWAPS=`fdisk -l |grep -i swap|awk '{print $1}'`
      for swap in $FDISK_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    fi
      if [ "$RESUME" ];then
         for swap in $PROC_SWAPS;
         do
            [ "$swap" = "$RESUME" ] && continue
            swapoff $swap
         done
      swapon $RESUME
      fi

      pidof sync >>$OUT || sync
      sleep 1

      if [ "$ACPITOOL" ];then
       acpitool -S
      else
       echo 'disk' >/sys/power/state
      fi

      sleep 1
      for swap in $PROC_SWAPS;
      do
       swapon $swap
      done

      if [ "$RESUME" ];then
       if test cat /proc/swaps |sed '1d' |wc -l -gt 1;then
        swapoff $RESUME
       fi
      fi

   #else #acpitool
   #  echo 'disk' >/sys/power/state
   #fi

sleep 5
_restore_mounts

elif [ "$ANSWER" = 188 ]; then  #standby
    echo standby >/sys/power/state

elif [ "$ANSWER" = 190 ]; then  #freeze
    echo freeze >/sys/power/state

else # timeout 0, error 1
 unset DISPLAY
 if test "`pidof X`"; then
 wmpoweroff force
 sleep 5
 pidof poweroff rc.shutdown >>$OUT || exec /sbin/poweroff force
 rm -f /tmp/acpi_button_count
 exit $?
 else
 exec /sbin/poweroff force
 fi
fi

sleep 5
aplay /usr/share/audio/2barks.au
case $ANSWER in
203)
xmessage -title "POWERBUTTON WAKEUP MESSAGE" "RETURNED from RAM light sleep"
;;
204)
xmessage -title "POWERBUTTON WELCOME BACK MESSAGE" "RETURNED from DISK winter sleep"
;;
*) :;;
esac

rm -f /tmp/acpi_button_count
exit 0
