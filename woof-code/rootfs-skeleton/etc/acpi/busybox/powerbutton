#!/bin/ash
# Karl Reimer Godt in June 2012
# usual Puppy license
Version='1.1 Puppy_Macpup-Foxy3 KRG'
echo "
$0:$Version:$*"
. /etc/rc.d/f4puppy5

# Power button pressed 5 times in 10 seconds : poweroff force
_check_if_already_running ${0##*/} || {
 [ -f /tmp/acpi_button_count ] && {
     read BUTTONcnt </tmp/acpi_button_count
     BUTTONcnt=$((BUTTONcnt+1))
     echo $BUTTONcnt >/tmp/acpi_button_count
     true
    } || echo 2 >/tmp/acpi_button_count
  [ "$BUTTONcnt" = 5 ] && {
      ( sleep 2; killall -9 ${0##*/} ) &
      exec /sbin/poweroff force
  }
  sleep 10
  rm -f /tmp/acpi_button_count
  exit 1
}

test "$DISPLAY" || { pidof X >>$OUT && export DISPLAY=':0'; }

_xmessage(){

[ "$DISPLAY" ] && {
 xmessage "$@"
true
 } || {
 echo "${*##*-title}"
 }
}

aplay /usr/share/audio/2barks.au
_xmessage -timeout 10 -title "POWERBUTTON ACKNOWLEDGE" "HELLO from `pwd`/$0"

_usage(){
MSG="
$0 [help|version]
Script to suspend or hibernate
called by busybox applet 'acpid'.
Busybox acpid since version 1.18 needs
the 'evdev' kernelmodule loaded , but
seems not to need the 'button' module.
Works only with the Powerbutton,
not with closing the lid.
Please don't call busybox applets with
'busybox appletname' . Closing commands like
kill could accidentaly kill busybox init, which
would result in immedeate reboot. Always call it with
the [/path/to/link/]appletname.

Uses acpitool if installed, otherwise the
simple 'echo \"\$state\" >/sys/power/state' .

Full acpid pkg available : unknown.
"
if [ "$2" ];then
MSG="$MSG

$2
"
fi
echo "$MSG"
[ "$DISPLAY" ] && xmessage -bg blue3 -fg white -title "POWERBUTTON HELP" "$MSG"
rm -f /tmp/acpi_button_count
exit $1
}

case $1 in
*help) _usage 0;;
*version) echo -e "$0: Version '$Version'\nTry help for more info.\n";rm -f /tmp/acpi_button_count;exit 0;;
"") :;;
*force) :;; #from enlightenment Bereitschaftsmodus
*) _usage 1 "Unknown Parameter '$1'";;
esac

LINEP=BEFORESYNC01
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"
pidof sync >>$OUT || sync
LINEP=AFTERSYNC01
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

_loop_umount_func(){
                    local M_LOOP mloop_ yPID

M_LOOP=`mount | grep -E '^/dev/loop[0-9]? ' |grep -v '/initrd'`
M_LOOP=`echo $M_LOOP |rev|sed 's! )!\n)!g'|rev`
M_LOOP=`echo "$M_LOOP" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`

for mloop_ in $M_LOOP;
do
    _yaf_splash -bg pink1 -text "Unmounting $mloop_ ..." & yPID=$!
    /bin/umount $VERB -r "$mloop_"
[ $? -ne 0 ] && { _xmessage -bg red2 -title "POWERBUTTON LOOP UMOUNT FAIL" "Please umount '$mloop_' manually and try again";rm -f /tmp/acpi_button_count;exit 0; }
    sleep 1
    kill $yPID
done
}
LINEP=A001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

rootSCREEN_XY=`_get_screen_resolution`    || rootSCREEN_XY=800x600+0+0
 rootCENTER_X=$((${rootSCREEN_XY%%x*}/2))
 #rootCENTER_Y=`expr $(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}') / 2`
 _Y_=$(echo "$rootSCREEN_XY" | awk -F'[x+]' '{print $2}')
 rootCENTER_Y=$((_Y_ / 2))

_yaf_splash(){

[ "$DISPLAY" ] && {
 yaf-splash "$@"
  true
 } || {
 echo "${*##*-text}"
 }
}

__xmessage(){

local RV SELECT
unset RV SELECT

[ "$DISPLAY" ] && {
 xmessage "$@"
 return $?
 } || {

 echo "${*##*-title}"
 echo "
$BUTTONS_GUI
"
 while [ selecting ];
 do
  read -t30 -p "Select one of the above numbers #: " SELECT
   RV=$?
   if [ ! "$SELECT" ]; then
    case $RV in
    0) continue;;
    1)  exit;;  #exec /sbin/poweroff force;;
    *) echo RV=$RV; continue;;
    esac
   else
    case $SELECT in
     204|203|200|190|188) break;;
     *) echo "Error - wrong entry '$SELECT'";;
    esac
   fi
  sleep 1
 done
return $SELECT
 }

}

_part_umount_func(){
                    local M_POI M_OPS mpart_ yPID
#M_DEV=`mount | grep -E '^/dev/[shfmdr][^ ]*[0-9]? ' |grep -vE '/initrd|^/dev/root|rootfs|^/dev/ram|^/dev/md|^/dev/mtd|^/dev/nbd'`
#M_DEV=`echo $M_DEV |rev|sed 's! )!)\n!g'|rev`
#M_DEV=`awk '{if (match($1, "/dev/[fhms][dmr][[:alnum:]].*[0-9]?$")) print $1}' /proc/mounts`
##M_DEV=`grep -E "^/dev/[fhms][dmr][[:alnum:]].*[0-9]?$" /proc/mounts`
#M_DEV=`grep -E "^/dev/[fhms][dmr][[:alnum:]][^ ]*[0-9]? " /proc/mounts`
 MOUNTED=`tac /proc/mounts |grep -E "^/dev/[fhms][dmr][[:alnum:]][^ ]*[0-9]? "`
#M_POI=`echo "$M_DEV" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`
 M_POI=`echo "$MOUNTED" | awk '{print $2}'`
 M_POI=`echo -e "$M_POI"`
 M_OPS=`echo "$MOUNTED" | awk '{print $4}'`
 M_OPS=`echo -e "$M_OPS"`
#M_DEV=`echo "$M_DEV" |grep -o '.* on ' |sed -r 's!(.*)( on )!\1!'`
 M_DEV=`echo "$MOUNTED" | awk '{print $1}'`
 M_DEV=`echo -e "$M_DEV"`

for mpart_ in $M_POI;
do

    ## BIG PROBLEM un-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/umount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 5 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 1 Exit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # xmessage -bg orange "Slow drive '$mpart_' is mounted ..!
    # Please un-mount it manually,
    # and try to put the machine to sleep again !!"
    # exit 1
    #;;
    #esac

    ## Solution Nr. 3 Omit :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    _yaf_splash -bg pink -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Unmounting $mpart_ ..." & yPID=$!

    ##Solution Nr. 2 and 4 Reasonable and BIG sleep :
    case $mpart_ in
    */sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    esac

    /bin/umount $VERB -r "$mpart_"
[ $? -ne 0 ] && { _xmessage -bg red2 -title "POWERBUTTON UMOUNT FAIL" "Please umount '$mpart_' manually and try again";rm -f /tmp/acpi_button_count;exit 0; }

    ## Solution Nr. 2 Reasonable sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 15 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 15 seconds.." &
    # sleep 15;;
    #esac

    ## Solution Nr. 4 BIG sleep :
    #case $mpart_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to stop the drive
    case $mpart_ in
     */sr[0-9]*|*/scd[0-9]*)
      hdparm $L_VERB -C /dev/${mpart_##*/} | grep $Q 'active' && {
           MSG="ERROR: Drive '/dev/${mpart_##*/}' still recognized as active.
           Exiting ${PWD}/${0}."
           MSG=`echo "$MSG" | sed 's%^[[:blank:]]*%%'`
           _xmessage -bg red -title "$MY_SELF" "$MSG"
           rm -f /tmp/acpi_button_count
           exit 5
      }
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C stop /dev/${mpart_##*/}
      sleep 17
     ;;

     */hd[a-d])
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB -Y /dev/${mpart_##*/}
      sleep 17
     ;;

     */fd[0-9]*)
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

    sleep 1
    kill $yPID
done
}
LINEP=B001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

_restore_mounts(){
                    local part_ basn FS_TYPE reMOUNT mntOPS yPID
for part_ in $M_DEV;
do

    ## BIG PROBLEM re-mounting slow devices like CD drives and Floppy drives!
    ## Puppy's /bin/mount may run probedisk2
    ## with guess_fstype and disktype to determine the file-system type
    ## and both spin-up the CD drive, disktype really heavily.
    ## My old worn out CD drive takes up to two minutes before stopping spinning.
    ## Un-mounting works, but re-mounting after waking up leads to kernel driver errors.
    ## 4 Solutions, I could think of:
    ## S1 : Demanding the USER to un-mount manually and try again and exit.
    ## S2 : Unmount the drives with a reasonable sleep of 30 seconds, and omitting them to re-mount after wake-up.
    ## S3 : Omitting un- and remounting the drives completely
    ## S4 : BIG sleep of 150 seconds after un-mounting and re-mounting.
    ## S5 : Use hdparm and sdparm

    ## Solution Nr. 2 and 3 Omit to un- and or re-mount :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 1; continue;;
    #esac

    _yaf_splash -bg purple -geometry +${rootCENTER_X}+${rootCENTER_Y} -text "Restoring mount of $part_ ..." & yPID=$!

        grep $Q -w "$part_" /proc/mounts && reMOUNT='remount,'
        mntOPS=`echo "$MOUNTED" | grep -m1 -w "^$part_" | awk '{print $4}'`
            [ "$mntOPS" ] || mntOPS=rw
        FS_TYPE=`guess_fstype $part_`

    ##Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d]) sleep 15;;
    #esac

    ## Solution Nr. 5 use hdparm and or sdparm to wake-up the drive
    case $part_ in
     */sr[0-9]*|*/scd[0-9]*)
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      sdparm $VERB -C start $part_
      sleep 17
     ;;

     */hd[a-d])
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 8
      hdparm $L_VERB --idle-immediate $part_
      sleep 17
     ;;

     */fd[0-9]*)
      _yaf_splash -timeout 25 -bg pink3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 25 seconds.." &
      sleep 25
     ;;
    esac

        basn=${part_##*/}
        mkdir -p /mnt/"$basn"

[ "$FS_TYPE" = unknown -o "$FS_TYPE" = "" ] && {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS             "$part_" /mnt/"$basn" || true
} || {
  /bin/mount $VERB -o ${reMOUNT}$mntOPS -t $FS_TYPE "$part_" /mnt/"$basn" || false
}

    ## Solution Nr. 4 BIG sleep :
    #case $part_ in
    #*/sr[0-9]*|*/fd[0-9]*|*/scd[0-9]*|*/hd[a-d])
    # yaf-splash -timeout 150 -bg purple3 -geometry +$((rootCENTER_X-100))+$((rootCENTER_Y-25)) -text "Floppy disk or CD drive, please wait 150 seconds.." &
    # sleep 150;;
    #esac

    sleep 1
    kill $yPID
    unset reMOUNT mntOPS FS_TYPE
done
}
LINEP=C001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

__set_usb_power_sysfs_values__(){

# wake up enabled : Device can trigger wake up while S3 RAM sleep
local KBD_WAKEUP_ENABLED MOU_WAKEUP_ENABLED OTH_WAKEUP_ENABLED
KBD_WAKEUP_ENABLED=1
MOU_WAKEUP_ENABLED=
OTH_WAKEUP_ENABLED=1

# control : autosuspend values : on = never autosuspend , auto = let kernel decide
local KBD_CONTROL MOU_CONTROL OTH_CONTROL
KBD_CONTROL=on
MOU_CONTROL=auto
OTH_CONTROL=auto

# delay : seconds/milliseconds to pass by idle before autosuspending
local KBD_DELAY KBD_DELAY_MS MOU_DELAY MOU_DELAY_MS OTH_DELAY OTH_DELAY_MS
KBD_DELAY=360  # seconds
KBD_DELAY_MS=$((KBD_DELAY*1000))
MOU_DELAY=360  # seconds
MOU_DELAY_MS=$((MOU_DELAY*1000))
OTH_DELAY=360  # seconds
OTH_DELAY_MS=$((OTH_DELAY*1000))


ls -1d /sys/bus/usb/devices/*/power/ | while read oneD;
do
  [ -f "$oneD"/control ] || continue  #+++2.6.34 35
  [ -f "$oneD"/level   ] || continue  #+++2.6.22 level and control same , depr. 2.6.35
  [ -f "$oneD"/wakeup  ] || continue  #
     #2.6.21/2.6.22            #2.6.37/2.6.38
  [ -f "$oneD"/autosuspend -o -f "$oneD"/autosuspend_delay_ms ] || continue

 _debug "oneD='$oneD'"

 if [ -f "$oneD/../uevent" ]; then
  _debug "`cat "$oneD"/../uevent`"
  source "$oneD/../uevent"
 fi
 if [ -f "$oneD/../product" ]; then
  _debug "`cat "$oneD"/../product`"
  grep $Q -Ei 'Keyboard'          "$oneD/../product" && IS_KBD=YES
  grep $Q -Ei 'Mouse|Transceiver' "$oneD/../product" && IS_MOU=YES
 fi
 if [ -f "$oneD/../interface" ]; then
  _debug "`cat "$oneD"/../interface`"
  grep $Q -Ei 'Keyboard'          "$oneD/../interface" && IS_KBD=YES
  grep $Q -Ei 'Mouse|Transceiver' "$oneD/../interface" && IS_MOU=YES
 fi

 _debugx "$(ls -1v "$oneD"/* | while read oneF; do [ -f "$oneF" ] || continue; echo -n "$oneF"':';cat "$oneF"; done)"


  read HAVE_WAKEUP <"$oneD"/wakeup

   if [ "$IS_KBD" ]; then
  case $HAVE_WAKEUP in
  enabled)   [ "$KBD_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$KBD_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for kbd '$oneD'";;
  esac

 elif [ "$IS_MOU" ]; then
  case $HAVE_WAKEUP in
  enabled)   [ "$MOU_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$MOU_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for '$oneD'";;
  esac

 else
  case $HAVE_WAKEUP in
  enabled)   [ "$OTH_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
  disabled)  [ "$OTH_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
  "") _notice "wakeup NOT implemented for '$oneD'";;
  esac
  fi

  read HAVE_CONTROL <"$oneD"/control

    if [ "$IS_KBD" ]; then
   case $HAVE_CONTROL in
   on)    [ "$KBD_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$KBD_CONTROL" = on ] && echo on   >"$oneD"/control;;
   #auto)  [ "$KBD_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac

  elif [ "$IS_MOU" ]; then
   case $HAVE_CONTROL in
   on)    [ "$MOU_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$MOU_CONTROL" = on ] && echo on   >"$oneD"/control;;
   #auto)  [ "$MOU_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac

  else
   case $HAVE_CONTROL in
   on)    [ "$OTH_CONTROL" = on ] || echo auto >"$oneD"/control;;
   auto)  [ "$OTH_CONTROL" = on ] && echo on   >"$oneD"/control;;
   #auto)  [ "$OTH_CONTROL" = on ] || echo on   >"$oneD"/control;;
   esac
  fi

  read HAVE_LEVEL <"$oneD"/level
  _debug "HAVE_LEVEL='$HAVE_LEVEL'"

  if [ -f "$oneD"/autosuspend ] ; then
   read HAVE_DELAY <"$oneD"/autosuspend
   _debug "HAVE_DELAY='$HAVE_DELAY'"

   if [ "$IS_KBD" ]; then
    [ "$KBD_DELAY" = $HAVE_DELAY ] || echo $KBD_DELAY >"$oneD"/autosuspend
   elif [ "$IS_MOU" ]; then
    [ "$MOU_DELAY" = $HAVE_DELAY ] || echo $MOU_DELAY >"$oneD"/autosuspend
   else
    [ "$OTH_DELAY" = $HAVE_DELAY ] || echo $OTH_DELAY >"$oneD"/autosuspend
   fi

  elif [ -f "$oneD"/autosuspend_delay_ms ]; then
   read HAVE_DELAY <"$oneD"/autosuspend_delay_ms
   _debug "HAVE_DELAY='$HAVE_DELAY'"

   if [ "$IS_KBD" ]; then
    [ "$KBD_DELAY_MS" = $HAVE_DELAY ] || echo $KBD_DELAY_MS >"$oneD"/autosuspend_delay_ms
   elif [ "$IS_MOU" ]; then
    [ "$MOU_DELAY_MS" = $HAVE_DELAY ] || echo $MOU_DELAY_MS >"$oneD"/autosuspend_delay_ms
   else
    [ "$OTH_DELAY_MS" = $HAVE_DELAY ] || echo $OTH_DELAY_MS >"$oneD"/autosuspend_delay_ms
   fi
  fi

  unset HAVE_WAKEUP HAVE_CONTROL HAVE_LEVEL HAVE_DELAY IS_KBD IS_MOU

 echo
done

local HAVE_WAKEUP HAVE_CONTROL HAVE_LEVEL HAVE_DELAY IS_KBD IS_MOU
}

_set_usb_power_sysfs_valuesSTUB(){

# wake up enabled : Device can trigger wake up while S3 RAM sleep
local KBD_WAKEUP_ENABLED MOU_WAKEUP_ENABLED OTH_WAKEUP_ENABLED
KBD_WAKEUP_ENABLED=1
MOU_WAKEUP_ENABLED=
#OTH_WAKEUP_ENABLED=1  ##unused

local CLASS PROTOCOL

 ls -1d /sys/bus/usb/devices/*/power/ | while read oneD;
do
   _debugx "$oneD"
   [ -f "$oneD"/wakeup ] || continue

   [ -f "$oneD"/../bInterfaceClass ]    || continue
   [ -f "$oneD"/../bInterfaceProtocol ] || continue
   _debug "$oneD"

unset CLASS PROTOCOL CURR_WAKEUP_SETTING

#<[uapi/]linux/usb/ch9.h>
#define USB_CLASS_HID           3
    read CLASS <"$oneD"/../bInterfaceClass
   _debug "`cat "$oneD"/../bInterfaceClass`"
   case $CLASS in
   03|3) :;;
   *) _notice "Unhandled USB_CLASS '$CLASS'"
      continue;;
   esac

#<[uapi/]linux/hid.h>
#define USB_INTERFACE_PROTOCOL_KEYBOARD 1
#define USB_INTERFACE_PROTOCOL_MOUSE    2
   read PROTOCOL <"$oneD"/../bInterfaceProtocol
     _debug "`cat "$oneD"/../bInterfaceProtocol`"
   case $PROTOCOL in
   01|1) :;;
   02|2) :;;
   *) _notice "Unhandled USB_INTERFACE_PROTOCOL '$PROTOCOL'"
      continue;;
   esac

   read CURR_WAKEUP_SETTING <"$oneD"/wakeup
   _debug "`cat "$oneD"/wakeup`"
   case $PROTOCOL in
   01|1)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$KBD_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
    disabled)  [ "$KBD_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
    "") _notice "wakeup NOT implemented for kbd '$oneD'";;
    esac
    ;;
   02|2)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$MOU_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
    disabled)  [ "$MOU_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
    "") _notice "wakeup NOT implemented for '$oneD'";;
    esac
    ;;
   esac

done
}

_set_usb_power_sysfs_values(){
DEBUG=1

KERNEL_RELEASE=`uname -r`
if test -f /etc/modules/DOTconfig-$KERNEL_RELEASE; then
 ##source /etc/modules/DOTconfig-$KERNEL_RELEASE || return 0
 ##[ "$CONFIG_USB_SUSPEND" = y ] || return 0
 ##[ "$CONFIG_USB_SUSPEND" ]     || return 0
 #grep -w 'CONFIG_USB_SUSPEND' | grep $Q 'is not set' && return 0
 grep $Q -w '# CONFIG_USB_SUSPEND' && return 9
elif modprobe $VERB configs; then
 zcat /proc/config.gz | grep $Q -w '# CONFIG_USB_SUSPEND' && return 8
elif [ -f /proc/config.gz ]; then
 zcat /proc/config.gz | grep $Q -w '# CONFIG_USB_SUSPEND' && return 7
fi

# wake up enabled : Device can trigger wake up while S3 RAM sleep
local KBD_WAKEUP_ENABLED MOU_WAKEUP_ENABLED OTH_WAKEUP_ENABLED
KBD_WAKEUP_ENABLED=1
MOU_WAKEUP_ENABLED=
#OTH_WAKEUP_ENABLED=1  ##unused
case $KBD_WAKEUP_ENABLED in
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1)    KBD_WAKEUP_ENABLED=1;;
FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0) KBD_WAKEUP_ENABLED='';;
esac

# control : autosuspend values : on = never autosuspend , auto = let kernel decide
local KBD_CONTROL MOU_CONTROL OTH_CONTROL
KBD_CONTROL=on
MOU_CONTROL=auto
#OTH_CONTROL=auto
case $KBD_CONTROL in
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1)    KBD_CONTROL='on';;
FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0) KBD_CONTROL='auto';;
esac
case $MOU_CONTROL in
TRUE|True|true|ON|On|on|YES|Yes|yes|Y|y|1)    MOU_CONTROL='on';;
FALSE|False|false|OFF|Off|off|NO|No|no|N|n|0) MOU_CONTROL='auto';;
esac


local CLASS PROTOCOL AM_HID AM_KBD AM_MOU oneCF onePF

 ls -1d /sys/bus/usb/devices/*/power/ | tac | while read oneDIR;
do
   oneD=`readlink -f "$oneDIR"`
   _debugx "$oneD"
   [ -f "$oneD"/wakeup ] || continue
   _debug "$oneD"

   #[ -f "${oneD}../bInterfaceClass" ]    || continue
   #[ -f "${oneD}../bInterfaceProtocol" ] || continue
    ls -1 "${oneD}"/../*/bInterfaceClass    >>$OUT 2>>$ERR  || continue
    ls -1 "${oneD}"/../*/bInterfaceProtocol >>$OUT 2>>$ERR  || continue
    _debug "$oneD"

    [ -f "$oneD"/../uevent ]       && _debugx "$oneD/../uevent:      `cat "$oneD"/../uevent`"
    [ -f "$oneD"/../class ]        && _info   "$oneD/../class:       `cat "$oneD"/../class`"
    [ -f "$oneD"/../vendor ]       && _info   "$oneD/../vendor:      `cat "$oneD"/../vendor`"
    [ -f "$oneD"/../manufacturer ] && _info   "$oneD/../manufacturer:`cat "$oneD"/../manufacturer`"
    [ -f "$oneD"/../product ]      && _info   "$oneD/../product:     `cat "$oneD"/../product`"

unset CLASS PROTOCOL CURR_WAKEUP_SETTING AM_HID AM_KBD AM_MOU oneCF onePF

#<[uapi/]linux/usb/ch9.h>
#define USB_CLASS_HID           3
    #read CLASS <"$oneD"../bInterfaceClass
   #_debug "`cat "$oneD"../bInterfaceClass`"
   #ls -1 "${oneD}"../*/bInterfaceClass | while read oneCF;
   while read oneCF
   do
     read CLASS <"$oneCF"
    _debug "$oneCF:`cat "$oneCF"`"
    case $CLASS in
     03|3) AM_HID=YES;;
     *) _notice "Unhandled USB_CLASS '$CLASS'"
        continue;;
    esac
   done <<EoI
`ls -1v "${oneD}"/../*/bInterfaceClass`
EoI
   [ "$AM_HID" ] || continue

#<[uapi/]linux/hid.h>
#define USB_INTERFACE_PROTOCOL_KEYBOARD 1
#define USB_INTERFACE_PROTOCOL_MOUSE    2
   #read PROTOCOL <"$oneD"../bInterfaceProtocol
   #  _debug "`cat "$oneD"../bInterfaceProtocol`"
   #ls -1 "${oneD}"../*/bInterfaceProtocol | while read onePF;
   while read onePF
   do
     read PROTOCOL <"$onePF"
       _debug "$onePF:`cat "$onePF"`"
   case $PROTOCOL in
   01|1) AM_KBD=YES;;
   02|2) AM_MOU=YES;;
   *) _notice "Unhandled USB_INTERFACE_PROTOCOL '$PROTOCOL'"
      continue;;
   esac

   oneD_="$oneD"
   oneD__="$oneD_"
   while [ "$oneD__" != "/power" ]; do

    oneD_=${oneD_%/*}
   oneD__=${oneD_%/*}/power
   _debugx " oneD_='$oneD_'"
   _debugx "oneD__='$oneD__'"
   test -f "$oneD__"/wakeup -a -f "$oneD__"/control || { _debug "No control and wakeup files in oneD__='$oneD__'"; continue; }

   case $oneD__ in
   ""|./power|../power|/power|power) _debug "breaking oneD__='$oneD__'"; break;;
   esac
   case $oneD_ in
   ""|./|../|/) _debug "breaking oneD_='$oneD_'"; break;;
   esac

   read CURR_WAKEUP_SETTING <"$oneD__"/wakeup
                 _info "$oneD__/wakeup:`cat "$oneD__"/wakeup`"
                 _info "$oneD__/control:`cat "$oneD__"/control`"
                 if test -f "$oneD__/autosuspend_delay_ms" ; then
                 _info "$oneD__/autosuspend_delay_ms:`cat "$oneD__"/autosuspend_delay_ms`"
                 fi
                 if test -f "$oneD__/autosuspend"; then
                 _info "$oneD__/autosuspend:`cat "$oneD__"/autosuspend`"
                 fi
   read CURR_CONTROL_SETTING <"$oneD__"/control

   case $PROTOCOL in

   02|2)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$MOU_WAKEUP_ENABLED" ] || echo disabled >"$oneD__"/wakeup;;
    disabled)  [ "$MOU_WAKEUP_ENABLED" ] && echo enabled  >"$oneD__"/wakeup;;
    "") _notice "wakeup NOT implemented for mouse '$oneD__'";;
    *)  _warn   "Unhandled CURR_WAKEUP_SETTING '$CURR_WAKEUP_SETTING'";;
    esac

    case $CURR_CONTROL_SETTING in
    on)   [ "$MOU_CONTROL" = on ] || echo auto >"$oneD__"/control;;
    auto) [ "$MOU_CONTROL" = on ] && echo on   >"$oneD__"/control;;
    "")  _warn "CURR_CONTROL_SETTING empty";;
    *)   _warn "Unhandled CURR_CONTROL_SETTING '$CURR_CONTROL_SETTING'";;
    esac
    ;;

   01|1)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$KBD_WAKEUP_ENABLED" ] || echo disabled >"$oneD__"/wakeup;;
    disabled)  [ "$KBD_WAKEUP_ENABLED" ] && echo enabled  >"$oneD__"/wakeup;;
    "") _notice "wakeup NOT implemented for kbd '$oneD__'";;
    *)  _warn   "Unhandled CURR_WAKEUP_SETTING '$CURR_WAKEUP_SETTING'";;
    esac

    case $CURR_CONTROL_SETTING in
    on)   [ "$KBD_CONTROL" = on ] || echo auto >"$oneD__"/control;;
    auto) [ "$KBD_CONTROL" = on ] && echo on   >"$oneD__"/control;;
    "")  _warn "CURR_CONTROL_SETTING empty";;
    *)   _warn "Unhandled CURR_CONTROL_SETTING '$CURR_CONTROL_SETTING'";;
    esac
    ;;

   esac
                 _info "$oneD__/wakeup:`cat "$oneD__"/wakeup`"
                 _info "$oneD__/control:`cat "$oneD__"/control`"
                 if test -f "$oneD__/autosuspend_delay_ms" ; then
                 _info "$oneD__/autosuspend_delay_ms:`cat "$oneD__"/autosuspend_delay_ms`"
                 fi
                 if test -f "$oneD__/autosuspend"; then
                 _info "$oneD__/autosuspend:`cat "$oneD__"/autosuspend`"
                 fi

   done

   done <<EoI
`ls -1v "${oneD}"/../*/bInterfaceProtocol`
EoI

__fall_through__(){ #BEGIN
   [ "$AM_KBD" -o "$AM_MOU" ] || continue

   read CURR_WAKEUP_SETTING <"$oneD"/wakeup
   _debug "`cat "$oneD"/wakeup`"
   case $PROTOCOL in
   01|1)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$KBD_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
    disabled)  [ "$KBD_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
    "") _notice "wakeup NOT implemented for kbd '$oneD'";;
    esac
    ;;
   02|2)
    case $CURR_WAKEUP_SETTING in
    enabled)   [ "$MOU_WAKEUP_ENABLED" ] || echo disabled >"$oneD"/wakeup;;
    disabled)  [ "$MOU_WAKEUP_ENABLED" ] && echo enabled  >"$oneD"/wakeup;;
    "") _notice "wakeup NOT implemented for mouse '$oneD'";;
    esac
    ;;
   esac
}  ###__fall_through__(){ #END

done
RV=$?
_notice "_set_usb_power_sysfs_values: RV='$RV'"
return $RV
}  ###_set_usb_power_sysfs_values(){ #END
#_set_usb_power_sysfs_values

ACPITOOL=`which acpitool`
states_avail=`cat /sys/power/state`
states_avail_=`echo "$states_avail" |tr ' ' '\n'|sed 's!disk!S4 Hibernation on disk!;s!mem!S3 PM_SLEEP in mem!;s!standby!S1 Stand By!'`
LINEP=D001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

aplay /usr/share/audio/2barks.au
_xmessage -timeout 20 -bg red1 -title "POWERBUTTON STATES" "$0
Available states:
$states_avail_
"
LINEP=E001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

for st_ in $states_avail
do
    case $st_ in
    *freeze*)   BUTTON_FREEZE=freeze:190;;
    *standby*)  BUTTON_STANDBY=standby:188;;
    *mem*)      BUTTON_MEM="RAM sleep:203";;
    *disk*)     BUTTON_DISK="hibernate on swap partition:204";;
        *)          _warn "Unhandled ACPI state '$st_'";;
    esac
done


test "$BUTTON_DISK"    && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_DISK"
test "$BUTTON_MEM"     && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_MEM"
test "$BUTTON_STANDBY" && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_STANDBY"
test "$BUTTON_FREEZE"  && BUTTONS_GUI="${BUTTONS_GUI},$BUTTON_FREEZE"

BUTTONS_GUI="${BUTTONS_GUI},DO NOTHING:200"
BUTTONS_GUI=`echo "$BUTTONS_GUI" | sed 's%^,*%%;s%,*$%%'`

  #xmessage -timeout 30 -buttons "HIBERNATE On DISK:204,RAM SLEEP:203,ESCAPE GUI:200" -bg blue3 -fg white "Busybox acpid :
 __xmessage -timeout 30 -buttons "$BUTTONS_GUI" -title "POWERBUTTON MENU" -bg blue3 -fg white "Busybox acpid :
Do you want to go into one of the ACPI PM SLEEP modes ?
Note : Timesout in 30 seconds to poweroff normally."
ANSWER=$?
LINEP=F001
echo "DBG line `[ $LINENO ] && echo $LINENO || _lineno $LINEP`"

_mouse_message(){
_yaf_splash -bg yellow -fg black -timeout 10 -text "OK, If your mouse receiver is
attached to a keyboard integrated hub, and you don't
want to wake the system by mouse moves,
then you have 10 seconds from now,
to switch off the mouse..."
}

if [ "$ANSWER" = 200 ];then
rm -f /tmp/acpi_button_count
exit 0

elif [ "$ANSWER" = 203 ];then

_set_usb_power_sysfs_values && _mouse_message

_handle_no_console_suspend(){    ##2014-10-18
test -f  /sys/module/printk/parameters/console_suspend || { _notice "File
/sys/module/printk/parameters/console_suspend
not in sysfs."; return 1; }

grep $Q -w no_console_suspend /proc/cmdline && {
 if [ "$VERBOSE" ]; then
  echo -n 'Content of sysfs file
     /sys/module/printk/parameters/console_suspend:'
 cat /sys/module/printk/parameters/console_suspend
 fi
echo N >/sys/module/printk/parameters/console_suspend
return $?
 }
return $?
}
_handle_no_console_suspend    ##2014-10-18

pidof sync >>$OUT || sync
_loop_umount_func
_part_umount_func
pidof sync >>$OUT || sync
sleep 1

   if [ "$ACPITOOL" ];then
    acpitool -s
   else
    echo 'mem' >/sys/power/state
   fi

sleep 5
_restore_mounts



elif [ "$ANSWER" = 204 ];then

_set_usb_power_sysfs_values && _mouse_message

pidof sync >>$OUT || sync
_loop_umount_func
_part_umount_func
pidof sync >>$OUT || sync
sleep 1

   #if [ "$ACPITOOL" ];then
   PROC_SWAPS=`cat /proc/swaps |sed '1d'|awk '{print $1}'`
      for swap in $PROC_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    if [ ! "$RESUME" ];then
    FDISK_SWAPS=`fdisk -l |grep -i swap|awk '{print $1}'`
      for swap in $FDISK_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    fi
      if [ "$RESUME" ];then
         for swap in $PROC_SWAPS;
         do
            [ "$swap" = "$RESUME" ] && continue
            swapoff $swap
         done
      swapon $RESUME
      fi

      pidof sync >>$OUT || sync
      sleep 1

      if [ "$ACPITOOL" ];then
       acpitool -S
      else
       echo 'disk' >/sys/power/state
      fi

      sleep 1
      for swap in $PROC_SWAPS;
      do
       swapon $swap
      done

      if [ "$RESUME" ];then
       if test cat /proc/swaps |sed '1d' |wc -l -gt 1;then
        swapoff $RESUME
       fi
      fi

   #else #acpitool
   #  echo 'disk' >/sys/power/state
   #fi

sleep 5
_restore_mounts

elif [ "$ANSWER" = 188 ]; then  #standby
_set_usb_power_sysfs_values && _mouse_message
    echo standby >/sys/power/state

elif [ "$ANSWER" = 190 ]; then  #freeze
_set_usb_power_sysfs_values && _mouse_message
    echo freeze >/sys/power/state

else # timeout 0, error 1
 unset DISPLAY
 if test "`pidof X`"; then
 wmpoweroff force
 sleep 5
 pidof poweroff rc.shutdown >>$OUT || exec /sbin/poweroff force
 rm -f /tmp/acpi_button_count
 exit $?
 else
 exec /sbin/poweroff force
 fi
fi

sleep 5
aplay /usr/share/audio/2barks.au
case $ANSWER in
203)
_xmessage -title "POWERBUTTON WAKEUP MESSAGE" "RETURNED from RAM light sleep"
;;
204)
_xmessage -title "POWERBUTTON WELCOME BACK MESSAGE" "RETURNED from DISK winter sleep"
;;
*) :;;
esac

rm -f /tmp/acpi_button_count
exit 0
