#!/bin/sh
# Karl Reimer Godt in November 2014
# usual Puppy license

#echo "$0 :HALLO"
#xmessage "$0: HALLO"

_TMP_=/tmp
_FEAT_=acpi
tmpDIR=${_TMP_}/${_FEAT_}/${0##*/}
rm -r "$tmpDIR"
mkdir -p "$tmpDIR"

TIMEOUT=30

test "`pidof xinit X Xorg Xvesa Xfbdev`" && {
 test "$DISPLAY" || export DISPLAY=:0
 }

Version='1.0 Puppy_Racy_5.3 KRG'
Version='2.2.1 luci-218 KRG'
TITLE="${0##*/} $Version"  #Xdialog xmessage -title option

# Xmessage app-default config file
if test -f /etc/acpi/X11/app-defaults/Xmessage; then
export XAPPLRESDIR=/etc/acpi/X11/app-defaults
fi

usage(){
USAGE_MSG=`gettext "
$0 [help]
Script to suspend or hibernate
called by busybox applet 'acpid'.
Busybox acpid since version 1.18 needs
the 'evdev' kernelmodule loaded , but
seems not to need the 'button' module.
Works only with the Powerbutton,
not with closing the lid.
Please don't call busybox applets with
'busybox appletname' . Closing commands like
kill could accidentaly kill busybox init, which
would result in immedeate reboot. Always call it with
the [/path/to/link/]appletname.

Uses acpitool if installed, otherwise the
simple 'echo \"\$state\" >/sys/power/state' .

Full acpid pkg available : unknown.
"`
if [ "$2" ];then
USAGE_MSG="$USAGE_MSG

`gettext \"$2\"`
"
fi
echo "$USAGE_MSG"
[ "$DISPLAY" ] && xmessage \
                        -bg blue3 \
                        -fg white  \
                        -title "$TITLE" \
                        "$USAGE_MSG"
exit $1
}

# Redirection and quiet variables
OUT=/dev/null; ERR=/dev/null; Q=-q; QUIET=--quiet
case $1 in
-h|*help|*usage) usage 0;;
*version|-V)    echo -e "$0: Version '$Version'\nTry help for more info.\n";exit 0;;
*check*)       set -n;;
*verbose|-v)  VERBOSE=1; VERB=-v; L_VERB=--verbose; A_VERB=-verbose;
              DEBUG=1;   DBG=-d;  L_DBG=--debug; OUT=/dev/stdout; ERR=/dev/stderr
             Q=''; QUIET='';
            ;;
*debug|-d) DEBUG=2; DBG=-d; L_DBG=--debug; set -x;;
"") :;;
*) usage 1 "Unknown Parameter '$1'";;
esac

xmPRINT=                     # pass -print to xmessage
[ "$VERBOSE" -o "$DEBUG" ] && xmPRINT=-print

pidof sync || sync

# Functions
_toggle_pm_async(){

test -f /sys/power/pm_async || return 1

read PM_ASYNC </sys/power/pm_async
cat /sys/power/pm_async  #DEBUG

PM_ASYNC_MSG=`gettext "The current value in
 /sys/power/pm_async
 is set to '$PM_ASYNC'

 Do you want to toggle it ?
"`

BUTTONS_TGL_MSG=`gettext "Yes - Toggle:200,NO NO NO - keep it as is:201"`
defBUTTON=`gettext "NO NO NO - keep it as is"`

xmessage \
 $xmPRINT \
 -buttons "$BUTTONS_TGL_MSG" \
 -default "$defBUTTON" \
 -bg green1 \
 -fg white  \
 -title "$TITLE" \
 "$PM_ASYNC_MSG"
case $? in 200)
 HAVE_ASYNC_TOGGLE=Y;;
 #case $PM_ASYNC in
 #0) echo 1 >/sys/power/pm_async;;
 #1) echo 0 >/sys/power/pm_async;;
 #*) echo "UNSUPPORTED pm_async value '$PM_ASYNC'";;
 #esac;;
esac
#cat /sys/power/pm_async
}

_set_image_size(){
test -f /sys/power/image_size || return 3

MEM_USED=0
while read oneUSED
do
 MEM_USED=$((MEM_USED+oneUSED))
done <<EoI
`free -m | grep -iE 'Mem:|Swap:' |awk '{print $3}'`
EoI

LARGEST_SWAP_K=`grep -viE 'file|deleted' /proc/swaps | awk '{if (match($1, "^/dev")) print $3}' | sort -n | tail -n1`

LARGEST_SWAP_P=`grep -viE 'file|deleted' /proc/swaps | awk "{if (\\$3 == "$LARGEST_SWAP_K") print \\$1}"`

LARGEST_SWAP_M=$((LARGEST_SWAP_K/1024))

read IMG_SZ_B </sys/power/image_size
[ "$IMG_SZ_B" ] || IMG_SZ_B=0

IMG_SZ_K=$((IMG_SZ_B/1024))
IMG_SZ_M=$((IMG_SZ_B/1024/1024))

R_MIN=50
[ "$LARGEST_SWAP_M" ] && R_MAX=$LARGEST_SWAP_M || R_MAX=1000
R_DEF=500
[ "$IMG_SZ_M" ] && {
R_MIN=$((IMG_SZ_M/10))
[ "$LARGEST_SWAP_M" ] && R_MAX=$LARGEST_SWAP_M || R_MAX=$((IMG_SZ_M*2))
R_DEF=$IMG_SZ_M
}

RBOX_TXT=`gettext "You are currently using
'$MEM_USED' MiB of RAM.

Your largest Swap Partition has a size of
'$LARGEST_SWAP_M' MiB.

and is/are
'$LARGEST_SWAP_P'

The default hibernation image size is currently set to
'$R_DEF' MiB.

The kernel source uses 500 MB image_size as default.
The kernel compresses the image though.
"`

Xdialog \
 -stdout \
 -title "$TITLE" \
 -backtitle "Select PM Ram2Swap Image Size"  \
 -rangebox \
 "$RBOX_TXT" \
 0x0 \
 $R_MIN $R_MAX $R_DEF \
 >"$tmpDIR"/pm_image_size.choice

case $? in
0) :;;
*) return 4;;
esac

read IMG_SZ_CHOICE <"$tmpDIR"/pm_image_size.choice
cat "$tmpDIR"/pm_image_size.choice
[ "$IMG_SZ_CHOICE" ] || return 5

IMG_SZ_CHOICE_B=$((IMG_SZ_CHOICE*1024*1024))

HAVE_IMAGE_SIZE=Y
#echo $IMG_SZ_CHOICE_B >/sys/power/image_size
#[ $? = 0 ] || return 6
#cat /sys/power/image_size
}

_select_swap_partition(){
#function to select a particular swap partition
local SWAPS_ SWAPS dev sizB sizK sizM

#get current swap partitions - files would need extra GUI (?)
# could use fdisk also, but fdisk is also not reliable
#in case partition reformatted to a different f.s.
# probably should use probepart next version ..
SWAPS_=`grep -viE 'file|deleted' /proc/swaps | awk '{ print $1":"$3}'`
[ "$SWAPS_" ] || return 3

#create menubox list - filter partitions too small
echo "IMG_SZ_CHOICE='$IMG_SZ_CHOICE'"
while read dev sizK
do
[ "$dev" -a "$sizK" ] || continue
 #sizM=$((sizB/1024/1024))
 sizM=$((sizK/1024))
 [ "$sizM" -lt $IMG_SZ_CHOICE ] && continue
 SWAPS="$SWAPS
 ${dev##*/} ${dev}:${sizM}MB "
done <<EoI
`echo "$SWAPS_" |tr ':' ' '`
EoI

#find out swap with highest priority ( default SWAP )
defSWAP_=`grep -vE 'file|deleted' /proc/swaps | awk '{ if (match($1, "/dev/")) print}' | sort -k5 | head -n1`
echo "defSWAP_='$defSWAP_'"

defSWAP_P=${defSWAP_%%[[:blank:]]*}
echo "defSWAP_P='$defSWAP_P'"

defSWAP_S=`echo "$defSWAP_" | awk '{print $3}'`
echo "defSWAP_S='$defSWAP_S'"

defSWAP_M=$((defSWAP_S/1024))
echo "defSWAP_M='$defSWAP_M'"

if [ "$defSWAP_M" -ge $IMG_SZ_CHOICE ]; then
 defSWAP="default ${defSWAP_P}:${defSWAP_M}MB"
 SWAPS="$SWAPS
 $defSWAP "
fi

#remove empty lines
SWAPS=`echo "$SWAPS" | sed '/^$/d'`

echo "'$SWAPS'"

Xd_MENU_HIGHT=`echo "$SWAPS" | wc -l`
Xd_MENU_HIGHT=$((Xd_MENU_HIGHT+1))

SELECT_PART_BTITLE=`gettext "Hibernation"`
SELECT_PART_MSG=`gettext "
Select which swap partition
to hibernate to :
"`

Xdialog \
-stdout \
-title "$TITLE" \
-backtitle "$SELECT_PART_BTITLE" \
-menubox \
"SELECT_PART_MSG" \
0x0 $Xd_MENU_HIGHT \
 $SWAPS \
>"$tmpDIR"/swap_partition.choice

case $? in
0) :;;
*) return 0;; #exit;;
esac

read SWAP_CHOICE <"$tmpDIR"/swap_partition.choice
echo "$SWAP_CHOICE"
[ "$SWAP_CHOICE" ] || return 5

case $SWAP_CHOICE in
default)
SWAP_CHOICE="${defSWAP_P##*/}"
;;
esac

echo "$SWAP_CHOICE"
[ -b /dev/$SWAP_CHOICE ] || return 7

#MajMin_=`stat -c %t":"%T /dev/$SWAP_CHOICE`
MajMin_=`stat -c "0x"%t" 0x"%T /dev/$SWAP_CHOICE`
echo "MajMin_='$MajMin_'"
#[ "${MajMin_//:/}" ] || return 8
MajMin=`printf %d":"%d $MajMin_`
echo "MajMin='$MajMin'"
HAVE_SWAP_PARTITION=Y
#echo "$MajMin" >/sys/power/resume
#[ $? = 0 ] || exit 9
#exit
}

loop_umount_func(){
local LOOP_MSG xPID xxPID mloop
LOOP_MSG=`gettext "Unmounting files..."`
#xmessage -bg green1 -fg pink -title "$TITLE" "$LOOP_MSG" & xPID=$!
M_LOOP=`mount | grep '/dev/loop' |grep -v '/initrd'`
M_LOOP=`echo $M_LOOP |rev|sed 's! )!\n)!g'|rev`
M_LOOP=`echo "$M_LOOP" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`
[ "$M_LOOP" ] && xmessage -bg green1 -fg pink -title "$TITLE" "$LOOP_MSG" & xPID=$!
for mloop in $M_LOOP;do
 sleep 1
 xmessage -bg pink -fg green4 -title "$TITLE" "umount $mloop ..." & xxPID=$!
umount $mloop
[ $? -ne 0 ] && { [ "$DISPLAY" ] && xmessage -bg red2 "Please umount '$mloop' manually and try again";exit 0; }
 kill $xxPID
done
kill $xPID
}

part_umount_func(){
local PART_MSG xPID xxPID mpart
PART_MSG=`gettext "Unmounting partitions..."`
#xmessage -bg green4 -fg pink -title "$TITLE" "$PART_MSG" & xPID=$!
M_DEV=`mount | grep '/dev/[shfmd]+[0-9]' |grep -v '/initrd'`
M_DEV=`echo $M_DEV |rev|sed 's! )!)\n!g'|rev`
M_POI=`echo "$M_DEV" |grep -o ' on .* type ' |sed -r 's!( on )(.*)( type )!\2!'`
M_DEV=`echo "$M_DEV" |grep -o '.* on ' |sed -r 's!(.*)( on )!\1!'`
[ "$M_POI" ] && xmessage -bg green4 -fg pink -title "$TITLE" "$PART_MSG" & xPID=$!
for mpart in $M_POI;do
 sleep 1
 xmessage -bg pink -fg green1 -title "$TILE" "umount $mpart ..." & xxPID=$!
umount "$mpart"
[ $? -ne 0 ] && { [ "$DISPLAY" ] && xmessage -bg red2 -title "$TITLE" "Please umount '$mpart' manually and try again";exit 0; }
 kill $xxPID
done
kill $xPID
}

restore_mounts(){
[ "$M_DEV" ] || return 0
local PART_MSG part FS_TYPE dirn xPID xxPID

PART_MSG=`gettext "Restoring mounts ..."`
xmessage -bg green2 -fg pink -title "$TITLE" "$PART_MSG" & xPID=$!

for part in $M_DEV;do
sleep 1
 xmessage -bg pink -fg green2 -title "$TITLE" "mount $part ..." & xxPID=$!
FS_TYPE=`guess_fstype $part`
[ "$FS_TYPE" ] || FS_TYPE=unknown

dirn=${part##*/}
mkdir -p /mnt/$dirn
[ "$FS_TYPE" = unknown ] && {
 mount $part /mnt/$dirn
 true
 } || {
mount -t $FS_TYPE $part /mnt/$dirn
 }
 kill $xxPID
done
kill $xPID
}

# Test if acpitool available
ACPITOOL=`which acpitool`
# Get supported ACPI states
states_avail_=`cat /sys/power/state`
states_avail=`echo "$states_avail_" |tr ' ' '\n' |sed 's!disk!S4 Hibernation:&!;s!mem!S3 PM_SLEEP:&!;s!standby!S1 CPU running:&!'`

# Create Menu buttons for supported ACPI states
for oneSTATE in $states_avail_; do
 case $oneSTATE in
 *freeze*)  xmBUTTONS="${xmBUTTONS},Freeze:190";;
 *standby*) xmBUTTONS="${xmBUTTONS},Standby:201";;
 *mem*)     xmBUTTONS="${xmBUTTONS},RAM Sleep:203";;
 *disk*)    xmBUTTONS="${xmBUTTONS},Hibernate:204";;
 *) echo "Unhandled STATE '$oneSTATE'";;
 esac
done

xmBUTTONS="$xmBUTTONS},ESCAPE GUI:200"
xmBUTTONS=`echo "$xmBUTTONS" | sed 's%^[,]*%%;s%[,]*$%%'`
defBUTTON=`gettext "ESCAPE GUI"`

aplay /usr/share/audio/2barks.au  # make some noise
sleep 1
read RTC0_WAKE_ALARM_TIME_PRE </sys/class/rtc/rtc0/wakealarm
cat /sys/class/rtc/rtc0/wakealarm  #DEBUG

# if DISPLAY use GUIs, else poweroff ( for now )
if [ "$DISPLAY" ];then

echo "$states_avail" #DEBUG

STATES_AVAIL_MSG=`gettext "$0
Available states:

$states_avail

"`

xmessage \
$xmPRINT  \
-timeout 10 \
-bg red1 \
-title "$TITLE" \
"$STATES_AVAIL_MSG"

STATE_MENU_MSG=`gettext "Busybox acpid :
Do you want to go into ACPI PM SLEEP mode ?

Note: Timesout in $TIMEOUT to poweroff force"`

#-buttons "HIBERNATE On DISK:204,RAM SLEEP:203,ESCAPE GUI:200" \
#

xmessage \
$xmPRINT  \
-timeout $TIMEOUT \
-buttons "$xmBUTTONS" \
-default "$defBUTTON" \
-bg blue3 \
-fg white \
-title "$TITLE" \
"$STATE_MENU_MSG"

     ANSWER=$?
 [ "$ANSWER" ] || ANSWER=203  #RAM
else ANSWER=0
fi # DISPLAY or not DISPLAY


if [ "$ANSWER" = 200 ]; then #QUIT
exit 0

elif [ "$ANSWER" = 0 ]; then # if DISPLAY: timeout expired,
                             # assume frozen system, poweroff force
                             # if not DISPLAY: just poweroff force for now;
                             # needs a text-mode dialog then ( TODO )
 test "$DISPLAY" && {
 exec wmpoweroff force
 false
 } || {
 exec poweroff force
 }
fi


# Run wakealarm setting GUI if available
_ask_rerun_wakealarm_gui(){
# function
RERUN_WAKEALARM_GUI_MSG=`gettext "Something went wrong..
Do you want to re-run the Wakealarm Settings Program ?"`

RERUN_WAKEALARM_GUI_BUTTONS=`gettext "Yes:200,No:201,Exit:202"`
local defBUTTON
defBUTTON=`gettext "No"`

xmessage \
$xmPRINT  \
-bg cyan  \
-buttons "$RERUN_WAKEALARM_GUI_BUTTONS" \
-default "$defBUTTON" \
-title "$TITILE" \
"$RERUN_WAKEALARM_GUI_MSG"
return $?
}

test -x /etc/acpi/wakealarm.sh && {

test -f /proc/driver/rtc && \
PROC_RTC=`cat /proc/driver/rtc`

SET_WAKEALARM_MSG=`gettext "Do you want to
set the rtc driver wakealarm ?
"`

if [ "$PROC_RTC" ]; then
SET_WAKEALARM_MSG="$SET_WAKEALARM_MSG
`gettext \"It is currently set to\"`

$PROC_RTC

"
fi

BUTTONS_SET_WAKEALARM=`gettext "No:201,Yes:200"`
defBUTTON=`gettext "Yes"`

xmessage   \
$xmPRINT    \
-bg yellow \
-fg black  \
-buttons "$BUTTONS_SET_WAKEALARM" \
-default "$defBUTTON" \
-title "$TITLE" \
"$SET_WAKEALARM_MSG"
case $? in
200)
/etc/acpi/wakealarm.sh
 case $? in 0) :;;
 *)
   while [ 1 = 1 ]; do
  _ask_rerun_wakealarm_gui
  case $? in
  200) /etc/acpi/wakealarm.sh && break;; #OK
  201) break;;
  202) exit $((cEXIT+1));;
  *)
  ;;esac
  done
 ;;esac
;;esac

# RTC0_WAKE_ALARM_TIME_PRE is used at the end of this script
# to check if waked up by schedule or by user interference before
# interupt could be triggered
read RTC0_WAKE_ALARM_TIME_PRE </sys/class/rtc/rtc0/wakealarm
cat /sys/class/rtc/rtc0/wakealarm  #DEBUG
}

pidof sync || sync

if [ "$ANSWER" = 201 ]; then

echo standby >/sys/power/state

elif [ "$ANSWER" = 190 ]; then

echo freeze >/sys/power/state

else

loop_umount_func
part_umount_func
pidof sync || sync
sleep 1

fi


if [ "$ANSWER" = 203 ];then # RAM

#echo 3 > /proc/sys/vm/drop_caches
#pidof sync || sync
#loop_umount_func
#part_umount_func
#pidof sync || sync
#sleep 1

   if [ "$ACPITOOL" ];then

      acpitool -s
   else
echo 'mem' >/sys/power/state
   fi


elif [ "$ANSWER" = 204 ];then # DISK

#echo 3 > /proc/sys/vm/drop_caches
#pidof sync || sync
#loop_umount_func
#part_umount_func
#pidof sync || sync
#sleep 1

__old_define_resume_partition__(){
  # if [ "$ACPITOOL" ];then
   PROC_SWAPS=`cat /proc/swaps |sed '1d'|awk '{print $1}'`
      for swap in $PROC_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    if [ ! "$RESUME" ];then
    FDISK_SWAPS=`fdisk -l |grep -i swap|awk '{print $1}'`
      for swap in $FDISK_SWAPS;do
       RESUME=`blkid $swap |grep -iE 'Winter|Hiber|Resume'`
       [ "$RESUME" ] && break
      done
    fi
    if [ "$RESUME" ];then
         for swap in $PROC_SWAPS;do
      [ "$swap" = "$RESUME" ] && continue
      swapoff $swap
         done
      swapon $RESUME
    fi
}

# Run Settings GUIs
_toggle_pm_async        || { echo "$? retunred from _toggle_pm_async";       exit 11; }
_set_image_size         || { echo "$? returned from _set_image_size";        exit 12; }
_select_swap_partition || { echo "$? returned from _select_swap_partition"; exit 13; }

# Set choose settings
if [ "$HAVE_ASYNC_TOGGLE" ]; then
#:
 case $PM_ASYNC in
 0) echo 1 >/sys/power/pm_async;;
 1) echo 0 >/sys/power/pm_async;;
 *) echo "UNSUPPORTED pm_async value '$PM_ASYNC'";;  #DEBUG
 esac
cat /sys/power/pm_async  #DEBUG
fi

if [ "$HAVE_IMAGE_SIZE" ]; then
#:
echo $IMG_SZ_CHOICE_B >/sys/power/image_size
[ $? = 0 ] || { echo "Failure @echo '$IMG_SZ_CHOICE_B' to /sys/power/image_size"; exit 6; }
cat /sys/power/image_size #DEBUG
fi

if [ "$HAVE_SWAP_PARTITION" ]; then
#:
echo "$MajMin" >/sys/power/resume
[ $? = 0 ] || { echo "Failure @echo '$MajMin' to /sys/power/resume"; exit 7; }
cat /sys/power/resume  #DEBUG
fi

#{ echo "TEST EXIT"; exit; }

# Now actually suspend to disk
      pidof sync || sync
      sleep 1

if [ "$ACPITOOL" ];then
      acpitool -S

__old_swapon__(){
      sleep 1
      for swap in $PROC_SWAPS;do
      swapon $swap
      done
      if  [ "$RESUME" ];then
        if test cat /proc/swaps |sed '1d' |wc -l -gt 1;then
         swapoff $RESUME
        fi
      fi #[ "$RESUME" ]
}
   else #acpitool
echo 'disk' >/sys/power/state
   fi


else
:
fi

sleep 6         # sleep 6 seconds that the kernel needs to return from S3
pidof mplayer && killall -9 mplayer
restore_mounts # restore mounted partitions

aplay /usr/share/audio/2barks.au & # make some wake up noise
sleep 1

# Welcome Back message
case $ANSWER in
190)
[ "$DISPLAY" ] && xmessage $xmPRINT -timeout 9 -title "Freeze Wakeup" "RETURNED from Freeze state"
;;
201)
[ "$DISPLAY" ] && xmessage $xmPRINT -timeout 9 -title "Standby Wakeup" "RETURNED from S1 RAM standby"
;;
203)
[ "$DISPLAY" ] && xmessage $xmPRINT -timeout 9 -title "Sleep Wakeup" "RETURNED from S3 RAM light sleep"
;;
204)
[ "$DISPLAY" ] && xmessage $xmPRINT -timeout 9 -title "Soft Off Wakeup" "RETURNED from S4 DISK winter sleep"
;;
*) :;;
esac

# Test if wakeup triggered by rtc driver
read CURRENT_SINCE_EPOCH_POST </sys/class/rtc/rtc0/since_epoch

echo "CURRENT_SINCE_EPOCH_POST   ='$CURRENT_SINCE_EPOCH_POST'"        #DEBUG
echo "CURRENT_SINCE_EPOCH_POST-60='$((CURRENT_SINCE_EPOCH_POST-60))'" #DEBUG
echo "RTC0_WAKE_ALARM_TIME_PRE   ='$RTC0_WAKE_ALARM_TIME_PRE'"         #DEBUG

if test "$RTC0_WAKE_ALARM_TIME_PRE"; then

 if test "$((RTC0_WAKE_ALARM_TIME_PRE))" -ge "$((CURRENT_SINCE_EPOCH_POST-60))"
 then
  if test "$((RTC0_WAKE_ALARM_TIME_PRE))" -le $((CURRENT_SINCE_EPOCH_POST))
   then

    if test -x /etc/acpi/wakealarm/wakealarm_cmd ; then
          exec /etc/acpi/wakealarm/wakealarm_cmd &
    else echo "/etc/acpi/wakealarm/wakealarm_cmd not executable" #DEBUG
    fi

  else   echo " RTC0_WAKE_ALARM_TIME_PRE greater than CURRENT_SINCE_EPOCH_POST" #DEBUG
   exec /etc/acpi/wakealarm.sh &
  fi
 else    echo " RTC0_WAKE_ALARM_TIME_PRE value too low" #DEBUG
 fi

else     echo " No RTC0_WAKE_ALARM_TIME_PRE" #DEBUG
fi

###END###
exit 0
###END###
