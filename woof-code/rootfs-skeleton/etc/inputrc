#Section "InputDevice"
#	Identifier  "Keyboard0"
#	Driver      "kbd"
#	Option      "XkbRules" "xorg"
#	Option      "XkbModel" "pc102"
#	Option      "XkbLayout" "us" #xkeymap0




set meta-flag on
set input-meta on
set convert-meta off
set output-meta on

## \e == ^[
"\e[5~": beginning-of-history
"\e[6~": end-of-history
"\e[3~": delete-char
"\e[2~": quoted-insert
"\eOH": beginning-of-line
"\eOF": end-of-line
"\e[B": history-search-forward
"\e[A": history-search-backward

"\C-\M-d": delete-char
"\C-d": unix-line-discard
"\M-d": backward-delete-char

set show-all-if-ambiguous on
set match-hidden-files on
set horizontal-scroll-mode off
set enable-keypad on
#set enable-meta-key on
# runs on rxvt but not on sakura&xterm-266
"\e[11~": "grin "
"\e[12~": "find * -name \"*"
"\e[13~": "ls -l \n"




"\C-\M-d": delete-char
"\C-d": unix-line-discard
"\M-d": backward-delete-char
"\eOd": backward-word
"\eOc": forward-word

#set keymap vi-move
#set keymap vi
#set keymap vi-insert
set keymap emacs-meta
set keymap emacs-ctlx
#set editing-mode vi

##2012-10-05
#   Commands for Moving
#       beginning-of-line (C-a)
#              Move to the start of the current line.
#       end-of-line (C-e)
#              Move to the end of the line.
#       forward-char (C-f)
#              Move forward a character.
#       backward-char (C-b)
#              Move back a character.

#       forward-word (M-f)
#              Move forward to the end of the next word.  Words are composed of
#              alphanumeric characters (letters and digits).
#       backward-word (M-b)
#              Move back to the start of this, or the  previous,  word.   Words
#              are composed of alphanumeric characters (letters and digits).

#       clear-screen (C-l)
#              Clear  the  screen  leaving  the  current line at the top of the
#              screen.  With an argument,  refresh  the  current  line  without
#              clearing the screen.

#   Commands for Manipulating the History
#       accept-line (Newline, Return)
#              Accept the line regardless of where the cursor is.  If this line
#              is non-empty, add it to the history list according to the  state
#              of  the HISTCONTROL variable.  If the line is a modified history
#              line, then restore the history line to its original state.
#       previous-history (C-p)
#              Fetch the previous command from the history list, moving back in
#              the list.
#       next-history (C-n)
#              Fetch  the next command from the history list, moving forward in
#              the list.
#       beginning-of-history (M-<)
#              Move to the first line in the history.
#       end-of-history (M->)
#              Move to the end of the input history, i.e., the  line  currently
#              being entered.
#       reverse-search-history (C-r)
#              Search  backward  starting  at  the current line and moving `up'
#              through the  history  as  necessary.   This  is  an  incremental
#              search.
#       forward-search-history (C-s)
#              Search  forward  starting  at the current line and moving `down'
#              through the  history  as  necessary.   This  is  an  incremental
#              search.
#       non-incremental-reverse-search-history (M-p)
#              Search backward through the history starting at the current line
#              using a non-incremental search for  a  string  supplied  by  the
#              user.
#       non-incremental-forward-search-history (M-n)
#              Search  forward  through  the  history  using  a non-incremental
#              search for a string supplied by the user.
#      history-search-forward
#              Search forward through the history for the string of  characters
#              between  the  start  of  the current line and the current point.
#              This is a non-incremental search.  By default, this  command  is
#              unbound.
#       history-search-backward
#              Search backward through the history for the string of characters
#              between the start of the current line  and  the  current  point.
#              This  is  a non-incremental search.  By default, this command is
#              unbound.
#       yank-nth-arg (M-C-y)
#              Insert the first argument to the previous command  (usually  the
#              second  word  on the previous line) at point (the current cursor
#              position).  With an argument n, insert the  nth  word  from  the
#              previous  command  (the words in the previous command begin with
#              word 0).  A negative argument inserts the nth word from the  end
#              of the previous command.
#       yank-last-arg (M-., M-_)
#              Insert  the last argument to the previous command (the last word
#              on the previous line).  With an argument,  behave  exactly  like
#              yank-nth-arg.
#       shell-expand-line (M-C-e)
#              Expand  the  line the way the shell does when it reads it.  This
#              performs alias and history expansion as well as all of the shell
#              word  expansions.  See HISTORY EXPANSION below for a description
#              of history expansion.
#       history-expand-line (M-^)
#              Perform history expansion on  the  current  line.   See  HISTORY
#              EXPANSION below for a description of history expansion.
#       insert-last-argument (M-., M-_)
#              A synonym for yank-last-arg.
#       operate-and-get-next (C-o)
#              Accept  the  current  line for execution and fetch the next line
#              relative to the current line from the history for editing.   Any
#              argument is ignored.


#       backward-kill-line (C-x C-Rubout)
#             Kill backward to the beginning of the line.
##example : which ld -> which[CURSOR][CTRL-x]ldd ld -> ldd ld
# set already as default


#       kill-word (M-d)
#              Kill from the cursor to the end  of  the  current  word,  or  if
#              between words, to the end of the next word.  Word boundaries are
#              the same as those used by forward-word.
##example : which ABC ld -> which[CURSOR][ALT-d] ABC ld -> which ldd
# set already as default
# *** WARNING *** CNTRL-d is suspend/exit the shell if no command/subshell is running ~ CNTRL-c
# ***             but unlike CNTRL-d CNTRL-c does not exit the shell (closes rxvt/ sakura-tab)


#       backward-kill-word (M-Rubout)
#              Kill the word behind the cursor.  Word boundaries are  the  same
#              as those used by backward-word.
##example : which ABC ld -> which ABC [CURSOR][ALT-Backspace]ld -> which ld
# set already as default


#       unix-word-rubout (C-w)
#              Kill  the  word  behind  the cursor, using white space as a word
#              boundary.   The  word  boundaries  are  different   from   back-
#              ward-kill-word.
# set already as default


#       yank (C-y)
#              Yank the top of the kill ring into the buffer at the cursor.
##translate : yank==insert :: inserts the last killed string at cursor position : useful ? (cut+paste)


#       yank-pop (M-y)
#              Rotate the kill-ring, and yank the new top.  Only works  follow-
#              ing yank or yank-pop.
##translate : goes back in the kill-history one by one at current cursor position


#   Completing
#       complete (TAB)
#              Attempt  to  perform  completion on the text before point.  Bash
#              attempts completion treating the text as a variable (if the text
#              begins  with  $), username (if the text begins with ~(ie root)), hostname
#              (if the text begins with @(ie puppypc)), or command (including  aliases  and
#              functions) in turn.  If none of these produces a match, filename
#              completion is attempted.


#       possible-completions (M-?)
#              List the possible completions of the text before point.
##translate : text==filneames in current directory ??

#       complete-filename (M-/)
#              Attempt filename completion on the text before point.

#       complete-username (M-~)
#              Attempt  completion  on  the text before point, treating it as a
#              username.

#       complete-variable (M-$)
#              Attempt  completion  on  the text before point, treating it as a
#              shell variable.

#       possible-variable-completions (C-x $)
#              List the possible completions of the text before point, treating
#              it as a shell variable.

#       complete-hostname (M-@)
#              Attempt  completion  on  the text before point, treating it as a
#              hostname.

#       possible-hostname-completions (C-x @)
#              List the possible completions of the text before point, treating
#              it as a hostname.

#       complete-command (M-!)
#              Attempt  completion  on  the text before point, treating it as a
#              command name.  Command completion attempts  to  match  the  text
#              against  aliases, reserved words, shell functions, builtins, and
#              finally executable filenames, in that order.
# *** WARN *** : in jwm ALT-1 switches virt desktop, in sakura ALT+SHIFT+1(!) switches tabs

#       possible-command-completions (C-x !)
#              List the possible completions of the text before point, treating
#              it as a command name.
##explain : similar to TABTAB

#       dynamic-complete-history (M-TAB)
#              Attempt  completion on the text before point, comparing the text
#              against lines from the  history  list  for  possible  completion
#              matches.
## in jwm set to switch windows ?? -> into foreground

C-h : dynamic-complete-history
