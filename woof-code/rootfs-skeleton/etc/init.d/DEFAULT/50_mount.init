#!/bin/ash


. /etc/rc.d/f4puppy5

__mount_none_filesystems(){
   nFS=`grep '^nodev' /proc/filesystems | tr  '\t' ' ' | cut -f 2 -d ' '`
#NODEV=`echo "$NFS" | grep -v -E 'pipe|sock|bdev|anon|inotify|aufs'`
 NODEV="$nFS"
test -d /nodev || mkdir $VERB /nodev

for oneFS in $NODEV ; do

 _debug "$oneFS"

 if test -z "`grep -Fw "$oneFS" /proc/mounts`"; then

  test "$1" = start || continue

   case $oneFS in

    debugfs) test -d /sys/kernel/debug        || { mkdir -p /sys/kernel/debug || continue; };        /bin/mount $VERB -t debugfs         debugfs /sys/kernel/debug;
    # REM: /proc/bus/usb also at /sys/kernel/debug/usb
    # REM: dmesg output for usb-storage now needs to be enabled
    echo 'module usb_storage +p' >/sys/kernel/debug/dynamic_debug/control;
    ;;

    fusectl) test -d /sys/fs/fuse/connections || { mkdir -p /sys/fs/fuse/connections || continue; }; /bin/mount $VERB -t fusectl fusectl /sys/fs/fuse/connections;;
binfmt_misc) test -d /proc/sys/fs/binfmt_misc || { mkdir -p /proc/sys/fs/binfmt_misc || continue; }; /bin/mount $VERB -t binfmt_misc     binfmt /proc/sys/fs/binfmt_misc;;
 securityfs) test -d /sys/kernel/security     || { mkdir -p /sys/kernel/security || continue; };     /bin/mount $VERB -t securityfs      securityfs /sys/kernel/security;;
      usbfs) test -d /proc/bus/usb            || { mkdir -p /proc/bus/usb || continue; };            /bin/mount $VERB -t usbfs           usbfs  /proc/bus/usb;; # -o devmode=0666;;
   configfs) test -d /config                  || { mkdir -p /config || continue; };                  /bin/mount $VERB -t configfs        configfs  /config;;
  hugetlbfs) test -d /mnt/huge                || { mkdir -p /mnt/huge || continue; };                /bin/mount $VERB -t hugetlbfs       hugetlbfs  /mnt/huge;;
    # pstore) test -d /sys/fs/pstore           || { mkdir -p /sys/fs/pstore || continue; };           /bin/mount $VERB -t pstore          nodev /sys/fs/pstore;;
      pstore) test -d /dev/pstore           || { mkdir -p /dev/pstore || continue; };           /bin/mount $VERB -t pstore          pstore /dev/pstore;;

ubifs|mtd_inodefs|exofs|autofs|nfs4|nfs|coda|bdev|sockfs|pipefs|anon_inodefs|aufs|unionfs) :;;
    #mount: wrong fs type, bad option, bad superblock on /nodev, ...

    jffs2) :;;   #mount: /nodev is not a block device
    fuse)  :;;   #bin/sh: /nodev: is a directory
    *ram*|*tmp*) :;; # devtmpfs
    rootfs)      :;;

#mqueue) test -d /proc/sys/fs/mqueue || mkdir -p /proc/sys/fs/mqueue; /bin/mount -v -t mqueue nodev /proc/sys/fs/mqueue;;

   nfsd) test -d /proc/fs/nfsd || { mkdir $VERB -p /proc/fs/nfsd || continue; }; /bin/mount $VERB -t nfsd nfsd /proc/fs/nfsd;;

    *)
    #DIR=`echo "$oneFS" | sed 's/fs$//'`
    DIR=${oneFS%fs}
    test -d /dev/fs/$DIR || { mkdir $VERB -p /dev/fs/$DIR || continue; }
    /bin/mount $VERB -t $oneFS $oneFS /dev/fs/$DIR
    ;;
   esac

 else

 test "$1" = stop || continue

 while read -r _device_ _mountpoint_ _filesystem_ _rest_
  do
   case $_filesystem_ in
    #rootfs|proc|sysfs|devpts|*tmpfs|*ramfs|aufs|unionfs) continue;;
     aufs|devpts|proc|*ramfs|rootfs|sysfs|*tmpfs|unionfs) continue;;
   esac
   _mountpoint_=`echo -e "$_mountpoint_"`
   _info "Attempting to unmount '$_mountpoint_'"
   /bin/umount $VERB "$_mountpoint_"
  done <<EoI
`grep -m1 -Fw "$oneFS" /proc/mounts`
EoI

 fi

done

}

_mount_none_filesystems(){
 test "$1" = start || return 1
   nFS=`grep '^nodev' /proc/filesystems | tr  '\t' ' ' | cut -f 2 -d ' '`
#NODEV=`echo "$NFS" | grep -v -E 'pipe|sock|bdev|anon|inotify|aufs'`
 NODEV="$nFS"
test -d /nodev || mkdir $VERB /nodev

for oneFS in $NODEV;
do
_debug "$oneFS"
grep $Q -Fw "$oneFS" /proc/mounts && continue

  case $oneFS in

    debugfs) test -d /sys/kernel/debug        || { mkdir $VERB -p /sys/kernel/debug || continue; };        /bin/mount $VERB -t debugfs         debugfs /sys/kernel/debug;
    # REM: /proc/bus/usb also at /sys/kernel/debug/usb
    # REM: dmesg output for usb-storage now needs to be enabled
    echo 'module usb_storage +p' >/sys/kernel/debug/dynamic_debug/control;
    ;;

    fusectl) test -d /sys/fs/fuse/connections || { mkdir $VERB -p /sys/fs/fuse/connections || continue; }; /bin/mount $VERB -t fusectl fusectl /sys/fs/fuse/connections;;
binfmt_misc) test -d /proc/sys/fs/binfmt_misc || { mkdir $VERB -p /proc/sys/fs/binfmt_misc || continue; }; /bin/mount $VERB -t binfmt_misc     binfmt /proc/sys/fs/binfmt_misc;;
 securityfs) test -d /sys/kernel/security     || { mkdir $VERB -p /sys/kernel/security || continue; };     /bin/mount $VERB -t securityfs      securityfs /sys/kernel/security;;
      usbfs) test -d /proc/bus/usb            || { mkdir $VERB -p /proc/bus/usb || continue; };            /bin/mount $VERB -t usbfs           usbfs  /proc/bus/usb;; # -o devmode=0666;;
   configfs) test -d /config                  || { mkdir $VERB -p /config || continue; };                  /bin/mount $VERB -t configfs        configfs  /config;;
  hugetlbfs) test -d /mnt/huge                || { mkdir $VERB -p /mnt/huge || continue; };                /bin/mount $VERB -t hugetlbfs       hugetlbfs  /mnt/huge;;
    # pstore) test -d /sys/fs/pstore           || { mkdir $VERB -p /sys/fs/pstore || continue; };           /bin/mount $VERB -t pstore          nodev /sys/fs/pstore;;
      pstore) test -d /dev/pstore           || { mkdir $VERB -p /dev/pstore || continue; };           /bin/mount $VERB -t pstore          pstore /dev/pstore;;

ubifs|mtd_inodefs|exofs|autofs|nfs4|nfs|coda|bdev|sockfs|pipefs|anon_inodefs|aufs|unionfs) :;;
    #mount: wrong fs type, bad option, bad superblock on /nodev, ...

    jffs2) :;;   #mount: /nodev is not a block device
    fuse)  :;;   #bin/sh: /nodev: is a directory
    *ram*|*tmp*) :;; # devtmpfs
    rootfs)      :;;

#mqueue) test -d /proc/sys/fs/mqueue || mkdir -p /proc/sys/fs/mqueue; /bin/mount -v -t mqueue nodev /proc/sys/fs/mqueue;;

   nfsd) test -d /proc/fs/nfsd || { mkdir $VERB -p /proc/fs/nfsd || continue; }; /bin/mount $VERB -t nfsd nfsd /proc/fs/nfsd;;

    *)
    #DIR=`echo "$oneFS" | sed 's/fs$//'`
    DIR=${oneFS%fs}
    test -d /dev/fs/$DIR || { mkdir $VERB -p /dev/fs/$DIR || continue; }
    /bin/mount $VERB -t $oneFS $oneFS /dev/fs/$DIR
    ;;
   esac

done
}

_unmount_none_filesystems(){
test "$1" = stop || return 1

_nFS_=`grep '^nodev' /proc/filesystems | tr  '\t' ' ' | cut -f 2 -d ' '`

for _oneFS_ in $_nFS_
do

case $_oneFS_ in
#sysfs|proc|*tmpfs|*ramfs|rootfs|devpts|aufs|unionfs) continue;;
 aufs|devpts|proc|*ramfs|rootfs|sysfs|*tmpfs|unionfs|'') continue;;
esac

_mntPTs_=`grep " ${_oneFS_} " /proc/mounts | awk '{print $2}' | tac`
 for _oneMNT_ in $_mntPTs_
 do
 oneMNT_=`busybox echo -e "$_oneMNT_"`
 case $oneMNT_ in /dev|/|'') continue;; esac
  _info "Attempting to unmount '$oneMNT_'"
 /bin/umount $VERB -lr "$oneMNT_"
 done
done

}

_info "$*"
case $1 in
stop)
 #_mount_none_filesystems $1
 _unmount_none_filesystems $1
;;
start)
 _mount_none_filesystems $1
;;
esac
_debug "$*"

__pstore_help__(){
    cat >>$OUT <<EoI
     config PSTORE
    bool "Persistent store support"
    default n
    help
       This option enables generic access to platform level
       persistent storage via "pstore" filesystem that can
       be mounted as /dev/pstore.  Only useful if you have
       a platform level driver that registers with pstore to
       provide the data, so you probably should just go say "Y"
       (or "M") to a platform specific persistent store driver
       (e.g. ACPI_APEI on X86) which will select this for you.
       If you don't have a platform persistent store driver,
       say N.

config PSTORE_CONSOLE
    bool "Log kernel console messages"
    depends on PSTORE
    help
      When the option is enabled, pstore will log all kernel
      messages, even if no oops or panic happened.

config PSTORE_FTRACE
    bool "Persistent function tracer"
    depends on PSTORE
    depends on FUNCTION_TRACER
    help
      With this option kernel traces function calls into a persistent
      ram buffer that can be decoded and dumped after reboot through
      pstore filesystem. It can be used to determine what function
      was last called before a reset or panic.

      If unsure, say N.

config PSTORE_RAM
    tristate "Log panic/oops to a RAM buffer"
    depends on PSTORE
    depends on HAS_IOMEM
    depends on HAVE_MEMBLOCK
    select REED_SOLOMON
    select REED_SOLOMON_ENC8
    select REED_SOLOMON_DEC8
    help
      This enables panic and oops messages to be logged to a circular
      buffer in RAM where it can be read back at some later point.

      Note that for historical reasons, the module will be named
      "ramoops.ko".

      For more information, see Documentation/ramoops.txt.
EoI

 }
