#!/bin/ash
#KRG ash instead sh
#(c) Copyright Barry Kauler 2010, bkhome.org
#Lesser GPL license v2 (/usr/share/doc/legal/lgpl-2.1.txt
#perform a f.s. check if file /fsckme.err exits, otherwise normal startup.
#/etc/rc.d/rc.sysinit creates /fsckme.err at bootup, rc.shutdown deletes it.
#this script is /sbin/init in the main Puppy f.s., which is the very first to run.
#in the case of not a full hd install, this script just passes execution to busybox init.


########################################################################
#
#
#
#
#
# /dev/sda5:
# LABEL="MacPup430_F3"
# UUID="07443de5-1fab-4656-a3ab-7b1c14ccc8c8"
# TYPE="ext3"
# DISTRO_VERSION=430·#481·#416·#218·#478······#####change·this·as·required#####
# DISTRO_BINARY_COMPAT="puppy"·#"ubuntu"·#"puppy"·#####change·this·as·required#####
# case·$DISTRO_BINARY_COMPAT·in
# ubuntu)
# DISTRO_NAME="Jaunty·Puppy"
# DISTRO_FILE_PREFIX="upup"
# DISTRO_COMPAT_VERSION="jaunty"
# ;;
# debian)
# DISTRO_NAME="Lenny·Puppy"
# DISTRO_FILE_PREFIX="dpup"
# DISTRO_COMPAT_VERSION="lenny"
# ;;
# slackware)
# DISTRO_NAME="Slack·Puppy"
# DISTRO_FILE_PREFIX="spup"
# DISTRO_COMPAT_VERSION="12.2"
# ;;
# arch)
# DISTRO_NAME="Arch·Puppy"
# DISTRO_FILE_PREFIX="apup"
# DISTRO_COMPAT_VERSION="200904"
# ;;
# t2)
# DISTRO_NAME="T2·Puppy"
# DISTRO_FILE_PREFIX="tpup"
# DISTRO_COMPAT_VERSION="puppy5"
# ;;
# puppy)·#built·entirely·from·Puppy·v2.x·or·v3.x·or·4.x·pet·pkgs.
# DISTRO_NAME="Puppy"
# DISTRO_FILE_PREFIX="pup"·#"ppa"·#"ppa4"·#"pup2"··#pup4··###CHANGE·AS·REQUIRED,·recommend·limit·four·characters###
# DISTRO_COMPAT_VERSION="4"·#"2"··#4·····###CHANGE·AS·REQUIRED,·recommend·single·digit·5,·4,·3,·or·2###
# ;;
# esac
# PUPMODE=2
# KERNVER=2.6.30.6-KRG-i486
# ATADRIVES='·sda'
# USB_SATAD=''
# PUP_HOME='/'
# Linux·puppypc·2.6.30.6-KRG-i486·#1·SMP·Sun·Jan·2·20:32:12·GMT-1·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xvesa_stripped_upx9
# $LANG=en_US
# today=Mon·Oct·24·22:54:36·CEST·2011
#
#
#
#
#
########################################################################

test -s /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5
# BATCHMARKER01 - Marker for Line-Position to bulk insert code into.
#echo "$0:$*:"

VERSION=1.9.1 # also create /dev if not PUPMODE=2
VERSION=1.9.2 # use _color_echo, _print_debug1, _print_debug2

PATH='/bin:/sbin:/usr/bin:/usr/sbin'
export LANG=C

TimeOut=60 # seconds. initial value. gets altered in _ask_debug() .
SLEEP=1    # seconds. initial value. gets altered in _ask_debug() .

# alias below option processing

_print_debug1(){
test "$DebugVal" -ge 1 || return 0
_color_echo orange "$*"
}

_print_debug2(){
test "$DebugVal" -ge 2 || return 0
_color_echo red "$*"
}

test -f /etc/rc.d/PUPSTATE && . /etc/rc.d/PUPSTATE || PUPMODE=2

_usage (){
MSG="
$0
Sript to check for inproper previous shutdown if
marker file *fsckme.flg|err* found. The content of the
fsckme.flg file needs to look like this : 'sda2,ext3,' .

Former [and still?] it was crudly done
by '/usr/bin/xwin' /etc/.XLOADED code by Pizzasgood.

If fsckme file exists, check the partition read-only,
and if found clean, boot anyway.

If the mount interval date or mounts have reached their
specified numbers, do an interval e2fsck .

Obeys the 'pfix=fsck' kernel parameter
to force file system checking.

Special feature : FSCK Interactive Mode.
Keyboard is not necessarily needed, any questions have
a timeout of 20 seconds and would fall back into
non-interactive mode.

"
gettext "$MSG"
exit $1
}

 while [ "$1" ]; do
#until [ $# = 0 ]; do
case $1 in
*h|*help|*usage) _usage 0;;
*V|*version)  echo -e "\n$0: Version '$VERSION'\nUse help to show usage.\n"; exit 0;;
*check*) set -n;;
*debug*) set -x;;
*verbose*) VERB=-v;L_VERB=--verbose;A_VERB=-verbose;VERBOSE=$((VERBOSE+1));;
*) :;;
esac
shift
done
#while [ "$1" ]; do shift; done

Q=-q; QUIET=--quiet
test "$VERBOSE" && unset Q QUIET

#alias modprobe='/sbin/modprobe --first-time'
alias chattr="chattr ${VERB:+'-V'}"
alias chmod="chmod $VERB"              ##+++2016-10-13
alias cp="cp $VERB"
alias ln="ln $VERB"
alias mkdir="mkdir $VERB"
alias modprobe="modprobe -b $Q $VERB"  ##+++2013-12-07
alias mount="busybox mount ${VERB:+'-vv'}"
alias mv="mv $VERB"
alias rm="rm $VERB"
alias rmdir="rmdir $VERB"
alias umount="busybox umount ${VERB:+}"



### +++ 2016-10-08
_check_chattr(){
which chattr lsattr >>$OUT || return 3
test "$*"    || return 2
test -e "$*" || return 2
stat -f -c %T / | grep $Q 'ext[2-5]' || return 1 # no ext2-4 filesystem
lsattr -d "$*" | awk '{print $1}' | grep $Q 'i'  # returns 0 if contained, 1 if not
}

_mkdir(){
test "$*"    || return 2
test -d "$*" && return 0
test -e "$*" && return 3
_check_chattr "${*%/*}" && chattr -i "${*%/*}"
#_check_chattr "$*"      && chattr -i "$*"
mkdir -p "$*"
}

_remount_root(){
local mode="$1"
[ "$mode" ] || return 2
#[ -L /proc/mounts -a -e /proc/mounts ] || {
 stat -f -c %T /proc | grep $Q '^proc$' || {
 #force /proc being mounted
 mount -o remount,rw /dev/root / || return 3
 _mkdir /proc                    || return 4
 mount -t proc proc /proc        || return 5
 }
grep '^/dev/root / ' /proc/mounts | grep $Q -w "$mode" && return 0
mount -o remount,$mode /dev/root /
}

_mount_proc(){
# STEP 1: unmount any overlay mounts of /proc
while :
do
# /proc/mounts is a link to /proc/self/mounts
# test -s /proc/self/mounts returns 1 always,
# file    /proc/self/mounts returns 'empty'
# file -s /proc/self/mounts returns 'ASCII text'
##( _test_Lef /proc/mounts && _test_Led /proc/self ) || break
# now trying stat ..
stat -f -c %T /proc | grep $Q '^proc$' || break
# unmount submounts like /proc/bus/usb
M=`/bin/cat -E /proc/mounts`
M=`echo $M | rev |sed 's/ $[0-9] [0-9] /\n/g' | rev`
P=`echo "$M" | cut -f2 -d' ' | grep '/proc/' | cut -f1 -d' '`
for oneP in $P; do oneP=`echo -e "$oneP"`; umount "$oneP"; done
cut -f2 -d' ' /proc/mounts | grep $Q '^/proc$' && umount /proc && sleep 1 || break
done
# STEP 2: remove bottom most /proc directory
_secure_remove_force /proc 2>/dev/null # printing errors if mounted is far too slow in kernel console
# STEP 3: get /dev/root rw, create /proc directory and mount /proc
_remount_root rw
stat -f -c %T /proc | grep $Q '^proc$' && return 0
_mkdir /proc
mount -t proc proc /proc
}
_mount_proc

_mount_sys(){
while :
do
# /proc/mounts is a link to /proc/self/mounts
# now trying stat ..
stat -f -c %T /proc | grep $Q '^proc$' || return 2
# unmount submounts like /sys/kernel/debug
M=`/bin/cat -E /proc/mounts`
M=`echo $M | rev |sed 's/ $[0-9] [0-9] /\n/g' | rev`
S=`echo "$M" | cut -f2 -d' ' | grep '/sys/' | cut -f1 -d' '`
for oneS in $S; do oneS=`echo -e "$oneS"`;
_debugx $one$
umount "$oneS"; done
cut -f2 -d' ' /proc/mounts | grep $Q '^/sys$' && umount /sys && sleep 1 || break
done
_debug "`mount | grep '/sys'`"
# STEP 2: remove bottom most /proc directory
_secure_remove_force /sys 2>/dev/null # printing errors if mounted is far too slow in kernel console
# STEP 3: get /dev/root rw, create /proc directory and mount /proc
_remount_root rw
_mkdir /sys
mount -t sysfs sysfs /sys
}
_mount_sys

status_func() {
 test "$*" || return 126
 test "${*//[[:digit:]]/}" && return 125
 if [ $1 -eq 0 ];then
  echo -e "\\033[72G\\033[1;32mdone\\033[0;39m"   >/dev/console #green [done] msg.
 else
  echo -e "\\033[70G\\033[1;31mfailed\\033[0;39m" >/dev/console #red [failed].
  STATUS=0
 fi
 return $1 #return with same status as entry param.
}

if [ "$PUPMODE" = 2 ]; then

_cleanup_tmp(){
_remount_root rw && {
###+++2011-11-10
 if [ -d /tmp ] ; then
   rm -rf /tmp/* ; rm -rf /tmp/.[a-zA-Z0-9]*  ##2011-11-25 added rm of hidden temp files
 else
   mkdir -p /tmp
 fi
 }
 chmod 1777 /tmp
 ###+++2011-11-10 2016-10-13
}
_cleanup_tmp
else
STATUS=0
status_func $STATUS
fi

_link_dev_stdfd(){
 ln -snf ../proc/self/fd /dev/fd
 ln -sf fd/0 /dev/stdin
 ln -sf fd/1 /dev/stdout
 ln -sf fd/2 /dev/stderr
 return 0
 }

_mk_dev_console(){
 test -c /dev/console || mknod /dev/console c 5 1
 test -c /dev/null    || mknod /dev/null    c 1 3
 return 0
 }

_populate_dev(){
 mountpoint $Q /dev && {
 # REM: Either initrd or kernel has mounted /dev
 #      but it could be mounted read-only
 #      or new initrd code unmounted /dev
 mountDEV=`grep ' /dev ' /proc/mounts | tail -n1`
 if echo "$mountDEV" | grep $Q -w ro; then
  deviceDEV=`echo "$mountDEV" | awk '{print $1}'`
  [ "$deviceDEV" ] && mount -o remount,rw $deviceDEV /dev
 else true
 fi
 [ $? = 0 ] && _link_dev_stdfd
 true   # TODO: if the above fails, what then ??
         } || {
 test -d /dev || mkdir /dev
 mount -t ramfs -o rw devramfs /dev # TEST: ramfs instead tmpfs
 _link_dev_stdfd ; _mk_dev_console ;

 test "`which mdev`" && { mdev -s; } || {

  oldIFS="$IFS"
     IFS=$'\n'
     /bin/find /sys -type f -name uevent -perm 644 |
     while read oneFILE
     do
     unset K MAJOR MINOR DEVPATH DEVNAME DEVTYPE DRIVER DEVICE PRODUCT TYPE BUSNUM DEVNUM INTERFACE MODALIAS DEVMODE
     source "$oneFILE" 2>>$ERR  || continue
     test "$MAJOR" -a "$MINOR"      || continue
     test "$DEVNAME" && { test -e /dev/$DEVNAME && continue; } || { DEVNAME=${oneFILE%/uevent*}; DEVNAME=${DEVNAME##*/}; test -e /dev/$DEVNAME && continue; }
     test "$DEVMODE" && DEVMODE=-m\ $DEVMODE
     test -e /dev/$DEVPATH/$DEVNAME || {
     test "$DEVTYPE" = disk -o "$DEVTYPE" = partition && K=b || K=c
     test ${DEVNAME%/*} = $DEVNAME || { test -d /dev/$DEVPATH/${DEVNAME%/*} || mkdir -p /dev/$DEVPATH/${DEVNAME%/*}; }
     mknod $DEVMODE /dev/$DEVPATH/$DEVNAME $K $MAJOR $MINOR
      }
     done
    IFS="$oldIFS"

          } ###+++2014-06-25 mdev
         }  # +++2015-06-19 manual
}
_populate_dev

#else
#STATUS=0
#status_func $STATUS
#fi   # "$PUPMODE" = 2

_do_busybox_init(){  ###KRG
_remount_root ro     ##+++2016-10-13
umount /sys
umount /proc
exec busybox init
}


if [ "$PUPMODE" != 2 ]; then
_do_busybox_init
fi  ###KRG

_get_rdev(){
devPDEV1=$(rdev | cut -f 1 -d ' ')
PDEV1=${devPDEV1##*/}
devROOT="$devPDEV1" # used four times in several functions
DEV1FS=`mount | grep '^/dev/root on / type ' | cut -f 5 -d ' '`
echo -e "\e[1;35m""PDEV1='$PDEV1' DEV1FS='$DEV1FS'""\e[0;39m"  ##+++2011-11-10 2016-10-13
if [ "$DEBUG" ]; then
case $DEV1FS in ext[2-5])
dumpe2fs /dev/$PDEV1 | grep -i 'state';;
esac
fi
test "$PDEV1" -a "$DEV1FS"  ##+++2016-10-13 create proper return value
}
_get_rdev

_get_errflg() {  ###KRG
echo -e "\\033[1;34m"'Checking for unpropper previous shutdown  ... '"\\033[0;39m"
echo -ne "\\033[1;33m"'Searching for *fsckme* file 3 levels deep ... '"\\033[0;39m"
ErrFlag=`/bin/find / -xdev -maxdepth 3 -type f -iname '*fsckme*' | head -n1`  ###KRG 3 deep for fsckme.file@etc @boot @$HOME ..etc..
if [ -n "$ErrFlag" ] ; then  ##1
echo -e "\\033[1;31m" ' Found : '"\\033[0;39m""\\033[1;5;31m""$ErrFlag"
echo -e "\\033[0;39m"
return 1
fi #1
echo -e "\\033[56G\\033[1;5;32m"'Hurray , not found !'"\\033[0;39m"

_get_dump_ext234(){
 PDEV1=${PDEV1:-"${1##*/}"}
DEV1FS=${DEV1FS:-"${2}"}
case $DEV1FS in ext[2-5]) :;; *) return 126;; esac

echo -e "\\033[1;33m"'Checking for filesystem check intervals using'"\\033[0;39m"
#LANG=C ##exported on top of script
VARS=`dumpe2fs -h /dev/$PDEV1 | grep -E 'Maximum mount count|Mount count|Next check after|Check interval'`
test "$VARS" || return 125

nextch=`echo "$VARS" | grep 'Next check after' | tr '\n' ' '`
nextcM=`echo "$nextch" | tr -s ' ' | cut -f 5 -d ' '`
nextcD=`echo "$nextch" | tr -s ' ' | cut -f 6 -d ' '`
nextcY=`echo "$nextch" | tr -s ' ' | cut -f 8 -d ' '`  ##+++2013-03-25 was missing, test further down : ash : bad number
todays=`date`
todayY=`echo "$todays" | tr -s ' ' | cut -f 6 -d ' ' | tr -d [[:punct:]]`  ##+++ 2011_11_15 from luci218
todayM=`echo "$todays" | tr -s ' ' | cut -f 2 -d ' ' | tr -d [[:punct:]]`  ##lang dependent pos
todayD=`echo "$todays" | tr -s ' ' | cut -f 3 -d ' ' | tr -d [[:punct:]]`
mntcnt=`echo "$VARS" | grep 'Mount count' | grep -o '[[:digit:]]' | tr -d '\n'`
maxmnt=`echo "$VARS" | grep 'Maximum mount count' | grep -o '[[:digit:]]' | tr -d '\n'`
diffMC=$(( maxmnt - mntcnt ))
monthN=`for i in $(seq 1 12) ; do cal $i 1 | head -n 1 | grep -o '[[:alpha:]]\+' | sed "s/^/$i /"; done`
monthT=`echo "$monthN" | grep "$todayM"`  # echo ".. \n11 November\n12 December" | grep "Dec"
montTN=`echo "$monthT" | cut -f 1 -d ' '`
monthC=`echo "$monthN" | grep "$nextcM"`  # echo "1 January\n2 February\n .." | grep "Feb"
montCN=`echo "$monthC" | cut -f 1 -d ' '`

echo -e "\\033[0;39m"
_debug "_get_dump_ext234:END"
test "$mntcnt" -a "$maxmnt" -a "$todayY" -a "$nextcY" -a "$montTN" -a "$montCN" -a "$todayD" -a "$nextcD"
}
_get_dump_ext234 || return 124

_eval_dump(){
FSCK=
# REM: Three simple conditions create early return:
#      1) Mount Count is greater-equal Maximum Mount Count
#      2) This year is greater than year of Next Check After - must do
#      3) This year is lesser  than year of Next Check After - can not be possible
if [ "$mntcnt" -ge "$maxmnt" ] ; then
 echo -e "\\033[1;33m"'Maximum mount count reached'"\\033[0;39m"
 #FSCK='yes'
 #return 1
 false
elif [ "$todayY" -gt "$nextcY" ] ; then
 echo -e "\\033[1;33m"'Last scheduled check should have been in the past year(s)'"\\033[0;39m"
 #FSCK='yes'
 #return 1
 false
elif [ "$todayY" -lt "$nextcY" ] ; then
 #return 0
 true
# REM: And the same applies to month, since only year equal is left now.
elif [ "$montTN" -lt "$montCN" ] ; then
 #return 0
 true
elif [ "$montTN" -gt "$montCN" ] ; then
  echo -e "\\033[1;33m"'Last scheduled check should have been in the past month(s)'"\\033[0;39m"
  #FSCK='yes'
  #return 1
  false
 # REM: Now only day is left. Using greater than because dumpe2fs says next check after.
elif [ "$todayD" -gt "$nextcD" ] ; then
 echo -e "\\033[1;33m"'Day interval reached'"\\033[0;39m"
 #FSCK='yes'
 #return 1
 false
else
 true # maybe some variable was not a number
fi

}

unset FSCK
_eval_dump || FSCK='yes'

if [ -z "$FSCK" ] ; then #7
echo -e "\\033[1;32m"'OK , '"\\033[0;32m""next check '$nextcM $nextcD' or in '$diffMC' mounts""\\033[0;39m"
echo -e "\\033[0;39m"
#_do_busybox_init

else #7
echo -e "\\033[1;33m"'Filesystem check interval reached :'"\\033[0;39m"
echo -e "\\033[0;33m"'Today : '"\\033[0;33m""$todayM $todayD""\\033[0;33m"' , next check was or would be : '"\\033[0;33m""$nextcM  $nextcD""\\033[0;33m"
echo -e "\\033[0;33m"'mount intervals : '"\\033[0;33m""$mntcnt""\\033[0;33m"' of '"\\033[0;33m""$maxmnt"
echo -e "\\033[0;39m"
false
fi #7
}  #_get_errflg

_check_puppy_kernel_parameter(){  ##+++2012-02-02 2016-10-09

for a in "$@"; do
LIST="$a|$LIST"
done
LIST=`echo "$LIST" | sed 's%^|*%%;s%|*$%%' | tr -s '|'`
LIST=${LIST:-'*'}

pkp=`echo $pfix |sed 's:^pfix=::' | tr ',' ' '`
if [ "$pkp" ]; then
 echo "Booting with pfix='$pkp' kernel parameters."
 for p in $pkp; do
 case $p in
  #fsck)  FSCK='yes';;
  $LIST) RV=$((RV+0));; #bash-3.0 has problems with $VAR) in case, busybox ash works fine
  *)     RV=$((RV+1));;
  esac; done
else
 RV=126
fi

_debug "_check_puppy_kernel_parameter:END"
return $RV
}

_check_puppy_kernel_parameter fsck  ##+++2012-02-02
[ $? = 0 ] && pfixFSCK='yes'
[ "$pfixFSCK" = 'yes' ] || { _get_errflg && _do_busybox_init; } ###KRG


_leave_to_simple_console(){
#[ -n "$ERRMSG" ] && echo -e "\\033[0;31m""$ERRMSG""\\033[0;39m"
[ "$*" ] && _color_echo red "$*\n"
cd /
_remount_root ro
sleep $((SLEEP*2))
case `rdev` in *ram*)
   echo "Now ramdiskshell without busybox init on top.";;
*) echo "Now simple init=/bin/sh kernel parameter console.";;
esac
_color_echo green "Type 'busybox reboot -f' or press Cnt+Alt+Del to reboot.\n"
exec chroot . sh
}

#only come here if full hd install, and previous improper shutdown.
#PDEV1="`cat $ErrFlag | cut -f 1 -d ','`" #file format: sda1,ext3,
#DEV1FS="`cat $ErrFlag | cut -f 2 -d ','`"
_debug "case '$DEV1FS'"
case $DEV1FS in
 ext[2-4])

  echo -e "\\033[1;33m"  #34=blue, 33=yellow, 32=green, 31=red, 35=purple, 36=aquablue, 38=black.

  if [ -n "$ErrFlag" ] ; then
  echo "Performing filesystem check of '${PDEV1}' after improper shutdown"
  elif [ -n "$pfixFSCK" ] ; then
  echo "Performing filesystem check of '${PDEV1}' by kernel cmdline parameter."
  FSCK='yes'
  else
  echo "Performing scheduled filesystem check of '${PDEV1}' ."
  echo -e "\\033[0;32m""Use 'tune2fs -i $todayD[d|w|m] [+-] -C $maxmnt [+-] /dev/$PDEV1' to adjust ."
  fi

  echo -e "\\033[1;34m""NOTE: no progress indication, may take awhile, please wait patiently..."
  echo -e "\\033[0;39m"
  echo

_ask_to_continue(){
[ "$DebugVal" -ge 2 ] || return 0

_color_set none '\n'
_color_echo green "Continue this $0 ?\t [ any key ]\n"
_color_echo red   "Dropout into console ?\t\t [ c ]\n"
_color_set none '\n'

echo -ne "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"
read -n 1 -t $TimeOut Key
_color_set none '\n'

case $Key in C|c)
#echo -e "\\033[1;34m"'dropping to console now , partition still mounted !'"\\033[0;39m"
_leave_to_simple_console 'dropping to console now , partition still mounted !'
;;
esac

}

_start_uevent_program(){
[ -n "$HOTPLUGD" ] && return 0

[ -s /etc/rc.d/PUPSTATE ] || echo 'PUPMODE=2' > /etc/rc.d/PUPSTATE
. /etc/rc.d/MODULESCONFIG

BLACKLISTVARS="`echo "$SKIPLIST" | tr '\-' '_' | tr ' ' '\n' | sed -e 's/^/blacklist /' | grep -v ' $'`"
[ -f /tmp/pup_event_skiplist.conf ] || echo "$BLACKLISTVARS" > /tmp/pup_event_skiplist.conf
[ -f /tmp/pup_event_modprobe.conf ] || echo "$BLACKLISTVARS" > /tmp/pup_event_modprobe.conf

_update_modprobe_conf(){

KERNVER=`uname -r`
CONFFILE='/etc/modprobe.conf'
[ -s /etc/modprobe.d/modprobe.conf ] && CONFFILE='/etc/modprobe.d/modprobe.conf'
[ -s /etc/modprobe.d/puppy.conf ]    && CONFFILE='/etc/modprobe.d/puppy.conf'

[ -f "$CONFFILE" ] || return 0

SYSTEM1=`dmidecode -t 0 | grep -i -E 'vendor|version|release' | tr '\n' ' ' | tr -s '\t' | tr -s ' ' | sed 's/^[[:blank:]]*/ / ; s%\t% ; %g' | tr -s ' '`
SYSTEM2=`dmidecode -t 1 | grep -i -E 'manufacturer|product|name|version|number|release' | tr '\n' ' ' | tr -s '\t' | tr -s ' '| sed 's/^[[:blank:]]*/ / ; s%\t% ; %g' | tr -s ' '`
SYSTEM3=`dmidecode -t 2 | grep -i -E 'manufacturer|product|name|version|number|release' | tr '\n' ' ' | tr -s '\t' | tr -s ' '| sed 's/^[[:blank:]]*/ / ; s%\t% ; %g' | tr -s ' '`
SYSTEM="${SYSTEM1}
${SYSTEM2}
${SYSTEM3}"
WC=`echo "$SYSTEM" | wc -l`
_debug "SYSTEM='$SYSTEM'"
_debugx "WC='$WC'"

#GREPpattern=$(echo "$SYSTEM" | head -n 1 | sed 's/\([[:punct:]]\)/\\\\\1/g ; s/\\\\/\\/g ; s#\ #\\\ #g ; s/ $// ; s/\\$//')
GREPpattern=$(echo "$SYSTEM" | head -n 1 | sed 's/\([[:punct:]]\)/\\\\\1/g ; s#\ #\\\ #g ; s/\ *$// ; s/\\$//' | tr -s '\\')
###|sed -r 's/\./\\\./g;s/\*/\\\*/g;s#-#\\\-#g'
FIELD=`grep -B 1 -n "$GREPpattern" "$CONFFILE"`
[ -n "`echo "$FIELD" | grep "$KERNVER"`" ] && return 0

cp "$CONFFILE" "$CONFFILE".`basename $0`.$KERNVER.sbin_init.bac

echo >> "$CONFFILE"
echo '#####  Updated modaliases for system  ###########' >> "$CONFFILE"
echo '### RUNNING kernel '"$KERNVER" >> "$CONFFILE"

for i in `seq 1 $WC` ; do

PARAM=`echo "$SYSTEM" | head -n $i | tail -n 1 | tr '\t' ' ' | tr -s ' '`
STRING="### ${PARAM} "
echo "$STRING" >> "$CONFFILE"

done

echo >> "$CONFFILE"

UEVENTS="`ls /sys/bus/*/devices/*/uevent`"

for i in $UEVENTS ; do

DRVR=`grep 'DRIVER'   $i 2>/dev/null | cut -f 2 -d '='`;
MODA=`grep 'MODALIAS' $i 2>/dev/null | cut -f 2 -d '='` ;

if [ -n "$DRVR" ] && [ -n "$MODA" ] ; then
echo -n 'alias ' >> /tmp/sbin_init_modaliases.conf
echo -n "$MODA " >> /tmp/sbin_init_modaliases.conf
echo "$DRVR" >> /tmp/sbin_init_modaliases.conf
fi

done

sort -u /tmp/sbin_init_modaliases.conf | sort -k 3 -t ' ' >> "$CONFFILE"

echo >> "$CONFFILE"
echo '### '`cat /proc/cmdline` >> "$CONFFILE"
echo '### '`date` >> "$CONFFILE"
echo "##### by $0 #######################" >> "$CONFFILE"

}
_update_modprobe_conf

if [ -x /sbin/photplug ] ; then
[ -f /tmp/hotplug.modules ] || { /sbin/modprobe -c | sed 's%\*%\.\*%g' >/tmp/hotplug.modules.sed
#awk '{print $2}' /tmp/hotplug.modules.sed >/tmp/hotplug.modules ;
grep '^alias' /tmp/hotplug.modules.sed | awk '{print $2}' > /tmp/hotplug.modules ;
}
echo '/sbin/photplug' >/proc/sys/kernel/hotplug
test $? = 0 && HOTPLUGD='photplug'

elif [ -x /sbin/udevd ];then

 echo '0' > /tmp/pup_event_alsa_cnt
 if [ -x /sbin/pup_event_backend_modprobe_protect ] ; then
 nice -n -3 /sbin/pup_event_backend_modprobe_protect --daemon &
 fi

 rm -rf /dev/.udev/*/*
 #100611 UDEV_LOG=2 to prevent non-critical o/p to screen at bootup and shutdown...
 UDEVVER=`udevd --version`
 if [ "${UDEVVER:-151}" -gt 150 ];then
  #100611 v151 is recommended for kernel 2.6.27+.
  UDEV_LOG=1 /sbin/udevd --daemon --resolve-names=never ###KRG ; orig LOG=2
 else
  UDEV_LOG=1 /sbin/udevd --daemon ###KRG ; orig LOG=2
 fi
 test $? = 0 && HOTPLUGD='udevd'
else
 /sbin/pup_event_backend_d >/tmp/pup_event_backend_errors 2>&1 & #hotplug daemon. my homebrew replacement for udevd.
 HOTPLUGD='pup_event_backend_d'
fi

_debug "_start_uevent_program:END"
}


_load_kernel_drivers(){
INITSTATE=`find /sys -name "initstate"`
INITSTATECOUNT=`echo "$INITSTATE" | wc -l`
_debug "INITSTATECOUNT='$INITSTATECOUNT'"

[ -n "$INITSTATE" ] && [ "$DebugVal" = "2" ] && for i in $INITSTATE ; do echo -n "$i " ; cat "$i" ; done  ##echo

if [ "${INITSTATECOUNT:-24}" -gt 25 ] ; then
echo "More than 25 initstate files exist ( $INITSTATECOUNT ) :"
echo "$INITSTATE" | tr '\n' ' '
sleep $((SLEEP*2))s
return 0
fi

MODALIASES="`ls /sys/bus/*/devices/*/modalias`"

if [ -z "$MODALIASES" ] ; then
echo -e "\e[1;5;31m"'WARNING : '"\e[0;31m"'No modaliases found !'"\e[39m"
echo -e "\e[39m"'Either the kernel detected no HW automatically'"\e[39m"
echo -e "\e[39m"'or something else went wrong'"\e[39m"
return 1
fi

echo -n "Loading kernel modules "

modprobe nls_cp437 #these needed by vfat/ntfs/ext2 f.s.'s.
modprobe nls_iso8859-1 #

echo 'Running the modaliases add by /sbin/init '$0 >> /tmp/pup_event_module_devpath_log

MODULECNT=0
for oneMODALIAS in $MODALIASES
do
 onePATH=${oneMODALIAS%/*}

 if [ -e "${onePATH}"/uevent ];then
 ## cat "${onePATH}"/uevent  #DEBUG
  ##sleep 2s
  echo "$oneMODALIAS" >> /tmp/modaliases.loaded
  echo 'add' > "${onePATH}"/uevent #generates an 'add' uevent.
  echo -n '.'
  MODULECNT=$((MODULECNT+1))
  sleep 0.2
 ## cat ${onePATH}/uevent  #DEBUG
 fi

done

echo >> /tmp/pup_eve_bac_mod.log
echo >> /tmp/pup_event_module_devpath_log
echo '###########' >> /tmp/pup_event_module_devpath_log
echo
echo -e 'Detected '"\e[1;34m""$MODULECNT ""\e[0;39m"'busses'
MODULECNT=0

sleep $((SLEEP*3))s

LSMODCNT=`wc -l /proc/modules | awk '{print $1}'`
if [ "${LSMODCNT:-0}" -gt 0 ] ; then
echo -ne 'Loaded   '"\e[1;35m""$LSMODCNT ""\e[0;39m"'drivers at least'
else
cut -f 1 -d ' ' /proc/modules | sort -g | tr '\n' ' '
fi

_debug "_load_kernel_drivers:END"
status_func 0
echo
sleep 1s
}

_update_partition_device_nodes(){
# REM: In case of usual static /dev directory
# when booting a kernel configured with CONFIG_DEBUG_BLOCK_EXT_DEVT=y
# which would use 259 major numbers instead 8 for sata or 3 for ide
# things might getting problematic. Also if more partitions
# made on a hdd than available device nodes.
_start_uevent_program
_load_kernel_drivers  # for usb drivers

echo -n "Updating Device nodes " >/dev/console
local STATUS=0 MAJ MIN SIZE SDEV
CATPROCPART=`cat /proc/partitions | sed 's%^\ *[[:alpha:]].*%%g' | sed '/^$/d'`
echo "$CATPROCPART" | while read MAJ MIN SIZE SDEV ; do
rm -f "$1"/dev/$SDEV
STATUS=$(( STATUS + $? ))
mknod "$1"/dev/$SDEV b $MAJ $MIN
STATUS=$(( STATUS + $? ))
echo -n '.' >/dev/console
done

if [ "$PUPMODE" = 2 ]; then
status_func $STATUS
fi

_debug "_update_partition_device_nodes:END"
return $STATUS
}
_update_partition_device_nodes

###KRG loading input drivers:
_load_input_drivers(){

_color_echo1 blue "Loading keyboard and other drivers ...\n"

DRIVERS=`modprobe -l | grep -E 'usbhid|rtc-cmos|libps2|atkbd|xtkbd|evdev' | grep -vE 'snd|sound' | sort -k4,8 -t '/'`

for i in $DRIVERS ; do

DRIVER=`basename $i | sed 's%\.ko.*$%%'`
DRVpattern=`echo "$DRIVER" | tr '-' '_'`

if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then
echo -ne "\\033[1;33m""$DRIVER ""\\033[1;34m"'.. '"\\033[0;39m"
modprobe $DRIVER
fi

done

echo -e "\\033[0;39m"
}
_load_input_drivers


###KRG loading fbcon :
_load_framebuffer_drivers(){
[ "`grep -E 'vga=ask|vga=0x3[0-9a-fA-F][0-9a-fA-F]|vga=[7-8][0-9][0-9]' /proc/cmdline`" ] || return 0

echo -e "\\033[1;34m""Trying to load i2c and framebuffer drivers ...""\\033[0;39m"
I2CS=`modprobe -l | grep -i 'i2c' | grep -v -E 'snd|sound' | while read line ;do basename $line | sed 's%\.ko.*$%%' ;done`

GRAPHB=`ddcprobe | grep -E 'vbe|oem|vendor|product' | cut -f 2-99 -d ' ' | tr '[A-Z]' '[a-z]' | tr '\n' ' '`
echo -e "\\033[1;33m"'video-info : '"\\033[1;34m"$GRAPHB"\\033[0;39m"

MBOARD=`dmidecode | grep -i -E 'Family|Manufacturer' | tr -d '\t ' | cut -f 2 -d ':' | grep -v -i 'none' | tr '[[:punct:]]' ' ' | cut -f 1 -d ' ' | tr '\n' ' '`
echo -e "\\033[1;33m"'board-info : '"\\033[1;34m"$MBOARD"\\033[0;39m"

POOL="$GRAPHB $MBOARD"
sleep 4s

if [ -n "`echo "$MBOARD" | grep -i 'Intel'`" ] ; then
if [ -n "`modprobe -l | grep -Ee 'i2c-i801|i801_smbus'`" ] ; then
POOL="$POOL i2c\-i801 i801_smbus"
fi
fi

#echo $POOL
##_ask_to_continue
POOL=`echo "$POOL" | sort -u`

if [ ! "`elspci -l | grep -i -E '<.*fb>|<agp.*>|<.*agp.*>|<.*agp>|<vga.*>|<.*vga.*>|<.*vga>'`" ] ; then

for i in $POOL ; do
##echo -e "\\033[0;39m"
I2C=`echo "$I2CS" | grep -i $i`

 if [ -n "$I2C" ] ; then
 echo -ne "\\033[1;33m"'Loading ...'"\\033[0;39m"

 for j in $I2C ; do
 DRIVER=`basename $j`
 DRVpattern=`echo "$DRIVER" | tr '-' '_'`
 if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then
 echo -ne "\\033[1;34m""$DRIVER ""\\033[1;33m"'.. '"\\033[0;39m"
 modprobe $DRIVER
 fi
 done

 echo -e "\\033[0;39m"
 fi

done
echo -e "\\033[0;39m"

FBDRIVERS=`modprobe -l | grep 'fb' | while read line ;do basename $line | sed 's%\.ko.*$%%' ;done`

if [ -n "`echo "$GRAPHB" | grep -i 'Intel'`" ] ; then
if [ -n "`modprobe -l | grep -E 'i810fb'`" ] ; then
POOL="$POOL $FBDRIVERS i810fb"
fi
fi

##_ask_to_continue
POOL=`echo "$POOL" | sort -u`

for i in $POOL ; do
##echo -e "\\033[0;39m"
 FBS=`echo "$FBDRIVERS" | grep -i $i`
 if [ -n "$FBS" ] ; then
 echo -ne "\\033[1;33m"'Loading ... '"\\033[0;39m"

  for j in $FBS ; do
  DRIVER=`basename $j`
  DRVpattern=`echo "$DRIVER" | tr '-' '_'`
  [ "$DRIVER" = "nvidiafb" -a "`lsmod | grep 'nouveau'`" ] && continue
  [ "$DRIVER" = "nouveau" -a "`lsmod | grep 'nvidiafb'`" ] && continue
  if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then
  echo -ne "\\033[1;34m""$DRIVER ""\\033[1;33m"'.. '"\\033[0;39m"
  modprobe $DRIVER
  fi
  done

 echo -e "\\033[0;39m"
 fi

done
sleep 4s
fi

if [ -n "`modprobe -l | grep 'fbcon'`" ] && [ -z "`lsmod | grep 'fbcon'`" ] ; then
modprobe fbcon
echo -e "\\033[0;39m"
fi
_debug "`lsmod | cut -f 1 -d ' ' | sort | tr '\n' ' '`"  #DEBUG
}
_load_framebuffer_drivers  ###COMMENT if required ; fbcon makes colors little greyish  ###KRG
sleep 5s  ###DBG


###KRG ask for debug mode
_ask_debug(){
test -x /etc/rc.d/rc.country && /etc/rc.d/rc.country # set correct keyboard layout

DebugVal=0

_color_echo none "Do you think $0 DEBUG MODE is required ?\n"

_color_echo1 blue "If so , press [ y ] for normal debug incl. 'fsck -v' ,\n"

echo -en "\\033[6;7;32m"
          echo    "    or  press [ Y ] for extensive output ,            "

_color_echo1 cyan "which may confuse muchly first and second time ...\n"

_color_echo1 pink "If not wait 20 sec. or press any other key and or simply [ Enter ]\n"

echo

echo -ne "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"

read -n 1 -t 20 K
_color_echo none '\n\n'

if [ "$K" = "y" ] ; then
DebugVal=1
_color_echo orange 'Debug Mode '"$DebugVal"' turned on' '\n  Have FUN !\n'

elif [ "$K" = "Y" ] ; then
DebugVal=2
_color_echo red 'Debug Mode '"$DebugVal"' turned on' '\n  Have FUN !!\n'

else
DebugVal=0
_color_echo pink 'Keeping in Silent Screen Mode.\n'
fi

TimeOut=$(( (DebugVal + 1) * 20 ))
SLEEP=$((DebugVal+1))

[ "$DebugVal" -ge "1" ] && echo && echo -e "\\033[0;33m"'TimeOut='"\\033[0;39m""$TimeOut""\\033[0;33m"' , additional_sleep_value='"\\033[0;39m""$SLEEP"
_color_echo none '\n'
}
_ask_debug


###+++2011-11-15
_null_or_console(){
if [[ $DebugVal == '0' ]] ; then
 OUT='/dev/null'  ##2>&1
 ERR='/dev/null'
elif [[ $DebugVal == '1' ]] ; then
 OUT='/dev/null'
 ERR='/dev/console'
elif [[ $DebugVal == '2' ]] ; then
 OUT='/dev/console'
 ERR='/dev/console'
else
 OUT='/dev/console'
 ERR='/dev/console'
 _warn "_null_or_console:Unhandled DebugVal '$DebugVal'"
 _warn "Setting OUT to '$OUT' , ERR to '$ERR'"
fi
_debug "OUT='$OUT' ERR='$ERR'"
_debug "OUT='$OUT'" >> $OUT  ##-2011-11-25 was > $directOutD
_debug "ERR='$ERR'" >> $ERR
}
_null_or_console
###+++2011-11-15


##+++2013-05-11
_kill_daemons(){
(
pidof udevd && killall udevd
pidof pup_event_backend_modprobe_protect && killall pup_event_backend_modprobe_protect
pidof pup_event_backend_d && killall pup_event_backend_d
sleep 1
) >>$OUT 2>>$ERR
}
_kill_daemons
##+++2013-05-11


_do_fsck(){
[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;33m"'_do_fsck called with param $1='"\\033[0;39m""$1""\\033[0;33m"' $2='"\\033[0;39m""$2"
_color_echo none '\n'

[ "$1" != "/dev/$PDEV1" ] && [ -n "`mount | grep -w "^$1"`" ] && umount -lr "$1"
sleep 1s
[ -n "`mount | grep -w "^$1" | cut -f 6 -d ' ' | grep 'rw'`" ] && mount -o remount,ro $1
sleep 2s
Err=''
RETFSCK=''
CLEAN=''

FSTYPE=`guess_fstype "$1"`
[ "$FSTYPE" = "unknown" ] && FSTYPE=`disktype "$1" | grep -i 'file system' | cut -f 1 -d ' ' | tr '[A-Z]' '[a-z]'`
[ -z "$FSTYPE" ] && FSTYPE='unknown'
[ "$DebugVal" = "2" ] && echo 'FSTYPE='"$FSTYPE"

case $FSTYPE in
ext2|ext3|ext4)

if [ -z "$2" ] ; then
_color_echo1 blue "Checking Partition $1 in -n mode
if required binaries are usable. Please wait ...\n"

[ "$DebugVal" = "0" ]   && { RETFSCK=`e2fsck -n "$1" 2>/dev/null` || Err=$?; }
[ "$DebugVal" -ge "1" ] && { RETFSCK=`e2fsck -n "$1"` || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Fsck returned'="$Err""\\033[0;39m"

else
_color_echo1 blue "Checking Partition $1 in normal mode
if required binaries are usable. Please wait ...\n"

[ "$DebugVal" = "0" ] && e2fsck -p "$1"
[ "$DebugVal" = "0" ] && { RETFSCK=`e2fsck -n "$1" 2>/dev/null` || Err=$?; }
[ "$DebugVal" -ge "1" ] && e2fsck "$1"
[ "$DebugVal" -ge "1" ] && { RETFSCK=`e2fsck -n "$1"` || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Fsck returned'="$Err""\\033[0;39m"
fi

CLEAN=`echo "$RETFSCK" | tail -n 1 | grep -i -o 'clean'`
;;
*)
_color_echo1 blue "NOTE : Filesystem types other than ext2|ext3|ext4 not yet supported .
Omitting fsck of $1 ...\n"
CLEAN='guessing_clean'
;;
esac

if [ -n "$CLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq 0 ] ; then
_color_echo1 green "! OK !\n"
_color_echo green "Filesystem marked 'clean' .\n"

else
echo -e "\\033[1;31m"":Ooops: ""\\033[0;31m""Fs not clean.""\\033[0;39m"
[ -n "$FSCK" ] && _color_echo green 'Reaching the max mount intervals also marks the fs "not clean" .\n'

[ "$FSTYPE" = "ext2" ] && _color_echo1 blue "Note : ext2 fs is getting marked 'unclean' very easily. Better use ext3 or ext4.\n"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m""$RETFSCK" | head -n 1
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m""$RETFSCK" | tail -n 1
_color_echo blue "Looking for other usable installations ...\n"
fi

_color_echo none '\n'
}

_do_first_fsck(){
_remount_root ro
_do_fsck "/dev/$PDEV1"
#_remount_root rw
if [ -n "$CLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq 0 ] ; then
_color_echo1 blue "Booting installation ...\n"
_color_echo none '\n'
_remount_root rw
rm -f "$ErrFlag"  # read-only filesystem
_remount_root ro
_ask_to_continue
_do_busybox_init
fi
_remount_root rw
}
[ -z "$FSCK" ] && _do_first_fsck

_get_partitions(){
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'ROOTDRIVE='"\\033[0;39m""$PDEV1"
DRIVES=''
DRIV=`cat /proc/partitions | grep '^ ' | grep -v 'loop' | sed 's%^ *%%' | tr -s ' ' | cut -f 4 -d ' ' | cut -b 1-3 | uniq`
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Attached drives : '"\\033[0;39m"$DRIV

for i in $DRIV ; do
FDISK=`fdisk -l /dev/$i | grep -i 'linux' | grep -viE 'swap|Partition' | cut -f 1 -d ' '`
DRIVES="`echo -e "$DRIVES\n""$FDISK"`"
done

DRIVES=`echo "$DRIVES" | sed '/^$/d' | grep -vw "$devROOT" | tr '\n' ' '`
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Other partitions : '"\\033[0;39m""$DRIVES"

[ -z "`echo $DRIVES | grep '[[:alpha:]]'`" ] && DRIVES=''
if [ -z "$DRIVES" ] ; then
DRIVES=`cat /proc/partitions | grep '^ ' | grep '[0-9]$' | sed 's%^ *%%' | tr -s ' ' | cut -f 4 -d ' '`

DRIVES=`echo "$DRIVES" | grep -vw "$PDEV1" | sed 's%^%/dev/%g' | tr '\n' ' '`
_print_debug1 'DRIVES: '"$DRIVES\n"
fi

if [ -z "$DRIVES" ] ; then
#ERRMSG="Could not find any usable drives in /proc/partitions"
_leave_to_simple_console "Could not find any usable drives in /proc/partitions"
fi
}

_check_alternate_repo(){
# REM: if _do_first_fsck is not OK, try to find
# first some usable pup-xyz.sfs, and if that fails
# try to find usable full installs.
[ -z "$CLEAN" ] || return 0
[ "$Err" -a "$Err" -ne 0 ] || return 0

_assign_glibc_version(){
CURRGLIBC=`basename $(find /lib -xdev -maxdepth 1 -name "libc-*.so")`

CURRCLMAJ=`echo "$CURRGLIBC" | cut -f 2 -d ' ' | cut -f 2 -d '.'`
CURRCLMin=`echo "$CURRGLIBC" | cut -f 2 -d ' ' | cut -f 3 -d '.'`
CURRCLMin=${CURRCLMin:-'0'}  ##+++2011-11-25
}

_umount_with_msg(){
MT="$1"
shift
MSG="$*"
test "$MT" || return 2
grep -w "$MT" /proc/mounts || return 1
MSG=`gettext "$MSG"`
echo "$MSG"
[ "$DebugVal" -ge "1" ] && echo -e '\033[0;33m'"Unmounting again "'\033[0;39m'"$MT"
umount "$MT"; RV=$?
test $RV = 0 && [ -d "$MT" ] && { sleep 1; rmdir "$MT"; }
return $RV
}

_find_install_frugal(){

_get_partitions  #TODO simplfy ?
_assign_glibc_version
modprobe squashfs

for oneDRV in $DRIVES ; do  ##for 0
[ "$oneDRV" ] || continue
[ "${oneDRV//[[:blank:]]/}" ] || continue

SIMPLEDRIVENAME=${oneDRV##*/}

mkdir -p /mnt/$SIMPLEDRIVENAME
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting '"\\033[0;39m"$oneDRV' on '"\\033[0;39m"/mnt/$SIMPLEDRIVENAME

mount -o ro $oneDRV /mnt/$SIMPLEDRIVENAME
[ $? = 0 ] || { rmdir /mnt/$SIMPLEDRIVENAME;continue; }  ##+++2013-12-07
SFS=`find /mnt/$SIMPLEDRIVENAME -xdev -maxdepth 3 -type f -name "*.sfs" | grep -iE 'luma|luci|lupu|pup|pu' | grep -vE 'devx|[a-z]drv|[a-z]drive|[a-z]p[0-9]+|\+mnt\+'`

###check found sfs part
if [ -z "$SFS" ] ; then  ##if 99
#echo  -e "\\033[0;33m"'No puppy.sfs found on '"\\033[0;39m"$oneDRV
_umount_with_msg /mnt/$SIMPLEDRIVENAME "No puppy.sfs found on '$oneDRV'"
continue  ##for 0
fi #if 99

for oneSFS in $SFS ; do ##for 1
[ "$oneSFS" ] || continue
[ "${oneSFS//[[:blank:]]/}" ] || continue

[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m"'Found '"\\033[0;35m"$oneSFS"\\033[0;39m"
bneSFS=`basename $oneSFS`

[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting now '"\\033[0;39m""$oneSFS /mnt/$bneSFS"
mkdir -p /mnt/$bneSFS
Err=0
mount-FULL -o loop $oneSFS /mnt/$bneSFS
Err=$?
sleep 1s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting returned error value='"\\033[1;34m""$Err""\\033[0;39m"

if [ "$Err" -eq 0 ] ; then ##100
 REPOGLIBC=$(find /mnt/$bneSFS/lib -xdev -maxdepth 1 -name "libc-*.so")
 if [ -z "$REPOGLIBC" ] ; then ##101
 #echo -e "\\033[0;31m"'No libc found in '"\\033[0;39m""$bneSFS"
 _umount_with_msg /mnt/$bneSFS "No libc found in '$bneSFS'"
 FOUND=''
 continue
 fi ##101
 
 REPOGLIBC=`basename "$REPOGLIBC"`
 REPOCLMAJ=`echo "$REPOGLIBC" | cut -f 2 -d '.'`
 REPOCLMin=`echo "$REPOGLIBC" | cut -f 3 -d '.'`
 REPOCLMin=${REPOCLMin:-'0'}  ##+++2011-11-25

 if [ "$REPOCLMAJ" -gt "$CURRCLMAJ" ] ; then #102
  #echo -e "\\033[0;31m""Major of libc in $bneSFS = '$REPOCLMAJ' and larger than actual '$CURRCLMAJ'""\\033[0;39m"
  _umount_with_msg /mnt/$bneSFS "Major of libc in $bneSFS = '$REPOCLMAJ' and larger than actual '$CURRCLMAJ'"
  FOUND=''
  continue
 elif [ "$REPOCLMAJ" -eq "$CURRCLMAJ" ] && [ "$REPOCLMin" -gt "$CURRCLMin" ] ; then #102
  #echo -e "\\033[0;31m""Minor of libc in $bneSFS = '$REPOCLMin' and larger than actual '$CURRCLMin'""\\033[0;39m"
  _umount_with_msg /mnt/$bneSFS "Minor of libc in $bneSFS = '$REPOCLMin' and larger than actual '$CURRCLMin'"
  FOUND=''
  continue
 else #102
  _color_echo green "Found '$REPOGLIBC' and should match '$CURRGLIBC' .\n"
  FOUND='1'
  break ##for 1
 fi #102
else #100
Err=99999
#echo -e "\\033[0;31m""Mounting $oneSFS failed""\\033[0;39m"
_umount_with_msg /mnt/$bneSFS "Mounting '$oneSFS' failed."
FOUND=''
continue
fi #100
unset bneSFS
done  ##for 1
###end check sfs part

[ -n "$FOUND" ] && [ "$Err" -eq 0 ] && break
unset oneDRV
done  ##for 0

echo -e "\\033[0;39m"
[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;31m"'$oneDRV='"\\033[0;39m""$oneDRV ""\\033[0;31m"'oneSFS='"\\033[0;39m""$oneSFS"
oneSFS=${oneSFS:-NOTAVAIL}
oneDRV=${oneDRV:-NOTAVAIL}

MOUNTLOOP=`mount | grep -E "$oneDRV|$bneSFS" | cut -f 1 -d ' ' | tr ' ' '|'`
MOUNT=`mount | /bin/grep -vE "$MOUNTLOOP|$devROOT" | grep '^/dev/' | grep -vE  'initrd|none|*tmpfs|root|unionfs|aufs|pts|shm|usbfs' | cut -f 1 -d ' '`
_print_debug2 "$MOUNTLOOP : $MOUNT :\n"
[ "$DebugVal" -ge "1" ] && mount

for m in $MOUNT ; do
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Unmounting again '"\\033[0;39m"$m
umount -dlr $m
sleep 1s
rmdir /mnt/${m##*/}
done

[ "$DebugVal" -ge "1" ] && [ -n "$MOUNT" ] && mount && _color_echo none '\n'
sleep $((SLEEP*3))s

#DEBUG
mount
echo "'/mnt/'$bneSFS'"
mount | grep "/mnt/$bneSFS"

if [ -n "`mount | grep "/mnt/$bneSFS"`" ] ; then #103
REPO="/mnt/$bneSFS"
REPOSFS="${REPO##*/}"
REPOPART="$oneDRV"

_color_echo none
echo -e "\\033[0;32m"'Repository to use : '"\\033[1;32m""$REPOSFS""\\033[0;32m"' on '"\\033[1;32m""$REPOPART"
_color_echo none
sleep $((SLEEP*2))s

else  #103
_color_echo none '\n'
_color_echo red "No suitable puppy.sfs found.\n"
echo "Trying for Puppy full installations ...."
_color_echo none '\n'
sleep $((SLEEP*2))s
REPO=''
fi #103
}
_find_install_frugal

_find_install_full(){
###partitions full installs
_get_partitions
_assign_glibc_version

for oneDRV in $DRIVES ; do ##for 0
[ "$oneDRV" ] || continue
[ "${oneDRV//[[:blank:]]/}" ] || continue

SIMPLEDRIVENAME=${oneDRV##*/}
mkdir -p /mnt/$SIMPLEDRIVENAME
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting '"\\033[0;39m""$oneDRV""\\033[0;33m"' on '"\\033[0;39m""/mnt/$SIMPLEDRIVENAME""\\033[0;39m"

mount -o rw $oneDRV /mnt/$SIMPLEDRIVENAME
[ $? = 0 ] || { rmdir /mnt/$SIMPLEDRIVENAME;continue; }

unset DS DISTRO_NAME DISTRO_VERSION
[ -d /mnt/$SIMPLEDRIVENAME/etc ] || { _umount_with_msg /mnt/$SIMPLEDRIVENAME "No /etc folder."; continue; }
DS=`find /mnt/$SIMPLEDRIVENAME/etc -xdev -maxdepth 2 -type f -name "DISTRO_SPECS"`
   [ "$DS" ] || { _umount_with_msg /mnt/$SIMPLEDRIVENAME "No Puppy Linux DISTRO_SPECS file."; continue; }
[ -f "$DS" ] || { _umount_with_msg /mnt/$SIMPLEDRIVENAME "DISTRO_SPECS is not a file."; continue; }
[ -s "$DS" ] || { _umount_with_msg /mnt/$SIMPLEDRIVENAME "DISTRO_SPECS is empty file."; continue; }
. "$DS"
[ -n "$DISTRO_NAME" ] && [ -n "$DISTRO_VERSION" ] || { _umount_with_msg /mnt/$SIMPLEDRIVENAME "DISTRO_NAME DISTRO_VERSION not set in DISTRO_SPECS"; continue; }
_color_echo1 green "Found $DISTRO_NAME $DISTRO_VERSION\n"

REPOGLIBC=$(find /mnt/$SIMPLEDRIVENAME/lib -xdev -maxdepth 1 -name "libc-*.so")

if [ -z "$REPOGLIBC" ] ; then #4.1.1
#echo -e "\\033[0;31m"'No GLIBC found on '"\\033[0;39m"$oneDRV
_umount_with_msg /mnt/$SIMPLEDRIVENAME "No GLIBC found on 'oneDRV'"
continue
fi  ##4.1.1

REPOGLIBC=`basename "$REPOGLIBC"`
REPOCLMAJ=`echo "$REPOGLIBC" | cut -f 2 -d '-' | cut -f 2 -d '.'`
REPOCLMin=`echo "$REPOGLIBC" | cut -f 2 -d '-' | cut -f 3 -d '.'`
REPOCLMin=${REPOCLMin:-0}

 if [ "$REPOCLMAJ" -gt "$CURRCLMAJ" ] ; then ##4.2
  #echo -e "\\033[0;31m""LIBC major = '$REPOCLMAJ' larger than '$CURRCLMAJ'""\\033[0;39m"
  _umount_with_msg /mnt/$SIMPLEDRIVENAME "LIBC major = '$REPOCLMAJ' larger than '$CURRCLMAJ'"
  continue
 elif [ "$REPOCLMAJ" -eq "$CURRCLMAJ" ] && [ "$REPOCLMin" -gt "$CURRCLMin" ] ; then ##4.2
  #echo -e "\\033[0;31m""LIBC minor = '$REPOCLMin' larger than '$CURRCLMin'""\\033[0;39m"
  _umount_with_msg /mnt/$SIMPLEDRIVENAME "LIBC minor = '$REPOCLMin' larger than '$CURRCLMin'"
  continue
 else ##4.2
  _color_echo green "Found '$REPOGLIBC' and should match '$CURRGLIBC'\n"
  _color_echo1 blue "Fscking $oneDRV just in case ....\n"
  umount -lr $oneDRV
  sleep 2s
 fi ##4.2

 _do_fsck "$oneDRV" "other_full_installs"
  if [ -n "$CLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq "0" ] ; then  ##5
    echo -e "\\033[0;32m"'OK ,'"\\033[1;32m"" using REPO /mnt/$SIMPLEDRIVENAME""\\033[0;39m"
     echo
      mount -o rw $oneDRV /mnt/$SIMPLEDRIVENAME
      [ $? = 0 ] || { rmdir /mnt/$SIMPLEDRIVENAME;continue; }
     sleep 1s
     REPO="/mnt/$SIMPLEDRIVENAME"
    break
  else  ##5
    echo
    echo -e "\\033[1;31m""No ,""\\033[0;31m"" $oneDRV seems to be not clean , too""\\033[0;39m"
     echo "Trying next if possible ...."
     echo
      REPO=''
      [ -n "`mount | grep -Fw "$oneDRV"`" ] && umount -lr $oneDRV
     sleep 1s
    rmdir /mnt/$SIMPLEDRIVENAME
  fi  ##5

done  ##for 0
}
[ -z "$REPO" ] && _find_install_full

_maybe_found_repo(){
[ -z "$REPO" ] || return 0
echo
_color_echo1 red "No alternative usable repositories found .\n"
echo "You can continuing using files of full installation ."
echo "Hopefully none are corrupted ."
echo
_color_echo red "Type [ r ] or [ R ] to reboot\n"
_color_echo1 green "Type [ c ] or [ k ] for dropout into console\n"
_color_echo green "Else any other key and or simply [ Enter ] to continue\n"
_color_echo none '\n'

read -t $TimeOut K
echo

Key=`echo "$K" | tr '[A-Z]' '[a-z]'`
if [ "$Key" = "c" -o "$Key" = "k" ] ; then #7
#echo 'dropping to console now , partition still mounted !'
_leave_to_simple_console 'dropping to console now , partition still mounted !'

elif [ "$Key" = "r" ] ; then  #7
echo "Please do an 'e2fsck $devROOT' "
echo "via console/terminal using a LiveCd ."
echo "You may need to boot it with 'puppy pfix=ram' ."
echo "Remember , the timeout is 5 sec to press 'F2' ."
echo "Rebooting now in approx. 25 seconds"
sleep 22s

[ "$DebugVal" = "0" ]   && umount -a -r 2>/dev/null
[ "$DebugVal" -ge "1" ] && umount -a -r
[ "$DebugVal" -ge "1" ] && sleep 10s
sleep 2s

exec busybox reboot -f

else #7
_color_echo orange "Ok ... continuing ...\n"
REPO=''
fi  ##7
}
_maybe_found_repo

}

_check_alternate_repo
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'$REPO='"\\033[0;39m""$REPO"
sleep $((SLEEP*5))s  ###KRG
_ask_to_continue


_remount_root rw


_check_partitions(){
#####KRG
###KRG check devices case switching kernels sda|hda
ROOTDRIVE=`basename $(busybox rdev | cut -f 1 -d ' ')`  ### | cut -f 1 -d ' ' | sed 's%/dev/%%'`
ROOTBLOCKDRIVE=${ROOTDRIVE:0:3}
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'rootdrive='"\\033[0;39m""$ROOTDRIVE" && echo  ###DBG
FS=`mount | grep -Fw '/' | grep '^/dev/' | tr -s ' ' | cut -f 5 -d ' '`
PDEV1="$ROOTDRIVE"
DEV1FS="$FS"

if [ "$DebugVal" -ge "2" ] ; then
 echo -e "\\033[0;33m""$ROOTDRIVE $ROOTBLOCKDRIVE $FS "','" $PDEV1 $DEV1FS"
  DMESG=`dmesg | grep 'Mounted root' | grep -o 'device.*' | cut -f 2 -d ' ' | sed 's%[[:alpha:][:punct:]]$%%'` #+-2017-04-14 added missing closing ' to sed
  MAJ=`echo $DMESG | cut -f 1 -d ':'`
  Min=`echo $DMESG | cut -f 2 -d ':'`
  CATPP=`cat /proc/partitions | sed 's%^[a-zA-Z].*%%g ; s%^[[:blank:]][a-zA-Z]%%g ; /^$/d' | tr -s ' ' | sed 's%^ %%'`
  MAJBL=`echo "$CATPP" | grep -w "$ROOTBLOCKDRIVE" | cut -f 1 -d ' '`
  MinBL=`echo "$CATPP" | grep -w "$ROOTBLOCKDRIVE" | cut -f 2 -d ' '`
 echo $CATPP" $DMESG $MAJ $Min "','" $MAJBL $MinBL "',' && echo -e "\\033[0;39m"
fi
}
[ "$DebugVal" -ge "1" ] && _check_partitions


_check_free_ram(){
####
####KRG check for enough space in RAM ...
_color_echo1 blue 'Freeing ram ...\n'
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m" && free && echo -e "\\033[0;39m"
echo 3 > /proc/sys/vm/drop_caches  ###KRG , thanks to Bruce B ;see http://www.murga-linux.com/puppy/viewtopic.php?t=33219
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m" && free && echo -e "\\033[0;39m"
sleep $((SLEEP*4))s  ###KRG

###Check for Available Test dev node :
if [ ! -b /dev/ram8 -o "`ls -l /dev/ram8 | cut -b 1-3`" != "brw" -o "`ls -l /dev/ram8 | awk '{print $5 $6}'`" != "1,8" ] ; then
rm -f /dev/ram8
mknod /dev/ram8 b 1 8
fi

_color_echo1 blue 'Checking for Compiled RamDisk Size using:\n'
MAXSIZEdevRAM1=`mkfs.ext2 -v -b 1024 -i 1024 /dev/ram8 | grep 'blocks' | grep 'inodes' | tr -s ' ' | cut -f 3 -d ' '`
SIZEdevRAMdisk1=$(( MAXSIZEdevRAM1 * 93 / 100))  ###KRG 0.93 is precaution
echo -e "\\033[1;33m"'Compiled-in RAMDisk Size='"\\033[0;39m""$SIZEdevRAMdisk1""\\033[0;39m"
_color_echo none '\n'
KERNV=`uname -r`

function_size_lib(){
###Check for /lib/lib*.so* sizes :
_color_echo1 blue "Checking Size of $REPO/lib/lib*.so* and $REPO/lib/ld*.so* ...\n"
_color_echo none '\n'

SPACElib=0
LLS=`ls -l "$REPO"/lib/* | grep -o '/lib/.*\->.*' | grep 'firefox' | cut -f 1 -d ' ' | grep -v -w '/lib/lib'`
[ -z "$LLS" ] && LLS="No_firefox_libs_in_lib"

[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;31m"'firefox-libs: '$LLS && echo

LF=`find "$REPO"/lib -xdev -maxdepth 1 \( -name "lib*.so*" -o -name "ld*.so*" \)`
#Filter not needed files :
LIBF=`echo "$LF" | grep -v "$LLS" | grep -v -E 'libuClibc.*|ld\-uClibc.*|libthread.*|libm\-0.*|libm\.so\.0' | sort`

for i in $LIBF ; do
SiZElib=`ls -s $i | awk '{print $1}'`  ##+++2013-12-07
SPACElib=$((SPACElib + SiZElib))
[ "$DebugVal" = "2" ] && echo -ne "\\033[0;39m""$i"'='"\\033[0;31m""$SiZElib "  ###DBG
[ "$DebugVal" = "1" ] && [ "$SiZElib" -ne "0" ] && echo -ne "\\033[0;39m""$i"'='"\\033[0;33m""$SiZElib "
done

[ "$DebugVal" = "2" ]   && echo && echo 'total /lib='"$SPACElib"  ###DBG
[ "$DebugVal" -ge "1" ] && echo && _color_echo none '\n'
}
function_size_lib

_color_echo1 blue 'Checking for available RAM ...\n'
_color_echo none '\n'

    RAM=`free | grep -i 'mem' | sed 's%^[[:blank:]]*%%' | tr -s ' ' | cut -f 2 -d ' '`
FREERAM=`free | grep -i 'mem' | sed 's%^[[:blank:]]*%%' | tr -s ' ' | cut -f 4 -d ' '`
RAMLIMITdevRAM2=$((MAXSIZEdevRAM1 * 2))
echo '                  free counted total RAM:'"$RAM"  ###DBG
echo 'Available RAM (minus Kernel and modules):'"$FREERAM"  ###DBG
echo '     Minimum available free RAM required:'"$RAMLIMITdevRAM2"' ... '  ###DBG

if [ "$SPACElib" -gt "$SIZEdevRAMdisk1" -o "$RAMLIMITdevRAM2" -ge "$FREERAM" ] ; then  #1
echo
echo ";)"
_color_set1 red
 if [ "$RAMLIMITdevRAM2" -ge "$FREERAM" ] ; then                         #1.1
 echo "Needed free RAM is $RAMLIMITdevRAM2 , but free RAM is $FREERAM"
 else                                                                    #1.1
 echo "/lib/lib*.so* is $SPACElib in KB and larger than the RamDisk compiled for"
 _color_set1 red
 echo "kernel $KERNV with $SIZEevRAMdisk1 / $MAXSIZEevRAM1 in KB"
 fi  #1.1
 
_color_echo none '\n'
_color_set1 red
echo 'fsck omitted !!!'
_color_set1 green
echo 'please do the filesystemcheck via Live CD'
_color_set1 orange
echo 'or booting another Puppy or Linux'
_color_set1 cyan
echo "type 'busybox reboot -f' to reboot"
echo 'eventually you need to press CTRL+ALT+DELETE to reboot'
echo 'you may need to check BIOS bootorder also before booting LiveCD'
echo 'do not forget to unmount everything first !'
_color_echo none '\n'
echo
#echo 'dropping to console now , partition still mounted !'
_leave_to_simple_console 'dropping to console now , partition still mounted !'
fi  #1

NRAM=$(( RAM - FREERAM + RAMLIMITdevRAM2 ))
NEEDRAM=`echo "$NRAM" | sed -r 's/(.)/ \1/g' | rev | tr ' ' '\n' | sed -r '4 i\,' | sed -r '8 i\,' | tr -d '\n' | rev | sed 's%^,%%'`
FORMRAM=`echo "$RAM"  | sed -r 's/(.)/ \1/g' | rev | tr ' ' '\n' | sed -r '4 i\,' | sed -r '8 i\,' | tr -d '\n' | rev | sed 's%^,%%'`
_color_set1 green
echo -e "\\033[18G"'... OK : '"\\033[0;39m"$NEEDRAM"\\033[1;32m"' required of '"\\033[0;39m"$FORMRAM
_color_echo none '\n'
sleep $((SLEEP*5))s
}
_check_free_ram


_ask_to_continue

  #creat a ramdisk...
  #note, Puppy kernels are compiled with 13MB ramdisk, so need to be careful not to fill it up...
  _color_echo pink 'Creating a ramdisk and populating with a Linux environment...\n'

_check_ram0(){
  if [ ! -b /dev/ram0 -o "`ls -l /dev/ram0 | cut -b 1-3`" != "brw" -o "`ls -l /dev/ram0 | awk '{print $5 $6}'`" != "1,0" ]; then  ###KRG
  _color_echo1 red 'block /dev/ram0 does not exist..\n'
  rm -f /dev/ram0
  _color_echo none 'creating now\n'
  mknod /dev/ram0 b 1 0
  fi
}
_check_ram0

mkfs.ext2 $Q -m 5 -b 1024 -i 1024 /dev/ram0 >>$OUT

_make_ram9(){
  [ ! -b /dev/ram9 -o "`ls -l /dev/ram9 | cut -b 1-3`" != "brw" -o "`ls -l /dev/ram9 | awk '{print $5 $6}'`" != "1,9" ] && rm -f /dev/ram9 && mknod /dev/ram9 b 1 9  ###KRG
  mkfs.ext2 $Q -m 5 -b 1024 -i 1024 /dev/ram9 >>$OUT
  sleep $((SLEEP*2))s
}
_make_ram9

  mkdir -p /mnt/ram0
  mkdir -p /mnt/ram9  ###KRG

  mount -t ext2 /dev/ram0 /mnt/ram0
  test $? = 0 || _leave_to_simple_console "Could not mount ram0 ."
  mount -t ext2 /dev/ram9 /mnt/ram9  ###KRG
  test $? = 0 || _leave_to_simple_console "Could not mount ram9 ."
  # _remount_root rw
  sleep $((SLEEP*2))s  ###KRG

  #populate the ramdisk...
  mkdir -p /mnt/ram0/old_root
  mkdir /mnt/ram0/bin

_copy_busybox(){
  ###KRG BUSYBOX
  echo
  _color_echo1 blue "Checking if $REPO/bin/busybox is a link to 'MyBusybox' : "
  RLF=`readlink -f "$REPO"/bin/busybox`  ## | sed "s%^$REPO%%"`
  LSLBB=`ls -l "$REPO"/bin/busybox | grep -o '\->.*'`  ###KRG if busybox is a symlink to busybox-version

  if test "$LSLBB" != "" ; then
  _color_echo1 green 'YES\n'
  _color_echo none 'Copying '"$RLF"' into RamDisk\n'
  #RLBB=`echo $RLF | sed 's%/bin/%%'`
  RLBB=`basename "$RLF"`
  cp -a "$REPO"/bin/"$RLBB" /mnt/ram0/bin/"$RLBB"
  else
  _color_echo red 'No\n'
  fi
  _color_echo none '\n'
}
_copy_busybox


  _color_echo1 blue "Populating /mnt/ram0/bin  ...\n"
  [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"'/mnt/ram0/bin/'"\\033[0;39m"

  for oneBIN in "[" "[[" ash autologinroot basename busybox cat chmod chown clear cp cut \
  date dc dd df dirname dmesg du e3 ed expr false find free grep head kill ln login ls lsmod \
  mkdir mknod more mv nice ntfs-3g pidof pwd readlink rev rm rmdir sed sleep sort stat su sync \
  tail tar touch tr true uname usleep waitmax wc which xargs
  do  ###KRG added e3

  if [ -x $REPO/bin/$oneBIN ] ; then
  BINDIR='/bin'
  elif [ -x $REPO/usr/bin/$oneBIN ] ; then
  BINDIR='/usr/bin'
  else
  continue
  fi
  RLF=`readlink -f "$REPO""$BINDIR"/"$oneBIN" | grep -v 'busybox' | sed "s%^$REPO%%"`
  LSLBIN=`ls -l "$REPO""$BINDIR"/"$oneBIN" | grep -o '\->.*' | grep -v 'busybox'`

  if [ -n "$LSLBIN" ] ; then
  [ "$DebugVal" = "1" ] && echo -ne "\\033[0;33m"" Link $oneBIN""\\033[0;39m"
  NEWBIN=`echo "$RLF" | sed 's%/usr%% ; s%/local%%'`
  [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"' Link '"\\033[0;39m""${REPO}${BINDIR}/$oneBIN ""\\033[0;31m"', '"\\033[0;39m"
  [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"' LinkTarget '"\\033[0;39m""${REPO}${RLF} ""\\033[0;31m"', '"\\033[0;39m"
  [ -x /mnt/ram0/${NEWBIN} ]   || cp -a ${REPO}${RLF} /mnt/ram0/${NEWBIN}
  [ -x /mnt/ram0/bin/$oneBIN ] || cp -a ${REPO}${BINDIR}/$oneBIN /mnt/ram0/bin/$oneBIN

  elif [ -x ${REPO}${BINDIR}/$oneBIN ] && [ ! -x /mnt/ram0/bin/$oneBIN ] ;then  ###KRG for symlink busybox
    cp -a ${REPO}${BINDIR}/$oneBIN /mnt/ram0/bin/
    [ "$DebugVal" = "2" ] && echo -ne "$oneBIN ""\\033[0;31m"', '"\\033[0;39m"

  elif [ "$oneBIN" != "busybox" -a "`busybox | grep $oneBIN`" != "" ] ; then  ###KRG
    [ "$DebugVal" = "2" ] && echo -ne 'link '"$oneBIN ""\\033[0;31m"', '"\\033[0;39m"
    ln -s busybox /mnt/ram0/bin/$oneBIN
  fi
  done

  ln -sf busybox /mnt/ram0/bin/ps
  [ "$DebugVal" = "2" ] && echo -ne 'link ps '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf busybox /mnt/ram0/bin/rdev
  [ "$DebugVal" = "2" ] && echo -ne 'link rdev '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf busybox /mnt/ram0/bin/sh
  [ "$DebugVal" = "2" ] && echo -ne 'link sh '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf busybox /mnt/ram0/bin/mount
  [ "$DebugVal" = "2" ] && echo -ne 'link mount '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf busybox /mnt/ram0/bin/umount
  [ "$DebugVal" = "2" ] && echo -n 'link umount '
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m" && echo

  _color_echo1 blue "Populating /mnt/ram0/sbin ...\n"
  [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"'/mnt/ram0/sbin/'"\\033[0;39m"
  mkdir /mnt/ram0/sbin

  for oneBIN in depmod dumpe2fs e2fsck elspci fdisk freeramdisk fsck.ext2 fsck.ext3 fsck.ext4 \
  getty guess_fstype halt hdparm hotplug2stdout hotplug2stdout_notimeout hwclock ifconfig ifplugstatus insmod \
  klogd ldconfig loadkmap losetup lsmod mount.ntfs-3g pivot_root probedisk probedisk2 probepart swapon
  do

  if [ -x $REPO/sbin/$oneBIN ] ; then
  BINDIR='/sbin'
  elif [ -x $REPO/usr/sbin/$oneBIN ] ; then
  BINDIR='/usr/sbin'
  else
  continue
  fi
  
  RLF=`readlink -f "$REPO""$BINDIR"/"$oneBIN" | grep -v 'busybox' | sed "s%^$REPO%%"`
  LSLSBIN=`ls -l "$REPO""$BINDIR"/"$oneBIN" | grep -o '\->.*' | grep -v 'busybox'`

  if [ -n "$LSLSBIN" ] ; then
   [ "$DebugVal" = "1" ] && echo -ne "\\033[0;33m"" Link $oneBIN ""\\033[0;39m"
   NEWBIN=`echo "$RLF" | sed 's%/usr%% ; s%/local%%'`
   [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"' Link '"\\033[0;39m""${REPO}${BINDIR}/$oneBIN ""\\033[0;31m"', '"\\033[0;39m"
   [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"' LinkTarget '"\\033[0;39m""${REPO}${RLF} ""\\033[0;31m"', '"\\033[0;39m"
   [ -x /mnt/ram0/sbin/$oneBIN ] || cp -a ${REPO}${BINDIR}/"$oneBIN" /mnt/ram0/sbin/"$oneBIN"
   [ -x /mnt/ram0/${NEWBIN} ]    || cp -a ${REPO}${RLF} /mnt/ram0/${NEWBIN}
  elif [ -x ${REPO}${BINDIR}/$oneBIN ];then  ###KRG -x for -e
    cp -a ${REPO}${BINDIR}/$oneBIN /mnt/ram0/sbin/
    [ "$DebugVal" = "2" ] && echo -ne "$oneBIN "
    [ "$DebugVal" = "2" ] && [ "$oneBIN" != "swapon" ] && echo -ne "\\033[0;31m"', '"\\033[0;39m"
  elif test "`busybox | grep $oneBIN`" != "" ; then  ###KRG
    ln -s ../bin/busybox /mnt/ram0/sbin/$oneBIN
    [ "$DebugVal" = "2" ] && echo -ne 'link '"$oneBIN "
    [ "$DebugVal" = "2" ] && [ "$oneBIN" != "swapon" ] && echo -ne "\\033[0;31m"', '"\\033[0;39m"
  fi
  done

_preserve_chroot(){
  CHROOT=`which chroot | grep '^/sbin/'`  #+-2017-04-14 added closing ' to grep
  if [ -n "$CHROOT" ] && [ ! -L "$CHROOT" ] && [ -x "$CHROOT" ] ; then
  echo "$CHROOT is no link but executable,
creating backup of $CHROOT.bac
Please restore manually for now."
  mv $CHROOT "$CHROOT.bac"
  fi
}
_preserve_chroot

  ln -sf ../bin/busybox /sbin/chroot #must match
  [ "$DebugVal" = "2" ] && echo -ne 'link chroot '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf ../bin/busybox /mnt/ram0/sbin/chroot #must match
  [ "$DebugVal" = "2" ] && echo -ne 'link chroot '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf ../bin/busybox /mnt/ram0/sbin/init
  [ "$DebugVal" = "2" ] && echo -ne 'link init '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf ../bin/busybox /mnt/ram0/sbin/poweroff
  [ "$DebugVal" = "2" ] && echo -ne 'link poweroff '"\\033[0;31m"', '"\\033[0;39m"
  ln -sf ../bin/busybox /mnt/ram0/sbin/reboot
  [ "$DebugVal" = "2" ] && echo -n 'link reboot '
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m" && echo


  _color_echo1 blue "Populating /mnt/ram0/etc  ...\n"
  mkdir /mnt/ram0/etc
  [ "$DebugVal" = "2" ] && echo -ne "\\033[0;31m"'/mnt/ram0/etc/'"\\033[0;39m"
  
  for oneFILE in codepage DISTRO_SPECS eventmanager fdprm floppy fontmap group gshadow \
  host.conf hostname hosts hosts.allow hosts.deny inittab inputrc issue keymap localtime \
  mailcap mime.types mke2fs.conf modprobe.conf modules.conf mtab networks nscd.conf nsswitch.conf \
  passwd printcap protocols services shadow
  do
   [ "$DebugVal" = "0" ]   && cp -a "$REPO"/etc/$oneFILE /mnt/ram0/etc/ 2>/dev/null
   [ "$DebugVal" = "2" ]   && echo -ne "$oneFILE "
   [ "$DebugVal" -ge "1" ] && cp -a "$REPO"/etc/$oneFILE /mnt/ram0/etc/
   [ "$DebugVal" = "2" ] && [ "$oneFILE" != "shadow" ] && echo -ne "\\033[0;31m"', '"\\033[0;39m"
  done

   [ "$DebugVal" = "2" ] && echo -e "\\033[0;39m" && echo

  echo "$PDEV1"','"$DEV1FS"',' > /mnt/ram0/etc/fsckme.err   ###KRG
  echo "DebugVal='$DebugVal'" > /mnt/ram0/etc/initdebug.in  ###KRG
  echo "TimeOut='$TimeOut'" >> /mnt/ram0/etc/initdebug.in   ###KRG
  [ -f /mnt/ram0/etc/fstab ] || touch /mnt/ram0/etc/fstab ##+++2013-12-07

  echo '/lib' > /mnt/ram0/etc/ld.so.conf
  echo 'export PATH="/bin:/sbin"
export LD_LIBRARY_PATH="/mnt/ram9/lib"
ulimit -c 0
umask 022
export USER=root
export LOGNAME=root
export TERM=linux' > /mnt/ram0/etc/profile

  mkdir /mnt/ram0/etc/rc.d

  echo '#!/bin/sh
 PDEV1=`cut -f 1 -d "," /etc/fsckme.err`  ###KRG
DEV1FS=`cut -f 2 -d "," /etc/fsckme.err`  ###KRG
. /etc/initdebug.in  ###KRG
PATH="/bin:/sbin"
echo -e "\\033[0;32m"
echo "Now running in ramdisk, preparing for filesystem check of ${PDEV1}..."
echo -e "\\033[0;39m"
[ ! -d /proc ] && mkdir /proc
if [ -z "`mount | grep -o /proc`" ] ; then
[ "$DebugVal" = "0" ] && mount -t proc none /proc 2>/dev/null  ###KRG added: 2>/dev/null  ###KRG
[ "$DebugVal" -ge "1" ] && mount -t proc none /proc
fi
if [ "`readlink /etc/mtab`" != "/proc/mounts" ] ; then ##e2fsck needs it , busybox mount apparently not
[ -f /etc/mtab ] || [ -L /etc/mtab ] && rm /etc/mtab
ln -s ../proc/mounts /etc/mtab
fi
[ "$DebugVal" = "0" ] && hwclock --hctosys --localtime 2>/dev/null
[ "$DebugVal" -ge "1" ] && hwclock --hctosys --localtime
echo "Unmounting the rootdrive ..."   ###KRG
echo
MOR=`mount | grep "/old_root/.*"`
for i in `echo "$MOR" | cut -f 3 -d " " | sort -r` ; do
[ "$DebugVal" = "0" ] && umount $i 2>/dev/null || ErrMor=$?  ###KRG
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Unmounting $i ...""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && umount $i || ErrMor=$?
if [ -n "`mount | grep "$i"`" ] ; then
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Failed to unmount $i with error=$ErrMor""\\033[0;39m" && echo
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Trying lazy now ...""\\033[0;39m"
umount -l $i || ErrMorl
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""umount -l $i returned errorcode=$ErrMorl""\\033[0;39m"
else
echo -e "\\033[1;32m""$i was unmounted""\\033[0;39m"
fi
done
if [ -n "`mount | grep -o /old_root`" ] ; then  ##1
[ "$DebugVal" = "0" ] && umount /old_root 2>/dev/null || Err1=$?
if [ "$DebugVal" -ge "1" ] ; then
umount /old_root || Err1=$?  ###KRG  ##2
echo -e "\\033[0;33m""Unmounting /old_root: error returncode=$Err1 , still mounted :""\\033[0;39m"
mount
echo  ###DBG
fi  ##2
sleep $((SLEEP*2))s
if [ -z "`mount | grep -o /old_root`" ] ; then  ##3
[ -n "$Err1" ] && [ "$Err1" -ne "0" ] && echo -e "\\033[1;32m""/old_root $PEDV1 was unmounted though""\\033[0;39m" && echo
else  ##3
echo "Not so good, was unable to unmount ${PDEV1}. trying lazy now..."
sleep $((SLEEP*2))s
umount -l /old_root
Err3=$?
sleep $((SLEEP*1))s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Umount error returnvalue=$Err3""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Still mounted :""\\033[0;39m" && mount && echo
fi ##3
if [ -n "$Err3" ] && [ "$Err3" -ne "0" ] ; then  ###KRG  ##5
echo "Not so good, was unable to unmount ${PDEV1}. trying option force ..."
sleep $((SLEEP*2))s
umount -f /old_root
Err5=$?
sleep $((SLEEP*1))s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Unmount error returncode=$Err5""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Still mounted :""\\033[0;39m" && mount && echo
fi  ##5
[ -n "$Err5" ] && [ "$Err5" -ne "0" ] && echo "Not so good, was unable to unmount ${PDEV1}. Continuing with f.s. check..."
fi  ##1
if [ -z "`mount | grep -o /old_root`" ] ; then
echo -e "\\033[1;32m""OK. /old_root was unmounted successfully .""\\033[0;32m"" Fscking $PDEV1  ...
Depending on size of installation, might take a while""\\033[0;39m"
if [ "$DebugVal" -ge "1" ] ; then
e2fsck -C 0 -v -f /dev/${PDEV1}
else
e2fsck -C 0 -f -y /dev/${PDEV1}
fi
else
echo -e "\\033[0;31m""Whatever cause ... /old_root or $PDEV1 still mounted!"
echo -e "\\033[0;33m""Performing read-only filesystem check ... ""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && e2fsck -C 0 -n -f -v /dev/${PDEV1}
[ "$DebugVal" = "0" ] && e2fsck -C 0 -n -f /dev/${PDEV1}
fi
sync
echo
echo -e "\\033[7;32m"
echo "Filesystem check completed!"
echo -e "\\033[0;39m"
echo -e "\\033[0;32m""Removing [ xwin ] blocking files ..."
echo -e "\\033[0;39m"
mkdir -p /mnt/${PDEV1}  ###KRG removing fsckme.file  ###KRG
mount -t ${DEV1FS} /dev/${PDEV1} /mnt/${PDEV1}
if [ $? = 0 ] ; then ##+++2013-12-07

 ErrFlag=`find /mnt/${PDEV1} -xdev -maxdepth 3 -type f -iname "*fsckme*"`
 for i in $ErrFlag ; do
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Removing $i""\\033[0;39m"
  rm $i
 done

  [ -f /mnt/${PDEV1}/var/lock/XLOADED ] && rm /mnt/${PDEV1}/var/lock/XLOADED
  [ -f /mnt/${PDEV1}/tmp/bootcnt* ] && rm /mnt/${PDEV1}/tmp/bootcnt*
  rm -f /var/log/X*
  rm -f /var/lock/LCK*
  rm -f /var/run/*.pid

 SOCK=`find /mnt/${PDEV1}/var -xdev -type s`
 for i in $SOCK ; do
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""removing ""$i""\\033[0;39m"
  rm -f $i
 done

 PIPE=`find /mnt/${PDEV1}/var -xdev -type p`
 for i in $PIPE ; do
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""removing ""$i""\\033[0;39m"
  rm -f $i
 done

sleep $((SLEEP*2))s
sync
umount /dev/${PDEV1}  ###KRG

else
:     ###+++2013-12-07
fi

[ "$DebugVal" = "0" ] && DUMPE=`dumpe2fs /dev/$PDEV1 2>/dev/null | grep -i "state"`
[ "$DebugVal" -gt "1" ] && DUMPE=`dumpe2fs /dev/$PDEV1 | grep -i "state"`
echo -e "\\033[1;34m""$DUMPE""\\033[0;39m"

echo -e "\\033[0;36m"
echo "The computer now has to be restarted."
echo -e "\\033[0;35m"
echo "Computer will reboot in 1-3  minutes, else press ENTER for immediate reboot."

echo
echo -e "\\033[0;32m"  ###KRG
echo "Press Any key and or simply ENTER to reboot ,"
echo "or wait $TimeOut sec again ,"
echo -e "\\033[0;31m"
echo "or [ r ] for dropout into rdsh :"

echo -e "\\033[0;39m"
echo -ne "\\033[4;5;34m""ENTER""\\033[0;39m"" -> ""\\033[1;7;32m"
read -n 1 -t $TimeOut K
if [ "$K" = "r" -o "$K" = "R" ] ; then
 echo
 echo -e "\\033[0;32m"
 echo "Dropping now"
 echo "Have FUN !"
 echo
 echo -e "\\033[0;39m"
 exit
else
echo -e "\\033[0;39m"  ###KRG
[ "$DebugVal" = "0" ] && umount /proc 2>/dev/null
[ "$DebugVal" -ge "1" ] && umount /proc && sleep $((SLEEP*3))s
reboot
fi
' > /mnt/ram0/etc/rc.d/rc.sysinit
  chmod 0755 /mnt/ram0/etc/rc.d/rc.sysinit


  _color_echo1 blue "Populating /mnt/ram0/usr  ...\n"
  LOCALTIME="${REPO}/usr/share`readlink $REPO/etc/localtime | sed 's%^.*/zoneinfo%/zoneinfo%'`"
  if [ -n "$REPO" ] ; then
  LOCALTDIR="`dirname $LOCALTIME | sed "s%$REPO%%g" | sed 's%^/%% ; s%//%/%g'`"
  else
  LOCALTDIR="`dirname $LOCALTIME | sed 's%^/%% ; s%//%/%g'`"
  fi

  mkdir -p /mnt/ram0/$LOCALTDIR
  cp -a $LOCALTIME /mnt/ram0/$LOCALTDIR/
  mkdir -p /mnt/ram0/usr/share
  cp -a "$REPO"/usr/share/terminfo /mnt/ram0/usr/share/


  _color_echo1 blue "Populating /mnt/ram0/dev  ...\n"
  cp -a "$REPO"/dev /mnt/ram0/
  _update_partition_device_nodes "/mnt/ram0"
  _ask_to_continue


  ###KRG splitting /lib to second RamDisk :
  _color_echo1 blue "Populating /mnt/ram9/lib  ...\n"
  mkdir /mnt/ram9/lib

  for i in $LIBF ; do  ###KRG to sort unneeded libs out , see further up ###KRG
  [ "$DebugVal" -ge "1" ] && echo -ne "\\033[0;39m""`basename $i`"
  [ "$DebugVal" -ge "1" ] && [ -z "`echo $i | grep 'libz\.so\..*\..*\..*'`" ] &&  echo -ne "\\033[0;33m"', '"\\033[0;39m"
  cp -a $i /mnt/ram9/lib/
  done

  if [ -f "$REPO"/lib/e2initrd_helper ] ; then
  [ "$DebugVal" = "0" ] && cp -a "$REPO"/lib/e2initrd_helper /mnt/ram9/lib/ 2>/dev/null #dunno what this is.  ###KRG me not either
  if [ "$DebugVal" -ge "1" ] ; then
  echo -e "\\033[0;33m"' Copying also '"\\033[0;39m"'/lib/e2initrd_helper'
  cp -a "$REPO"/lib/e2initrd_helper /mnt/ram9/lib/
  echo
  fi
  fi
  _color_echo none

  busybox ln -sn /mnt/ram9/lib /mnt/ram0/lib
  mkdir /mnt/ram0/mnt
  mkdir /mnt/ram0/mnt/ram9

  mkdir /mnt/ram0/root
  mkdir /mnt/ram0/tmp
  mkdir -p /mnt/ram0/var/run
  mkdir /mnt/ram0/proc

  sleep $((SLEEP*3))s
  _sync


  #pivot_root to the ramdisk...
  _color_echo pink 'Performing a pivot_root to the ramdisk...\n'
  _color_echo none '\n'

  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'1_mounts :'"\\033[0;39m" && mount && echo  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*3))s  ###DBG

  cd /mnt/ram0
  [ "$DebugVal" -ge "1" ] && echo -ne "\\033[0;33m"'Have changed into /mnt/ram0 , pwd:'"\\033[0;39m"`pwd` && echo  ###DBG
  [ "$DebugVal" = "2" ]   && echo  -e "\\033[0;31m"'ls :'"\\033[0;39m" && ls --color=auto && echo  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" = "2" ]   && echo  -e "\\033[0;31m"'ls  ./bin :'"\\033[0;39m" && ls --color=auto ./bin && echo  ###DBG
  [ "$DebugVal" = "2" ]   && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" = "2" ]   && echo  -e "\\033[0;31m"'ls ./sbin :'"\\033[0;39m" && ls --color=auto ./sbin && echo  ###DBG
  [ "$DebugVal" = "2" ]   && sleep $((SLEEP*2))s  ###DBG

  [ -d ./mnt/ram9 ] || mkdir -p ./mnt/ram9
  mount -o move /mnt/ram9 ./mnt/ram9
  [ -d ./sys ]  || mkdir ./sys
  mount -o move /sys ./sys
  [ -d ./proc ] || mkdir ./proc
  mount -o move /proc ./proc
  [ -d ./dev ]  || mkdir ./dev
  mountpoint $Q /dev && mount -o move /dev ./dev

  #_ask_to_continue
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG

  [ "$DebugVal" -ge "1" ] && echo && echo -e "\\033[1;33m""Now just before pivot_root :""\\033[;39m"
  _ask_to_continue

  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'pivot_root now ...'  ###DBG
  pivot_root . old_root
  
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'...        pivoted' && echo  ###DBG

  _ask_to_continue
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG

  [ "$DebugVal" -ge "1" ] && echo -ne "\\033[0;33m"'pwd now :'"\\033[0;39m"`pwd` && echo  ###DBG
  [ "$DebugVal" = "2" ]   && echo -e "\\033[0;31m"'ls :'"\\033[0;39m" && ls --color=auto  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m"  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG

  cd /  ###KRG
  [ "$DebugVal" -ge "1" ] && echo -ne "\\033[0;33m""ch'ed dir to / , pwd: ""\\033[0;39m"`pwd` && echo  ###DBG
  [ "$DebugVal" = "2" ]   && echo -e "\\033[0;31m"'ls /:'"\\033[0;39m" && ls --color=auto /  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m"  ###DBG

  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'2_mounts :'"\\033[0;39m" && mount && echo  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG

  _kill_daemons


  _color_echo1 blue 'Unmounting everything beneath /old_root/* ...\n'
  OR=`mount | grep '/old_root/' | cut -f 3 -d ' ' | tac`
  for i in $OR ; do
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'unmounting '"\\033[0;39m""$i"  ###DBG
  if [ "$DebugVal" = "0" ] ; then
  umount -lr $i 2>/dev/null
  else
  umount -lr $i
  Err=$?
  if [ "$Err" -ne "0" ] ; then
  _color_echo orange 'failed , trying lazy .. \n'  ###DBG
  umount -lr $i
  fi
  sleep 1s
  [ -d "/old_root/mnt/${i##*/}" ] && rmdir /old_root/mnt/${i##*/}
  fi
  done
  mount -o remount,ro /old_root

  _color_echo none
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'3_mounts :'"\\033[0;39m" && mount && echo  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG

  [ "$DebugVal" = "2" ] && echo -e "\\033[0;31m"'ls /old_root:'"\\033[0;39m" && ls --color=auto /old_root && echo  ###KRG ls -R would show whole partition ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG

  ####KRG Menu for ConsoleShell
  ##echo
  _color_set green
  echo 'Press ANY key and or ENTER to perform fsck'
  echo "or wait $TimeOut seconds ."
  echo 'Scrolling might be allowed by Shift+PageUP/Down .'
  _color_set red
  echo "or [c] or [k] for drop out into simple console mode"
  echo "or [i] or [b] for drop out into console with busybox init on top."
  _color_set none 
  
  echo -ne "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"

  read -n 1 -t $TimeOut K
  _color_echo none '\n'

  if [ "$K" = "c" -o "$K" = "C" -o "$K" = "k" -o "$K" = "K" ] ; then
  _color_set green 
  echo 'Dropping now into simple rdsh .'
  echo 'Have FUN !'
  echo
  _color_echo none '\n'
  login -f root
  exec chroot . sh

  elif [ "$K" = "i" -o "$K" = "I" -o "$K" = "b" -o "$K" = "B" ] ; then
  _color_set green
  echo 'Dropping now into busybox init rdsh .'
  _color_set1 green
  echo 'Have MORE FUN !'
  echo
  _color_set none
  
  echo '#DUMMY' > /etc/rc.d/rc.sysinit
  chmod 0775 /etc/rc.d/rc.sysinit
  exec chroot . sh -c "exec busybox init" <dev/console >/dev/console 2>&1

  else
  exec chroot . sh -c "exec busybox init" <dev/console >/dev/console 2>&1
  fi
  #...the ramdisk is setup so that /etc/rc.d/rc.sysinit will run, which does the f.s. check.
 ;;
 *)  # not ext2-4
  _color_echo1 red "Previous improper shutdown, sorry can only do f.s. check of ext2/3/4.\n"
  sleep 5s
  _do_busybox_init
 ;;
esac

###END###
