#!/bin/ash
#
# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_init"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/sbin/init"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#KRG ash instead sh
#(c) Copyright Barry Kauler 2010, bkhome.org
#Lesser GPL license v2 (/usr/share/doc/legal/lgpl-2.1.txt
#perform a f.s. check if file /fsckme.err exits, otherwise normal startup.
#/etc/rc.d/rc.sysinit creates /fsckme.err at bootup, rc.shutdown deletes it.
#this script is /sbin/init in the main Puppy f.s., which is the very first to run.
#in the case of not a full hd install, this script just passes execution to busybox init.


########################################################################
#
# CHANGES by Karl Reimer Godt
#
# 01.0 : mounting of /sys and /proc
#   .1 : adopted status_func from rc.sysinit ( as _status(){ )
#   .2 : BUSYBOX_INIT_FUNC ( _do_BUSYBOX_INIT )
#   .3 : check for proper devname using rdev instead of fsckme entry
#        RDEV_FUNC ( _get_ROOT_DEVICE )
#
# 02.0 : ERRFLG_FUNC ( _test_ERR_FLAG ): Support for -iname *fsckme* (hidden)file(s)
#   .1 : check for fsck intervals
#
# 03.0 : failsafe_func
# [ $noalsa ] &&          safeBoot=+16 && echo 'noalsa' >/tmp/alsa.flg
# [ $nographics ] &&      safeBoot=+1  && echo 'nographics' >/tmp/graphics.flg
# [ $nofb ] &&            safeBoot=+2  && echo 'nofb' >/tmp/framebuffer.flg
# [ $nofbcon ]         && safeBoot=+4  && echo 'nofbcon' >/tmp/fbcon.flg
# [ $userdrivers ]      && safeBoot=128
# [ $kerneldrivers ]    && safeBoot=+64
# [ $alldrivers ]       && safeBoot=256|0
# [ $nodrivers ]        && safeBoot=0|256
# [ ! "$safeBoot" ]     && safeBoot=?
# [ "$safeBoot" = "0" ] && safeboot=?
# echo 'safeBoot='"$safeBoot"
#
# 04.0 : loading of drivers
#   .1 : UDEVD_FUNC with
#         modprobe_conf_func(multiple_kernels<-rc.sysinit)
#         update_modprobe_conf_func
#   .2 : update device nodes :
#         UPDATINGDEV_FUNC #MY_FUNC
#   .3 :
#   .4 : MODULES_ADD_FUNC ( _add_MODULES )
#   .5 : load_INPUT_DRIVERS_FUNC ( _load_INPUT_DRIVERS )
#   .6 : FBCON_FUNC ( _load_FBCON  )
#
# 05.0 : ASK_DEBUG_FUNC ( _askto_DEBUG )
#   .1 : SIMPLE_CONSOLE_FUNC ( _dropto_SIMPLE_CONSOLE )
#   .2 : _askto_CONTINUE ( CONTINUE_FUNC )
#
# 06.0 : FSCK_FUNC ( _do_FSCK )
#   .1 : FIRST_FSCK_FUNC
# 07.0 : CHECK_FOR_ALT_PART_FUNC
#
# 08.0 : CHECK_ALTERNATE_REPO_FUNC
#   .1 : CURR_GLIBC_FUNC
#   .2 : FIND_SFS_FUNC
#   .3 :
#   .4 :
# 08.0 :
# 09.0 :
# 10.0 : try to mount a sfs with the current libc version to ensure working binaries
#        ( not neccessary , but precaution )
# 11.0 :
# 12.0 : check if fs is cleam
# 13.0 :
# 14.0 :
# 15.0 :
# 16,0 : use second ramdisk for libs
# 17.0 :
#
#
# /dev/hda8:
# LABEL="MacPup431_O2"
# UUID="6d9a8e91-c301-4ff8-9875-97ec708cbee8"
# TYPE="ext3"
# DISTRO_NAME='Puppy'
# DISTRO_VERSION=431
# DISTRO_BINARY_COMPAT='puppy'
# DISTRO_FILE_PREFIX='pup'
# DISTRO_COMPAT_VERSION='4'
# PUPMODE=2
# KERNVER=2.6.30.9-i586-dpup005-Celeron2G
# PUP_HOME='/'
# SATADRIVES='·'
# USBDRIVES='·'
# Linux·puppypc·2.6.30.9-i586-dpup005-Celeron2G·#6·SMP·Sat·Jan·15·13:35:51·GMT-8·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xorg
# $LANG=de_DE@euro
# today=Do·27.·Okt·22:22:42·GMT-1·2011
#
# WARNING : udevd absolutely has to be killed , otherwise udevd keeps device busy
#           and won't unmount
#           busybox ps failed
#
# TODO1 : merge CHECKYEAR !!
# TODO2 : find out why /tmp/pup_eve_bac_mod.log does not get created
#                                       or newly written @rc.sysinit
#         same with /tmp/pup_event_module_devpath_log  (partition ro ??)
#         first ro mentioned in _askto_CONTINUE(drop to console)
#         and after that FSCK_FUNC FIRST_FSCK_FUNC so partition should be rw
#        ~FIXED : was rm -rf /tmp/* in rc.sysinit
#
# TODO4 : rm /tmp files , also in rc.sysinit #DONE
# TODO5 : alias modprobe='modprobe -b'       # done
# TODO6 : mult_kernels modprobe.d.$KERNVERS was empty
# TODO7 : ADD support for nofsck kernel parameter to force boot in case of scripting errors
#
########################################################################

###2011-10-28 at boot rdev does not return the devicename(basename fails)
###particular kernel lowlatencydevtmpfs ??
###2.6.37.4-KRG-i486-StagingDrivers-3 seems ok for that, also has sound


################# INFO ################
Version='2.1-module_loading-mount_interval_check-use_alternate_repo_sfs Puppy-Linux-4.3.1 KRG'
usage (){
MSG="
$0 [checkcode|debug|help|version]
Sript to check for inproper previous shutdown if
marker file *fsckme.flg|err* found. The content of the
fsckme.flg file needs to look like this : 'sda2,ext3,' .
Former and still it was done by '/usr/bin/xwin' code by
Pizzasgood.
If fsckme file exists, check the partition read-only,
and if found clean, boot anyway.
If the mount interval date or mounts have reached their
specified numbers, do an interval e2fsck .
Obeys the 'pfix=fsck' kernel parameter
to force file system checking.
Special feature : FSCK Interactive Mode
Keyboard is not necessarily needed, any questions have
a timeout of 20 seconds and would fall back into
non-interactive mode.
"
[ "$2" ] && MSG="$MSG
$2"
echo "$MSG"
exit $1
}

#[ "`echo "$@" |grep -E '\-V|version'`" ] && { echo -e "\n$0: Version '$Version'\nTry 'help' parameter for more info\n";exit $?; }
for p_ in $@;do
 P_="${p_//-/}"
  case $P_ in
*checkcode|*codecheck|*check) set -n;shift;;
-d|*debug)                    set -x;shift;;
-h|*help|*usage)              usage 0;;
-V|*version)                  { echo -e "\n$0: Version '$Version'\nTry 'help' parameter for more info\n";exit $?; };;
*) :;;
  esac;     done
#[ "$1" ] && usage 1 "GOT '$*'" ## noconsolesuspend was passed as $1
################# INFO ################


################ VARIABLES ############
PATH='/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin' #local for reiser
export PATH  ##+++2012-03-06 for hwclock in rc.country
export LANG=C

test -f /etc/rc.d/PUPSTATE && . /etc/rc.d/PUPSTATE || PUPMODE=2

alias modprobe='modprobe -b'  ##+++2012-01-30
#modprobeFIRST_TIME=--first-time
modprobeFIRST_TIME='';

################ VARIABLES #####################

_debug1(){    test "$DEBUG" -ge 1   && echo  -e "\\033[0;33m$*\\033[0;39m"; }
_debug2(){    test "$DEBUG" -ge 2   && echo  -e "\\033[0;31m$*\\033[0;39m"; }

_verbose1(){  test "$VERBOSE" -ge 1 && echo  -e "\\033[0;33m$*\\033[0;39m"; }
_verbose2(){  test "$VERBOSE" -ge 2 && echo  -e "\\033[0;31m$*\\033[0;39m"; }

_debug1n(){   test "$DEBUG" -ge 1   && echo -ne "\\033[0;33m$*\\033[0;39m"; }
_debug2n(){   test "$DEBUG" -ge 1   && echo -ne "\\033[0;31m$*\\033[0;39m"; }

_verbose1n(){ test "$VERBOSE" -ge 1 && echo -ne "\\033[0;33m$*\\033[0;39m"; }
_verbose2n(){ test "$VERBOSE" -ge 2 && echo -ne "\\033[0;31m$*\\033[0;39m"; }

################ PREPARE FILE SYSTEM ###########

if [ -d /proc ]; then
[ -f /proc/mounts ] || busybox mount $VERB $VERB -t proc proc /proc  ###KRG put here for additional df check (wary094 frugal had written /initrd directory into full install) ###KRG
else
mount $VERB $VERB -o remount,rw /dev/root /
rm -rf /proc
mkdir -p /proc
busybox mount $VERB $VERB -t proc proc /proc
fi

if [ -d /sys ]; then
[ "`grep ' /sys ' /proc/mounts`" ] || busybox mount $VERB $VERB -t sysfs sysfs /sys
else
mount $VERB $VERB -o remount,rw /dev/root /
rm -fr /sys
mkdir -p /sys
busybox mount $VERB $VERB -t sysfs sysfs /sys
fi

_status(){
 if [ $1 -eq 0 ]; then
  /bin/echo -e "\\033[72G\\033[1;32mdone\\033[0;39m"   >/dev/console #green [done] msg.
 else
  /bin/echo -e "\\033[70G\\033[1;31mfailed\\033[0;39m" >/dev/console #red [failed].
  STATUS=0
 fi
 return $1 #return with same status as entry param.
}

[ "$PUPMODE" = 2 ] && busybox mount $VERB $VERB -o remount,rw /dev/root /

sleep 1

test -d /dev || { rm -fr /dev && mkdir /dev; }
grep $QUIET ' /dev ' /proc/mounts 2>$ERR || mount $VERB $VERB -t ramfs devramfs /dev

if [ ! -L /dev/fd ]; then
ln $VERB -snf /proc/self/fd /dev/fd
ln $VERB -snf fd/0 /dev/stdin
ln $VERB -snf fd/1 /dev/stdout
ln $VERB -snf fd/2 /dev/stderr
fi

test -c /dev/null    || { rm -rf /dev/null;    mknod /dev/null    c 1 3; }
test -c /dev/console || { rm -rf /dev/console; mknod /dev/console c 5 1; }

 test "`which mdev`" && mdev -s || {

     oldIFS="$IFS"
     IFS=$'\n'
     find /sys -type f -name uevent -perm 644 |
     while read oneFILE
     do
     unset K MAJOR MINOR DEVPATH DEVNAME DEVTYPE DRIVER DEVICE PRODUCT TYPE BUSNUM DEVNUM INTERFACE MODALIAS DEVMODE
     source "$oneFILE" 2>$ERR  || continue
     test "$MAJOR" -a "$MINOR"      || continue
     test "$DEVNAME" && { test -e /dev/$DEVNAME && continue; } || { DEVNAME=${oneFILE%/uevent*}; DEVNAME=${DEVNAME##*/}; test -e /dev/$DEVNAME && continue; }
     test "$DEVMODE" && DEVMODE="-m $DEVMODE"
     test -e /dev/$DEVPATH/$DEVNAME || {
     test "$DEVTYPE" = disk -o "$DEVTYPE" = partition && K=b || K=c
     test ${DEVNAME%/*} = $DEVNAME || { test -d /dev/$DEVPATH/${DEVNAME%/*} || mkdir -p /dev/$DEVPATH/${DEVNAME%/*}; }
     mknod $DEVMODE /dev/$DEVPATH/$DEVNAME $K $MAJOR $MINOR
      }
     done
     IFS="$oldIFS"
  }

_pupmode2_and_rm_tmp(){
if [ "$PUPMODE" = 2 ]; then
busybox mount $VERB $VERB -o remount,rw /dev/root /

mkdir -p /tmp

if [ ! "$DISPLAY" ];then  #for test run in X
while read file_or_dir
do
[ "$file_or_dir" ] || continue
rm -rf /tmp/"$file_or_dir"
done << __EOI
$(ls -1A /tmp)
__EOI

fi # DISPLAY

_debug "`ls -A /tmp`"  ##;sleep 10
else
STATUS=0
_status $STATUS
fi
}
_pupmode2_and_rm_tmp
################ PREPARE FILE SYSTEM ###########


################ RUN BUSYBOX INIT ##############
_do_BUSYBOX_INIT(){  #BEGIN
busybox umount $VERB /sys
busybox umount $VERB /proc
exec busybox init
}  ###_do_BUSYBOX_INIT(){  #END

if [ "$PUPMODE" != 2 ]; then
_do_BUSYBOX_INIT #frugal installation
fi
################ RUN BUSYBOX INIT ##############


########### UPDATE DEVICE NODES ################
_do_BLOCK_DEVICES(){  #BEGIN
echo -n "Updating Device nodes $*" >/dev/console
 test -f /proc/partitions && {
 STATUS=0
 test -d "$1"/dev || mkdir -p "$1"/dev

 while read MAJ MIN SIZE SDEV;
 do
 [ "$MAJ" ] || continue
 [ "${MAJ//[[:digit:]]/}" ] && continue

  rm -f "$1"/dev/$SDEV
  STATUS=$((STATUS+$?))
  mknod "$1"/dev/$SDEV b $MAJ $MIN
  STATUS=$((STATUS+$?))
  echo -n '.' >/dev/console

 done</proc/partitions

 } || STATUS=1

if [ "$PUPMODE" = 2 ]; then
 _status $STATUS
fi
}  ###_do_BLOCK_DEVICES(){  #END
########### UPDATE DEVICE NODES ##########


############ ROOTDRIVE ###################
[ "$DEBUG" ] || DEBUG=''; #set to anything than empty for some between values showing on the screen
_get_ROOT_DEVICE(){  #BEGIN

while [ -z "$havePDEV1" ] ; do  ##+++2011-10-28
 [ "$DEBUG" ] && echo "havePDEV1=$havePDEV1'"

 DEVPDEV1=`busybox rdev | cut -f 1 -d ' '`  ##+2011-10-28 changed position to top
 test "$DEVPDEV1" || { UPDATINGDEV_FUNC "/"; DEVPDEV1=`busybox rdev | cut -f 1 -d ' '`; }

 DEVROOTDRIVE="$DEVPDEV1"                   ##+2011-10-28 changed position to second
 DEV1FS=`mount | grep ^[\ \"\'\/]*dev/root | cut -f 5 -d ' ' |tr -d \'\"`  ##+2011-10-28 changed position to third

 #PDEV1=`basename "$DEVPDEV1"`
 PDEV1="${DEVPDEV1##*/}"
 [ "$DEBUG" ] && echo "PDEV1=$PDEV1"

 MAJh=`stat -c %t "$DEVROOTDRIVE"`
 MAJh=`echo "$MAJh" | tr '[a-z]' '[A-Z]'`
 [ "$DEBUG" ] && echo "MAJh=$MAJh"

 #MAJd=$((16#MAJh))
 MAJd=`echo "ibase=16;$MAJh" | bc -l`
 [ "$DEBUG" ] && echo "MAJd=$MAJd"

 MINh=`stat -c %T "$DEVROOTDRIVE"`
 MINh=`echo "$MINh" | tr '[a-z]' '[A-Z]'`
 [ "$DEBUG" ] && echo "MINh=$MINh"

 #MINd=$((16#MINh))
 MINd=`echo "ibase=16;$MINh" | bc -l`
 [ "$DEBUG" ] && echo "MINd=$MINd"

 POSSIBLE=`LANG=C ls -l /dev |awk '{print $5" "$6" "$10}' |grep "${MAJd}, ${MINd} " |awk '{print $3}'`
  for p_ in $POSSIBLE;
 do
 [ "$DEBUG" ] && echo "POSSIBLE='$p_'"
 [ -e /sys/class/block/$p_ ] && {
    [ -r /sys/class/block/$p_/uevent ]    || continue
    unset MAJOR MINOR
    source /sys/class/block/$p_/uevent    || continue
    test $MAJOR = $MAJd -a $MINOR = $MINd || continue
    PDEV1=$p_ ; break ; }
 done

 ROOTDRIVE="$PDEV1"

 if [ -z "`echo "$PDEV1" | grep '^[shmf]'`" ]; then  ##+++2011-10-28
  havePDEV1=''
  [ "$DEBUG" ] && head -n 5 /proc/partitions
  UPDATINGDEV_FUNC "/"
 else
  echo -e "\\033[1;32m""Root device is /dev/$PDEV1""\\033[0;39m"
  havePDEV1='yes'
 fi  ##+++2011-10-28

[ "$DEBUG" ] && echo "havePDEV1Count=$havePDEV1Count'"
                      havePDEV1Count=$((havePDEV1Count+1))
[ "$havePDEV1Count" -gt "10" ] && break  ##precaution to prevent neverending loop
[ "$DEBUG" ] && echo "havePDEV1Count=$havePDEV1Count'"
sleep 1s

done  ##+++2011-10-28

return 0
}  ###_get_ROOT_DEVICE(){  #END

[ -r /etc/DISTRO_SPECS -a -f /etc/DISTRO_SPECS ] && {
    . /etc/DISTRO_SPECS
    echo -e "\\033[1;36mPuppy Linux '$DISTRO_NAME' '$DISTRO_VERSION' booting. Have a nice day"'!'"\\033[0;39m"
}

[ -z "$havePDEV1" ] && _get_ROOT_DEVICE
############ ROOTDRIVE #####################


############# ERRFLAG OR INTERVALS #########
[ "$DEBUG" ] || DEBUG=''; #set to anything than empty for some between values showing on the screen
_test_ERRFLAG() {  #BEGIN
echo -e "\\033[1;34m"'Checking for unpropper previous shutdown  ... '"\\033[0;39m"
echo -n -e "\\033[1;33m"'Searching for *fsckme* file 3 levels deep ... '"\\033[0;39m"
ErrFlag=`busybox find / -maxdepth 3 -type f -iname '*fsckme*' | head -n1`  ###KRG 3 deep for fsckme.file@etc @boot @$HOME ..etc..
if [ -z "$ErrFlag" ] ; then  ##1
echo -e "\\033[56G\\033[1;5;32m"'Hurray , not found !'"\\033[0;39m"

LANG=C
todayY=`date +%Y`;[ "$todayY" ] || todayY='9999'
todayM=`date +%m | sed 's/^0//'`;[ "$todayM" ] || todayM=12
todayD=`date +%d | sed 's/^0//'`;[ "$todayD" ] || todayD='1'
#todayYDN=`date +%j`;[ "$todayYDN" ] || todayYDN=100
todayYDN=`date +%j |sed 's%^0*%%'`;[ "$todayYDN" ] || todayYDN=100

[ "$DEBUG" ] && echo "
todayY='$todayY'
todayM='$todayM'
todayD='$todayD'
todayYDN='$todayYDN'
"

monthN=`for i in $(seq 1 12) ; do cal $i 1 | head -n 1 | grep -o '[[:alpha:]]*' | sed "s/^/$i /"; done`
monthT=`echo "$monthN" | /bin/grep -w "^$todayM"`
montTN=`echo "$monthT" | cut -f 1 -d ' '`
montTO=`echo "$monthT" | cut -f 2 -d ' '`

#echo "monthN=$monthN"
[ "$DEBUG" ] && echo "monthT='$monthT'"
[ "$DEBUG" ] && echo "monthTN='$montTN'"
[ "$DEBUG" ] && echo "montTO='$montTO'"

#funcs:

func_next_check(){
nextcY=`echo "$nextch" |awk '{print $1}'`;[ "$nextcY" ] || nextcY=2038
nextcM=`echo "$nextch" |awk '{print $2}'`;[ "$nextcM" ] || nextcM='Dec'
nextcD=`echo "$nextch" |awk '{print $3}'`;[ "$nextcD" ] || nextcD='31'
}
func_last_check(){
lastcY=`echo "$lastch" |awk '{print $1}'`;[ "$lastcY" ] || lastcY=1902
lastcM=`echo "$lastch" |awk '{print $2}'`;[ "$lastcM" ] || lastcM='Dec'
lastcD=`echo "$lastch" |awk '{print $3}'`;[ "$lastcD" ] || lastcD='31'
}


func_mount_count(){
    #echo "mntcnt=$mntcnt maxmnt=$maxmnt"
diffMC=$(( $maxmnt - $mntcnt ));
}

func_check_maxmnt(){
    #echo "mntcnt=$mntcnt maxmnt=$maxmnt"
if [ "$mntcnt" -ge "$maxmnt" ] ; then  ##1
echo -e "\\033[1;33m"'Maximum mount count reached'"\\033[0;39m"
FSCK='yes';fi
}

func_thirties(){
montCN=`echo "$monthC" | cut -f 1 -d ' '`
montCO=`echo "$monthC" | cut -f 2 -d ' '`
val30C=`cal $montCN 1 | grep '[[:digit:]]$' | sed '/^$/d' | tail -n 1 | grep -o '[[:digit:]]*$'`


##+++
val30B=0
for i in `seq $((montCN+1)) $((montTN-1))` ; do
val30i=`cal $i 1 | grep '[[:digit:]]$' | sed '/^$/d' | tail -n 1 | grep -o -e '[[:digit:]]*$'`
val30B=$((val30B+val30i))
done
###+++

val30T=`cal $montTN 1 | grep '[[:digit:]]$' | sed '/^$/d' | tail -n 1 | grep -o '[[:digit:]]*$'`
}

func_compare(){
echo -e "\\033[0;39m"
FSCK=''
[ "$DEBUG" ] && echo "$mntcnt -ge $maxmnt ?:"
if [ "$mntcnt" -ge "$maxmnt" ] ; then  ##1
echo -e "\\033[1;33m"'Maximum mount count reached'"\\033[0;39m"
FSCK='yes'
else ##1
  [ "$DEBUG" ] && echo "$todayY -ge $nextcY ?:"
  if [ "$todayY" -ge "$nextcY" ] ; then    #2
   [ "$DEBUG" ] && echo  "$montTN = $montCN ?:"
   if [ "$montTN" = "$montCN" ] ; then     #3
    [ "$DEBUG" ] && echo "$todayD -ge $nextcD ?:"
    if [ "$todayD" -ge "$nextcD" ] ; then  #4 ##+-2012-05-24 changed -gt to -ge
echo -e "\\033[1;33m"'Day interval reached'"\\033[0;39m"
FSCK='yes'
    fi #4
   else #3
    [ "$DEBUG" ] && echo "$montTN -gt $montCN ?:"
    if [ "$montTN" -gt "$montCN" ] ; then #5
     MinusTD=$todayD
     PlusCD=$(( $val30C - $nextcD ))
     SUM=$(( $MinusTD + $val30B + $PlusCD ))
      if [ "$SUM" -ge "$ckdays" ] ; then  #6 ##+-2012-05-24 changed -gt to -ge  ##+-2013-08-10 OLD BUG was interN instead ckdays
       echo -e "\\033[1;33m"'Day interval reached'"\\033[0;39m"
       FSCK='yes'
      fi #6
    fi #5 "$montTN" -gt "$montCN"
   fi #3 "$montTN" = "$montCN"
  fi #2 "$todayY" -ge "$nextcY"
fi #1 "$mntcnt" -ge "$maxmnt"
}

func_notify(){
if [ -z "$FSCK" ] ; then #8
  echo -e "\\033[1;32m"'OK , '"\\033[0;32m""next check '$nextcM $nextcD' or in '$diffMC' mounts""\\033[0;39m"
  echo -e "\\033[0;39m"
  _do_BUSYBOX_INIT
                    else #8
   if [ "$TIME_ELAPSED" ];then
  echo -e "\\033[1;33m"'Filesystem check interval reached :'"\\033[0;39m"
  echo -e "\\033[0;33m"'Today : '"\\033[0;33m""$montTO $todayD""\\033[0;33m"' , next check was or would be : '"\\033[0;33m""$nextcM  $nextcD""\\033[0;33m"
   elif [ "$MAX_MOUNT_COUNT" ];then
  echo -e "\\033[0;33m"'mount intervals : '"\\033[0;33m""$mntcnt""\\033[0;33m"' of '"\\033[0;33m""$maxmnt"
   else
  echo -e "\\033[0;33m"'File System Apparently marked unclean'
   fi
  echo -e "\\033[0;39m"
fi #8                    #8
}

#func
busybox mount $VERB $VERB -o remount,ro /dev/root /  ##+++2012-08-21 for reiserfs
                  if [ "`echo "$DEV1FS" |grep -Ei 'ext[234]'`" ];then #1.5
echo -e "\\033[1;33m"'Checking for filesystem check intervals using'"\\033[0;39m"
VARS=`dumpe2fs -h $DEVROOTDRIVE | grep -E 'Maximum mount count|Mount count|Next check after|Check interval'`  ##+2013-07-07 added -h option to dumpe2fs
nextch=`echo "$VARS" | grep 'Next check after:' |cut -f2- -d':' |awk '{print $5" "$2" "$3}'`;[ "$nextch" ] || nextch="Next check after:         Sun Dec 31 17:51:27 9999"
func_next_check

mntcnt=`echo "$VARS" | grep 'Mount count:' |cut -f 2 -d ':' |awk '{print $1}'`;[ "$mntcnt" ] || mntcnt='1'
maxmnt=`echo "$VARS" | grep 'Maximum mount count:' |grep -o '[[:digit:]]' |tr -d '\n'`;[ "$maxmnt" ] || maxmnt=999
#func_mount_count
func_check_maxmnt
func_mount_count

monthC=`echo "$monthN" | grep -e "^[0-9]* $nextcM.*"`
func_thirties
#func_compare

#NEW*
#ckday=`echo "$VARS" |grep 'Check interval:' |cut -f2 -d ':' |awk '{print $1}'`
#chdays=$((checkday/60/60/24))
#chdays=$((ckday/60/60/24))
nextckYDN=`/bin/date --d="$montCN"/"$nextcD"/"$nextcY" +%j |sed 's%^0*%%'`
[ "$DEBUG" ] && echo "todayY=$todayY'"
if [ "$nextcY" -gt $((todayY+1)) ];then
  [ "$DEBUG" ] && echo "$nextcY -gt $((todayY+1))"
  part_1=$nextckYDN
for i in `seq $nextcY -1 $todayY`;do
[ $i = $todayY ] && break
  part_2=$((part_2+365))
done
  part_3=$((365-todayYDN))
  time_elapsed=$((part_1+part_2+part_3))
elif [ "$nextcY" -eq $((todayY+1)) ];then
     [ "$DEBUG" ] && echo "$nextcY -eq $((todayY+1))"
     part_1=$nextckYDN
     [ "$DEBUG" ] && echo "part_1=$part_1' nextckYDN=$nextckYDN' todayYDN=$todayYDN'"
     part_3=$((365-todayYDN))
     [ "$DEBUG" ] && echo "part_3=$part_3'"
     time_elapsed=$((part_1+part_3))
     [ "$DEBUG" ] && echo "time_elapsed=$time_elapsed'"
elif [ "$nextcY" -eq $todayY ];then
  [ "$DEBUG" ] && echo "$nextcY -eq $todayY"
  time_elapsed=$((nextckYDN-todayYDN))  ##+++2013-07-07 BUG was nextYDN , should have been nextckYDN
fi

###+++2013-07-07
ckdays=`echo "$VARS" | grep 'Check interval:' | awk '{print $3}'`
 ckdays=$(($ckdays/60/60/24))
###+++2013-07-07
 #if [ $time_elapsed -ge $ckdays ];then
  if [ $time_elapsed -gt $ckdays ];then ##+-2013-08-10 180er problematic
       FSCK=yes;TIME_ELAPSED=yes
   fi

func_notify

   elif [ "`echo "$DEV1FS" |grep -Ei 'reiser'`" ];then #1.5
   VERSION=`debugreiserfs -V 2>&1|awk '{print $2}' |tr -d '.'`

 echo -e "\\033[1;33m"'Checking for filesystem check intervals using'"\\033[0;39m"
###VARS=`debugreiserfs -J $DEVROOTDRIVE`  ##---2012-09-03
VARS=`debugreiserfs $DEVROOTDRIVE`

#sh-3.2# debugreiserfs -J /dev/sda3
#debugreiserfs 3.6.18 (2003 www.namesys.com)

#Filesystem state: consistency is not checked after last mounting

#Reiserfs super block in block 16 on 0x20010300 of format 3.6 with standard journal
#Count of blocks on the device: 5317504
#Number of bitmaps: 163
#Blocksize: 4096
#Free blocks (count of blocks - used [journal, bitmaps, data, reserved] blocks): 2689033
#Root block: 4030501
#Filesystem marked as NOT cleanly umounted
#Tree height: 5
#Hash function used to sort names: "r5"
#Objectid map size 2, max 972

#Journal parameters:
#   Device [0x0]
#   Magic [0x2e25382]
#   Size 8193 blocks (including 1 for journal header) (first block 18)
#   Max transaction length 1024 blocks
#   Max batch size 900 blocks
#   Max commit age 30

#Blocks reserved by journal: 0
#Fs state field: 0x0:
#sb_version: 2
#inode generation number: 30835
#UUID: 6040ae97-a196-48e5-8738-6f9c30cb5e7d
#LABEL: MacPup_O2

#Set flags in SB:
#   ATTRIBUTES CLEAN

###3.6.21
#Mount count: 32
#Maximum mount count: 30
#Last fsck run: Tue May 15 21:16:51 2012
#Check interval in days: 180
###3.6.21

#Journal header (block #8210 of /dev/sda3):
#   j_last_flush_trans_id 19138
#   j_first_unflushed_offset 6697
#   j_mount_id 32
#   Device [0x0]
#   Magic [0x2e25382]
#   Size 8193 blocks (including 1 for journal header) (first block 18)
#   Max transaction length 1024 blocks
#   Max batch size 900 blocks
#   Max commit age 30
###echo -e "\\033[1;33m""for $DEVROOTDRIVE""\\033[0;39m"
       if echo "$VARS" |grep -i 'NOT clean' ;then
       FSCK=yes
       else
       FSCK=''
       fi

      if [ "$VERSION" = 3621 ];then

#######################

maxmnt=`echo "$VARS" |grep 'Maximum mount count:' |cut -f 2 -d ':' |tr -d '[[:blank:]]'`
[ "$maxmnt" ] || maxmnt=30
mntcnt=`echo "$VARS" |grep 'Mount count:' |cut -f 2 -d ':' |tr -d '[[:blank:]]'`
[ "$mntcnt" ] || mntcnt=1
#func_mount_count
func_check_maxmnt
func_mount_count
#######################

#######################
ckdays=`echo "$VARS" |grep 'Check interval in days:' |cut -f2 -d':' |tr -d '[[:blank:]]'`
###echo $ckdays
[ "$ckdays" ] || ckdays=180
lastch=`echo "$VARS" |grep 'Last fsck run:' |cut -f2- -d':' |awk '{print $5" "$2" "$3}'`
###echo $lastch
##[[ "$lastch" =~ '[[:alpha:][:digit:]]' ]] || lastch=''
[ "`echo "$lastch" |grep '[[:alpha:][:digit:]]'`" ] || lastch=''
[ "$lastch" ] || lastch='2012 May 1'
func_last_check
[ "$DEBUG" ] && echo "
lastcY=$lastcY
lastcM=$lastcM
lastcD=$lastcD
"
monthC=`echo "$monthN" | grep -e "^[0-9]* ${lastcM}.*"`
[ "$monthC" ] || monthC='1 Jan'
func_thirties
#echo "monthN=$monthN"
[ "$DEBUG" ] && echo "monthN=$monthN"
[ "$DEBUG" ] && echo "monthC=$monthC"
[ "$DEBUG" ] && echo "montCN=$montCN/lastcD=$lastcD/lastcY=$lastcY"
/bin/date --d="$montCN"/"$lastcD"/"$lastcY" +%j |sed 's%^0*%%'
lastcYDN=`/bin/date --date="$montCN"/"$lastcD"/"$lastcY" +%j |sed 's%^0*%%'`
[ "$lastcYDN" ] || lastcYDN=1
if [ "$lastcY" -lt $((todayY-1)) ];then
part_1=$((365-lastcYDN))
for i in `seq $lastcY 1 $todayY`;do
[ $i = $todayY ] && break
part2=$((part_2+365))
done
part_3=$todayYDN
time_elapsed=$((part_1+part_2+part_3))

elif [ "$lastcY" -eq $((todayY-1)) ];then
part_1=$((365-lastcYDN))
part_3=$todayYDN
time_elapsed=$((part_1+part_3))
elif [ "$lastcY" -eq $todayY ];then
time_elapsed=$((todayYDN-lastcYDN))
fi
[ "$DEBUG" ] && echo "time_elapsed=$time_elapsed"
##+++2012-08-22
[ "$time_elapsed" ] || time_elapsed=1
##nextcM=`date -d "${time_elapsed} days" +%b`  ##---2012-09-03
nextcM=`/bin/date -d "$((ckdays-time_elapsed)) days" +%b`
#date -d "${time_elapsed} days" +%m
##nextcD=`date -d "${time_elapsed} days" +%d`  ##---2012-09-03
nextcD=`/bin/date -d "$((ckdays-time_elapsed)) days" +%d`
##+++2012-08-22

 #if [ $time_elapsed -ge $ckdays ];then
  if [ $time_elapsed -gt $ckdays ];then  ##+-2013-08-10 180er problem
       FSCK=yes;TIME_ELAPSED=yes
   fi
func_notify

#monthC=`echo "$monthN" | grep -e "^[0-9]* $lastcM.*"`
#func_thirties

    fi #version 3.6.21

   else #1.5
   echo -e "\\033[1;34m""FILESYSTEM '$DEV1FS' not supported""\\033[0;39m"
   ErrFlag='';FSCK='';
   fi   #1.5
else #1
echo -e "\\033[1;31m" ' Found : '"\\033[0;39m""\\033[1;5;31m""$ErrFlag"
echo -e "\\033[0;39m"
fi #1
busybox mount $VERB $VERB -o remount,rw /dev/root /  ##+++2012-08-21 for reiserfs
}
############# ERRFLAG OR INTERVALS #########


########### KERNEL PARAMETER ###############
_resolve_PUPPY_KERNEL_PARAMETERS(){  #BEGIN
 pkp=`echo $pfix |sed 's§^pfix=§§' | tr ',' ' '`
 [ "$pkp" ] && _info "pkp='$pkp'"

  for p_ in $pkp;do
   case $p_ in
    fsck)   _FSCK_='yes';;
    nofsck) _FSCK_='no' ;;  ##+++2013-08-10
   esac;        done

test "$_FSCK_" || {
if [ "`grep -i -w 'fsck' /proc/cmdline`" ];then
 _FSCK_='yes';
elif [ "`grep -i -w 'nofsck' /proc/cmdline`" ];then  ##+++2013-08-10
 _FSCK_='no'
fi
}

[ "$_FSCK_" ]         && _info "_FSCK_='$_FSCK_'"
}  ###_resolve_PUPPY_KERNEL_PARAMETERS(){  #END
_resolve_PUPPY_KERNEL_PARAMETERS ##+++2012-02-02 ##2014-10-05 renamed to _resolve_PUPPY_KERNEL_PARAMETERS

[ "$FSCK" = 'no' ]  && _do_BUSYBOX_INIT ##+++2013-08-10
[ "$FSCK" = 'yes' ] || _test_ERRFLAG
########### KERNEL PARAMETER ########


########### SIMPLE SHELL ############
_dropto_SIMPLE_CONSOLE(){  #BEGIN
[ -n "$ERRMSG" ] && echo -e "\\033[0;31m""$ERRMSG""\\033[0;39m"
echo "Now ramdiskshell without busybox init on top"
echo -e "\\033[0;32m""Type 'busybox reboot -f' or press Cnt+Alt+Del to reboot""\\033[0;39m"
exec chroot . sh
}  ###_dropto_SIMPLE_CONSOLE(){  #END
########### SIMPLE SHELL ############


########### FSCK INTRO ##############

##+++2012-05-09
if [ ! "$DEV1FS" ];then
 if [ -r "$ErrFlag" ];then
  DEV1FS=`cat "$ErrFlag" |cut -f2 -d','`
   if [ ! "$DEV1FS" ];then
    echo -e "\\033[0;31m""WARNING : Was unable to determine the FS type""\\033[0;39m"
fi;fi;fi
##+++2012-05-09

_fsck_INTRO(){  #BEGIN
  echo -e "\\033[1;33m"  #34=blue, 33=yellow, 32=green, 31=red, 35=purple, 36=aquablue, 38=black.
  if [ -n "$ErrFlag" ] ; then
  echo "Performing filesystem check of '${PDEV1}' after improper shutdown"
  elif [ "$TIME_ELAPSED" ];then
  echo "Performing scheduled filesystem check of '${PDEV1}' ."
  [ "`echo "$DEV1FS" |grep 'ext[234]'`" ] && echo -e "\\033[0;32m""Use 'tune2fs -i $todayD[d|w|m] [+-] -C $maxmnt [+-] /dev/$PDEV1' to adjust ."
  else
  echo "Performing filesystem check of '${PDEV1}' ."
  fi
  echo -e "\\033[1;34m""NOTE: may take awhile, please wait patiently..."
  echo -e "\\033[0;39m"
  echo
}  ###_fsck_INTRO(){  #END
########### FSCK INTRO ##############


########### SHELL DROP ##############

TimeOut=60

_askto_CONTINUE(){  #BEGIN
echo -e "\\033[0;39m"
echo -e "\\033[0;32m""Continue this $0 ?\t [ y ]"
echo -e "\\033[0;31m""Dropout into console ?\t\t [ c ]""\\033[0;32m"
echo -e "\\033[0;39m"
echo -n -e "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"
read -n 1 -t $TimeOut K
echo -e "\\033[0;39m"
Key=`echo "$K" | tr '[A-Z]' '[a-z]'`
if [ "$Key" = "n" -o "$Key" = "c" -o "$Key" = "k" ] ; then
echo -e "\\033[1;34m"'dropping to console now , partition still mounted !'"\\033[0;39m"
cd /
busybox mount $VERB $VERB -o remount,ro /dev/root /
sleep $((SLEEP*1))s
exec chroot . sh
fi
}  ###_askto_CONTINUE(){  #END
########### SHELL DROP ##########


########### KERNEL PARAMETERS ###
_stub_failsafe(){  #BEGIN
#rm -rf /tmp/*  ##+++2011-10-31 moved here
if [ $nodrivers ] ; then
 nodrivers=`echo "$nodrivers" |tr '[[:upper:]' '[[:lower:]]'`
  case $nodrivers in
   all|yes|y|1)      safeBoot=0   ;return 0;;
   none|no|nope|n|0) safeBoot=256 ;return 0;;
   *) noDriversList=`echo "$nodrivers" | tr ',' '\n' | sed 's/^/blacklist /g'`
                  safeBoot=256                  ;;
  esac
fi

#[ $noalsa ] && safeBoot=10 && echo 'noalsa' >/tmp/alsa.flg
 [ $noalsa ] &&    { safeBoot=$((safeBoot+16)) ; echo 'noalsa' >/tmp/pup_event_alsa_cnt ; }

[ $nographics ] && { safeBoot=$((safeBoot+1))  ; echo 'nographics' >/tmp/graphics.flg;    }
[ $nofb ] &&       { safeBoot=$((safeBoot+2))  ; echo 'nofb'       >/tmp/framebuffer.flg; }
[ $nofbcon ] &&    { safeBoot=$((safeBoot+4))  ; echo 'nofbcon'    >/tmp/fbcon.flg;       }

[ $userdriversonly ]   && { safeBoot=64;return 0; }  #load only ADDLIST from /etc/rc.d/MODULESCONFIG
[ $noaddlist ]         && safeBoot=$((safeBoot+32))  #dont load addlist
[ $kerneldriversonly ] && safeBoot=128               #dont load addlist,respect other params

if [ $alldrivers ];then
 case $alldrivers in
 1|Y|y|Yes|YES|yes) safeBoot=256 ;return 0;;
 *) safeBoot=0;return 0;;
 esac;fi
#[ "$safeBoot" ] || safeBoot=256
_debugx "safeBoot='$safeBoot'"
}  ###_stub_failsafe(){  #END
########### KERNEL PARAMETERS ###


########### MODPROBECONF ########
_create_modprobe_confFILES(){  #BEGIN
mkdir -p /etc/mult_kernels
mkdir -p /etc/mult_kernels/modprobe.d.$KERNVER
mkdir -p /etc/modprobe.d

if test -f /etc/modprobe.conf ; then #1
if [ ! -f /etc/mult_kernels/modprobe.conf."$KERNVER" ] ; then  ##&&
cp $VERB -f "/etc/modprobe.conf" "/etc/mult_kernels/modprobe.conf.$KERNVER"
else
cp $VERB -f /etc/mult_kernels/modprobe.conf."$KERNVER" /etc/modprobe.conf
fi
fi

if test -d /etc/mult_kernels/modprobe.d."$KERNVER" ; then #2
rm -f -r /etc/modprobe.d
cp $VERB -a /etc/mult_kernels/modprobe.d."$KERNVER" /etc/modprobe.d
else #2
 if test -d /etc/modprobe.d ; then #2.1
 cp $VERB -r /etc/modprobe.d /etc/mult_kernels/modprobe.d."$KERNVER"
 fi #2.1
fi #2

mkdir -p /etc/mult_kernels/rc.d
if test ! -f /etc/mult_kernels/rc.d/MODULESCONFIG."$KERNVER" ; then
cp $VERB /etc/rc.d/MODULESCONFIG /etc/mult_kernels/rc.d/MODULESCONFIG."$KERNVER"
else
rm /etc/rc.d/MODULESCONFIG
cp $VERB /etc/mult_kernels/rc.d/MODULESCONFIG."$KERNVER" /etc/rc.d/MODULESCONFIG
fi

#if test -f /lib/modules/"$KERNVER"/DOTconfig* ; then
#cp /lib/modules/"$KERNVER"/DOTconfig* /etc/modules/
if test -f /lib/modules/"$KERNVER"/DOTconfig-"$KERNVER" ; then
cp $VERB /lib/modules/"$KERNVER"/DOTconfig-"$KERNVER" /etc/modules/
fi
}  ###_create_modprobe_confFILES(){  #END

_update_modprobe_confFILES(){  #BEGIN
[ "$KERNVER" ] || KERNVER=`uname -r`

CONFFILE='/etc/modprobe.conf'
[ -f /etc/modprobe.d/modprobe.conf ] && CONFFILE='/etc/modprobe.d/modprobe.conf'
[ -f /etc/modprobe.d/puppy.conf ]    && CONFFILE='/etc/modprobe.d/puppy.conf'
#basenameCONFFILE=`basename $CONFFILE`
basenameCONFFILE="${CONFFILE##*/}"

#modprobe_conf_func
_create_modprobe_confFILES

if [ -f "$CONFFILE" ] ; then
SYSTEM=`dmidecode -t 0 | grep -i -E 'vendor|version|release'`

##+++2011-11-07
SYSTEM="$SYSTEM
`dmidecode -t 1 | grep -i -E 'manufacturer|version|product'`"
SYSTEM="$SYSTEM
`dmidecode -t 2 | grep -i -E 'manufacturer|version|product'`"
##+++2011-11-07

WC=`echo "$SYSTEM" | wc -l`
GREPpattern=$(echo "$SYSTEM" | head -n 1 | tr '\t' ' ' | tr -s ' ' | sed 's/\([[:punct:]]\)/\\\\\1/g; s/\\\\/\\/g')
FIELD=`grep -B 1 -n "$GREPpattern" "$CONFFILE"`
if [ -z "`echo "$FIELD" | grep "$GREPpattern"`" ] || [ -z "`echo "$FIELD" | grep "$KERNVER"`" ] ; then
#cp "$CONFFILE" "$CONFFILE".`basename $0`."$KERNVER".sbin_init.bac
cp $VERB "$CONFFILE" "$CONFFILE"."${0##*/}"."$KERNVER".sbin_init.bac
echo                                                     >> "$CONFFILE"
echo '#####  Updated modaliases for system  ###########' >> "$CONFFILE"
echo '### RUNNING kernel '"$KERNVER"                     >> "$CONFFILE"
for i in `seq 1 $WC` ; do
PARAM=`echo "$SYSTEM" | head -n $i | tail -n 1 | tr '\t' ' ' | tr -s ' '`
STRING="### ${PARAM} "
echo "$STRING"                                           >> "$CONFFILE"
done
BOARD=`dmidecode -t1 | grep -i -E 'Manufacturer|Product' | tr -d '[[:blank:]]' | cut -f 2 -d ':' | tr '\n' ' '`
echo '### '"$BOARD"                        >> "$CONFFILE"
BOAR2=`dmidecode -t2 | grep -i -E 'Manufacturer|Product' | tr -d '[[:blank:]]' | cut -f 2 -d ':' | tr '\n' ' '`
echo '### '"$BOAR2"                        >> "$CONFFILE"
echo >> "$CONFFILE"
UEVENTS=`ls /sys/bus/*/devices/*/uevent`
for i in $UEVENTS ; do
DRVR=`grep 'DRIVER' $i   2>$ERR | cut -f 2 -d '='`;
MODA=`grep 'MODALIAS' $i 2>$ERR | cut -f 2 -d '='` ;
if [ -n "$DRVR" ] && [ -n "$MODA" ] ; then
echo -n 'alias ' >> /tmp/sbin_init_modaliases.conf
echo -n "$MODA " >> /tmp/sbin_init_modaliases.conf
echo "$DRVR"     >> /tmp/sbin_init_modaliases.conf
fi
done
cat /tmp/sbin_init_modaliases.conf | sort -u | sort -k 3 -t ' ' >> "$CONFFILE"
echo >> "$CONFFILE"
echo '### '`cat /proc/cmdline`             >> "$CONFFILE"
echo '### '`date`                          >> "$CONFFILE"
echo "##### by $0 #######################" >> "$CONFFILE"
fi
fi

if [ -f /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" ] ; then
DIFF=`diff -uaNd /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" "$CONFFILE"`
echo "$DIFF" > /tmp/sbin_init."$basenameCONFFILE".diff
if [ -n "`grep -E '[[:alpha:]]|[[:punct:]]' /tmp/sbin_init."$basenameCONFFILE".diff`" ] ; then
if [ "$DebugVal" = "0" ] ; then
#patch -s -b /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff
patch -p 0 /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff >$OUT 2>$ERR
elif [ "$DebugVal" = "1" ] ; then
#patch -b /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff
patch -p 0 /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff >$OUT 2>$ERR
else
#patch --verbose -b /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff
patch -p 0 /etc/mult_kernels/"$basenameCONFFILE"."$KERNVER" /tmp/sbin_init."$basenameCONFFILE".diff >$OUT 2>$ERR
fi
fi
fi

if [ -f "/etc/mult_kernels/modprobe.d.${KERNVER}/${basenameCONFFILE}" ] ; then
DIFF=`diff -uaNd "/etc/mult_kernels/modprobe.d.${KERNVER}/${basenameCONFFILE}" "$CONFFILE"`
echo "$DIFF" > "/tmp/sbin_init.${basenameCONFFILE}.2.diff"
if [ -n "`grep -E '[[:alpha:]]|[[:punct:]]' /tmp/sbin_init."$basenameCONFFILE".2.diff`" ] ; then
if [ "$DebugVal" = "0" ] ; then
#patch -s -b /etc/mult_kernels/modprobe.d.${KERNVER}/"$basenameCONFFILE" /tmp/sbin_init."$basenameCONFFILE".2.diff
patch -p 0 /etc/mult_kernels/modprobe.d.${KERNVER}/"$basenameCONFFILE" /tmp/sbin_init."$basenameCONFFILE".2.diff     >$OUT 2>$ERR
elif [ "$DebugVal" = "1" ] ; then
#patch -b "/etc/mult_kernels/modprobe.d.${KERNVER}/${basenameCONFFILE}" "/tmp/sbin_init.${basenameCONFFILE}.2.diff"
patch -p 0 "/etc/mult_kernels/modprobe.d.${KERNVER}/${basenameCONFFILE}" "/tmp/sbin_init.${basenameCONFFILE}.2.diff" >$OUT 2>$ERR
else
#patch --verbose -b /etc/mult_kernels/modprobe.d.${KERNVER}/"$basenameCONFFILE" /tmp/sbin_init."$basenameCONFFILE".2.diff
patch -p 0 /etc/mult_kernels/modprobe.d.${KERNVER}/"$basenameCONFFILE" /tmp/sbin_init."$basenameCONFFILE".2.diff     >$OUT 2>$ERR
fi
fi
fi
}  ###_update_modprobe_confFILES(){  #END
########### MODPROBECONF #####


########### MODULES ##########
alias modprobe='modprobe -b'  ##+++2012-01-15

_do_HOTPLUG(){  #BEGIN
if [ -z "$HOTPLUGDMN" ] ; then
[ -f /etc/rc.d/PUPSTATE ] || echo 'PUPMODE=2' > /etc/rc.d/PUPSTATE
. /etc/rc.d/MODULESCONFIG
##rm -rf /tmp/*  ##+++2011-10-29 -2011-10-31
BLACKLISTVARS=`echo "$SKIPLIST" | tr '\-' '_' | tr ' ' '\n' | sed -e 's/^/blacklist /' | grep -v ' $'`
echo "$BLACKLISTVARS" > /tmp/pup_event_skiplist.conf
echo "$BLACKLISTVARS" > /tmp/pup_event_modprobe.conf

#update_modprobe_conf_func
_update_modprobe_confFILES

if _test_fx /sbin/photplug; then
 echo '/sbin/photplug' > /proc/sys/kernel/hotplug
 HOTPLUGDMN='photplug'
else
    [ -f /tmp/pup_event_alsa_cnt ] || echo '0' > /tmp/pup_event_alsa_cnt
    if [ -x /sbin/pup_event_backend_modprobe_protect ] ; then
 nice -n -3 /sbin/pup_event_backend_modprobe_protect --daemon &
    fi

 if [ -x /sbin/udevd ];then
 rm -rf /dev/.udev/*/*
 HOTPLUGDMN='udevd'
 UDEVVER=`udevd --version`
  if [ $UDEVVER -gt 150 ];then
  UDEV_LOG=1 /sbin/udevd --daemon --resolve-names=never ###KRG ; orig LOG=2
  else
  UDEV_LOG=1 /sbin/udevd --daemon ###KRG ; orig LOG=2
  fi

 else
 /sbin/pup_event_backend_d >/tmp/pup_event_backend_errors 2>&1 & #hotplug daemon. my homebrew replacement for udevd.
 HOTPLUGDMN='pup_event_backend_d'
 fi
fi

sleep 0.1
fi #[ -z "$HOTPLUGDMN" ]
}  ###_do_HOTPLUG(){  #END

_add_MODULES(){  #BEGIN

INITSTATE=`find /sys -name "initstate"`
INITSTATECOUNT=`echo "$INITSTATE" | wc -l`
[ -n "$INITSTATE" ] && { [ "$DebugVal" = "2" ] && for i in $INITSTATE ; do echo -n "$i " ; cat "$i" ; done ; }  ##echo

if [ "$INITSTATECOUNT" -lt 25 ] ; then
MODALIASES=`ls -1v /sys/*/*/*/*/modalias`
[ "$noDriversList" ] && echo "$noDriversList" >>/tmp/pup_event_skiplist.conf

echo -n "Loading kernel modules "
if [ -z "$MODALIASES" ] ; then
 echo -e "\\033[1;5;31m"'WARNING : '"\\033[0;31m"'No modaliases found !'"\\033[0;39m"
 echo -e "\\033[1;35m"'Either the kernel detected no HardWare automatically'"\\033[0;39m"
 echo -e "\\033[0;39m"'or something else went wrong'"\\033[0;39m"

else
modprobe nls_cp437 #these needed by vfat/ntfs/ext2 f.s.'s.
modprobe nls_iso8859-1 #
echo 'Running the modaliases add by /sbin/init '$0 >> /tmp/pup_eve_bac_mod.log
MODULECNT=0

 oldIFS="$IFS"
 IFS=$'\n'
 for oneMODALIAS in $MODALIASES
 do
 onePATH=${oneMODALIAS%/*}
 if [ -e "${ONEPATH}/uevent" ];then
  echo "$ONEMODALIAS" >> /tmp/modaliases.loaded
  echo 'add' > "${ONEPATH}/uevent" #generates an 'add' uevent.
  echo -n '.'
  MODULECNT=$((MODULECNT+1))
  sleep 0.2
 fi
 done
 IFS="$oldIFS"

 echo >> /tmp/pup_eve_bac_mod.log
 echo
 echo -e 'Detected '"\\033[1;34m""$MODULECNT ""\\033[0;39m"'busses'
 MODULECNT=0
 sleep $((SLEEP*3))s
 LSMODCNT=`lsmod | sed "1 d" | wc -l`
  if [ "$LSMODCNT" = 0 ] ; then
  lsmod | cut -f 1 -d ' ' | sort -g | tr '\n' ' '
  else
  echo -e -n 'Loaded   '"\\033[1;35m""$LSMODCNT ""\\033[0;39m"'drivers at least'
  fi
 _status 0
 echo
 sleep 1s
fi

else
_notice "More than 10 initstate files exist ( $INITSTATECOUNT ) :"
_notice "$INITSTATE" | tr '\n' ' ';echo
sleep $((SLEEP*2))s
fi
}  ###_add_MODULES(){  #END

_load_USB_DRIVERS(){  #BEGIN
if [ -z "`lsmod | grep 'usb'`" ] || [ "$FORCE_USB_DRIVERS" ]; then
echo -e "\\033[1;34m""Loading usb drivers ...""\\033[0;39m"
#DRIVERS=`modprobe -l | grep -E 'ehci[-_]hcd|ohci[-_]hcd|uhci[-_]hcd|usbcore|usb[-_]storage' | sort -k4,8 -t '/'`
DRIVERS=`modprobe -l | grep -E '[eoux]hci[-_]hcd|usbcore|usb[-_]storage' | sort -k4,8 -t '/'`  ##++2012-10-14 added xhci USB-3.0
for i in $DRIVERS ; do
#DRIVER=`basename $i | sed 's#\.ko.*$##'`
#DRVpattern=`echo "$DRIVER" | tr '-' '_'`
I=${i##*/};DRIVER=${I%\.ko*}
echo -e -n "\\033[1;33m""$DRIVER ""\\033[1;34m"'.. '"\\033[0;39m"
if [ "$DRVpattern" != "usb-storage" ] ; then
#[ -z "`lsmod | grep "$DRVpattern"`" ] && modprobe --first-time $DRIVER
modprobe $VERB $modprobeFIRST_TIME $DRIVER
else
#[ -z "`lsmod | grep "$DRVpattern"`" ] && modprobe --first-time $DRIVER delay_use=1  ##+-2011-12-10 delay_use:1 to delay_use=1
modprobe $VERB $modprobeFIRST_TIME $DRIVER delay_use=1
fi
done
echo -e "\\033[1;34m"'Waiting 15 sec. for kernel to register usb devices ...'"\\033[0;39m"
sleep 15s
echo
fi
}  ###_load_USB_DRIVERS(){  #END

_load_INPUT_DRIVERS(){  #BEGIN

if [ "$safeBoot" != "0" -a "$safeBoot" != 128 ] || [ "$FORCE_INPUT_DRIVERS" ] ; then
echo -e "\\033[1;34m""Loading keyboard and other drivers ...""\\033[0;39m"
DRIVERS=`modprobe -l | grep -E 'usbhid|rtc-cmos|libps2|atkbd|xtkbd|evdev' | grep -v -E 'snd|sound' | sort -k4,8 -t '/'`
for i in $DRIVERS ; do
#DRIVER=`basename $i | sed 's#\.ko.*$##'`
#DRVpattern=`echo "$DRIVER" | tr '-' '_'`
#if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then
I=${i##*/};DRIVER=${I%\.ko*}
echo -e -n "\\033[1;33m""$DRIVER ""\\033[1;34m"'.. '"\\033[0;39m"
modprobe $VERB $modprobeFIRST_TIME $DRIVER
#fi
done
echo -e "\\033[0;39m"
fi
}  ###_load_INPUT_DRIVERS(){  #END

_load_FB_DRIVERS(){  #BEGIN
    if [ $safeBoot -ne 128 ];then #0

if [ "$safeBoot" -gt 3 ] ; then #1
    if [ "`cat /proc/cmdline | grep -E 'vga=ask|vga=0x3[0-9a-fA-F][0-9a-fA-F]|vga=7[0-9][0-9]'`" != "" ]; then #1.0
echo -e "\\033[1;34m""Trying to load i2c and framebuffer drivers ...""\\033[0;39m"
#I2CS=`modprobe -l | grep -i 'i2c' | grep -v -E 'snd|sound' | while read line ;do basename $line | sed 's#\.ko.*$##' ;done`
I2CS=`modprobe -l | grep -i 'i2c' | grep -v -E 'snd|sound' | while read line ;do echo "${line##*/}" | sed 's#\.ko.*$##' ;done`
GRAPHB=`ddcprobe | grep -E 'vbe|oem|vendor|product' | cut -f 2-99 -d ' ' | tr '[A-Z]' '[a-z]' | tr '\n' ' '`
echo -e "\\033[1;33m"'video-info : '"\\033[1;34m"$GRAPHB"\\033[0;39m"
MBOARD=`dmidecode | grep -i -E 'Family|Manufacturer' | tr -d '\t ' | cut -f 2 -d ':' | grep -v -i 'none' | tr '[[:punct:]]' ' ' | cut -f 1 -d ' ' | tr '\n' ' '`
echo -e "\\033[1;33m"'board-info : '"\\033[1;34m"$MBOARD"\\033[0;39m"
POOL="$GRAPHB $MBOARD"
sleep 4s
        if [ -n "`echo "$MBOARD" | grep -i 'Intel'`" ] ; then #1.0.0
        if [ -n "`modprobe -l | grep -E 'i2c\-i801|i801_smbus'`" ] ; then #1.0.0.0
        POOL="$POOL i2c\-i801 i801_smbus"
        fi #1.0.0.0
        fi #1.0.0
POOL=`echo "$POOL" | sort -u`
        if [ -z "`elspci -l | grep -i -E '<.*fb>|<agp.*>|<.*agp.*>|<.*agp>|<vga.*>|<.*vga.*>|<.*vga>'`" ] ; then #1.0.1
for i in $POOL ; do #POOL
I2C=`echo "$I2CS" | grep -i $i`
        if [ -n "$I2C" ] ; then #1.0.1.0
echo -e -n "\\033[1;33m"'Loading ...'"\\033[0;39m"
    for j in $I2C ; do #I2C
#DRIVER=`basename $j`
DRIVER="${j##*/}"
DRVpattern=`echo "$DRIVER" | tr '-' '_'`
    if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then #1.0.1.0.0
echo -e -n "\\033[1;34m""$DRIVER ""\\033[1;33m"'.. '"\\033[0;39m"
modprobe $VERB $modprobeFIRST_TIME $DRIVER 2>$ERR
    fi #1.0.1.0.0
    done #I2C
echo -e "\\033[0;39m"
        fi #1.0.1.0
done #POOL
echo -e "\\033[0;39m"

#FBDRIVERS=`modprobe -l | grep 'fb' | while read line ;do basename $line | sed 's#\.ko.*$##' ;done`
FBDRIVERS=`modprobe -l | grep 'fb' | while read line ;do echo "${line##*/}" | sed 's#\.ko.*$##' ;done`
if [ -n "`echo "$GRAPHB" | grep -i 'Intel'`" ] ; then #1.0.1.1
if [ -n "`modprobe -l | grep -E 'i810fb'`" ] ; then  #1.0.1.1.0
POOL="$POOL $FBDRIVERS i810fb"
fi #1.0.1.1.0
fi #1.0.1.1
POOL=`echo "$POOL" | sort -u`
for i in $POOL ; do #POOL
FBS=`echo "$FBDRIVERS" | grep -i $i`
    if [ -n "$FBS" ] ; then #1.0.1.2
echo -n -e "\\033[1;33m"'Loading ... '"\\033[0;39m"
    for j in $FBS ; do #FBS
#DRIVER=`basename $j`
DRIVER="${j##*/}"
DRVpattern=`echo "$DRIVER" | tr '-' '_'`
[[ "$DRIVER" = "nvidiafb" -a "`lsmod | grep 'nouveau'`" != "" ]] && continue
[[ "$DRIVER" = "nouveau" -a "`lsmod | grep 'nvidiafb'`" != "" ]] && continue
        if [ -z "`lsmod | grep "$DRVpattern"`" ] ; then #1.0.1.2.0
echo -e -n "\\033[1;34m""$DRIVER ""\\033[1;33m"'.. '"\\033[0;39m"
modprobe $VERB $modprobeFIRST_TIME $DRIVER 2>$ERR
        fi #1.0.1.2.0
    done #FBS
echo -e "\\033[0;39m"
    fi #1.0.1.2
done #POOL
sleep 4s
fi #1.0.1
fi #1.0
fi #1
fi #0
}  ##_load_FB_DRIVERS(){  #END

_load_FBCON(){  #BEGIN
    if [ "$safeBoot" != 128 ];then
if [ "$safeBoot" = "2" ] || [ ! $safeBoot -le 4 -a $safeBoot -gt 7 ]  ; then
if [ -n "`modprobe -l | grep 'fbcon'`" ] && [ -z "`lsmod | grep 'fbcon'`" ] ; then
modprobe $VERB $modprobeFIRST_TIME fbcon
echo -e "\\033[0;39m"
fi;fi;  fi
}  ###_load_FBCON(){  #END

########### MODULES ########


########### DEBUG ##########

OUT=/dev/null;ERR=/dev/null
_ask_DEBUG(){  #BEGIN
[ -x /etc/rc.d/rc.country ] && /etc/rc.d/rc.country
DebugVal=0
echo -e "\\033[0;39m"
echo "Do you think $0 DEBUG MODE is required ?"
echo -e -n "\\033[1;34m"
echo "If so , press [ y ] and [ Enter ] for normal debug incl. 'fsck -v' ,"
echo -e -n "\\033[0;39m""\\033[6;7;32m"
echo "    or  press [ Y ] and [ Enter ] for extensive output ,            "
echo -e -n "\\033[0;39m"
echo -e -n "\\033[1;36m"
echo -e "which may confuse muchly first and second time ..."
echo -e "\\033[1;35m"
echo "If not wait 20 sec. or press any other key and or simply [ Enter ]"
echo -e "\\033[0;39m"
echo -n -e "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"
read -n 1 -t 20 K
echo -e "\\033[0;39m" && echo

if [ "$K" = "y" ] ; then
DebugVal=1;OUT=/dev/null;ERR=/dev/console
echo -e "\\033[0;33m"'Debug Mode '"$DebugVal"' turned on'
   echo 'Have FUN !'
elif [ "$K" = "Y" ] ; then
DebugVal=2;OUT=/dev/console;ERR=/dev/console
echo -e "\\033[0;31m"'Debug Mode '"$DebugVal"' turned on'
   echo 'Have FUN !'
else
DebugVal=0
echo -e "\\033[0;35m"'Keeping in Silent Screen Mode'
fi

TimeOut=$(( ($DebugVal + 1) * 20 ))
SLEEP=$((DebugVal+1))
[ "$DebugVal" -ge "1" ] && echo -e "\n\\033[0;33m"'TimeOut='"\\033[0;39m""$TimeOut""\\033[0;33m"' , additional_sleep_value='"\\033[0;39m""$SLEEP"
echo -e "\\033[0;39m"
}  ###_ask_DEBUG(){  #END

########### DEBUG ##########


########### FSCK ###########

_do_FSCK(){  #BEGIN
[ "$DebugVal" -ge "2" ]   && echo -e "\\033[0;33m"'FSCK_FUNC called with param $1='"\\033[0;39m""${1}""\\033[0;33m"' $2='"\\033[0;39m""${2}"
echo -e "\\033[0;39m"
[ "${1}" = "/dev/" ]        && { sleep 5s;iamCLEAN='guessing_clean';return; } ##2011-10-02
[ "${1}" != "/dev/${PDEV1}" ] && [ -n "`grep  "^${1} " /proc/mounts`" ] && busybox umount -lr "${1}"
sleep 1s
RO_ERR=1

     local awk_P="${1}"
until [ "${RO_ERR}" = '0' ];do
 if [ -n "`awk '{if ($1 == "$awk_P" && match($4, "^rw")) print $4}' /proc/mounts`" ];then
  busybox mount $VERB $VERB -o remount,ro $1
  RO_ERR=$?
  sleep 2s
 else
  RO_ERR=0
 fi
done

Err=''
RETFSCK=''
iamCLEAN=''
FSTYPE=`guess_fstype "$1"`
[ "$FSTYPE" = "unknown" ] && FSTYPE=`disktype "$1" | grep -i 'file system' | cut -f 1 -d ' ' | tr '[A-Z]' '[a-z]'` ##2011-10-02 disktype /dev/
[ -z "$FSTYPE" ]         && FSTYPE='unknown'
[ "$DebugVal" = "2" ]   && echo 'FSTYPE='"$FSTYPE"

case $FSTYPE in
ext2|ext3|ext4)
if [ -z "$2" ] ; then
echo -e "\\033[1;34m""Checking Partition $1 in -n mode
if required binaries are useable . Please wait""\\033[0;39m"
[ "$DebugVal" = "0" ]   && { RETFSCK=`e2fsck -C 0 -n "$1" 2>$ERR` || Err=$?; }
[ "$DebugVal" -ge "1" ] && { RETFSCK=`e2fsck -C 0 -n "$1"`        || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Fsck returned'="$Err""\\033[0;39m"

else
echo -e "\\033[1;34m""Checking Partition $1 in normal mode
if required binaries are useable . Please wait""\\033[0;39m"
[ "$DebugVal" = "0" ]   && e2fsck -C 0 -p "$1"
[ "$DebugVal" = "0" ]   && { RETFSCK=`e2fsck -C 0 -n "$1" 2>$ERR` || Err=$?; }
[ "$DebugVal" -ge "1" ] && e2fsck -C 0 "$1"
[ "$DebugVal" -ge "1" ] && { RETFSCK=`e2fsck -C 0 -n "$1"`        || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'E2fsck returned'="$Err""\\033[0;39m"
fi
iamCLEAN=`echo "$RETFSCK" | tail -n 1 | grep -i -o 'clean'`
;;

### REISERFS ###
reiserfs)  ##2012-06-09
if [ -z "$2" ] ; then
echo -e "\\033[1;34m""Checking Partition $1 in -a -p mode
if required binaries are useable . Please wait""\\033[0;39m"
[ "$DebugVal" = "0" ]   && { RETFSCK=`reiserfsck -a -p -y "$1" 2>$ERR` || Err=$?; }
[ "$DebugVal" -ge "1" ] && { RETFSCK=`reiserfsck -a -p "$1"`           || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Reiserfsck returned'="$Err""\\033[0;39m"

else
echo -e "\\033[1;34m""Checking Partition $1 in normal mode
if required binaries are useable . Please wait""\\033[0;39m"
[ "$DebugVal" = "0" ]   &&            reiserfsck -y "$1"
[ "$DebugVal" = "0" ]   && { RETFSCK=`reiserfsck "$1" 2>$ERR` || Err=$?; }
[ "$DebugVal" -ge "1" ] &&            reiserfsck "$1"
[ "$DebugVal" -ge "1" ] && { RETFSCK=`reiserfsck "$1"`        || Err=$?; }
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Reisersck returned'="$Err""\\033[0;39m"
fi
echo "$RETFSCK"

if [ "`echo "$RETFSCK" | grep 'NOT cleanly'`" ];then
iamCLEAN=''
else
iamCLEAN=`echo "$RETFSCK" | grep -i -w 'marked as cleanly'`
fi
;;

### OTHER FILESYSTEMS ###
*)
echo -e "\\033[1;34m""NOTE : Filesystem types other than ext2|ext3|ext4|reiserfs v3|* not yet supported .
Omitting fsck of $1 ...""\\033[0;39m"
iamCLEAN='guessing_clean'
;;
esac

if [ -n "$iamCLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq 0 ] ; then
echo -e "\\033[1;32m""OK"
echo -e "\\033[0;32m""Filesystem marked 'clean'""\\033[0;39m"

else
echo -e "\\033[1;31m"":Ooops: ""\\033[0;31m""Fs not clean.""\\033[0;39m"
[ -n "$FSCK" ] && echo -e "\\033[0;32m"'Reaching the max mount intervals also marks the fs "not clean" .'"\\033[0;39m"
[ "$FSTYPE" = "ext2" ]  && echo -e "\\033[1;34m""Note : ext2 fs is getting marked 'unclean' very easily . Better use ext3 or ext4""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m""$RETFSCK" | head -n 1
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m""$RETFSCK" | tail -n 1
echo -e "\\033[0;34m""Looking for other useable installations ..."
fi

echo -e "\\033[0;39m"
}

_do_FSCK_RO(){
RO_ERR=1
while [ "$RO_ERR" != '0' ];do
 if [ -n "`busybox mount | grep -m1 '^/dev/root ' | cut -f 6 -d ' ' | grep -w 'rw'`" ];then
 busybox mount $VERB $VERB -o remount,ro /dev/root /
      RO_ERR=$?
 sleep 2s
 count_=$((count_+1)); [ "$count_" = 9 ] && break
 else RO_ERR=0
 fi
done

_do_FSCK "/dev/$PDEV1"

busybox mount $VERB $VERB -o remount,rw /dev/root /  ##TODO 2011-10-28 move further down
if [ -n "$iamCLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq 0 ] ; then
echo -e "\\033[1;34m""Booting installation ..."
echo -e "\\033[0;39m"
[ "$ErrFlag" ] && rm "$ErrFlag"
[ "$DebugVal" = "2" ] && _askto_CONTINUE
_do_BUSYBOX_INIT
fi
}
########### FSCK ###########


########### UDEV ###########
##+++2012-01-29
_kill_daemons(){
echo -en "\\033[0;31m"
pidof pup_event_backend_modprobe_protect >$OUT && {
    pup_event_backend_modprobe_protect --stop     && sleep 1
    killall -9 pup_event_backend_modprobe_protect 1>$OUT 2>$ERR; }
pidof udevd >$OUT               && killall -9 udevd               1>$OUT 2>$ERR
pidof pup_event_backend_d >$OUT && killall -9 pup_event_backend_d 1>$OUT 2>$ERR
_sync
echo -e "\\033[0;39m"
}
##+++2012-01-29
########### UDEV ###########


###########
_fsck_INTRO
###########


########### MODULES ##########
_stub_failsafe
[ "$safeBoot" ] || safeBoot=256

_do_HOTPLUG
_add_MODULES
_do_BLOCK_DEVICES

_load_USB_DRIVERS
_load_INPUT_DRIVERS

_load_FB_DRIVERS
_load_FBCON

#kill_daemons
########### MODULES ##########


###########
_ask_DEBUG
###########
_kill_daemons
###########

case $DEV1FS in
 ext2|ext3|ext4)

#UPDATEdevCOUNT=0

#UDEVD_FUNC
#MODULES_ADD_FUNC
#UPDATINGDEV_FUNC

#load_INPUT_DRIVERS_FUNC

#FBCON_FUNC  ###COMMENT if required ; fbcon makes colors little greyish  ###KRG
#sleep 5s  ###DBG

#ASK_DEBUG_FUNC

[ -z "$FSCK" ] && _do_FSCK_RO


############## CHECK ALTERNATE PARTITION ############

CHECK_FOR_ALT_PART_FUNC(){
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'$ROOTDRIVE='"\\033[0;39m""$ROOTDRIVE"
DRIVES=''
DRIV=`cat /proc/partitions | grep '^ ' | grep -vE 'loop|ram|md|mtd|nbd' | sed 's#^ *##' | tr -s ' ' | cut -f 4 -d ' ' | cut -b 1-3 | uniq`
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Attached drives : '"\\033[0;39m"$DRIV
for i in $DRIV ; do
FDISK=`LC_ALL=C fdisk -l /dev/$i | grep -i 'linux' | grep -v -i -E 'swap|Partition' | cut -f 1 -d ' '`
DRIVES=`echo -e "$DRIVES\n""$FDISK"`
done
DRIVES=`echo "$DRIVES" | sed '/^$/d' | grep -v "$DEVROOTDRIVE" | tr '\n' ' '`
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Other partitions : '"\\033[0;39m""$DRIVES"
[ -z "`echo $DRIVES | grep '[[:alpha:]]'`" ] && DRIVES=''
if [ -z "$DRIVES" ] ; then
DRIVES=`cat /proc/partitions | grep '^ ' | grep '[0-9]$' | sed 's#^ *##' | tr -s ' ' | cut -f 4 -d ' '`
DRIVES=`echo "$DRIVES" | grep -v "$PDEV1" | sed 's#^#/dev/#g' | tr '\n' ' '`
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'DRIVES: '"$DRIVES""\\033[0;39m"
fi
if [ -z "$DRIVES" ] ; then
ERRMSG="Could not find any useable drives in /proc/partitions"
_dropto_SIMPLE_CONSOLE
fi
}
############## CHECK ALTERNATE PARTITION ############


############## CHECK ALTERNATE pup-xyz.sfs REPOSITORY ###########

CHECK_ALTERNATE_REPO_FUNC(){

#----------------- CHECK GLIBC --------------#
CURR_GLIBC_FUNC(){
#CURRGLIBC=`basename $(find /lib -maxdepth 1 -name "libc-*.so")`
CURRGLIBC=`basename $(readlink -f /lib/libc.so.6)`  ##+-+2012-10-14
CURRCLMAJ=`echo "$CURRGLIBC" | cut -f 2 -d ' ' | cut -f 2 -d '.'`
CURRCLMin=`echo "$CURRGLIBC" | cut -f 2 -d ' ' | cut -f 3 -d '.'`
}
#----------------- CHECK GLIBC --------------#

if [ -z "$iamCLEAN" ] ; then  #0
if [ -n "$Err" ] && [ "$Err" -ne 0 ] ; then #1

#----------------- FIND SFS --------------#
FIND_SFS_FUNC(){

CHECK_FOR_ALT_PART_FUNC  #TODO simplfy ?
CURR_GLIBC_FUNC

[ -z "`lsmod | grep 'squashfs'`" ] && modprobe squashfs
for oneDRV in $DRIVES ; do  ##for 0
#SIMPLEDRIVENAME=`basename $oneDRV`
SIMPLEDRIVENAME="${oneDRV##*/}"
mkdir -p /mnt/$SIMPLEDRIVENAME
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting '"\\033[0;39m"$oneDRV' on '"\\033[0;39m"/mnt/$SIMPLEDRIVENAME
busybox mount $VERB $VERB -o ro $oneDRV /mnt/$SIMPLEDRIVENAME
SFS=`find /mnt/$SIMPLEDRIVENAME -maxdepth 3 -type f -name "*.sfs" | grep -i -E 'dpup|luci|luma|lupu|spup|upup|zpup|puppy|qret|qrky|wary|pup\-' | grep -v -E -e 'devx|\+mnt\+|z[a-z][0-9]*|zdrv'`
if [ -z "$SFS" ] ; then  ##if 99
echo  -e "\\033[0;33m"'No puppy.sfs found on '"\\033[0;39m"$oneDRV
sleep 1s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Unmounting again '"\\033[0;39m"$oneDRV
busybox umount $VERB $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
continue  ##for 0
else  ##if 99
for oneSFS in $SFS ; do ##for 1
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m"'Found '"\\033[0;35m"$oneSFS"\\033[0;39m"
#bneSFS=`basename $oneSFS`
bneSFS="${oneSFS##*/}"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting now '"\\033[0;39m""$oneSFS /mnt/$bneSFS"
mkdir -p /mnt/$bneSFS
mount-FULL -o loop $oneSFS /mnt/$bneSFS
Err=$?
sleep 1s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting returned error value='"\\033[1;34m""$Err""\\033[0;39m"
if [ "$Err" -eq 0 ] ; then ##100
if [ "$DebugVal" = "0" ] ; then
#REPOGLIBC=`basename $(find /mnt/$bneSFS/lib -maxdepth 1 -name "libc-*.so") 2>/dev/null`
REPOGLIBC=`basename $(readlink -f /mnt/$bneSFS/lib/libc.so.6) 2>/dev/null`
else
#REPOGLIBC=`basename $(find /mnt/$bneSFS/lib -maxdepth 1 -name "libc-*.so")`
REPOGLIBC=`basename $(readlink -f /mnt/$bneSFS/lib/libc.so.6)`
fi
REPOCLMAJ=`echo "$REPOGLIBC" | cut -f 2 -d '.'`
REPOCLMin=`echo "$REPOGLIBC" | cut -f 3 -d '.'`
if [ -z "$REPOGLIBC" ] ; then ##101
echo -e "\\033[0;31m"'No libc found in '"\\033[0;39m""$bneSFS"
busybox umount $VERB $VERB -lrd /mnt/$bneSFS
sleep 1s
rmdir /mnt/$bneSFS
FOUND=''
continue
else ##101
if [ "$REPOCLMAJ" -gt "$CURRCLMAJ" ] ; then #102
echo -e "\\033[0;31m""Major of libc in $bneSFS = '$REPOCLMAJ' and larger than actual '$CURRCLMAJ'""\\033[0;39m"
busybox umount $VERB $VERB -lrd /mnt/$bneSFS
sleep 1s
rmdir /mnt/$bneSFS
FOUND=''
continue
elif [ "$REPOCLMAJ" -eq "$CURRCLMAJ" ] && [ "$REPOCLMin" -gt "$CURRCLMin" ] ; then #102
echo -e "\\033[0;31m""Minor of libc in $bneSFS = '$REPOCLMin' and larger than actual '$CURRCLMin'""\\033[0;39m"
busybox umount $VERB $VERB -lrd /mnt/$bneSFS
sleep 1s
rmdir /mnt/$bneSFS
FOUND=''
continue
else #102
echo -e "\\033[0;32m""Found '$REPOGLIBC' and should match '$CURRGLIBC'""\\033[0;39m"
FOUND='1'
break ##for 1
fi #102
fi #101
else #100
Err=99999
echo -e "\\033[0;31m""Mounting $oneSFS failed""\\033[0;39m"
busybox umount $VERB $VERB -lrd /mnt/$bneSFS
sleep 1s
rmdir /mnt/$bneSFS
FOUND=''
continue
fi #100
done  ##for 1
fi  ##if 99
[ -n "$FOUND" -a "$Err" -eq 0 ] && break
done  ##for 0
echo -e "\\033[0;39m"
[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;31m"'$oneDRV='"\\033[0;39m""$oneDRV ""\\033[0;31m"'oneSFS='"\\033[0;39m""$oneSFS"
MOUNTLOOP=`busybox mount | grep -E "$oneDRV|$bneSFS" | cut -f 1 -d ' ' | tr ' ' '|'`
MOUNT=`busybox mount | grep -v -E "$MOUNTLOOP|$DEVROOTDRIVE" | grep '^/dev/' | grep -v -E  'initrd|none|*tmpfs|root|unionfs|aufs' | cut -f 1 -d ' '`
[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;31m""$MOUNTLOOP : $MOUNT :""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && busybox mount
for m in $MOUNT ; do
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Unmounting again '"\\033[0;39m"$m
busybox umount $VERB $VERB -lrd $m
sleep 1s
rmdir /mnt/`basename $m`
done
[ "$DebugVal" -ge "1" ] && [ -n "$MOUNT" ] && { busybox mount;echo -e "\\033[0;39m"; }
sleep $((SLEEP*3))s
if [ -n "`busybox mount | grep "/mnt/$bneSFS"`" ] ; then #103
REPO="/mnt/$bneSFS"
#REPOSFS=`basename $REPO`
REPOSFS="${REPO##*/}"
REPOPART="$oneDRV"
echo -e "\\033[0;39m"
echo -e "\\033[0;32m"'Repository to use : '"\\033[1;32m""$REPOSFS""\\033[0;32m"' on '"\\033[1;32m""$REPOPART"
echo -e "\\033[0;39m"
sleep $((SLEEP*2))s
else  #103
echo -e "\\033[0;39m"
echo -e "\\033[0;31m""No suitable puppy.sfs found""\\033[0;39m"
echo "Trying for Puppy full installations ...."
echo -e "\\033[0;39m"
sleep $((SLEEP*2))s
REPO=''
fi #103
}
FIND_SFS_FUNC
#----------------- FIND SFS ---------------#

#----------------- FIND FULL --------------#

FIND_FULLINSTALL_FUNC(){

CHECK_FOR_ALT_PART_FUNC
CURR_GLIBC_FUNC

for oneDRV in $DRIVES ; do ##for 0
#SIMPLEDRIVENAME=`basename $oneDRV`
SIMPLEDRIVENAME="${oneDRV##*/}"
mkdir -p /mnt/$SIMPLEDRIVENAME
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'Mounting '"\\033[0;39m""$oneDRV""\\033[0;33m"' on '"\\033[0;39m""/mnt/$SIMPLEDRIVENAME""\\033[0;39m"
busybox mount $VERB $VERB -o rw $oneDRV /mnt/$SIMPLEDRIVENAME
DS=
[ -d /mnt/$SIMPLEDRIVENAME/etc ] && DS=`find /mnt/$SIMPLEDRIVENAME/etc -maxdepth 2 -name "DISTRO_SPECS"`
sleep 2s
if [ -n "$DS" ] ; then  ##3
if [ -f "$DS" ] ; then  ##4
source $DS
if [ -n "$DISTRO_NAME" ] && [ -n "$DISTRO_VERSION" ] ; then  ##4.1
echo -e "\\033[1;32m""Found $DISTRO_NAME $DISTRO_VERSION"
#REPOGLIBC=`basename $(find /mnt/$SIMPLEDRIVENAME/lib -maxdepth 1 -name "libc-*.so")`
REPOGLIBC=`basename $(readlink -f /mnt/$SIMPLEDRIVENAME/lib/libc.so.6)`
REPOCLMAJ=`echo "$REPOGLIBC" | cut -f 2 -d '-' | cut -f 2 -d '.'`
REPOCLMin=`echo "$REPOGLIBC" | cut -f 2 -d '-' | cut -f 3 -d '.'`
if [ -n "$REPOGLIBC" ] ; then #4.1.1
if [ "$REPOCLMAJ" -gt "$CURRCLMAJ" ] ; then ##4.2
echo -e "\\033[0;31m""LIBC major = '$REPOCLMAJ' larger than '$CURRCLMAJ'""\\033[0;39m"
busybox umount $VERB $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
continue
elif [ "$REPOCLMAJ" -eq "$CURRCLMAJ" ] && [ "$REPOCLMin" -gt "$CURRCLMin" ] ; then ##4.2
echo -e "\\033[0;31m""LIBC minor = '$REPOCLMin' larger than '$CURRCLMin'""\\033[0;39m"
busybox umount $VERB $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
continue
else ##4.2
echo -e "\\033[0;32m""Found '$REPOGLIBC' and should match '$CURRGLIBC'""\\033[0;39m"
echo -e "\\033[1;34m""Fscking $oneDRV just in case ....""\\033[0;39m"
busybox umount $VERB $VERB -lr $oneDRV
sleep 2s
fi ##4.2
_do_FSCK "$oneDRV" "other_full_installs"
if [ -n "$iamCLEAN" ] || [ -z "$Err" ] || [ "$Err" -eq "0" ] ; then  ##5
echo -e "\\033[0;32m"'OK ,'"\\033[1;32m"" using REPO /mnt/$SIMPLEDRIVENAME""\\033[0;39m"
echo
busybox mount $VERB $VERB -o rw $oneDRV /mnt/$SIMPLEDRIVENAME
sleep 1s
REPO="/mnt/$SIMPLEDRIVENAME"
break
else  ##5
echo
echo -e "\\033[1;31m""No ,""\\033[0;31m"" $oneDRV seems to be not clean , too""\\033[0;39m"
echo "Trying next if possible ...."
echo
REPO=''
[ -n "`busybox mount | grep "$oneDRV"`" ] && busybox umount -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
fi  ##5
else
echo -e "\\033[0;31m"'No GLIBC found on '"\\033[0;39m"$oneDRV
busybox umount $VERB $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
continue
fi  ##4.1.1
else ##4.1
echo -e "\\033[1;31m"'No , $DISTRO_NAME or $DISTRO_VERSION not available'"\\033[0;39m"
echo 'Trying next if possible ....'
busybox umount $VERb $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
fi  ##4.1
fi  ##4
else #3
echo -e "\\033[0;33m"'Apparently no Puppy Linux full installation on '"\\033[0;39m""$oneDRV"
busybox umount $VERB $VERB -lr $oneDRV
sleep 1s
rmdir /mnt/$SIMPLEDRIVENAME
fi  ##3
done  ##for 0
}
[ -z "$REPO" ] && FIND_FULLINSTALL_FUNC
#----------------- FIND FULL --------------#

#----------------- IF NO OTHER REPOSITORY --------------#

NO_REPO_DIALOG_FUNC(){
if [ -z "$REPO" ] ; then  #6
echo
echo -e "\\033[1;31m""No alternative useable repositories found .""\\033[0;39m"
echo "You can continuing using files of full installation ."
echo "Hopefully none are corrupted ."
echo
echo -e "\\033[0;31m""Type [ r ] or [ R ] to reboot"
echo -e "\\033[1;32m""Type [ c ] or [ k ] for dropout into console"
echo -e "\\033[0;32m""Else any other key and or simply [ Enter ] to continue"
echo -e "\\033[0;39m"
read -t $TimeOut K
echo
Key=`echo "$K" | tr '[A-Z]' '[a-z]'`
if [ "$Key" = "c" -o "$Key" = "k" ] ; then #7
echo 'dropping to console now , partition still mounted !'
cd /
sleep 2
exec chroot . sh
elif [ "$Key" = "r" ] ; then  #7
echo "Please do an 'e2fsck $DEVROOTDRIVE' "
echo "via console/terminal using a LiveCd ."
echo "You may need to boot it with 'puppy pfix=ram' ."
echo "Remember , the timeout is 5 sec to press 'F2' ."
echo "Rebooting now in 25 seconds"
sleep 22s
[ "$DebugVal" = "0" ]   && busybox umount -a -r 2>$ERR
[ "$DebugVal" -ge "1" ] && busybox umount -a -r
[ "$DebugVal" -ge "1" ] && sleep 10s
sleep 2s
exec busybox reboot -f
else #7
echo -e "\\033[0;33m""Ok ... continuing ...""\\033[0;39m"
REPO=''
fi  ##7
fi  ##6
}
NO_REPO_DIALOG_FUNC
#----------------- IF NO OTHER REPOSITORY --------------#

fi  ##1
fi  #0
sleep $((SLEEP*5))s  ###KRG
[ "$DebugVal" = "2" ] && _askto_CONTINUE
}
CHECK_ALTERNATE_REPO_FUNC

[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'$REPO='"\\033[0;39m""$REPO"

[ -z "`busybox mount | grep -Fw '/' | grep -w 'rw'`" ] && busybox mount -o remount,rw /dev/root /  ##-+2012-05-09 was grep '(rw)'
############## CHECK ALTERNATE pup-xyz.sfs REPOSITORY ###########


############## CHECK DEVICE NODES ###############################
CHECK_DEV_NODES_FUNC(){
ROOTDRIVE=`basename $(busybox rdev | cut -f 1 -d ' ')`  ### | cut -f 1 -d ' ' | sed 's#/dev/##'`
ROOTBLOCKDRIVE=${ROOTDRIVE:0:3}
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'rootdrive='"\\033[0;39m""$ROOTDRIVE\n"  ###DBG
FS=`mount | grep -Fw '/' | grep '/dev' | tr -s ' ' | cut -f 5 -d ' ' |tr -d \'\"`
PDEV1="$ROOTDRIVE"
DEV1FS="$FS"
[ "$DebugVal" -eq "2" ] && echo -e "\\033[0;33m""$ROOTDRIVE $ROOTBLOCKDRIVE $FS "','" $PDEV1 $DEV1FS"
DMESG=`dmesg | grep 'Mounted root' | grep -o 'device.*' | cut -f 2 -d ' ' | sed 's#[[:alpha:][:punct:]]$##`
MAJ=`echo $DMESG | cut -f 1 -d ':'`
Min=`echo $DMESG | cut -f 2 -d ':'`
CATPP=`cat /proc/partitions | sed 's#^[a-zA-Z].*##g ; s#^[[:blank:]][a-zA-Z]##g ; /^$/d' | tr -s ' ' | sed 's#^ ##'`
MAJBL=`echo "$CATPP" | grep -w "$ROOTBLOCKDRIVE" | cut -f 1 -d ' '`
MinBL=`echo "$CATPP" | grep -w "$ROOTBLOCKDRIVE" | cut -f 2 -d ' '`
[ "$DebugVal" -eq "2" ] && { echo -e $CATPP"\n$DMESG $MAJ $Min "','" $MAJBL $MinBL "',';echo -e "\\033[0;39m"; }
}
[ "$DebugVal" -ge "1" ] && CHECK_DEV_NODES_FUNC
############## CHECK DEVICE NODES ###############################


############## CHECK AVAILABLE RAM ###############################

CHECK_SPACE_FUNC(){
echo -e "\\033[1;34m"'Freeing ram ...'"\\033[0;39m"
[ "$DebugVal" -ge "1" ] && { echo -e "\\033[0;36m";free;echo -e "\\033[0;39m"; }
sleep $((SLEEP*2))s
echo 3 > /proc/sys/vm/drop_caches  ###KRG , thanks to Bruce B ;see http://www.murga-linux.com/puppy/viewtopic.php?t=33219
[ "$DebugVal" -ge "1" ] && { echo -e "\\033[0;35m";free;echo -e "\\033[0;39m"; }
sleep $((SLEEP*4))s  ###KRG
if [ "`ls -l /dev/ram8 | cut -b 1-3`" != 'brw' -o "`ls -l /dev/ram8 | cut -f 5,6 -d ' '`" != '1, 8' ] ; then
rm -f /dev/ram8
mknod /dev/ram8 b 1 8
fi
echo -e "\\033[1;34m"'Checking for Compiled RamDisk Size using:'"\\033[0;39m"
MAXSIZEdevRAM1=`mkfs.ext2 -v -b 1024 -i 1024 /dev/ram8 | grep 'blocks' | grep 'inodes' | tr -s ' ' | cut -f 3 -d ' '`
SIZEdevRAMdisk1=$(($MAXSIZEdevRAM1 * 93 / 100))  ###KRG 0.93 is precaution
echo -e "\\033[1;33m"'Compiled-in RAMDisk Size='"\\033[0;39m""$SIZEdevRAMdisk1""\\033[0;39m"
echo -e "\\033[0;39m"
KERNV=`uname -r`
echo -e "\\033[1;34m""Checking Size of $REPO/lib/lib*.so* and $REPO/lib/ld*.so* ..."
echo -e "\\033[0;39m"
SPACElib=0
LLS=`ls -l "$REPO"/lib/* | grep -o '/lib/.*\->.*' | grep 'firefox' | cut -f 1 -d ' '`
[ -z "$LLS" ] && LLS="No_firefox_libs_in_lib"
[ "$DebugVal" -ge "2" ] && echo -e "\\033[0;31m"'firefox-libs: '$LLS"\n"
LF=`find "$REPO"/lib -maxdepth 1 \( -name "lib*.so*" -o -name "ld*.so*" \)`
LIBF=`echo "$LF" | grep -v "$LLS" | grep -v -E 'libuClibc.*|ld\-uClibc.*|libthread.*|libm\-0.*|libm\.so\.0' | sort`
for i in $LIBF ; do
#SiZElib=`ls -s $i | cut -f 1 -d ' '`
SiZElib=`ls -s $i | awk '{print $1}'`
SPACElib=$((SPACElib + SiZElib))
[ "$DebugVal" = "2" ] && echo -n -e "\\033[0;39m""$i"'='"\\033[0;31m""$SiZElib "  ###DBG
[ "$DebugVal" = "1" -a "$SiZElib" -ne "0" ] && echo -n -e "\\033[0;39m""$i"'='"\\033[0;33m""$SiZElib "
done
[ "$DebugVal" = "2" ]   && echo -e "\n"'total /lib='"$SPACElib"  ###DBG
[ "$DebugVal" -ge "1" ] && echo -e "\n\\033[0;39m"
echo -e "\\033[1;34m"'Checking for available RAM ...'
echo -e "\\033[0;39m"
RAM=`free | grep -i 'mem' | sed 's#^[[:blank:]]*##' | tr -s ' ' | cut -f 2 -d ' '`
FREERAM=`free | grep -i 'mem' | sed 's#^[[:blank:]]*##' | tr -s ' ' | cut -f 4 -d ' '`
RAMLIMITdevRAM2=$(($MAXSIZEdevRAM1 * 2))
echo '                  free counted total RAM:'"$RAM"  ###DBG
echo 'Available RAM (minus Kernel and modules):'"$FREERAM"  ###DBG
echo '     Minimum available free RAM required:'"$RAMLIMITdevRAM2"' ... '  ###DBG
if [ "$SPACElib" -gt "$SIZEdevRAMdisk1" -o "$RAMLIMITdevRAM2" -ge "$FREERAM" ] ; then  #1
echo
echo ";)"
echo -e "\\033[1;31m"
if [ "$RAMLIMITdevRAM2" -ge "$FREERAM" ] ; then                         #1.1
echo "Needed free RAM is '$RAMLIMITdevRAM2' , but free RAM is '$FREERAM'"
else                                                                    #1.1
echo "/lib/lib*.so* is '$SPACElib in KB' and larger than the RamDisk compiled for"
echo -e "\\033[1;32m"
echo "kernel '$KERNV' with '$SIZEevRAMdisk1 / $MAXSIZEevRAM1 in KB'"
fi  #1.1
echo -e "\\033[0;39m"
echo -e "\\033[1;31m"
echo 'fsck omitted !!!'
echo -e "\\033[1;32m"
echo 'please do the filesystemcheck via Live CD'
echo -e "\\033[1;33m"
echo 'or booting another Puppy or Linux'
echo -e "\\033[1;36m"
echo "type 'busybox reboot -f' to reboot"
echo 'eventually you need to press CTRL+ALT+DELETE to reboot'
echo 'you may need to check BIOS bootorder also before booting LiveCD'
echo 'do not forget to unmount everything first !'
echo -e "\\033[0;39m"
echo
echo 'dropping to console now , partition still mounted !'
cd /
busybox mount $VERB $VERB -o remount,ro /dev/root /
sleep $((SLEEP*2))s
exec chroot . sh
fi  #1
NRAM=$(( $RAM - $FREERAM + $RAMLIMITdevRAM2 ))
NEEDRAM=`echo "$NRAM" | sed -r 's/(.)/ \1/g' | rev | tr ' ' '\n' | sed -r '4 i\,' | sed -r '8 i\,' | tr -d '\n' | rev | sed 's#^,##'`
FORMRAM=`echo "$RAM" | sed -r 's/(.)/ \1/g' | rev | tr ' ' '\n' | sed -r '4 i\,' | sed -r '8 i\,' | tr -d '\n' | rev | sed 's#^,##'`
echo -e "\\033[1;32m"
echo -e "\\033[18G"'... OK : '"\\033[0;39m"$NEEDRAM"\\033[1;32m"' required of '"\\033[0;39m"$FORMRAM
echo -e "\\033[0;39m"
sleep $((SLEEP*5))s
}
CHECK_SPACE_FUNC
############## CHECK AVAILABLE RAM ###############################


[ "$DebugVal" = "2" ] && _askto_CONTINUE


############## RAMDISKS ###########################################
  echo -e "\\033[0;35m"'Creating a ramdisk and populating with a Linux environment...'"\\033[0;39m"
CHECK_RAM0_FUNC(){
  if [ ! -b /dev/ram0 -o "`ls -l /dev/ram0 | cut -b 1-3`" != "brw" -o "`ls -l /dev/ram0 | cut -f 5,6 -d ' '`" != "1, 0" ]; then  ###KRG
  echo  -e "\\033[1;31m"'block /dev/ram0 does not exist'"\\033[0;39m"
  rm -f /dev/ram0
  echo -e "\\033[0;39m"'creating now'"\\033[0;39m"
  mknod /dev/ram0 b 1 0
  fi
}
CHECK_RAM0_FUNC
mkfs.ext2 $Q -m 5 -b 1024 -i 1024 /dev/ram0
MAKE_RAM9_FUNC(){
  [ ! -b /dev/ram9 -o "`ls -l /dev/ram9 | cut -b 1-3`" != "brw" -o "`ls -l /dev/ram9 | cut -f 5,6 -d ' '`" != "1, 9" ] && { rm -f /dev/ram9;mknod /dev/ram9 b 1 9; }  ###KRG
  mkfs.ext2 $Q -m 5 -b 1024 -i 1024 /dev/ram9
  sleep $((SLEEP*2))s
}
MAKE_RAM9_FUNC
############## RAMDISKS ###########################################


#--------- FOLDERS -------------#
  mkdir -p /mnt/ram0
  mkdir -p /mnt/ram9  ###KRG
  busybox mount $VERB $VERB -t ext2 /dev/ram0 /mnt/ram0
  busybox mount $VERB $VERB -t ext2 /dev/ram9 /mnt/ram9  ###KRG
  sleep $((SLEEP*2))s  ###KRG
  mkdir -p /mnt/ram0/old_root
  mkdir /mnt/ram0/bin
#--------- FOLDERS -------------#

#--------- BUSYBOX -------------#
BUSYBOX_FUNC(){
  echo
  echo -n -e "\\033[1;34m""Checking if $REPO/bin/busybox is a link to 'MyBusybox' : ""\\033[0;39m"
  RLF=`readlink -f "$REPO"/bin/busybox`  ## | sed "s%^$REPO%%"`
  LSLBB=`ls -l "$REPO"/bin/busybox | grep -o '\->.*'`  ###KRG if busybox is a symlink to busybox-version
  if test "$LSLBB" != "" ; then
  echo -e "\\033[1;32m"'YES'"\\033[0;39m"
  echo -e "\\033[0;39m"'Copying '"$RLF"' into RamDisk'"\\033[0;39m"
  #RLBB=`basename "$RLF"`
  RLBB="${RLF##*/}"
  cp $VERB -a "$REPO"/bin/"$RLBB" /mnt/ram0/bin/"$RLBB"
  else
  echo -e "\\033[0;32m"'No'
  fi
  echo -e "\\033[0;39m"
}
BUSYBOX_FUNC
#--------- BUSYBOX -------------#


#--------- FILES ---------------#
#--------- BIN -----------------#
  echo -e "\\033[1;34m""Populating /mnt/ram0/bin  ...""\\033[0;39m"
  [ "$DebugVal" = "2" ] && echo -e -n "\\033[0;31m"'/mnt/ram0/bin/'"\\033[0;39m"
  for ONEBIN in "[" "[[" ash autologinroot basename busybox cat chmod chown clear cp cut date dc dd df dirname dmesg du e3 ed expr false find free grep head kill ln login ls lsmod mkdir mknod more mv nice ntfs-3g pidof pwd readlink rev rm rmdir sed sleep sort stat su sync tail tar touch tr true uname usleep waitmax wc which xargs
  do  ###KRG added e3
  if [ -x $REPO/bin/$ONEBIN ] ; then
  BINDIR='/bin'
  elif [ -x $REPO/usr/bin/$ONEBIN ] ; then
  BINDIR='/usr/bin'
  else
  continue
  fi
  RLF=`readlink -f "$REPO""$BINDIR"/"$ONEBIN" | grep -v 'busybox' | sed "s%^$REPO%%"`
  LSLBIN=`ls -l "$REPO""$BINDIR"/"$ONEBIN" | grep -o '\->.*' | grep -v 'busybox'`
  if [ -n "$LSLBIN" ] ; then
  [ "$DebugVal" = "1" ] && echo -n -e "\\033[0;33m"" Link $ONEBIN""\\033[0;39m"
  NEWBIN=`echo "$RLF" | sed 's#/usr## ; s#/local##'`
  [ "$DebugVal" = "2" ] && echo -n -e "\\033[0;31m"' Link '"\\033[0;39m""${REPO}${BINDIR}/$ONEBIN ""\\033[0;31m"', '"\\033[0;39m"
  [ "$DebugVal" = "2" ] && echo -n -e "\\033[0;31m"' LinkTarget '"\\033[0;39m""${REPO}${RLF} ""\\033[0;31m"', '"\\033[0;39m"
  [ -x /mnt/ram0/${NEWBIN} ]   || cp $VERB -a ${REPO}${RLF} /mnt/ram0/${NEWBIN}
  [ -x /mnt/ram0/bin/$ONEBIN ] || cp $VERB -a ${REPO}${BINDIR}/$ONEBIN /mnt/ram0/bin/$ONEBIN
  else
   if [ -x ${REPO}${BINDIR}/$ONEBIN ] && [ ! -x /mnt/ram0/bin/$ONEBIN ] ;then  ###KRG for symlink busybox
    cp $VERB -a ${REPO}${BINDIR}/$ONEBIN /mnt/ram0/bin/
    [ "$DebugVal" = "2" ] && echo -e -n "$ONEBIN ""\\033[0;31m"', '"\\033[0;39m"
   else
    if [ "$ONEBIN" != "busybox" -a "`busybox | grep $ONEBIN`" != "" ] ; then  ###KRG
    [ "$DebugVal" = "2" ] && echo -e -n 'link '"$ONEBIN ""\\033[0;31m"', '"\\033[0;39m"
    ln $VERB -s busybox /mnt/ram0/bin/$ONEBIN
    fi
   fi
  fi
  done
  ln $VERB -snf busybox /mnt/ram0/bin/ps
  [ "$DebugVal" = "2" ]   && echo -n -e 'link ps '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf busybox /mnt/ram0/bin/rdev
  [ "$DebugVal" = "2" ]   && echo -n -e 'link rdev '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf busybox /mnt/ram0/bin/sh
  [ "$DebugVal" = "2" ]   && echo -n -e 'link sh '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf busybox /mnt/ram0/bin/mount
  [ "$DebugVal" = "2" ]   && echo -n -e 'link mount '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf busybox /mnt/ram0/bin/umount
  [ "$DebugVal" = "2" ]   && echo -n 'link umount '
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m\n"
#--------- BIN -----------------#

#--------- SBIN ----------------#
  echo -e "\\033[1;34m""Populating /mnt/ram0/sbin ...""\\033[0;39m"
  [ "$DebugVal" = "2" ] && echo -e -n "\\033[0;31m"'/mnt/ram0/sbin/'"\\033[0;39m"
  mkdir /mnt/ram0/sbin
  for ONEBIN in depmod dumpe2fs e2fsck elspci fdisk freeramdisk fsck.ext2 fsck.ext3 fsck.ext4 getty guess_fstype halt hdparm hotplug2stdout hotplug2stdout_notimeout hwclock ifconfig ifplugstatus insmod klogd ldconfig loadkmap losetup lsmod mount.ntfs-3g pivot_root probedisk probedisk2 probepart swapon
  do
  if [ -x $REPO/sbin/$ONEBIN ] ; then
  BINDIR='/sbin'
  elif [ -x $REPO/usr/sbin/$ONEBIN ] ; then
  BINDIR='/usr/sbin'
  else
  continue
  fi
  RLF=`readlink -f "$REPO""$BINDIR"/"$ONEBIN" | grep -v 'busybox' | sed "s%^$REPO%%"`
  LSLSBIN=`ls -l "$REPO""$BINDIR"/"$ONEBIN" | grep -o '\->.*' | grep -v 'busybox'`
   if [ -n "$LSLSBIN" ] ; then
   [ "$DebugVal" = "1" ] && echo -n -e "\\033[0;33m"" Link $ONEBIN ""\\033[0;39m"
   NEWBIN=`echo "$RLF" | sed 's#/usr## ; s#/local##'`
   [ "$DebugVal" = "2" ] && echo -n -e "\\033[0;31m"' Link '"\\033[0;39m""${REPO}${BINDIR}/$ONEBIN ""\\033[0;31m"', '"\\033[0;39m"
   [ "$DebugVal" = "2" ] && echo -n -e "\\033[0;31m"' LinkTarget '"\\033[0;39m""${REPO}${RLF} ""\\033[0;31m"', '"\\033[0;39m"
   [ -x /mnt/ram0/sbin/$ONEBIN ] || cp $VERB -a ${REPO}${BINDIR}/"$ONEBIN" /mnt/ram0/sbin/"$ONEBIN"
   [ -x /mnt/ram0/${NEWBIN} ]    || cp $VERB -a ${REPO}${RLF} /mnt/ram0/${NEWBIN}
   else
   if [ -x ${REPO}${BINDIR}/$ONEBIN ];then  ###KRG -x for -e
    cp $VERB -a ${REPO}${BINDIR}/$ONEBIN /mnt/ram0/sbin/
    [ "$DebugVal" = "2" ] && echo -e -n "$ONEBIN "
    [ "$DebugVal" = "2" ] && [ "$ONEBIN" != "swapon" ] && echo -e -n "\\033[0;31m"', '"\\033[0;39m"
   else
    if test "`busybox | grep $ONEBIN`" != "" ; then  ###KRG
    ln $VERB -s ../bin/busybox /mnt/ram0/sbin/$ONEBIN
    [ "$DebugVal" = "2" ] && echo -e -n 'link '"$ONEBIN "
    [ "$DebugVal" = "2" ] && [ "$ONEBIN" != "swapon" ] && echo -e -n "\\033[0;31m"', '"\\033[0;39m"
    fi
   fi
  fi
  done
PRESERVE_CHROOT_FUNC(){
  CHROOT=`which chroot | grep '^/sbin/`
  if [ -n "$CHROOT" ] && [ ! -L "$CHROOT" ] && [ -x "$CHROOT" ] ; then
  echo "$CHROOT is no link but executable ,
creating backup of $CHROOT.bac
Please restore manually for now"
  mv $VERB $CHROOT "$CHROOT.bac"
  fi
}
PRESERVE_CHROOT_FUNC
  ln $VERB -snf ../bin/busybox /sbin/chroot #must match
  [ "$DebugVal" = "2" ]   && echo -n -e 'link chroot '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf ../bin/busybox /mnt/ram0/sbin/chroot #must match
  [ "$DebugVal" = "2" ]   && echo -n -e 'link chroot '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf ../bin/busybox /mnt/ram0/sbin/init
  [ "$DebugVal" = "2" ]   && echo -n -e 'link init '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf ../bin/busybox /mnt/ram0/sbin/poweroff
  [ "$DebugVal" = "2" ]   && echo -n -e 'link poweroff '"\\033[0;31m"', '"\\033[0;39m"
  ln $VERB -snf ../bin/busybox /mnt/ram0/sbin/reboot
  [ "$DebugVal" = "2" ]   && echo -n 'link reboot '
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m\n"
#--------- SBIN ----------------#

#--------- ETC -----------------#
  echo -e "\\033[1;34m""Populating /mnt/ram0/etc  ...""\\033[0;39m"
  mkdir /mnt/ram0/etc
  [ "$DebugVal" = "2" ] && echo -n -e "\\033[0;31m"'/mnt/ram0/etc/'"\\033[0;39m"
  for ONEFILE in codepage DISTRO_SPECS eventmanager fdprm floppy fontmap group gshadow host.conf hostname hosts hosts.allow hosts.deny inittab inputrc issue keymap localtime mailcap mime.types mke2fs.conf modprobe.conf modules.conf mtab networks nscd.conf nsswitch.conf passwd printcap protocols services shadow
  do
   [ "$DebugVal" = "0" ]   && cp $VERB -a "$REPO"/etc/$ONEFILE /mnt/ram0/etc/ 2>$ERR
   [ "$DebugVal" = "2" ]   && echo -e -n "$ONEFILE "
   [ "$DebugVal" -ge "1" ] && cp $VERB -a "$REPO"/etc/$ONEFILE /mnt/ram0/etc/
   [ "$DebugVal" = "2" ]   && [ "$ONEFILE" != "shadow" ] && echo -e -n "\\033[0;31m"', '"\\033[0;39m"
  done
   [ "$DebugVal" = "2" ]   && echo -e "\\033[0;39m\n"

  echo "$PDEV1"','"$DEV1FS"',' > /mnt/ram0/etc/fsckme.err  ###KRG

  echo 'DebugVal='"$DebugVal" > /mnt/ram0/etc/initdebug.in  ###KRG
  echo 'TimeOut='"$TimeOut" >> /mnt/ram0/etc/initdebug.in  ###KRG

  echo '/lib' > /mnt/ram0/etc/ld.so.conf

  echo 'export PATH="/bin:/sbin"
export LD_LIBRARY_PATH="/mnt/ram9/lib"
ulimit -c 0
umask 022
export USER=root
export LOGNAME=root
export TERM=linux' > /mnt/ram0/etc/profile

#---------- RC.SYSINIT ------------------#
  mkdir /mnt/ram0/etc/rc.d
  echo '#!/bin/ash
PDEV1=`cat /etc/fsckme.err | cut -f 1 -d ","`  ###KRG
DEV1FS=`cat /etc/fsckme.err | cut -f 2 -d ","`  ###KRG
. /etc/initdebug.in  ###KRG
PATH="/bin:/sbin"
echo -e "\\033[0;32m"
echo "Now running in ramdisk, preparing for filesystem check of ${PDEV1}..."
echo -e "\\033[0;39m"
mkdir -p /proc
if [ -z "`mount | grep -o /proc`" ] ; then
[ "$DebugVal" = "0" ] && mount -t proc none /proc 2>/dev/null  ###KRG added: 2>$ERR  ###KRG
[ "$DebugVal" -ge "1" ] && mount -t proc none /proc
fi
if [ "`readlink /etc/mtab`" != "/proc/mounts" ] ; then ##e2fsck needs it , busybox mount apparently not
[ -f /etc/mtab ] || [ -L /etc/mtab ] && rm /etc/mtab
ln -s ../proc/mounts /etc/mtab
fi
[ "$DebugVal" = "0" ] && hwclock --hctosys --localtime 2>/dev/null
[ "$DebugVal" -ge "1" ] && hwclock --hctosys --localtime
echo "Unmounting the rootdrive ..."   ###KRG
echo
MOR=`mount | grep "/old_root/.*"`
for i in `echo "$MOR" | cut -f 3 -d " " | sort -r` ; do
[ "$DebugVal" = "0" ] && umount $i 2>$ERR || ErrMor=$?  ###KRG
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Unmounting $i ...""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && umount $i || ErrMor=$?
if [ -n "`mount | grep "$i"`" ] ; then
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Failed to unmount $i with error=$ErrMor""\\033[0;39m\n"
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Trying lazy now ...""\\033[0;39m"
umount -l $i || ErrMorl
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""umount -l $i returned errorcode=$ErrMorl""\\033[0;39m"
else
echo -e "\\033[1;32m""$i was unmounted""\\033[0;39m"
fi
done
if [ -n "`mount | grep -o /old_root`" ] ; then  ##1
[ "$DebugVal" = "0" ] && umount /old_root 2>$ERR || Err1=$?
if [ "$DebugVal" -ge "1" ] ; then
umount /old_root || Err1=$?  ###KRG  ##2
echo -e "\\033[0;33m""Unmounting /old_root: error returncode=$Err1 , still mounted :""\\033[0;39m"
mount
echo  ###DBG
fi  ##2
sleep $((SLEEP*2))s
if [ -z "`mount | grep -o /old_root`" ] ; then  ##3
[ -n "$Err1" ] && [ "$Err1" -ne "0" ] && echo -e "\\033[1;32m""/old_root $PEDV1 was unmounted though""\\033[0;39m\n"
else  ##3
echo "Not so good, was unable to unmount ${PDEV1}. trying lazy now..."
sleep $((SLEEP*2))s
umount -l /old_root
Err3=$?
sleep $((SLEEP*1))s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Umount error returnvalue=$Err3""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && { echo -e "\\033[1;33m""Still mounted :""\\033[0;39m";mount;echo; }
fi ##3
if [ -n "$Err3" ] && [ "$Err3" -ne "0" ] ; then  ###KRG  ##5
echo "Not so good, was unable to unmount ${PDEV1}. trying option force ..."
sleep $((SLEEP*2))s
umount -f /old_root
Err5=$?
sleep $((SLEEP*1))s
[ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m""Unmount error returncode=$Err5""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && { echo -e "\\033[1;33m""Still mounted :""\\033[0;39m";mount;echo; }
fi  ##5
[ -n "$Err5" ] && [ "$Err5" -ne "0" ] && echo "Not so good, was unable to unmount ${PDEV1}. Continuing with f.s. check..."
fi  ##1
if [ -z "`mount | grep -o /old_root`" ] ; then
echo -e "\\033[1;32m""OK. /old_root was unmounted successfully .""\\033[0;32m"" Fscking $PDEV1  ...
Depending on size of installation, might take a while""\\033[0;39m"
if [ "$DebugVal" -ge "1" ] ; then
e2fsck -C 0 -v -f /dev/${PDEV1}
else
e2fsck -C 0 -f /dev/${PDEV1}
fi
else
echo -e "\\033[0;31m""Whatever cause ... /old_root or $PDEV1 still mounted!"
echo -e "\\033[0;33m""Performing read-only filesystem check ... ""\\033[0;39m"
[ "$DebugVal" -ge "1" ] && e2fsck -C 0 -n -f -v /dev/${PDEV1}
[ "$DebugVal" = "0" ]   && e2fsck -C 0 -n -f    /dev/${PDEV1}
fi
sync
echo
echo -e "\\033[7;32m"
echo "Filesystem check completed!"
echo -e "\\033[0;39m"
echo -e "\\033[0;32m""Removing [ xwin ] blocking files ..."
echo -e "\\033[0;39m"
mkdir -p /mnt/${PDEV1}  ###KRG removing fsckme.file  ###KRG
mount -t ${DEV1FS} /dev/${PDEV1} /mnt/${PDEV1}
case $? in
0)
ErrFlag=`find /mnt/${PDEV1} -maxdepth 3 -type f -iname "*fsckme*"`
for i in $ErrFlag ; do
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""Removing $i""\\033[0;39m"
rm $i
done
[ -f /mnt/${PDEV1}/etc/.XLOADED ] && rm /mnt/${PDEV1}/etc/.XLOADED
[ -f /mnt/${PDEV1}/tmp/bootcnt* ] && rm /mnt/${PDEV1}/tmp/bootcnt*
rm -f /var/log/X*
rm -f /var/lock/LCK*
rm -f /var/run/*.pid
SOCK=`find /mnt/${PDEV1}/var -xdev -type s | tr "\n" " "`
for i in $SOCK ; do
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""removing ""$i""\\033[0;39m"
rm -f $i
done
PIPE=`find /mnt/${PDEV1}/var -xdev -type p | tr "\n" " "`
for i in $PIPE ; do
[ "$DebugVal" -ge "1" ] && echo -e "\\033[1;33m""removing ""$i""\\033[0;39m"
rm -f $i
done
sleep $((SLEEP*2))s
sync
umount /dev/${PDEV1}  ###KRG
;;
esac
[ "$DebugVal" = "0" ]   && DUMPE=`dumpe2fs /dev/$PDEV1 2>/dev/null | grep -i "state"`
[ "$DebugVal" -gt "1" ] && DUMPE=`dumpe2fs /dev/$PDEV1 | grep -i "state"`
echo -e "\\033[1;34m""$DUMPE""\\033[0;39m"
echo -e "\\033[0;36m"
echo "The computer now has to be restarted."
echo -e "\\033[0;35m"
echo "Computer will reboot in 1-3  minutes, else press ENTER for immediate reboot."
echo
echo -e "\\033[0;32m"  ###KRG
echo "Press Any key and or simply ENTER to reboot ,"
echo "or wait $TimeOut sec again ,"
echo -e "\\033[0;31m"
echo "or [ r ] for dropout into rdsh :"
echo -e "\\033[0;39m"
echo -n -e "\\033[4;5;34m""ENTER""\\033[0;39m"" -> ""\\033[1;7;32m"
read -n 1 -t $TimeOut K
if [ "$K" = "r" -o "$K" = "R" ] ; then
echo
echo -e "\\033[0;32m"
echo "Dropping now"
echo "Have FUN !"
echo
echo -e "\\033[0;39m"
exit
else
echo -e "\\033[0;39m"  ###KRG
[ "$DebugVal" = "0" ]   && umount /proc 2>/dev/null
[ "$DebugVal" -ge "1" ] && { umount /proc;sleep $((SLEEP*3))s; }
reboot
fi' > /mnt/ram0/etc/rc.d/rc.sysinit
  chmod 0755 /mnt/ram0/etc/rc.d/rc.sysinit
#---------- RC.SYSINIT ------------------#
#---------- ETC -------------------------#

#---------- USR -------------------------#
  echo -e "\\033[1;34m""Populating /mnt/ram0/usr  ...""\\033[0;39m"
  LOCALTIME="${REPO}/usr/share`readlink $REPO/etc/localtime | sed 's%^.*/zoneinfo%/zoneinfo%'`"
  if [ -n "$REPO" ] ; then
  LOCALTDIR=`dirname $LOCALTIME | sed "s%$REPO%%g" | sed 's#^/## ; s#//#/#g'`
  else
  LOCALTDIR=`dirname $LOCALTIME | sed 's#^/## ; s#//#/#g'`
  fi
  mkdir -p /mnt/ram0/$LOCALTDIR
  cp $VERB -a $LOCALTIME /mnt/ram0/$LOCALTDIR/
  mkdir -p /mnt/ram0/usr/share
  cp $VERB -a "$REPO"/usr/share/terminfo /mnt/ram0/usr/share/
#---------- USR -------------------------#

#---------- DEV -------------------------#
  echo -e "\\033[1;34m""Populating /mnt/ram0/dev  ...""\\033[0;39m"
  cp $VERB -a "$REPO"/dev /mnt/ram0/
  _do_BLOCK_DEVICES "/mnt/ram0"
  [ "$DebugVal" = "2" ] && _askto_CONTINUE
#---------- DEV -------------------------#

#---------- LIB -------------------------#
  echo -e "\\033[1;34m""Populating /mnt/ram9/lib  ...""\\033[0;39m"
  mkdir /mnt/ram9/lib
  for i in $LIBF ; do  ###KRG to sort unneeded libs out , see further up ###KRG
  #[ "$DebugVal" -ge "1" ] && echo -n -e "\\033[0;39m""`basename $i`"
  [ "$DebugVal" -ge "1" ]                                                     && echo -n -e "\\033[0;39m""${i##*/}"
  [ "$DebugVal" -ge "1" ] && [ -z "`echo $i | grep 'libz\.so\..*\..*\..*'`" ] && echo -n -e "\\033[0;33m"', '"\\033[0;39m"
  cp $VERB -a $i /mnt/ram9/lib/
  done

  if [ -f "$REPO"/lib/e2initrd_helper ] ; then
  [ "$DebugVal" = "0" ] && cp $VERB -a "$REPO"/lib/e2initrd_helper /mnt/ram9/lib/ 2>$ERR #dunno what this is.  ###KRG me not either
  if [ "$DebugVal" -ge "1" ] ; then
  echo -e "\\033[0;33m"' Copying also '"\\033[0;39m"'/lib/e2initrd_helper'
  cp $VERB -a "$REPO"/lib/e2initrd_helper /mnt/ram9/lib/
  echo
  fi
  fi

  echo -e "\\033[0;39m"
  busybox ln $VERB -snf /mnt/ram9/lib /mnt/ram0/lib
#---------- LIB -------------------------#

#--------- FOLDERS -------------#
  mkdir /mnt/ram0/mnt
  mkdir /mnt/ram0/mnt/ram9
  mkdir /mnt/ram0/root
  mkdir /mnt/ram0/selinux
  mkdir /mnt/ram0/tmp
  mkdir -p /mnt/ram0/var/run
  mkdir /mnt/ram0/proc
  sleep $((SLEEP*3))s
  _sync
#--------- FOLDERS -------------#

#--------- PIVOT ---------------#
  echo -e "\\033[0;35m"'Performing a pivot_root to the ramdisk...'
  echo -e "\\033[0;39m"
  [ "$DebugVal" -ge "1" ] && { echo -e "\\033[0;33m"'1_mounts :'"\\033[0;39m";busybox mount;echo; }  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*3))s  ###DBG
  cd /mnt/ram0
  [ "$DebugVal" -ge "1" ] && echo -n -e "\\033[0;33m"'Have changed into /mnt/ram0 , pwd:'"\\033[0;39m"`pwd`"\n"  ###DBG
  [ "$DebugVal" = "2" ]   && { echo  -e "\\033[0;31m"'ls :'"\\033[0;39m";ls --color=auto;echo; }  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" = "2" ] && { echo  -e "\\033[0;31m"'ls  ./bin :'"\\033[0;39m";ls --color=auto ./bin;echo; }  ###DBG
  [ "$DebugVal" = "2" ] && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" = "2" ] && { echo  -e "\\033[0;31m"'ls ./sbin :'"\\033[0;39m";ls --color=auto ./sbin;echo; }  ###DBG
  [ "$DebugVal" = "2" ] && sleep $((SLEEP*2))s  ###DBG

  mkdir -p ./mnt/ram9
  busybox mount $VERB $VERB -o move /mnt/ram9 ./mnt/ram9
  grep $Q ' /dev ' /proc/mounts && {
  [ -d ./dev ] || mkdir ./dev
  busybox mount $VERB $VERB -o move /dev ./dev
  }

  [ -d ./sys ] || mkdir ./sys
  busybox mount $VERB $VERB -o move /sys ./sys
  [ -d ./proc ] || mkdir ./proc
  busybox mount $VERB $VERB -o move /proc ./proc

  #[ "$DebugVal" = "2" ]   && _askto_CONTINUE
  #[ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -e "\n\\033[1;33m""Now just before pivot_root :""\\033[;39m"
  [ "$DebugVal" = "2" ]   && _askto_CONTINUE
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'pivot_root now ...'  ###DBG
  pivot_root . old_root
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'...        pivoted'"\n"  ###DBG
  [ "$DebugVal" = "2" ]   && _askto_CONTINUE
#--------- PIVOT ---------------#

#--------- DEBUG ---------------#
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -n -e "\\033[0;33m"'pwd now :'"\\033[0;39m"`pwd`"\n"  ###DBG
  [ "$DebugVal" = "2" ]   && { echo -e "\\033[0;31m"'ls :'"\\033[0;39m";ls --color=auto; }  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m"  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*2))s  ###DBG
  cd /  ###KRG
  [ "$DebugVal" -ge "1" ] && echo -n -e "\\033[0;33m""ch'ed dir to / , pwd: ""\\033[0;39m"`pwd`"\n"  ###DBG
  [ "$DebugVal" = "2" ]   && { echo -e "\\033[0;31m"'ls /:'"\\033[0;39m";ls --color=auto /; }  ###DBG
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;39m"  ###DBG
  [ "$DebugVal" -ge "1" ] && { echo -e "\\033[0;33m"'2_mounts :'"\\033[0;39m";busybox mount;echo; }  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG
#--------- DEBUG ---------------#

#--------- KILL DAEMONS --------#
  pidof pup_event_backend_d                 >$OUT 2>$ERR && busybox killall -9 pup_event_backend_d                1>$OUT 2>$ERR
  pidof pup_event_backend_modprobe_protect 1>$OUT 2>$ERR && busybox killall -9 pup_event_backend_modprobe_protect 1>$OUT 2>$ERR
  pidof udevd                              1>$OUT 2>$ERR && busybox killall -9 udevd                              1>$OUT 2>$ERR
#--------- KILL DAEMONS --------#

#--------- FUSER ---------------#
fuser_func(){  ##+-+2011-10-28 commented for now
  echo -e "\\033[1;34m"'Killing all filesystem users ...'"\\033[0;39m"
  fsUsers=`fuser -m /old_root/* 2>/dev/null | tr '[[:blank:]]' ' ' | tr -s ' ' | tr ' ' '\n' | sort -u | sort -rg`
  for i in $fsUsers ; do
  [ "$DebugVal" = "0" ]   && echo -n "$i "
  [ "$DebugVal" -ge "1" ] && echo "$i"
  kill -1 $i
  [ "$DebugVal" = "1" ] && ps -p $i | sed -n '2 p'
  [ "$DebugVal" = "2" ] && ps -p $i
  sleep 1s
  done
  [ -n "fsUsers" ] && echo
}
#--------- FUSER ---------------#

#--------- OLD_ROOT ------------#
  echo -e "\\033[1;34m"'Unmounting everything beneath /old_root/* ...'"\\033[0;39m"
  OR=`mount | grep '/old_root/' | cut -f 3 -d ' ' |tr -d \'\"| sort -r`
  for i in $OR ; do
  [ "$DebugVal" -ge "1" ] && echo -e "\\033[0;33m"'unmounting '"\\033[0;39m""$i"  ###DBG
  if [ "$DebugVal" = "0" ] ; then
  busybox umount $VERB $VERB -r $i 2>$ERR
  Err=$?
  else
  busybox umount $VERB $VERB -lrd $i
  Err=$?
  fi

  if [ "$Err" -ne "0" ] ; then
  echo -e "\\033[0;33m"'failed , trying lazy .. '"\\033[0;39m"  ###DBG
  busybox umount $VERB $VERB -lrd $i
  fi
  sleep 1s

  #[ -d "/old_root/mnt/`basename $i`" ] && rmdir /old_root/mnt/`basename $i` 1>$out 2>$err
  [ -d "/old_root/mnt/${i##*/}" ] && rmdir /old_root/mnt/"${i##*/}" 1>$OUT 2>$ERR
  done

  busybox mount $VERB $VERB -o remount,ro /old_root
  echo -e "\\033[0;39m"
  [ "$DebugVal" -ge "1" ] && { echo -e "\\033[0;33m"'3_mounts :'"\\033[0;39m";busybox mount;echo; }  ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG
  [ "$DebugVal" = "2" ]   && { echo -e "\\033[0;31m"'ls /old_root:'"\\033[0;39m";ls --color=auto /old_root;echo; }  ###KRG ls -R would show whole partition ###DBG
  [ "$DebugVal" -ge "1" ] && sleep $((SLEEP*4))s  ###DBG
#--------- OLD_ROOT ------------#

#--------- MENU ----------------#
  echo -e "\\033[0;32m"
  echo 'Press ANY key and or ENTER to perform fsck'
  echo "or wait $TimeOut seconds ."
  echo 'Scrolling might be allowed by Shift+PageUP/Down .'
  echo -e "\\033[0;31m"
  echo "or [c] or [k] for drop out into simple console mode"
  echo "or [i] or [b] for drop out into console with busybox init on top ."
  echo -e "\\033[0;39m"
  echo -n -e "\\033[4;5;34m"'ENTER'"\\033[0;39m"' -> '"\\033[1;7;32m"
  read -n 1 -t $TimeOut K
  echo -e "\\033[0;39m"
  if [ "$K" = "c" -o "$K" = "C" -o "$K" = "k" -o "$K" = "K" ] ; then
  echo -e "\\033[0;32m"
  echo 'Dropping now into simple Single User Mode sh .'
  echo 'Have FUN !'
  echo
  echo -e "\\033[0;39m"
  login -f root
  exec chroot . sh
  elif [ "$K" = "i" -o "$K" = "I" -o "$K" = "b" -o "$K" = "B" ] ; then
  echo -e "\\033[0;32m"
  echo 'Dropping now into busybox init Single User Mode sh .'
  echo -e "\\033[1;32m"
  echo 'Have MORE FUN !'
  echo
  echo -e "\\033[0;39m"
  echo '#DUMMY' > /etc/rc.d/rc.sysinit
  chmod 0775 /etc/rc.d/rc.sysinit
  exec chroot . sh -c "exec busybox init" <dev/console >dev/console 2>&1
  else
  exec chroot . sh -c "exec busybox init" <dev/console >dev/console 2>&1
  fi
#--------- MENU ----------------#
 ;;
 reiserfs)

 [ -z "$FSCK" ] && _do_FSCK_RO
 _do_FSCK_RO
 echo -e "\\033[0;31m""
 STUB for reiserfs support"
 echo -e "\\033[1;35m""Do you want to drop into shell [Y|n]? ""\\033[0;39m"
  read -n 1 -t $TimeOut K
 echo
  [ "$K" ] || K=n
  if [ "$K" = 'Y' -o "$K" = 'y' ];then
  _dropto_SIMPLE_CONSOLE
  else
   mount $VERB $VERB -o remount,ro /dev/root /
   _do_BUSYBOX_INIT
   fi
 ;;
 xfs)

 [ -z "$FSCK" ] && _do_FSCK_RO

 echo -e "\\033[0;31m""
 STUB for xfs support"
 echo -e "\\033[1;35m""Do you want to drop into shell [Y|n]? ""\\033[0;39m"
  read -n 1 -t $TimeOut K
 echo
 [ "$K" ] || K=n
  if [ "$K" = 'Y' -o "$K" = 'y' ];then
  _dropto_SIMPLE_CONSOLE
  else
   mount $VERB $VERB -o remount,ro /dev/root /
   _do_BUSYBOX_INIT
   fi
 ;;
 jfs)

 [ -z "$FSCK" ] && _do_FSCK_RO

 echo -e "\\033[0;31m""
 STUB for jfs support"
 echo -e "\\033[1;35m""Do you want to drop into shell [Y|n]? ""\\033[0;39m"
  read -n 1 -t $TimeOut K
 echo
  [ "$K" ] || K=n
  if [ "$K" = 'Y' -o "$K" = 'y' ];then
  _do_SIMPLE_CONSOLE
  else
   mount $VERB $VERB -o remount,ro /dev/root /
   _do_BUSYBOX_INIT
   fi
 ;;
 *)
  echo -e "\\033[1;31m"  #34=blue, 33=yellow, 32=green, 31=red, 35=purple, 36=aquablue, 38=black.
  echo -n "Previous improper shutdown, sorry can only do f.s. check of ext2/3/4."
  echo -e "\\033[0;39m"
  sleep 5s
  mount $VERB $VERB -o remount,ro /dev/root /  ###KRG
  #exec busybox init  ###should be something like umount -ar ; reboot ###KRG
  _do_BUSYBOX_INIT
 ;;
esac
