#!/bin/ash
#
# New header by Karl Reimer Godt, September 2014
  _TITLE_="Puppy_pup_event_backend_modprobe_protect"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux shell script [to TODO here]"

MY_SELF="/sbin/pup_event_backend_modprobe_protect"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || source /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE='1'; TWO_DEBUG='1'; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header

DEBUG=1
#
#Serializes access to the backend_modprobe protect_data file
#by processing gate-keeping requests for particular resources
#and entities. Databases are maintained internally
#and in some cases written to a file.
#Takes input from single named pipe
#and returns status in caller-created pipe:
# 0 = first claimer, OK to process for entity
# 1 - not first, abort processing of entity.

SVCNAME="pup_event_backend_modprobe_protect"
SVCN_15="${SVCNAME:0:15}"
LOG_FILE=/tmp/${SVCNAME}.log
LOG_FILE2=/tmp/${SVCNAME}.log.$$

[ "$1" = 'debug' ] && { DEBUG=1;shift; }
[ "$DEBUG" ] && echo "'$SVCNAME' '$SVCN_15'"

OPTION="$1"
[ "$DEBUG" ] && echo "DBG \$1='$1' 'OPTION='$OPTION"
[ "$OPTION" = "" ] && OPTION="--help"

#if [ "$OPTION" != "--help" ];then
# [ ! -p /tmp/${SVCNAME}_pipe ] && mkfifo /tmp/${SVCNAME}_pipe
#fi


claim_resource_entity_func() {
[ "$DEBUG" ] && echo "($$) DBG claim_resource_entity_func '$1' START" >>"$LOG_FILE"
 #Requires OPTION, SVCNAME, and argument:  M(odule), R(eplaced module), U(sbserial dependent), F(irmware), S(nd-card), D(evice_major_number), L(ock).
 [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
[ "$DEBUG" ] && echo "($$) ($PPID) DEBUG claim_resource_entity_func: Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >>"$LOG_FILE" #debug
 echo "add $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read -t10 REPLY </tmp/${SVCNAME}_pipe-$PPID
[ "$DEBUG" ] && echo "($$) ($PPID) DEBUG claim_resource_entity_func : REPLY: $REPLY" >>"$LOG_FILE" #debug
 [ "$RESOURCE" = "L" ] || rm $VERB /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
  echo "($$) ($PPID) ERROR claim_resource_entity_func: Invalid reply from daemon'  REPLY: '$REPLY'" >>"$LOG_FILE"
  return 2; }
[ "$DEBUG" ] && echo "($$) DBG claim_resource_entity_func '$1' REPLY='$REPLY' END" >>"$LOG_FILE"
 if test "$REPLY"; then
 return `echo "$REPLY" | cut -f 1 -d ' '`
 else return 3
 fi
}

check_firmware_count_func() {
[ "$DEBUG" ] && echo "($$) DBG check_firmware_count_func '$1' START" >>"$LOG_FILE"
 #Requires SVCNAME
 [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
[ "$DEBUG" ] && echo "($$) ($PPID) DEBUG check_firmware_count_func: Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >>"$LOG_FILE" #debug
 echo "testzero $PPID F null" >/tmp/${SVCNAME}_pipe
 read -t10 REPLY </tmp/${SVCNAME}_pipe-$PPID
[ "$DEBUG" ] &&  echo "($$) ($PPID) DEBUG check_firmware_count_func: REPLY: $REPLY" >>"$LOG_FILE" #debug
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID F null" ] && {
  echo "($$) ($PPID) ERROR check_firmware_count_func: Invalid reply from daemon'  REPLY: '$REPLY'" >>"$LOG_FILE"
  return 2; }
[ "$DEBUG" ] && echo "($$) DBG check_firmware_count_func '$1' REPLY='$REPLAY' END" >>"$LOG_FILE"
 if test "$REPLY"; then
 return `echo "$REPLY" | cut -f 1 -d ' '`
 else return 4
 fi
}

check_entity_claimed_func() {
[ "$DEBUG" ] && echo "($$) DBG check_entity_claimed_func '$1' START" >>"$LOG_FILE"
 #Requires OPTION, SVCNAME, and argument:  M(odule), F(irmeare), S(nd-card), D(evice_major_number), L(ock).
 [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
[ "$DEBUG" ] && echo "($$) ($PPID) DEBUG check_entity_claimed_func: Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >>"$LOG_FILE" #debug
 echo "check $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read -t10 REPLY </tmp/${SVCNAME}_pipe-$PPID
[ "$DEBUG" ] && echo "($$) ($PPID) DEBUG check_entity_claimed_func: REPLY: $REPLY" >>"$LOG_FILE" #debug
 rm $VERB /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
 echo "($$) ($PPID) ERROR check_entity_claimed_func: Invalid reply from daemon'  REPLY: '$REPLY'" >>"$LOG_FILE"
 return 2; }
[ "$DEBUG" ] && echo "($$) DBG check_entity_claimed_func '$1' REPLY='$REPLAY' END" >>"$LOG_FILE"
 if test "$REPLY"; then
 return `echo "$REPLY" | cut -f 1 -d ' '`
 else return 5
 fi
}

### Resume main line ###
#set -x

case $OPTION in

 module=* )
  [ "$DEBUG" ] && echo "($$) DBG option module=\\* new START" >>"$LOG_FILE"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  [ $? -eq 0 ] || { echo 'DBG returncode -ne 0';exit 1; }
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial\.ko' | cut -f 1 -d : | grep $Q -E "$FPATTERN" \
   && claim_resource_entity_func U
  [ "$DEBUG" ] && echo "($$) DBG option new module= END" >>"$LOG_FILE"
  exit 0
  ;;

 --module=*)
  [ "$DEBUG" ] && echo "($$) DBG OPTION='$OPTION' --module=\* START" >>"$LOG_FILE"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  retVal_CREF_M=$?
  [ "$DEBUG" ] && echo "($$) DBG retVal_CREF_M='$retVal_CREF_M'" >>"$LOG_FILE"
  #[ $? -eq 0 ] || { echo 'returncode of --module=* -ne 0';exit 1; }
  #[ "$retVal_CREF_M" -eq 0 ] || { echo 'returncode of --module=* -ne 0';exit 1; }
  if [ "$retVal_CREF_M" -ne 0 ] ; then
  [ "$DEBUG" ] && echo "($$)"' DBG returncode of --module=* -ne 0' >>"$LOG_FILE"
  exit 1
  fi
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  [ "$DEBUG" ] && echo "($$) DBG altMODULE='$altMODULE'" >>"$LOG_FILE"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  [ "$DEBUG" ] && echo "($$) DBG FPATTERN='$FPATTERN'" >>"$LOG_FILE"
  #grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
  # && claim_resource_entity_func U
   if [ -n "`grep -E "$FPATTERN" /lib/modules/$(uname -r)/modules.dep 2>/dev/null | grep '/usbserial\.ko' | cut -f 1 -d : | grep -E "$FPATTERN"`" ] ; then ##TODO -n or -z ??
   [ "$DEBUG" ] && echo "($$) DBG $0 running CREF_U for usbserial found\?" >>"$LOG_FILE"
   claim_resource_entity_func U
   [ "$DEBUG" ] && echo "($$) DBG $0 finished CREF_U for usbserial found\?" >>"$LOG_FILE"
   fi
  [ "$DEBUG" ] && echo "($$) DBG '$?'" >>"$LOG_FILE"
  [ "$DEBUG" ] && echo "($$) DBG OPTION='$OPTION' --module=\* END ; exit 0" >>"$LOG_FILE"
  exit 0
  ;;

 --replacedmod=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --replacedmod=\\* START" >>"$LOG_FILE"
  claim_resource_entity_func R
  [ "$DEBUG" ] && echo "($$) DBG $0 --replacedmod=\\* END ; exit 0" >>"$LOG_FILE"
  exit 0
  ;;

 --modcheck=usbserial)
  [ "$DEBUG" ] && echo "($$) DBG $0 --modcheck=usbserial START"  >>"$LOG_FILE"
  [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
  RESOURCE="U"
  ENTITY="usbserial"
  MAXRETRIES=60; RETRIES=0
  while true;do
   [ "$RETRIES" -ge $MAXRETRIES ] && break
   echo "checkgroup $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
   read -t10 REPLY </tmp/${SVCNAME}_pipe-$PPID
  [ "$DEBUG" ] &&  echo "($$) ($PPID) DEBUG : REPLY: $REPLY" >>"$LOG_FILE" #debug
   [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
    echo "($$) ($PPID) ERROR : Invalid reply from daemon'  REPLY: '$REPLY'" >>"$LOG_FILE"
    STATUS=1;break; }
   STATUS=`echo "$REPLY" | cut -f 1 -d ' '`
   [ "$STATUS" -eq 0 ] && break
   RETRIES=$((RETRIES + 1))
   sleep 1
  done
  rm $VERB /tmp/${SVCNAME}_pipe-$PPID
  if [ "$RETRIES" -ge $MAXRETRIES ];then
   echo "($$) ($PPID) ERROR : Loading of usbserial-dependent module(s) timed out after 1 minute" >>"$LOG_FILE"
   [ "$DEBUG" ] && echo "DBG $0 --modcheck=usbserial exiting 1"  >>"$LOG_FILE"
   exit 1
  elif [ "$RETRIES" -gt 0 ];then
   echo "($$) ($PPID) DEBUG : Loading of usbserial-dependent module(s) required wait of $RETRIES seconds" >>"$LOG_FILE"
  fi
  [ "$DEBUG" ] && echo "($$) DBG $0 --modcheck=usbserial END ; exit '$STATUS'"  >>"$LOG_FILE"
  exit $STATUS
  ;;

 --modcheck=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --modcheck=\\* START"  >>"$LOG_FILE"
  ENTITY="" #make visible here
  check_entity_claimed_func M || { echo "($$)"' DBG returncode -ne 0';exit 1; }
  [ "`lsmod | grep "^$ENTITY "`" ] && { echo "($$) DBG $ENTITY already loaded ;exit '0'"  >>"$LOG_FILE";exit 0; }
  check_entity_claimed_func R && { echo "$($$)"' DBG finished check_entity_claimed_func ;exit 0'  >>"$LOG_FILE";exit 0; }
  sleep 1
  MAXRETRIES=60; RETRIES=1
  while [ "`lsmod | grep "^$ENTITY "`" = "" ];do
   [ "$RETRIES" -ge $MAXRETRIES ] && break
   RETRIES=$((RETRIES + 1))
   sleep 1
  done
  if [ "$RETRIES" -ge $MAXRETRIES ];then
   echo "($$) ($PPID) ERROR : Loading of module '$ENTITY' timed out after 1 minute" >>"$LOG_FILE"
   [ "$DEBUG" ] && echo "($$) DBG $0 exiting 1" >>"$LOG_FILE"
   exit 1
  elif [ "$RETRIES" -gt 0 ];then
   echo "($$) ($PPID) DEBUG : Loading of module '$ENTITY' required wait of $RETRIES seconds" >>"$LOG_FILE"
  fi
  [ "$DEBUG" ] && echo "($$) DBG $0 --modcheck=\\* END ; exit 0" >>"$LOG_FILE"
  exit 0
  ;;

 --firmware=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --firmware=\\* START" >>"$LOG_FILE"
  claim_resource_entity_func F
  retValCREF_F=$?
  [ "$DEBUG" ] && echo "($$) DBG $0 --firmware=\\* END ; returnvalue='$retValCREF_F'" >>"$LOG_FILE"
  exit $retValCREF_F
  ;;

 --fwdone)
  [ "$DEBUG" ] && echo "($$) DBG $0 --fwdone START" >>"$LOG_FILE"
  echo "decrement $PPID F null" >/tmp/${SVCNAME}_pipe
  [ "$DEBUG" ] && echo "($$) DBG $0 --fwdone END ; exit 0" >>"$LOG_FILE"
  exit 0
  ;;

 --fwcomplete)
  [ "$DEBUG" ] && echo "($$) DBG $0 --fwcomplete START" >>"$LOG_FILE"
  MAXRETRIES=60;   RETRIES=0
  while [ -e /tmp/.usb_modeswitch_active ] \
    || ! check_firmware_count_func;do
   [ "$RETRIES" -ge "$MAXRETRIES" ] && break
   sleep 1; RETRIES=$((RETRIES + 1))
  done
  rm $VERB -f /tmp/${SVCNAME}_pipe-$PPID
  if [ "$RETRIES" -ge "$MAXRETRIES" ];then
   echo "($$) ($PPID) ERROR : Firmware/modeswitch completion timeout after 1 minute" >>"$LOG_FILE"
   rm $VERB -f /tmp/.usb_modeswitch_active
   [ "$DEBUG" ] && echo "($$) DBG $0 --fwcomplete exiting '1' ..."  >>"$LOG_FILE"
   exit 1
  elif [ "$RETRIES" -gt 0 ];then
   echo "($$) ($PPID) DEBUG : Firmware/modeswitch completion test waited $RETRIES seconds" >>"$LOG_FILE"
  fi
  [ "$DEBUG" ] && echo "($$) DBG $0 --fwcomplete END ; exit 0"  >>"$LOG_FILE"
  exit 0
  ;;

 --snd_card_number=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --snd_card_number=\\* START"  >>"$LOG_FILE"
  claim_resource_entity_func S
  retValCREF_S=$?
  [ "$DEBUG" ] && echo "($$) DBG $0 --snd_card_number=\\* END ; exit '$retValCREF_S"  >>"$LOG_FILE"
  exit $retValCREF_S
  ;;

 --device_major_number=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --device_major_number=\\* START"  >>"$LOG_FILE"
  claim_resource_entity_func D
  retValCREF_D=$?
  [ "$DEBUG" ] && echo "($$) DBG $0 --device_major_number=\\* END ; exit '$retValCREF_D'"  >>"$LOG_FILE"
  exit $retValCREF_D
  ;;

 --lock=*)
  [ "$DEBUG" ] && echo "($$) DBG $0 --lock=\\* START"  >>"$LOG_FILE"
  ENTITY="" #make visible here
  MAXRETRIES=60;   RETRIES=0
  while ! claim_resource_entity_func L;do
   [ "$RETRIES" -ge $MAXRETRIES ] && break
   sleep 1; RETRIES=$((RETRIES + 1))
  done
  rm $VERB /tmp/${SVCNAME}_pipe-$PPID
  STATUS=0
  if [ "$RETRIES" -ge $MAXRETRIES ];then
   echo "($$) ($PPID) ERROR : Lock timeout after 1 minute for lock $ENTITY" >>"$LOG_FILE"
   STATUS=1
  elif [ "$RETRIES" -gt 0 ];then
   echo "($$) ($PPID) DEBUG : Lock retried for $RETRIES seconds for $RESOURCE $ENTITY" >>"$LOG_FILE"
  fi
  [ "$DEBUG" ] && echo "($$) ($PPID) DBG $0 --lock=\\* END ; exit '$STATUS'"  >>"$LOG_FILE"
  exit $STATUS
  ;;

 --unlock=*)

  [ "$DEBUG" ] && echo "($$) DBG $0 --unlock=\\* START"

  ENTITY="`echo "$OPTION" | grep '=' | cut -f 2 -d '='`"
  [ "$ENTITY" != "" ] && echo "delete $PPID L $ENTITY" >/tmp/${SVCNAME}_pipe
  [ "$DEBUG" ] && echo "($$) DBG $0 --unlock=\\* END ; exit 0"
  exit 0
  ;;

 --help)
  cat 1>&2 << EOT

Usage: `basename $0` option

Only one of the following options is required:
  --module=<module-name>         Prevent redundant loading of module (by backend_modprobe)
  --modcheck=<module-name>       Verify module completed loading (for initialization scripts)
  --modcheck=usbserial       Verify all usbserial-dependent modules completed loading (for initialization scripts)
  --firmware=<firmware-tarball-name> Prevent redundant installation of firmware (by backend_modprobe)
  --fwdone                       One firmware installation finished - decrement firmware counter
  --fwcomplete                   Wait until all firmware installation is completed
  --snd_card_number=<number>     Reserve sound car number (0 - 10) (by backend_modprobe)
  --device_major_number=<number> Reserve major number (240-251) (by modem firmware)
  --lock=<name>                  Temporarily lock object to serialize access
  --unlock=<name>                Unlock locked object
  --done                         Remove the automatically created named pipe used to communicate with the daemon
  --daemon                       Start the lock-manager daemon (by rc.sysinit)
  --stop                         terminate the daemon
  --dump                         Log current reserved/locked entities
  --help                         This small usage guide

EOT
  ;;

 --dump)
  [ "`/bin/ps -C pup_event_backend_modprobe_protect | grep -c ''`" -gt 3 ] || exit 1
  [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
  echo "dump $PPID" >/tmp/${SVCNAME}_pipe
  read -t10 REPLY </tmp/${SVCNAME}_pipe-$PPID
  rm $VERB /tmp/${SVCNAME}_pipe-$PPID
  [ "`echo "$REPLY" | cut -f 2 -d ' '`" != "$PPID" ] && {
   echo "($$) ($PPID) ERROR : Invalid reply from daemon'  REPLY: '$REPLY'" >>"$LOG_FILE"
   exit 2; }
  ;;

 --stop)
  #echo "quit" >/tmp/${SVCNAME}_pipe
  ##+++2012-01-26
  echo "quit" >/tmp/${SVCNAME}_pipe &
  ##exit $?
  ##/
  ;;

 --daemon)
  #Inpipe request syntax: action PID resource entity
  # action: add delete decrement testzero check checkgroup help dump quit
  # resource: M R U F S D L
  # entity: modulename firmwarename number text-string
  #ps |grep "$SVCNAME $OPTION";echo '#'
  #ps |grep "$SVCNAME $OPTION" |grep -vE "$$|grep";echo '#'
  grepOPTION="${OPTION//-/\\-}";[ "$DEBUG" ] && echo "DBG $0 grepOPTION='$grepOPTION'"
  #echo PS_PERSONALITY=$PS_PERSONALITY
  #unset PS_PERSONALITY
  #echo PS_PERSONALITY=$PS_PERSONALITY
  #echo '$$='$$
  pid=$$
  #otherSVCNAMES=`busybox ps | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`
  #otherSVCNAMES=`/bin/ps -A | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`
  otherSVCNAMES=`/bin/ps -A`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep "$SVCNAME"`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep "$grepOPTION"`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep -vE "$pid|grep"`
  #if [ "QUIRK $(/bin/ps -A | grep "$SVCNAME" | grep "$grepOPTION" | grep -v "$pid" | grep -v 'grep' |tr -d '[[:blank:]]')" != "QUIRK " ];then # && exit 140
  # if [ "`/bin/ps -A | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`" != "" ];then
  if [ "$otherSVCNAMES" ];then
   #echo '$$='$$
   #echo "'$(ps | grep "$SVCNAME" | grep "$grepOPTION" | grep -vE "$$|grep" |tr -d '[[:blank:]]')'"
   #echo "'$(ps -A --forest| grep "$SVCNAME" | grep "$grepOPTION" | grep -vE "$$|grep" |tr -d '[[:blank:]]')'"
   [ "$DEBUG" ] && echo "DBG $0 @will now exit@"
   exit 140
  fi

  [ -p /tmp/${SVCNAME}_pipe ] || mkfifo /tmp/${SVCNAME}_pipe
  trap "rm $VEBR -f /tmp/${SVCNAME}_pipe; exit" INT TERM EXIT

  KERNVER="`uname -r`"
  LISTM=" "; LISTR=" "; LISTU=" "; LISTF=" "; LISTS=" "; LISTD=" "; LISTL=" "; LISTFNEW=""
  FILEF="/etc/modules/firmware.inst.$KERNVER"
  [ -s "$FILEF" ] && { LISTF=" `cat "$FILEF" | tr '\n' ' '` "
  LISTF="`echo -n "$LISTF" | tr -s ' '`"; }
  COUNTF=0

#function
 restore_main_pipe(){
while [ 1 ];do
[ -p  /tmp/${SVCNAME}_pipe ] || mkfifo /tmp/${SVCNAME}_pipe
sleep 3
done
}
#restore_main_pipe &

#function
 restore_program(){
while [ 1 ];do
sleep 3
if [ ! -p /tmp/${SVCNAME}_pipe ];then
killall $SVCNAME
sleep 2
DEBUG=$DEBUG $SVCNAME --daemon &
fi

done
}
#restore_program &

#function
 escape_cat(){
while [ 1 ];do
sleep 3
if [ ! -p /tmp/${SVCNAME}_pipe ];then
killall $SVCNAME
exit 1
fi

done
}
escape_cat &

_check_lists(){
test "$*" || return 2
for l in $LISTM $LISTR $LISTU $LISTF $LISTFNEW $LISTS $LISTD $LISTL
do echo "$l" | grep -w "$*" && return 0; done
return 1
}

  #while true; do
   while [ -e "/tmp/${SVCNAME}_pipe" ]; do
   [ "$DEBUG" ] && echo 'DBG outer true loop to read pipe'
   REQUESTS="`cat /tmp/${SVCNAME}_pipe`"        # needs to be cat here since the pipe may contain several lines
   [ "$DEBUG" ] && echo "REQUESTS='$REQUESTS'"
   [ "${REQUESTS//[[:blank:]]/}" ] || continue
   #while :; do read -t2 REQUESTS </tmp/${SVCNAME}_pipe; REQUESTSALL="$REQUESTSALL{REQUESTS} ";done
   #[ "$DEBUG" ] && echo "REQUESTSALL='$REQUESTSALL'"
   #[ "${REQUESTSALL//[[:blank:]]/}" ] || continue

    while true; do
    [ "$DEBUG" ] && echo 'DBG inner true loop processing pipe content'
    REQUEST="`echo "$REQUESTS" | head -n 1`"
    [ "$DEBUG" ] && echo "REQUEST='$REQUEST'"
    read ACTION CLIENTPID RESOURCE ENTITY <<EoI
$REQUEST
EoI
    RVRQ="$?";[ "$DEBUG" ] && echo RVRQ=$RVRQ
    ##[ "$ACTION" = "" -o $? -ne 0 ] && break
    ##[ $? -ne 0 -o "$ACTION" = "" ] && break
    if [ "$RVRQ" != '0' -o "$ACTION" = "" ];then
    [ "$DEBUG" ] && echo 'breaking true 2'
    break;
    fi
    REQUESTS="`echo "$REQUESTS" | sed '1d'`"
    case $ACTION in
     add)
      #LIST="LIST$RESOURCE"
      LIST="$LIST$RESOURCE"
     #if [ "`echo "${!LIST[*]}" | grep -w "${ENTITY}"`" ];then
      if _check_lists "${ENTITY}" ; then
       STATUS=1
       [ "$RESOURCE" != "L" -a "$RESOURCE" != "R" ] && echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTPID REJECTED for resource $RESOURCE $ENTITY" >>"$LOG_FILE"
      else
       STATUS=0
       case $RESOURCE in
        M)
         LISTM="${LISTM}$ENTITY "
[ "$DEBUG" ] && echo LISTM=$LISTM #>>"$LOG_FILE"
        ;;
        R)
         LISTR="${LISTR}$ENTITY "
[ "$DEBUG" ] && echo LISTR=$LISTR #>>"$LOG_FILE"
        ;;
        U)
         LISTU="${LISTU}$ENTITY "
[ "$DEBUG" ] && echo LISTU=$LISTU #>>"$LOG_FILE"
         ;;
        F)
         if [ "`echo "$LISTL" | grep -w 'firmwareinst'`" ];then
          LISTFNEW="${LISTFNEW}$ENTITY "
         else
          LISTF="${LISTF}$ENTITY "
          echo -n "$LISTF" | tr ' ' '\n' > ${FILEF}
         fi
         COUNTF=$((COUNTF + 1))
[ "$DEBUG" ] && echo LISTF=$LISTF #>>"$LOG_FILE"
         ;;
        S)
         #LISTS="${!LIST*}$ENTITY "
          LISTS="${LIST}$ENTITY "
[ "$DEBUG" ] && echo LISTS=$LISTS #>>"$LOG_FILE"
         ;;
        D)
         #LISTD="${!LIST*}$ENTITY "
[ "$DEBUG" ] && echo LISTD=$LISTD #>>"$LOG_FILE"
          LISTD="${LISTD}$ENTITY "
[ "$DEBUG" ] && echo LISTD=$LISTD #>>"$LOG_FILE"
         ;;
        L)
         #LISTL="${!LIST*}$ENTITY "
          LISTL="${LISTL}$ENTITY "
[ "$DEBUG" ] && echo LISTL=$LISTL #>>"$LOG_FILE"
         ;;
        *)
        echo "  DEBUG (daemon): Invalid RESOURCE: $RESOURCE" >>"$LOG_FILE"
         ;;
       esac #END RESOURCE
       echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTPID GRANTED for resource $RESOURCE $ENTITY" >>"$LOG_FILE"
      fi
      echo "$STATUS $CLIENTPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTPID
      ;;
     delete)
      SEDSCRIPT="s/ ${ENTITY} / /"
      LISTL="`echo -n "$LISTL" | sed -e "$SEDSCRIPT"`"
      if [ "$ENTITY" = "firmwareinst" ];then
       LISTF=" `cat /etc/modules/firmware.inst.${KERNVER} | tr '\n' ' '` $LISTFNEW"
       LISTF="`echo -n "$LISTF" | tr -s ' '`"
       [ "$LISTFNEW" ] && { echo -n "$LISTF" | tr ' ' '\n' > ${FILEF}
       LISTFNEW=""; }
      fi
      echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTPID FREED resource $RESOURCE $ENTITY" >>"$LOG_FILE"
      ;;
     decrement)
      [ "$RESOURCE" = "F" ] && COUNTF=$((COUNTF - 1))
      ;;
     testzero)
      if [ "$RESOURCE" != "F" -o "$COUNTF" -le 0 ];then
       STATUS=0
      else
       STATUS=1;
      fi
      echo "$STATUS $CLIENTPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTPID
      ;;
     check)
      LIST="${LIST}$RESOURCE"
      #if [ "`echo "${!LIST[*]}" | grep -w "${ENTITY}"`" ];then
      if _check_lists "${ENTITY}" ; then
           STATUS=0
      else STATUS=1;fi
      echo "$STATUS $CLIENTPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTPID
      ;;
     checkgroup)
      STATUS=0
      if [ "$RESOURCE" = "U" -a "$ENTITY" = "usbserial" ];then
       REPLIST="`echo "$LISTR" | tr ' ' '\n' | sed /^$/d`"
       USLIST="`echo "$LISTU" | tr ' ' '\n' | sed /^$/d | sort -u`"
       [ "$REPLIST" != "" ] && USLIST="`echo "$USLIST" | grep -v -w -F "$REPLIST"`"
       LSMODSTRG="`lsmod | cut -f 1 -d ' ' | grep -F -w "$USLIST" | sort -u | tr '\n' ' '`"
       USSTRG="`echo "$USLIST" | tr '\n' ' '`"
       [ "$LSMODSTRG" != "$USSTRG" ] && STATUS=1
       [ "$DEBUG" ] && echo -e "($$) ($PPID) DEBUG : REPLIST: $REPLIST  USLIST: $USLIST\nLSMODSTRG: $LSMODSTRG\nUSSTRG: $USSTRG" >>"$LOG_FILE"   #DEBUG
      fi
      echo "$STATUS $CLIENTPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTPID
      ;;
     dump)
      echo -e "SUMMARY (daemon):\nLoaded modules: ${LISTM}\nReplaced modules: ${LISTR}\nUsbserial-dependent modules: ${LISTU}\nInstalled firmware: ${LISTF}\nUsed sound card numbers: ${LISTS}\nUsed 'experimental' device major numbers: ${LISTD}\nLocked files or other entities: ${LISTL}\nFirmware installation count: $COUNTF" >>"$LOG_FILE"
      echo -e "Pending request processes:\n`/bin/ps aux | grep 'backend_modprobe_protect --' | grep -v ' grep ' | grep -v '\--daemon' | grep -v '\--dump' | tr -s ' ' | cut -f 2,13 -d ' '`" >>"$LOG_FILE"
      pidof sync || sync
      echo "0 $CLIENTPID" >/tmp/${SVCNAME}_pipe-$CLIENTPID
      ;;
     quit)
      exit
      ;;
     *)
      echo "  DEBUG (daemon): Invalid action '$ACTION'" >>"$LOG_FILE"
      ;;
    esac
   done
   ##END true
  done
  ##END true
   ;;
##END --daemon

 *)
  echo "($$) ($PPID) DEBUG : Invalid option '$OPTION'" >>"$LOG_FILE"  # Should not be executed.
  ;;
esac
exit 0

##### END ######
