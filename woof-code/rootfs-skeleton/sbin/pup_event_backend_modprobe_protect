#!/bin/bash
#Serializes access to the backend_modprobe protect_data file
#by processing gate-keeping requests for particular resources
#and entities. Databases are maintained internally
#and in some cases written to a file.
#Takes input from single named pipe
#and returns status in caller-created pipe:
# 0 = first claimer, OK to process for entity
# 1 - not first, abort processing of entity.

SVCNAME="pup_event_backend_modprobe_protect"
SVCN_15="${SVCNAME:0:15}"
[ "$1" = 'debug' ] && { DEBUG=1;shift; }
[ "$DEBUG" ] && echo "'$SVCNAME' '$SVCN_15'"

OPTION="$1"
[ "$DEBUG" ] && echo "DBG \$1='$1' 'OPTION='$OPTION"
[ "$OPTION" = "" ] && OPTION="--help"

#if [ "$OPTION" != "--help" ];then
# [ ! -p /tmp/${SVCNAME}_pipe ] && mkfifo /tmp/${SVCNAME}_pipe
#fi


claim_resource_entity_func() {
[ "$DEBUG" ] && echo "DBG claim_resource_entity_func '$1' START"
 #Requires OPTION, SVCNAME, and argument:  M(odule), R(eplaced module), U(sbserial dependent), F(irmware), S(nd-card), D(evice_major_number), L(ock).
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "add $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 [ "$RESOURCE" != "L" ] && rm /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
  echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log
  return 2; }
[ "$DEBUG" ] && echo "DBG claim_resource_entity_func '$1' REPLY='$REPLY' END"
return `echo "$REPLY" | cut -f 1 -d ' '`
}

check_firmware_count_func() {
[ "$DEBUG" ] && echo "DBG check_firmware_count_func '$1' START"
 #Requires SVCNAME
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "testzero $PPID F null" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID F null" ] && {
  echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log
  return 2; }
[ "$DEBUG" ] && echo "DBG check_firmware_count_func '$1' REPLY='$REPLAY' END"
 return `echo "$REPLY" | cut -f 1 -d ' '`
}

check_entity_claimed_func() {
[ "$DEBUG" ] && echo "DBG check_entity_claimed_func '$1' START"
 #Requires OPTION, SVCNAME, and argument:  M(odule), F(irmeare), S(nd-card), D(evice_major_number), L(ock).
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "check $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 rm /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
 echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log
 return 2; }
[ "$DEBUG" ] && echo "DBG check_entity_claimed_func '$1' REPLY='$REPLAY' END"
 return `echo "$REPLY" | cut -f 1 -d ' '`
}


### Resume main line ###
#set -x
case $OPTION in

 module=* )
  [ "$DEBUG" ] && echo "DBG option module=\\* new START"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  [ $? -eq 0 ] || { echo 'DBG returncode -ne 0';exit 1; }
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
   && claim_resource_entity_func U
  [ "$DEBUG" ] && echo "DBG option new module= END"
  exit 0
  ;;

 --module=*)
  [ "$DEBUG" ] && echo "DBG OPTION='$OPTION' --module=\* START"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  retVal_CREF_M=$?
  [ "$DEBUG" ] && echo "DBG retVal_CREF_M='$retVal_CREF_M'"
  #[ $? -eq 0 ] || { echo 'returncode of --module=* -ne 0';exit 1; }
  #[ "$retVal_CREF_M" -eq 0 ] || { echo 'returncode of --module=* -ne 0';exit 1; }
  if [ "$retVal_CREF_M" -ne 0 ] ; then
  [ "$DEBUG" ] && echo 'DBG returncode of --module=* -ne 0'
  exit 1
  fi
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  [ "$DEBUG" ] && echo "DBG altMODULE='$altMODULE'"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  [ "$DEBUG" ] && echo "DBG FPATTERN='$FPATTERN'"
  #grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
  # && claim_resource_entity_func U
   if [ -n "`grep -E "$FPATTERN" /lib/modules/$(uname -r)/modules.dep 2>/dev/null | grep '/usbserial\.ko' | cut -f 1 -d : | grep -E "$FPATTERN"`" ] ; then ##TODO -n or -z ??
   [ "$DEBUG" ] && echo "DBG $0 running CREF_U for usbserial found\?"
   claim_resource_entity_func U
   [ "$DEBUG" ] && echo "DBG $0 finished CREF_U for usbserial found\?"
   fi
  [ "$DEBUG" ] && echo "DBG '$?'"
  [ "$DEBUG" ] && echo "DBG OPTION='$OPTION' --module=\* END ; exit 0"
  exit 0
  ;;

 --replacedmod=*)
  [ "$DEBUG" ] && echo "DBG $0 --replacedmod=\\* START"
  claim_resource_entity_func R
  [ "$DEBUG" ] && echo "DBG $0 --replacedmod=\\* END ; exit 0"
  exit 0
  ;;

 --modcheck=usbserial)
  [ "$DEBUG" ] && echo "DBG $0 --modcheck=usbserial START"
  [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
  RESOURCE="U"
  ENTITY="usbserial"
  MAXRETRIES=60; RETRIES=0
  while true;do
   [ $RETRIES -ge $MAXRETRIES ] && break
   echo "checkgroup $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
   read REPLY </tmp/${SVCNAME}_pipe-$PPID
#   echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
   [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] && {
    echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log
    STATUS=1;break; }
   STATUS=`echo "$REPLY" | cut -f 1 -d ' '`
   [ $STATUS -eq 0 ] && break
   RETRIES=`expr $RETRIES + 1`
   sleep 1
  done
  rm /tmp/${SVCNAME}_pipe-$PPID
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Loading of usbserial-dependent module(s) timed out after 1 minute" >> /tmp/${SVCNAME}.log
   [ "$DEBUG" ] && echo "DBG $0 --modcheck=usbserial exiting 1"
   exit 1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Loading of usbserial-dependent module(s) required wait of $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  [ "$DEBUG" ] && echo "DBG $0 --modcheck=usbserial END ; exit '$STATUS'"
  exit $STATUS
  ;;

 --modcheck=*)
  [ "$DEBUG" ] && echo "DBG $0 --modcheck=\\* START"
  ENTITY="" #make visible here
  check_entity_claimed_func M || { echo 'DBG returncode -ne 0';exit 1; }
  [ "`lsmod | grep "^$ENTITY "`" ] && { echo "DBG $ENTITY already loaded ;exit '0'";exit 0; }
  check_entity_claimed_func R && { echo 'DBG finished check_entity_claimed_func ;exit 0';exit 0; }
  sleep 1
  MAXRETRIES=60; RETRIES=1
  while [ "`lsmod | grep "^$ENTITY "`" = "" ];do
   [ $RETRIES -ge $MAXRETRIES ] && break
   RETRIES=`expr $RETRIES + 1`
   sleep 1
  done
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Loading of module '$ENTITY' timed out after 1 minute" >> /tmp/${SVCNAME}.log
   [ "$DEBUG" ] && echo "DBG $0 exiting 1"
   exit 1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Loading of module '$ENTITY' required wait of $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  [ "$DEBUG" ] && echo "DBG $0 --modcheck=\\* END ; exit 0"
  exit 0
  ;;

 --firmware=*)
  [ "$DEBUG" ] && echo "DBG $0 --firmware=\\* START"
  claim_resource_entity_func F
  retValCREF_F=$?
  [ "$DEBUG" ] && echo "DBG $0 --firmware=\\* END ; returnvalue='$retValCREF_F'"
  exit $retValCREF_F
  ;;

 --fwdone)
  [ "$DEBUG" ] && echo "DBG $0 --fwdone START"
  echo "decrement $PPID F null" >/tmp/${SVCNAME}_pipe
  [ "$DEBUG" ] && echo "DBG $0 --fwdone END ; exit 0"
  exit 0
  ;;

 --fwcomplete)
  [ "$DEBUG" ] && echo "DBG $0 --fwcomplete START"
  MAXRETRIES=60;   RETRIES=0
  while [ -e /tmp/.usb_modeswitch_active ] \
    || ! check_firmware_count_func;do
   [ "$RETRIES" -ge "$MAXRETRIES" ] && break
   sleep 1; RETRIES=`expr $RETRIES + 1`
  done
  rm -f /tmp/${SVCNAME}_pipe-$PPID
  if [ "$RETRIES" -ge "$MAXRETRIES" ];then
   echo "ERROR ($PPID): Firmware/modeswitch completion timeout after 1 minute" >> /tmp/${SVCNAME}.log
   rm -f /tmp/.usb_modeswitch_active
   [ "$DEBUG" ] && echo "DBG $0 --fwcomplete exiting '1' ..."
   exit 1
  elif [ "$RETRIES" -gt 0 ];then
   echo "DEBUG ($PPID): Firmware/modeswitch completion test waited $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  [ "$DEBUG" ] && echo "DBG $0 --fwcomplete END ; exit 0"
  exit 0
  ;;

 --snd_card_number=*)
  [ "$DEBUG" ] && echo "DBG $0 --snd_card_number=\\* START"
  claim_resource_entity_func S
  retValCREF_S=$?
  [ "$DEBUG" ] && echo "DBG $0 --snd_card_number=\\* END ; exit '$retValCREF_S"
  exit $retValCREF_S
  ;;

 --device_major_number=*)
  [ "$DEBUG" ] && echo "DBG $0 --device_major_number=\\* START"
  claim_resource_entity_func D
  retValCREF_D=$?
  [ "$DEBUG" ] && echo "DBG $0 --device_major_number=\\* END ; exit '$retValCREF_D'"
  exit $retValCREF_D
  ;;

 --lock=*)
  [ "$DEBUG" ] && echo "DBG $0 --lock=\\* START"
  ENTITY="" #make visible here
  MAXRETRIES=60;   RETRIES=0
  while ! claim_resource_entity_func L;do
   [ $RETRIES -ge $MAXRETRIES ] && break
   sleep 1; RETRIES=`expr $RETRIES + 1`
  done
  rm /tmp/${SVCNAME}_pipe-$PPID
  STATUS=0
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Lock timeout after 1 minute for lock $ENTITY" >> /tmp/${SVCNAME}.log
   STATUS=1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Lock retried for $RETRIES seconds for $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
  fi
  [ "$DEBUG" ] && echo "DBG $0 --lock=\\* END ; exit '$STATUS'"
  exit $STATUS
  ;;

 --unlock=*)

  [ "$DEBUG" ] && echo "DBG $0 --unlock=\\* START"

  ENTITY="`echo "$OPTION" | grep '=' | cut -f 2 -d '='`"
  [ "$ENTITY" != "" ] && echo "delete $PPID L $ENTITY" >/tmp/${SVCNAME}_pipe
  [ "$DEBUG" ] && echo "DBG $0 --unlock=\\* END ; exit 0"
  exit 0
  ;;

 --help)
  cat 1>&2 << EOT

Usage: `basename $0` option

Only one of the following options is required:
  --module=<module-name>         Prevent redundant loading of module (by backend_modprobe)
  --modcheck=<module-name>       Verify module completed loading (for initialization scripts)
  --modcheck=usbserial       Verify all usbserial-dependent modules completed loading (for initialization scripts)
  --firmware=<firmware-tarball-name> Prevent redundant installation of firmware (by backend_modprobe)
  --fwdone                       One firmware installation finished - decrement firmware counter
  --fwcomplete                   Wait until all firmware installation is completed
  --snd_card_number=<number>     Reserve sound car number (0 - 10) (by backend_modprobe)
  --device_major_number=<number> Reserve major number (240-251) (by modem firmware)
  --lock=<name>                  Temporarily lock object to serialize access
  --unlock=<name>                Unlock locked object
  --done                         Remove the automatically created named pipe used to communicate with the daemon
  --daemon                       Start the lock-manager daemon (by rc.sysinit)
  --stop                         terminate the daemon
  --dump                         Log current reserved/locked entities
  --help                         This small usage guide

EOT
  ;;

 --dump)
  [ "`ps -C pup_event_backend_modprobe_protect | grep -c ''`" -gt 3 ] || exit 1
  [ -p /tmp/${SVCNAME}_pipe-$PPID ] || mkfifo /tmp/${SVCNAME}_pipe-$PPID
  echo "dump $PPID" >/tmp/${SVCNAME}_pipe
  read REPLY </tmp/${SVCNAME}_pipe-$PPID
  rm /tmp/${SVCNAME}_pipe-$PPID
  [ "`echo "$REPLY" | cut -f 2 -d ' '`" != "$PPID" ] && {
   echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log
   exit 2; }
  ;;

 --stop)
  #echo "quit" >/tmp/${SVCNAME}_pipe
  ##+++2012-01-26
  echo "quit" >/tmp/${SVCNAME}_pipe &
  ##exit $?
  ##/
  ;;

 --daemon)
  #Inpipe request syntax: action PID resource entity
  # action: add delete decrement testzero check checkgroup help dump quit
  # resource: M R U F S D L
  # entity: modulename firmwarename number text-string
  #ps |grep "$SVCNAME $OPTION";echo '#'
  #ps |grep "$SVCNAME $OPTION" |grep -vE "$$|grep";echo '#'
  grepOPTION="${OPTION//-/\\-}";[ "$DEBUG" ] && echo "DBG $0 grepOPTION='$grepOPTION'"
  #echo PS_PERSONALITY=$PS_PERSONALITY
  #unset PS_PERSONALITY
  #echo PS_PERSONALITY=$PS_PERSONALITY
  #echo '$$='$$
  pid=$$
  #otherSVCNAMES=`busybox ps | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`
  #otherSVCNAMES=`ps -A | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`
  otherSVCNAMES=`ps -A`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep "$SVCNAME"`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep "$grepOPTION"`
  otherSVCNAMES=`echo "$otherSVCNAMES" | grep -vE "$pid|grep"`
  #if [ "QUIRK $(ps -A | grep "$SVCNAME" | grep "$grepOPTION" | grep -v "$pid" | grep -v 'grep' |tr -d '[[:blank:]]')" != "QUIRK " ];then # && exit 140
  # if [ "`ps -A | grep "${SVCNAME}.*${grepOPTION}" | grep -vE "$pid|grep"`" != "" ];then
  if [ "$otherSVCNAMES" ];then
   #echo '$$='$$
   #echo "'$(ps | grep "$SVCNAME" | grep "$grepOPTION" | grep -vE "$$|grep" |tr -d '[[:blank:]]')'"
   #echo "'$(ps -A --forest| grep "$SVCNAME" | grep "$grepOPTION" | grep -vE "$$|grep" |tr -d '[[:blank:]]')'"
   [ "$DEBUG" ] && echo "DBG $0 @will now exit@"
   exit 140
  fi

  [ ! -p /tmp/${SVCNAME}_pipe ] && mkfifo /tmp/${SVCNAME}_pipe
  trap "rm -f /tmp/${SVCNAME}_pipe; exit" INT TERM EXIT
  KERNVER="`uname -r`"
  LISTM=" "; LISTR=" "; LISTU=" "; LISTF=" "; LISTS=" "; LISTD=" "; LISTL=" "; LISTFNEW=""
  FILEF="/etc/modules/firmware.inst.$KERNVER"
  [ -s $FILEF ] && { LISTF=" `cat $FILEF | tr '\n' ' '` "
  LISTF="`echo -n "$LISTF" | tr -s ' '`"; }
  COUNTF=0

function restore_main_pipe(){
while [ 1 ];do
[ -p  /tmp/${SVCNAME}_pipe ] || mkfifo /tmp/${SVCNAME}_pipe
sleep 3
done
}
#restore_main_pipe &
function restore_program(){
while [ 1 ];do
if [ ! -p /tmp/${SVCNAME}_pipe ];then
killall $SVCNAME
sleep 2
DEBUG=$DEBUG $SVCNAME --daemon &
fi
sleep 3
done
}
#restore_program &
function escape_cat(){
while [ 1 ];do
if [ ! -p /tmp/${SVCNAME}_pipe ];then
killall $SVCNAME
exit 1
fi
sleep 3
done
}
escape_cat &


  #while true; do
   while [ -e  /tmp/${SVCNAME}_pipe ];do
   [ "$DEBUG" ] && echo 'DBG true 1'
   #REQUESTS="`cat </tmp/${SVCNAME}_pipe`"
   REQUESTS=$(</tmp/${SVCNAME}_pipe)
   [ "$DEBUG" ] && echo "REQUESTS:
$REQUESTS"
   while true;do
    [ "$DEBUG" ] && echo 'DBG true 2'
    REQUEST="`echo "$REQUESTS" | head -n 1`"
    [ "$DEBUG" ] && echo "REQUEST=$REQUEST"
    read ACTION CLIENTID RESOURCE ENTITY <<<$REQUEST
    RVRQ="$?";[ "$DEBUG" ] && echo RVRQ=$RVRQ
    #[ "$ACTION" = "" -o $? -ne 0 ] && break
    #[ $? -ne 0 -o "$ACTION" = "" ] && break
    if [ "$RVRQ" != '0' -o "$ACTION" = "" ];then
    [ "$DEBUG" ] && echo 'breaking true 2'
    break;fi
    REQUESTS="`echo "$REQUESTS" | sed 1d`"
    case $ACTION in
     add)
      LIST="LIST$RESOURCE"
      #LIST="$LIST$RESOURCE"
      if [ "`echo "${!LIST}" | grep -w "${ENTITY}"`" ];then
       STATUS=1
       [ "$RESOURCE" != "L" -a "$RESOURCE" != "R" ] && echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID REJECTED for resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      else
       STATUS=0
       case $RESOURCE in
        M)
         LISTM="$LISTM$ENTITY "
        ;;
        R)
         LISTR="$LISTR$ENTITY "
        ;;
        U)
         LISTU="$LISTU$ENTITY "
         ;;
        F)
         if [ "`echo "$LISTL" | grep -w 'firmwareinst'`" ];then
          LISTFNEW="${LISTFNEW}$ENTITY "
         else
          LISTF="${LISTF}$ENTITY "
          echo -n "$LISTF" | tr ' ' '\n' > ${FILEF}
         fi
         COUNTF=`expr $COUNTF + 1`
         ;;
        S)
         LISTS="${!LIST}$ENTITY "
         ;;
        D)
         LISTD="${!LIST}$ENTITY "
         ;;
        L)
         LISTL="${!LIST}$ENTITY "
         ;;
        *)
        echo "  DEBUG (daemon): Invalid RESOURCE: $RESOURCE" >> /tmp/${SVCNAME}.log
         ;;
       esac #END RESOURCE
       echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID GRANTED for resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     delete)
      SEDSCRIPT="s/ ${ENTITY} / /"
      LISTL="`echo -n "$LISTL" | sed -e "$SEDSCRIPT"`"
      if [ "$ENTITY" = "firmwareinst" ];then
       LISTF=" `cat /etc/modules/firmware.inst.${KERNVER} | tr '\n' ' '` $LISTFNEW"
       LISTF="`echo -n "$LISTF" | tr -s ' '`"
       [ "$LISTFNEW" ] && { echo -n "$LISTF" | tr ' ' '\n' > ${FILEF}
       LISTFNEW=""; }
      fi
      echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID FREED resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      ;;
     decrement)
      [ "$RESOURCE" = "F" ] && COUNTF=`expr $COUNTF - 1`
      ;;
     testzero)
      if [ "$RESOURCE" != "F" -o $COUNTF -le 0 ];then
       STATUS=0
       else STATUS=1;fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     check)
      LIST="LIST$RESOURCE"
      if [ "`echo "${!LIST}" | grep -w "${ENTITY}"`" ];then
       STATUS=0
      else STATUS=1;fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     checkgroup)
      STATUS=0
      if [ "$RESOURCE" = "U" -a "$ENTITY" = "usbserial" ];then
       REPLIST="`echo "$LISTR" | tr ' ' '\n' | sed /^$/d`"
       USLIST="`echo "$LISTU" | tr ' ' '\n' | sed /^$/d | sort -u`"
       [ "$REPLIST" != "" ] && USLIST="`echo "$USLIST" | grep -v -w -F "$REPLIST"`"
       LSMODSTRG="`lsmod | cut -f 1 -d ' ' | grep -F -w "$USLIST" | sort -u | tr '\n' ' '`"
       USSTRG="`echo "$USLIST" | tr '\n' ' '`"
       [ "$LSMODSTRG" != "$USSTRG" ] && STATUS=1
#       echo -e "DEBUG ($PPID): REPLIST: $REPLIST  USLIST: $USLIST\nLSMODSTRG: $LSMODSTRG\nUSSTRG: $USSTRG" >> /tmp/${SVCNAME}.log   #DEBUG
      fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     dump)
      echo -e "SUMMARY (daemon):\nLoaded modules: ${LISTM}\nReplaced modules: ${LISTR}\nUsbserial-dependent modules: ${LISTU}\nInstalled firmware: ${LISTF}\nUsed sound card numbers: ${LISTS}\nUsed 'experimental' device major numbers: ${LISTD}\nLocked files or other entities: ${LISTL}\nFirmware installation count: $COUNTF" >> /tmp/${SVCNAME}.log
      echo -e "Pending request processes:\n`ps aux | grep 'backend_modprobe_protect --' | grep -v ' grep ' | grep -v '\--daemon' | grep -v '\--dump' | tr -s ' ' | cut -f 2,13 -d ' '`" >> /tmp/${SVCNAME}.log
      sync
      echo "0 $CLIENTID" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     quit)
      exit
      ;;
     *)
      echo "  DEBUG (daemon): Invalid action '$ACTION'" >> /tmp/${SVCNAME}.log
      ;;
    esac
   done
   ##END true
  done
  ##END true
   ;;
##END --daemon

 *)
  echo "DEBUG ($PPID): Invalid option '$OPTION'" >> /tmp/${SVCNAME}.log  # Should not be executed.
  ;;
esac
exit 0

##### END ######
