#!/bin/sh
#Serializes access to the backend_modprobe protect_data file by processing gate-keeping requests for particular resources and entities. Databases are maintained internally and in some cases written to a file.  Takes input from single named pipe and returns status in caller-created pipe:
# 0 = first claimer, OK to process for entity
# 1 - not first, abort processing of entity.


if [ -n "$1" ] && [ "$1" != "--daemon" ] && [ -z "`/bin/ps -elF | grep 'pup_event_backend_modprobe_protect \-\-daemon' | grep -v 'grep'`" ] ; then
pup_event_backend_modprobe_protect --daemon &
sleep 2s
fi

OK='0'
ERROR_ALL='1'
QUIT='9'
END='99'
OPTION_INVALID='5'
HELP='6'

SVCNAME="pup_event_backend_modprobe_protect"
echo $SVCNAME
OPTION="$1"
echo "DBG $1='$1' OPTION='$OPTION'"
[ "$OPTION" = "" ] && OPTION="--help"
if [ "$OPTION" != "--help" ];then
 [ ! -p /tmp/${SVCNAME}_pipe ] && mkfifo /tmp/${SVCNAME}_pipe
fi


claim_resource_entity_func() {
echo DBG claim_resource_entity_func START $1
 #Requires OPTION, SVCNAME, and argument:  M(odule), R(eplaced module), U(sbserial dependent), F(irmware), S(nd-card), D(evice_major_number), L(ock).
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "add $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 [ "$RESOURCE" != "L" ] && rm /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] \
  && echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log \
  && return 2
 echo DBG claim_resource_entity_func END 
 return `echo "$REPLY" | cut -f 1 -d ' '`
#echo DBG claim_resource_entity_func END
}

check_firmware_count_func() {
 #Requires SVCNAME
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "testzero $PPID F null" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID F null" ] \
  && echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log \
  && return 2
 return `echo "$REPLY" | cut -f 1 -d ' '`
}

check_entity_claimed_func() {
 #Requires OPTION, SVCNAME, and argument:  M(odule), F(irmeare), S(nd-card), D(evice_major_number), L(ock).
 [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
 RESOURCE="$1"
 ENTITY="`echo "$OPTION" | cut -f 2 -d '='`"
#  echo "DEBUG ($PPID): Request PPID: $PPID  RESOURCE: $RESOURCE ENTITY: $ENTITY" >> /tmp/${SVCNAME}.log #debug
 echo "check $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
 read REPLY </tmp/${SVCNAME}_pipe-$PPID
#  echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
 rm /tmp/${SVCNAME}_pipe-$PPID
 [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] \
  && echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log \
  && return 2
 return `echo "$REPLY" | cut -f 1 -d ' '`
}


### Resume main line ###

case $OPTION in
 module=*)
  echo "DBG option module=\* new START"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  [ $? -eq 0 ] || exit 1
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
   && claim_resource_entity_func U
  echo "DBG option module=\* new END"
  exit 0
  ;;


 --module=*)
  echo "DBG option module=\* START"
  ENTITY="" #make visible here
  claim_resource_entity_func M
  [ $? -eq 0 ] || exit 1
  altMODULE="`echo -n "$ENTITY" | tr '_' '-'`"
  FPATTERN='/'"${ENTITY}"'\.ko|/'"${altMODULE}"'\.ko'
  grep -E "$FPATTERN" /lib/modules/`uname -r`/modules.dep | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
   && claim_resource_entity_func U
  echo "DBG option module=\* END"
  exit 0
  ;;
 --replacedmod=*)
  claim_resource_entity_func R
  exit 0
  ;;
 --modcheck=usbserial)
  [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
  RESOURCE="U"
  ENTITY="usbserial"
  MAXRETRIES=60; RETRIES=0
  while true;do
   [ $RETRIES -ge $MAXRETRIES ] && break
   echo "checkgroup $PPID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe
   read REPLY </tmp/${SVCNAME}_pipe-$PPID
#   echo "DEBUG ($PPID): REPLY: $REPLY" >> /tmp/${SVCNAME}.log #debug
   [ "`echo "$REPLY" | cut -f 2-4 -d ' '`" != "$PPID $RESOURCE $ENTITY" ] \
    && echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log \
    && STATUS=1 \
    && break
   STATUS=`echo "$REPLY" | cut -f 1 -d ' '`
   [ $STATUS -eq 0 ] && break
   RETRIES=`expr $RETRIES + 1`
   sleep 1
  done
  rm /tmp/${SVCNAME}_pipe-$PPID
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Loading of usbserial-dependent module(s) timed out after 1 minute" >> /tmp/${SVCNAME}.log
   exit 1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Loading of usbserial-dependent module(s) required wait of $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  exit $STATUS
  ;;
 --modcheck=*)
  ENTITY="" #make visible here
  check_entity_claimed_func M || exit 1
  [ "`lsmod | grep "^$ENTITY "`" != "" ] && exit 0
  check_entity_claimed_func R && exit 0
  sleep 1
  MAXRETRIES=60; RETRIES=1
  while [ "`lsmod | grep "^$ENTITY "`" = "" ];do
   [ $RETRIES -ge $MAXRETRIES ] && break
   RETRIES=`expr $RETRIES + 1`
   sleep 1
  done
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Loading of module '$ENTITY' timed out after 1 minute" >> /tmp/${SVCNAME}.log
   exit 1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Loading of module '$ENTITY' required wait of $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  exit 0
  ;;
 --firmware=*)
  claim_resource_entity_func F
  exit $?
  ;;
 --fwdone)
  echo "decrement $PPID F null" >/tmp/${SVCNAME}_pipe
  exit 0
  ;;
 --fwcomplete)
  MAXRETRIES=60;   RETRIES=0
  while [ -e /tmp/.usb_modeswitch_active ] \
    || ! check_firmware_count_func;do
   [ "$RETRIES" -ge "$MAXRETRIES" ] && break
   sleep 1; RETRIES=`expr $RETRIES + 1`
  done
  rm -f /tmp/${SVCNAME}_pipe-$PPID
  if [ "$RETRIES" -ge "$MAXRETRIES" ];then
   echo "ERROR ($PPID): Firmware/modeswitch completion timeout after 1 minute" >> /tmp/${SVCNAME}.log
   rm -f /tmp/.usb_modeswitch_active
   exit 1
  elif [ "$RETRIES" -gt 0 ];then
   echo "DEBUG ($PPID): Firmware/modeswitch completion test waited $RETRIES seconds" >> /tmp/${SVCNAME}.log
  fi
  exit 0
  ;;
 --snd_card_number=*)
  claim_resource_entity_func S
  exit $?
  ;;
 --device_major_number=*)
  claim_resource_entity_func D
  exit $?
  ;;
 --lock=*)
  ENTITY="" #make visible here
  MAXRETRIES=60;   RETRIES=0
  while ! claim_resource_entity_func L;do
   [ $RETRIES -ge $MAXRETRIES ] && break
   sleep 1; RETRIES=`expr $RETRIES + 1`
  done
  rm /tmp/${SVCNAME}_pipe-$PPID
  STATUS=0
  if [ $RETRIES -ge $MAXRETRIES ];then
   echo "ERROR ($PPID): Lock timeout after 1 minute for lock $ENTITY" >> /tmp/${SVCNAME}.log
   STATUS=1
  elif [ $RETRIES -gt 0 ];then
   echo "DEBUG ($PPID): Lock retried for $RETRIES seconds for $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
  fi
  exit $STATUS
  ;;
 --unlock=*)
  ENTITY="`echo "$OPTION" | grep '=' | cut -f 2 -d '='`"
  [ "$ENTITY" != "" ] \
   && echo "delete $PPID L $ENTITY" >/tmp/${SVCNAME}_pipe
  exit 0
  ;;
 --dump)
  [ `ps -C pup_event_backend_modprobe_protect | grep -c ''` -gt 3 ] \
   || exit 1
  [ ! -p /tmp/${SVCNAME}_pipe-$PPID ] && mkfifo /tmp/${SVCNAME}_pipe-$PPID
  echo "dump $PPID" >/tmp/${SVCNAME}_pipe
  read REPLY </tmp/${SVCNAME}_pipe-$PPID
  rm /tmp/${SVCNAME}_pipe-$PPID
  [ "`echo "$REPLY" | cut -f 2 -d ' '`" != "$PPID" ] \
   && echo "ERROR ($PPID): Invalid reply from daemon'  REPLY: '$REPLY'" >> /tmp/${SVCNAME}.log \
   && exit 2
   exit $OK  ##++2011-11-10
  ;;
 --stop)
 
  if [ -n "`/bin/ps-FULL -C "$SVCNAME" | sed '1 d'`" ] ; then  ##+++2011-11-10 added if check
  echo "quit" >/tmp/${SVCNAME}_pipe & ##+2011-11-10 added '&' to prvent program hang
  ##2011-11-10 remark : echo > pipe does not delete the entry(s) in the pipe but gets added
  ##2011-11-10 remark : underneath the last entry
  ##2011-11-10 remark : BUT echo > hangs if already one enrty
  ##2011-11-10 remark : echo > & lets the program continue
  ##2011-11-10 remark : killall pup_event_backend_modprobe_protect also deleted the pipe ???? huch ????
  fi
  exit $QUIT  ##++2011-11-10
  ;;
 --daemon)
  #Inpipe request syntax: action PID resource entity
  # action: add delete decrement testzero check checkgroup help dump quit
  # resource: M R U F S D L
  # entity: modulename firmwarename number text-string
  trap "rm -f /tmp/${SVCNAME}_pipe; exit" INT TERM EXIT
  KERNVER="`uname -r`"
  LISTM=" "; LISTR=" "; LISTU=" "; LISTF=" "; LISTS=" "; LISTD=" "; LISTL=" "; LISTFNEW=""
  FILEF="/etc/modules/firmware.inst.$KERNVER"
  [ -s $FILEF ] \
   && LISTF=" `cat $FILEF | tr '\n' ' '` " \
   && LISTF="`echo -n "$LISTF" | tr -s ' '`"
  COUNTF=0
  
  while true; do
   REQUESTS="`cat </tmp/${SVCNAME}_pipe`"
   while true;do
    REQUEST="`echo "$REQUESTS" | head -n 1`"
    read ACTION CLIENTID RESOURCE ENTITY <<<$REQUEST
    [ "$ACTION" = "" -o $? -ne 0 ] && break
    REQUESTS="`echo "$REQUESTS" | sed 1d`"
    case $ACTION in
     add)
      LIST="LIST$RESOURCE"
      if [ "`echo "${!LIST}" | grep -w "${ENTITY}"`" != "" ];then
       STATUS=1
       [ "$RESOURCE" != "L" -a "$RESOURCE" != "R" ] \
        && echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID REJECTED for resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      else
       STATUS=0
       case $RESOURCE in
        M)
         LISTM="$LISTM$ENTITY "
        ;;
        R)
         LISTR="$LISTR$ENTITY "
        ;;
        U)
         LISTU="$LISTU$ENTITY "
         ;;
        F)
         if [ "`echo "$LISTL" | grep -w 'firmwareinst'`" != "" ];then
          LISTFNEW="${LISTFNEW}$ENTITY "
         else
          LISTF="${LISTF}$ENTITY "
          echo -n "$LISTF" | tr ' ' '\n' > ${FILEF}
         fi
         COUNTF=`expr $COUNTF + 1`
         ;;
        S)
         LISTS="${!LIST}$ENTITY "
         ;;
        D)
         LISTD="${!LIST}$ENTITY "
         ;;
        L)
         LISTL="${!LIST}$ENTITY "
         ;;
        *)
        echo "  DEBUG (daemon): Invalid RESOURCE: $RESOURCE" >> /tmp/${SVCNAME}.log
         ;;
       esac
       echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID GRANTED for resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     delete)
      SEDSCRIPT="s/ ${ENTITY} / /"
      LISTL="`echo -n "$LISTL" | sed -e "$SEDSCRIPT"`"
      if [ "$ENTITY" = "firmwareinst" ];then
       LISTF=" `cat /etc/modules/firmware.inst.${KERNVER} | tr '\n' ' '` $LISTFNEW"
       LISTF="`echo -n "$LISTF" | tr -s ' '`"
       [ "$LISTFNEW" != "" ] \
        && echo -n "$LISTF" | tr ' ' '\n' > ${FILEF} \
        && LISTFNEW=""
      fi
      echo "`date | tr -s ' ' | cut -f 4 -d ' '` Request from PID $CLIENTID FREED resource $RESOURCE $ENTITY" >> /tmp/${SVCNAME}.log
      ;;
     decrement)
      [ "$RESOURCE" = "F" ] \
       && COUNTF=`expr $COUNTF - 1`
      ;;
     testzero)
      [ "$RESOURCE" != "F" -o $COUNTF -le 0 ] \
       && STATUS=0 \
       || STATUS=1
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     check)
      LIST="LIST$RESOURCE"
      [ "`echo "${!LIST}" | grep -w "${ENTITY}"`" != "" ] \
       && STATUS=0 \
       || STATUS=1
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     checkgroup)
      STATUS=0
      if [ "$RESOURCE" = "U" -a "$ENTITY" = "usbserial" ];then
       REPLIST="`echo "$LISTR" | tr ' ' '\n' | sed /^$/d`"
       USLIST="`echo "$LISTU" | tr ' ' '\n' | sed /^$/d | sort -u`"
       [ "$REPLIST" != "" ] \
        && USLIST="`echo "$USLIST" | grep -v -w -F "$REPLIST"`"
       LSMODSTRG="`lsmod | cut -f 1 -d ' ' | grep -F -w "$USLIST" | sort -u | tr '\n' ' '`"
       USSTRG="`echo "$USLIST" | tr '\n' ' '`"
       [ "$LSMODSTRG" != "$USSTRG" ] && STATUS=1
#       echo -e "DEBUG ($PPID): REPLIST: $REPLIST  USLIST: $USLIST\nLSMODSTRG: $LSMODSTRG\nUSSTRG: $USSTRG" >> /tmp/${SVCNAME}.log   #DEBUG
      fi
      echo "$STATUS $CLIENTID $RESOURCE $ENTITY" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     dump)
      echo -e "SUMMARY (daemon):\nLoaded modules: ${LISTM}\nReplaced modules: ${LISTR}\nUsbserial-dependent modules: ${LISTU}\nInstalled firmware: ${LISTF}\nUsed sound card numbers: ${LISTS}\nUsed 'experimental' device major numbers: ${LISTD}\nLocked files or other entities: ${LISTL}\nFirmware installation count: $COUNTF" >> /tmp/${SVCNAME}.log
      echo -e "Pending request processes:\n`ps aux | grep 'backend_modprobe_protect --' | grep -v ' grep ' | grep -v '\--daemon' | grep -v '\--dump' | tr -s ' ' | cut -f 2,13 -d ' '`" >> /tmp/${SVCNAME}.log
      sync
      echo "0 $CLIENTID" >/tmp/${SVCNAME}_pipe-$CLIENTID
      ;;
     quit)
      rm -f /tmp/${SVCNAME}_pipe  ##+++2011-11-10 
      rm -f /tmp/${SVCNAME}_pipe* ##+++2011-11-10 
      exit $QUIT ##+2011-11-10 added $QUIT
      ;;
     *)
      echo "  DEBUG (daemon): Invalid action '$ACTION'" >> /tmp/${SVCNAME}.log
      ;;
    esac
   done
  done
  ;;
--help)
  cat 1>&2 << EOT

Usage: `basename $0` option

Only one of the following options is required:
  --module=<module-name>         Prevent redundant loading of module (by backend_modprobe)
  --modcheck=<module-name>       Verify module completed loading (for initialization scripts)
  --modcheck=usbserial       Verify all usbserial-dependent modules completed loading (for initialization scripts)
  --firmware=<firmware-tarball-name> Prevent redundant installation of firmware (by backend_modprobe)
  --fwdone                       One firmware installation finished - decrement firmware counter
  --fwcomplete                   Wait until all firmware installation is completed
  --snd_card_number=<number>     Reserve sound car number (0 - 10) (by backend_modprobe)
  --device_major_number=<number> Reserve major number (240-251) (by modem firmware)
  --lock=<name>                  Temporarily lock object to serialize access
  --unlock=<name>                Unlock locked object
  --done                         Remove the automatically created named pipe used to communicate with the daemon
  --daemon                       Start the lock-manager daemon (by rc.sysinit)
  --stop                         terminate the daemon
  --dump                         Log current reserved/locked entities
  --help                         This small usage guide
  
EOT
exit $HELP##+2011-11-10
  ;;
 *)
  echo "DEBUG ($PPID): Invalid option '$OPTION'" >> /tmp/${SVCNAME}.log  # Should not be executed.
  echo "($SVCNAME): Invalid option '$OPTION' :: TRY '--help'"  ##+2011-11-10
  if [ -n "`/bin/ps-FULL -C "$SVCNAME" | sed '1 d'`" ] ; then  ##+++2011-11-10 added if check
  echo "quit" >/tmp/${SVCNAME}_pipe & ##+2011-11-10 added '&' to prvent program hang
  ##2011-11-10 remark : echo > pipe does not delete the entry(s) in the pipe but gets added
  ##2011-11-10 remark : underneath the last entry
  ##2011-11-10 remark : BUT echo > hangs if already one enrty
  ##2011-11-10 remark : echo > & lets the program continue
  ##2011-11-10 remark : killall pup_event_backend_modprobe_protect also deleted the pipe ???? huch ????
  fi
  exit $OPTION_INVALID  ##+2011-11-10
  ;;

esac
exit $END  ##+2011-11-10 changed '0' to $END

##### END ######
