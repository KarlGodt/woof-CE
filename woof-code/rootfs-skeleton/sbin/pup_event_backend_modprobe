#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#called via udev rule /etc/udev/rules.d/50-udev-puppy-basic.rules
#i pulled this code out of /sbin/pup_event_backend_d, see 4.1alpha3.
#all of the uevent variables (exs: MODALIAS, SUBSYSTEM) are available here.
#v408 hack for madwifi ath_pci in 4.1retro. Alsa fix.
#w004 LANG=C, faster. /bin/ash, even faster.
#w463 rerwin: Correct override extraction of module name. Add use of optional first argument as MODULE, to support special udev rules added for hardware (modems) not automatically detected by the kernel.
#w478 support firmware in dirs, not .tar.gz tarballs.
#v424 For hybrid modem devices, select modem driver instead of storage driver when both are found by modprobe. (replaced in v432)
#v432 Remove reentrancy vulnerabiliies for 3 files, to prevent erratic preference substitution and potential multiple-ALSA setup errors.
#v432 For preferences, ensure preference found regardless of the number and order of matching modaliases.
#v432 For HSF/ALSA and hybrid modems, append appropriate preferences to ensure correct driver selected; a substitution flag is set by HSF init script.
#433 Consolidate usbserial modem scripts, using modules.dep for associations; track preference-replaced module.

export LANG=C #w004

#NOTICE: If the full 'udev' package, with utility 'udevd' is installed, rc.sysinit
#   will run 'udevd' instead of 'pup_event_backend_d' and this script will be used.

. /etc/rc.d/PUPSTATE
. /etc/rc.d/MODULESCONFIG
PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"
KERNVER="`uname -r`"

#w463 optional $1 supplied by triggered udev rule, see /etc/udev/rules.d/60-udev-modem.rules
RULEMODULE=""
[ $1 ] && RULEMODULE="$1"
touch /tmp/pup_event_module_devpath_log

[ "$FASTBOOTMODULESLIST" != "" ] && exit 1 #fastboot, see /etc/rc.d/MODULESCONFIG.

setup_alsa_func() { #uses MODULE.
 #if a sound module, preconfigure alsa (/etc/init.d/alsa will start it)...
 if [ "`echo -n "$MODULE" | grep '^snd_'`" != "" ];then
  CNTSND=0 #v432 Reserve first available card number
  while ! pup_event_backend_modprobe_protect --snd_card_number=$CNTSND;do
   CNTSND=`expr $CNTSND + 1`
   [ $CNTSND -gt 10 ] && return 1
  done
  pup_event_backend_modprobe_protect --lock=modprobeconf #v432 end
  DPATTERN="alias snd\\-card\\-$CNTSND"
  dMODULE="`echo -n "$MODULE" | tr '_' '-'`" #v407
  if [ "`grep "$DPATTERN" /etc/modprobe.conf`" = "" ];then
   echo "alias snd-card-$CNTSND $dMODULE" >> /etc/modprobe.conf
   echo "alias sound-slot-$CNTSND $dMODULE" >> /etc/modprobe.conf
  else
   #for portability, check if correct sound card...
   BPATTERN="alias snd\\-card\\-$CNTSND $dMODULE" #v408
   if [ "`grep "$BPATTERN" /etc/modprobe.conf`" = "" ];then
    SEDSCRIPT1="s/^\\(alias\\ snd\\-card\\-$CNTSND\\ \\).*/\\1${dMODULE}/" #v432
    SEDSCRIPT2="s/^\\(alias\\ sound\\-slot\\-$CNTSND\\ \\).*/\\1${dMODULE}/" #v432
    sed -i -e "$SEDSCRIPT1" -e "$SEDSCRIPT2" /etc/modprobe.conf #v432
   fi
  fi
  pup_event_backend_modprobe_protect --unlock=modprobeconf #v432
 fi
}

pci_fixup_func() { #w463 needs MODALIAS, MODULE, RULEMODULE
 #returns 0 if ok to load module, changes MODULE if required.
 VENDOR='0x'"`echo -n "$MODALIAS" | cut -f 2 -d 'v' | cut -b 1-8 | tr [A-Z] [a-z]`"
 DEVICE='0x'"`echo -n "$MODALIAS" | cut -f 2 -d 'v' | cut -b 10-17 | tr [A-Z] [a-z]`"
 #######/etc/rc.d/MODULESCONFIG overrides######
 #may need to do substitution for specific pci interface...
 APATTERN="$VENDOR $DEVICE"
 REPLACEMENT="`echo "$PCI_OVERRIDES" | grep "$APATTERN"`"
 #w463 replace only if not already forced by udev rule...
 #v432 add blacklist of drivers for specific hardware.
 if [ "$REPLACEMENT" != "" ] && [ "$RULEMODULE" = "" ];then
  REPLACEMENT="`echo "$REPLACEMENT" | cut -f 1 -d ' '`"
  [ "$REPLACEMENT" != "(none)" ] \
   && MODULE="$REPLACEMENT" \
   || return 1
 fi #v432 end

 #######END MODULESCONFIG OVERRIDES#######
 ######HACKS SECTION#######
 #in some cases a special hack is required, hardcoded in here...
 #8139cp is buggy...
 [ "$MODULE" = "8139cp" ] && MODULE="8139too" \
  && ! pup_event_backend_modprobe_protect --module=$MODULE \
  && return 1 #v432
 #v2.17 another hack, mwave.ko (modem), do not load module, just the firmware,
 #as /etc/init.d/ in firmware has script that correctly loads mwave.ko...
 if [ "$MODULE" = "mwave" ];then
  firmware_module_func #modprobe -n mwave #pretend load.
  return 1
 fi
 #v2.17 intel pci numbering is peculiar, need this hack....
 if [ "$MODULE" = "ipw2200" ];then
  [ "`lspci -m -n -d 8086:1043 | cut -f 10 -d '"' | cut -b 1,2`" = "25" ] && MODULE="ipw2100" \
   && ! pup_event_backend_modprobe_protect --module=$MODULE \
   && return 1 #'geany #v432
 fi
 #v408 pup 4.1retro, k2.6.21.7, madwifi wireless, ath_pci.ko loads then
 #my pcmcia and sd-card no longer work -- no uevents from kernel. yet, if
 #I blacklist ath_pci then load it later, all is ok. So, perhaps ath_pci
 #is grabbing control of too much hardware? try a delay...
 [ "$MODULE" = "ath_pci" ] && sleep 5
 #######END HACKS SECTION#######
 #v432 Override AC97 modem module to use alternate if modem not supported by default driver.
 [ -e /etc/hsfmodem/.substitute_alternate_module ] \
  && PREFEXTRAS="${PREFEXTRAS} ${PREFHSFALSA}"
 return 0
}

firmware_module_func() {
 #global MODULE is name of module, global KERNVER.
 altMODULE="`echo -n "$MODULE" | tr '_' '-'`"
 FPATTERN='[:,]'"${MODULE}"'\.ko|[:,]'"${altMODULE}"'\.ko'
 FIRMPKG="`cat /etc/modules/firmware.dep.$KERNVER  | grep -v '^#' | grep ':' | grep -E "$FPATTERN" | cut -f 1 -d ':' | head -n 1`"
 #v433 If module is front end for usbserial, use common firmware.
 if [ "$FIRMPKG" = "" ];then
  FPATTERN='/'"${MODULE}"'\.ko|/'"${altMODULE}"'\.ko'
  cat /lib/modules/$KERNVER/modules.dep | grep -E "$FPATTERN" | grep '/usbserial.ko' | cut -f 1 -d : | grep -q -E "$FPATTERN" \
   && FIRMPKG="usbserial"
 fi #v433 end
 if [ "$FIRMPKG" != "" ];then
  #v432 Ensure firmware installed only once.
  pup_event_backend_modprobe_protect --firmware=$FIRMPKG \
   || return 0
   
  if [ -f /lib/modules/all-firmware/${FIRMPKG}.tar.gz ];then
   cp -af /lib/modules/all-firmware/${FIRMPKG}.tar.gz /tmp >/dev/null 2>&1
   cd /tmp
   tar -zxf ${FIRMPKG}.tar.gz >/dev/null 2>&1
  fi
  if [ -d /tmp/${FIRMPKG} ];then
   cp -a --remove-destination /tmp/${FIRMPKG}/* / 2>/dev/null
  fi
  #in case firmware is not a .tar.gz tarball...
  if [ -d /lib/modules/all-firmware/${FIRMPKG} ];then #w478
   cp -a --remove-destination /lib/modules/all-firmware/${FIRMPKG}/* / 2>/dev/null
  fi
  if [ -f /pinstall.${FIRMPKG}.sh ];then
   cd /
   /pinstall.${FIRMPKG}.sh >/dev/null 2>&1 #execute script.
   rm -f /pinstall.${FIRMPKG}.sh >/dev/null 2>&1
  fi
  pup_event_backend_modprobe_protect --fwdone
 fi
}

#v432 Provide for optional preferences for internal use...
PREFEXTRAS=""
#find a matching module... (/etc/pup_event_modprobe.conf created in rc.sysinit)
MODULE="`/sbin/modprobe --config /tmp/pup_event_modprobe.conf --show-depends $MODALIAS 2>/dev/null | tail -n 1 | rev | cut -f 1 -d '/' | rev | cut -f 1 -d '.' | tr '\-' '_'`"
[ "$RULEMODULE" != "" ] && [ "$MODULE" = "" -o "$MODULE" = "usb_storage" ] && MODULE="$RULEMODULE" #w463 Use module from argument
[ "$MODULE" = "" ] && exit 1
#[ "$MODULE" = "usb_storage" ] && exit 1 #loaded explicitly in boot scripts.

#v432 Ensure module procesing done only once, except for usb-storage (needed to find hybrid-device co-driver).
[ "$MODULE" != "usb_storage" ] \
 && ! pup_event_backend_modprobe_protect --module=$MODULE \
 && exit 0

case $MODALIAS in
 pci:*)
  pci_fixup_func #w463 needs MODALIAS, MODULE, RULEMODULE
  [ $? -ne 0 ] && exit 1
 ;;
 usb:*) #v432
  #v432 For USB hybrid storage/modem devices, ensure storage driver loaded, then modem driver (on repeated event, if necessary).
  if [ "$MODULE" = "usb_storage" ] \
    && [ "`lsmod | grep '^usb_storage `" != "" ];then #v433
   PREFUSBSTG=" usb_storage:cdc_acm|`grep -w 'usbserial.ko' /lib/modules/$KERNVER/modules.dep | grep -o '^[^:]*' | rev | cut -f 1 -d / | rev | tr '\n' '|'`hso" #v433
   PREFEXTRAS="${PREFEXTRAS} ${PREFUSBSTG}"
  fi
 ;;
esac

#v404 preferences list, ex rt2500usb and rt73usb both hits, then choose latter...
modPATTERN='^'"$MODULE"':'
PREFHIT="`echo -n "${PREFLIST}${PREFEXTRAS}" | tr -s ' ' | tr ' ' '\n' | grep "$modPATTERN"`" #v432
if [ "$PREFHIT" != "" ];then
 prefMODULES="`echo -e -n "$PREFHIT" | cut -f 2 -d ':' | tr '|' '\n'`"
 echo "blacklist $MODULE" > /tmp/pup_event_prefhit_blacklist-$$ #v432 begin
 RETRIES=0
 while [ $RETRIES -le 10 ];do
  xMODULE="`/sbin/modprobe --config /tmp/pup_event_prefhit_blacklist-$$ --show-depends $MODALIAS 2>/dev/null | tail -n 1 | rev | cut -f 1 -d '/' | rev | cut -f 1 -d '.' | tr '\-' '_'`"
  [ "$xMODULE" = "" ] && break
  echo "blacklist $xMODULE" >> /tmp/pup_event_prefhit_blacklist-$$
  RETRIES=`expr $RETRIES + 1`
 done
 modPATTERN="`cat /tmp/pup_event_prefhit_blacklist-$$ | sed -e s/blacklist\ /\^/ -e s/$/\$/ | tr '\n' '|' | sed -e s/\|$//`"
 xMODULE="`echo "$prefMODULES" | grep -m 1 -E "$modPATTERN"`"
 rm /tmp/pup_event_prefhit_blacklist-$$
 [ "$xMODULE" != "" -a "$xMODULE" != "$MODULE" ] \
  && pup_event_backend_modprobe_protect --replacedmod=$MODULE \
  && MODULE="$xMODULE" \
  && ! pup_event_backend_modprobe_protect --module=$MODULE \
  && exit 0 #v433 v432 end
fi

#installs a firmware tarball (once only. loading firmware is something else)...
firmware_module_func

setup_alsa_func #MODULE and CNTSND are used in this func.

#log to file. rc.modules2 needs this info to find out if any modaliases missed (also above)...
echo "MODULE=$MODULE DEVPATH=$DEVPATH" >> /tmp/pup_event_module_devpath_log
cd /sbin #v408 rerwin thinks this is needed for slamr module.
exec /sbin/modprobe $MODULE

###END###
