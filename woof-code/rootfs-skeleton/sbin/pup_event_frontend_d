#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#this is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
#This script is part of 'pup_event', my (very) light-weight alternative to udev.
#responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
#this script is launched from /root/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#v408 rewrite, now works by polling /sys/block.
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.
#091208 fine-tune placement of desktop drive icons.
#091223 partial fix, some interfaces, no change in /sys/block when insert/remove a card.
#100613 some locales (ex: nl_BE) have ',' instead of '.' in numeric, ex o/p of 'dc'.

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"


pidof_function(){
pidof -o $ME_PID -o %PPID ${ME_PROGRAM##*/} && { echo " Already Running.";exit 1; }
}

clean_up_script(){
#!/bin/sh

ME_PROGRAM=`readlink -e "$0"`
ME_PID=$$

usage(){
MSG="
$ME_PROGRAM FILENAME

Script to convert strings
VALUE=\"\`command\`\"
back to
VALUE=\`command\`
"

[ "$2" ] && MSG="$MSG
$2
"

echo "$MSG"
exit $1
}

[ "$*" ] || usage 1
FILE="$1"
[ -e "$FILE" ] || usage 1 "$FILE does not exist."
[ -f "$FILE" ] || usage 1 "$FILE is not a regular file."

cp "$FILE" /root/changes

while read -r line; do
[ "$line" ] || continue
echo "$line"

NEW_LINE=`echo "$line" | sed 's%\(.*=\)\"\(\`.*\`\)\"\(.*\)%\1\2\3%'`
NEW_LINE=`echo "$NEW_LINE" | sed 's%\*%\\\\\*%g' | sed 's%\\\%\\\\\\\\%g'`

line=`echo "$line" | sed 's/\\\/\\\\\\\\/g'`

echo "\"s~${line}~${NEW_LINE}~\""
echo LINE $LINENO

sed -i "s~${line}~${NEW_LINE}~" /root/changes
[ "$?" = 0 ] || exit

done<<EOI
$(grep -I '[[:alnum:]]="`.*`"' "$FILE")
EOI

}


#Version='1.1-kill luci_218-Puppy_Linux_511 KRG'

Version='1.1-kill Macpup_Opera_2-Puppy_Linux_431-KRG'

usage(){
MSG="
$0 [ help | version ]
$0 [ debug | verbose ] [ start | restart ]
$0 [ stop | status ]
$0 [ codecheck ]
Puppy Daemon to manage the Drive Icons on the desktop.
Is configurable by /usr/sbin/eventmanager gtkdialog GUI.

Help Options :
-V|version) show version information
-h|help) show this usage information

Development Options :
codecheck)    run with set -n
-d|debug)     run with set -x
-v|verbose) show variables to stdout

Main Options :
stop ) stop
start) start
restart) stop and start
status) say if already running
"

[ "$2" ] && "MSG=$MSG
$2
"

echo "$MSG"

exit $1
}

out=/dev/null;err=$out;QUIET='-q'

while getopts Vhvd opt; do
 case $opt in
  V) echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0;;
  h) usage 0;;
  v) VERB=-v;L_VERB=--verbose;A_VERB=-verbose;out=/dev/stdout;err=/dev/stderr;DEBUG=1;ME_VERB=1;QUIET='';;
  d) set -x;;
  *) :;;
  esac
done


ME_PROGRAM=`readlink -f "$0"`  ##+-2013-08-10 should be readlink -e but busybox readlink treats -f as -e option
ME_PID=$$
PIDS_OTHER_MES=`pidof -o $$ -o %PPID ${ME_PROGRAM##*/}`

PARAMETER_LINE="$@"

while [ "$1" ];do
CASEPARAM=$1;shift

case "$CASEPARAM" in
help|-*help|-h) usage 0
;;
version|-*version|-V)
echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0
;;
codecheck|-*codecheck|checkcode|-*checkcode)
#BASH set -n
bn=${0##*/}
cp $0 /tmp/
sed -i '1d' /tmp/"$bn"
sed -i '1i\#!/bin/bash -n' /tmp/"$bn"
/tmp/"$bn" $PARAMETER_LINE
echo "<$?>"
echo "Codecheck finished"
echo "Attention :
Normally uses ash, this had been done in bash,
because ash has no -n parameter"
exit 0
;;
debug|-*debug|-d) set -x
;;
verbose|-*verbose|-v) ME_VERB=1
VERB=-v;L_VERB=--verbose;A_VERB=-verbose;out=/dev/stdout;err=/dev/stderr;QUIET=''
;;

stop)
for pid in $PIDS_OTHER_MES ; do
kill $pid
RETVAL=$((RETVAL+$?))
done
echo
exit "$RETVAL"
;;

restart)
for pid in $PIDS_OTHER_MES ; do
kill $pid
done
echo
pidof -o $$ -o %PPID ${ME_PROGRAM##*/} && { echo " Already Running.";exit 1; }
break
;;

start)
pidof -o $$ -o %PPID ${ME_PROGRAM##*/} && { echo " Already Running.";exit 1; }
break
;;

status)
echo -n "$ME_PROGRAM : "
[ "`echo $PIDS_OTHER_MES | wc -w`" = 1 ] && IS=is || IS=are
[ "$PIDS_OTHER_MES" ] && echo "$PIDS_OTHER_MES $IS already running." || echo "not already running."
exit 0
;;

esac
done
### OPTIONS ###


get_jobs_pids(){
ps-FULL -o ppid,lwp,tty,start,s,psr,pcpu,args -C ${ME_PROGRAM##*/} --no-headers | while read PPid Pid rest ; do
Pids="$Pids
$Pid"
echo "$Pids" | grep $QUIET -w "$PPid" && echo "$Pid"
done
}

kill_jobs(){
JOBS=`get_jobs_pids`
for Pid in $JOBS ; do
ps -p "$Pid" && kill $Pid
done
}

probedisk_simple(){
    echo probing for drives >&2
ALLDRIVES=`ls -1 /sys/block | grep -vE 'ram|loop|mtd|md'`
for drive in $ALLDRIVES ; do
[ -f /sys/block/$drive/removable ] && read REMOVABLE </sys/block/$drive/removable
case $drive in
sd*)
[ "$REMOVABLE" = 0 ] && KIND=drive || KIND=usbdrv ;;
sr*)
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=usbdrv   ;;
fd*)
[ "$REMOVABLE" = 1 ] && KIND=floppy || KIND=floppy  ;;
hd*)
[ "$REMOVABLE" = 0 ] && KIND=drive || KIND=usbdrv    ;;
scd*)
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=usbdrv   ;;
mmc*)
[ "$REMOVABLE" = 1 ] && KIND=card || KIND=usbdrv   ;;
esac
[ -f /sys/block/$drive/device/vendor ] && read VEND </sys/block/$drive/device/vendor
[ -f /sys/block/$drive/device/model ] && read MODL </sys/block/$drive/device/model
[ "$VEND" ] || VEND=Unknown
[ "$MODL" ] || MODL=Unknown
#PARTS=`ls -1 /sys/block/$drive/$drive[0-9]* 2>$ERR | grep -o -e '[0-9]*' |tr '\n' ' '`
echo "$drive|$KIND|$VEND $MODL"
done
    echo done probing >&2
}

echo here 0
### CODE ###
OLDLANG=$LANG #100613
export LANG=C #w004

#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.

sleep 2 #let the dust settle after X has started.
until [ "`awk -F '.' '{print $1}' /proc/loadavg`" -lt 2 ];do sleep 5;done
#w471 slow cpus need more delay (well, rox does)...
DELAYFACTOR=0
CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
[ "$CPUMHZ" -a "$CPUMHZ" -gt 100 ] && DELAYFACTOR=$(( 1100 / $CPUMHZ ))
[ "$DELAYFACTOR" -gt 0 ] && sleep $DELAYFACTOR

[ "$DISPLAY" ] || exit 0 #X not running.

#v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_icon_change_flag
#which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
#however I think it would be good to test here also if X mode not yet settled on...
if [ -f /tmp/videomode ];then #only exists during X resolution setup.
 if [ "`readlink /usr/bin/X`" = "Xvesa" ];then
  while [ -f /tmp/videomode ];do
count=$((count+1))
   sleep 3
[ "$count" = 100 ] && { echo "/tmp/videomode still exist after 5 minutes. Exit.";exit 0; }
  done
 fi
fi

SAVECNT=0
MOUSECNT=0 #w007
MINUTECNT=0 #w007
CURPOS1="" #w007

ZDRV='';ZDRVINIT='no' #these usually set in PUPSTATE.
. /etc/rc.d/PUPSTATE

KERNVER=`uname -r`
. /etc/eventmanager #has RAMSAVEINTERVAL, ICONDESK, HOTPLUGNOISY, ICONPARTITIONS, BACKENDON, POWERTIMEOUT
. /etc/rc.d/functions4puppy4

SCRNXY=`xwininfo -root | grep -o '\-geometry .*' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'`
SCRN_X=`echo -n "$SCRNXY" | cut -f 1 -d 'x'`
SCRN_Y=`echo -n "$SCRNXY" | cut -f 2 -d 'x'`

[ "$RAMSAVEINTERVAL" ] || RAMSAVEINTERVAL=30 #412
RAMSAVEINTERVAL=$(($RAMSAVEINTERVAL * 60)) #convert minutes to seconds.

[ "$POWERTIMEOUT" ] || POWERTIMEOUT=0 #w007
POWERTIMEOUT=$(($POWERTIMEOUT * 60)) #convert minutes to seconds.

SIZE_MODS_M=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_M=`du -m -s /lib/modules | cut -f 1`
fi
RETVALm=1
PREVSIZETMPM=0
PREVSIZEFREEM=0

####KRG:VARIABLES
####KRG

###<KRG>
stateDir="$HOME/Choices/Puppy"
drvDir="$stateDir"/.pup_event
mkdir -p "$drvDir"

#v424 experiment, automatic unmounting...
auto_unmount_func() {
 for ONEMNTPT in `mount | grep '^/dev/' | grep -vE '^/dev/loop|^/dev/ram' | cut -f 3 -d ' ' | grep -v '^/initrd/' | grep -v '^/$' | tr '\n' ' '`
 do
  if [ "`fuser -v -m $ONEMNTPT`" = "" ];then
   sync
   umount $ONEMNTPT ; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ $umVAL -ne 0 ];then
    ZOMBIES=`ps -H -A | grep '<defunct>' | grep -v 'grep' | sed 's#^ *##;s/  /|/g' | grep -v '|||' | cut -f 1 -d ' '`
    for ONEZOMBIE in $ZOMBIES
    do
     kill $ONEZOMBIE
    done
    umount $ONEMNTPT ; umVAL=$?
   fi
  fi
 done
}

format_size_func() {
 [ ! "$SIZE" ] && SIZE=0
 if [ "$SIZE" -gt 1048576 ];then #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p` #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 else
  if [ "$SIZE" -gt 1024 ];then
   SIZE="`expr $SIZE \/ 1024`MB"
  else
   #SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
   SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`KB" #100613
  fi
 fi
 [ "${SIZE//[[:alpha:][:punct:]]/}" = '00' ] && SIZE=0
}

create_appinfo_func() { #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
   [ "$1" ] && DRV_NAME="$1"
   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${INFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${DRV_CATEGORY}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item><Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>${MOREITEMS}
  </AppMenu>
</AppInfo>" > $drvDir/drive_${DRV_NAME}/AppInfo.xml
}

#COORDSGRID="`grep -o ' x="[0-9]*" y="[0-9]*" ' /root/Choices/ROX-Filer/PuppyPin | sed 's/[0-9]"/"/g'`"
 PIN_GRID_STEP=`grep "pinboard_grid_step" $HOME/.config/rox.sourceforge.net/ROX-Filer/Options | sed -e "s/ *<[^>]*>//g"`
 [ $PIN_GRID_STEP ] || PIN_GRID_STEP=16 #16=medium.
 [ $PIN_GRID_STEP -eq 0 ] && PIN_GRID_STEP=16 #precaution.
 PIN_GRID_STEP2=`expr $PIN_GRID_STEP \/ 2`
 MAX_X=`expr $SCRN_X - 96`
 MAX_Y=`expr $SCRN_Y - 96`
[ "$DEBUG" ] && echo "PIN_GRID_STEP=$PIN_GRID_STEP PIN_GRID_STEP2=$PIN_GRID_STEP2"






free_coord_normal(){
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...
 COORDSGRID=`grep -o -e ' x="[0-9]*" y="[0-9]*" ' /root/Choices/ROX-Filer/PuppyPin | sed 's/[0-9]"/"/g'`
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   COORD_Y=`expr $SCRN_Y - $ICON_PLACE_EDGE_GAP` #default 64, see /etc/eventmanager
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while [ 1 ];do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" = "" ] && break
    COORD_X=`expr $COORD_X + $ICON_PLACE_SPACING`
    if [ $COORD_X -gt $MAX_X ];then #start next line up.
     xyCNT=`expr $xyCNT + 1`
     [ $xyCNT -gt 1 ] && break
     COORD_Y=`expr $COORD_Y - $ICON_PLACE_SPACING`
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  top)
   COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while [ 1 ];do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" = "" ] && break
    COORD_X=`expr $COORD_X + $ICON_PLACE_SPACING`
    if [ $COORD_X -gt $MAX_X ];then #start next line down.
     xyCNT=`expr $xyCNT + 1`
     [ $xyCNT -gt 1 ] && break
     COORD_Y=`expr $COORD_Y + $ICON_PLACE_SPACING`
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  left)
   COORD_X=$ICON_PLACE_EDGE_GAP #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   #COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   COORD_Y=$((((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while [ 1 ];do
    #xgPATTERN="`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`"
    xgPATTERN="${xPATTERN//[0-9]\"/\"}"
    #[ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" = "" ] && break
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    #COORD_Y=`expr $COORD_Y + $ICON_PLACE_SPACING`
    COORD_Y=$((COORD_Y+ICON_PLACE_SPACING))
    if [ $COORD_Y -gt $MAX_Y ];then #start next row. ##FIXME
     #xyCNT=`expr $xyCNT + 1` ##FIXME
     xyCNT=$((xyCNT+1))
     [ $xyCNT -gt 1 ] && break ##FIXME
     #COORD_X=`expr $COORD_X + $ICON_PLACE_SPACING`
     COORD_X=$((COORD_X+ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  right)
   COORD_X=`expr $SCRN_X - $ICON_PLACE_EDGE_GAP` #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while [ 1 ];do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" = "" ] && break
    COORD_Y=`expr $COORD_Y + $ICON_PLACE_SPACING`
    if [ $COORD_Y -gt $MAX_Y ];then #start next row back.
     xyCNT=`expr $xyCNT + 1`
     [ $xyCNT -gt 1 ] && break
     COORD_X=`expr $COORD_X - $ICON_PLACE_SPACING`
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
 esac
}






free_coord_simple(){
 #DRIVE_NAME="$1"
 #LAST_PLACE=`grep -m1 -w "\.pup_event/drive_${OLD_DRV_NAME}" /root/Choices/ROX-Filer/PuppyPin`
 LAST_PLACE=`grep -m1 '\.pup_event/drive_' /root/Choices/ROX-Filer/PuppyPin`
 [ "$LAST_PLACE" ] && { COORD_X=`echo "$LAST_PLACE" | cut -f2 -d'"'`; COORD_Y=`echo "$LAST_PLACE" | cut -f4 -d'"'`; }
 #echo "'$OLD_DRV_NAME' $DRIVE_NAME
echo "'$LAST_PLACE'
$COORD_X $COORD_Y"
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   [ "$COORD_Y" ] || COORD_Y=`expr $SCRN_Y - $ICON_PLACE_EDGE_GAP` #default 64, see /etc/eventmanager
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y - ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   echo COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  top)
   [ "$COORD_Y" ] || COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   echo COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  left)
   [ "$COORD_X" ] || COORD_X=$ICON_PLACE_EDGE_GAP #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$((((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X + ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   echo COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  right)
   [ "$COORD_X" ] || COORD_X=`expr $SCRN_X - $ICON_PLACE_EDGE_GAP` #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*' $PIN_GRID_STEP`
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X - ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   echo COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
   esac
#OLD_DRV_NAME="$DRIVE_NAME"
}

echo here

add_pinboard_func() { #needs ONEDRVNAME, DRV_CATEGORY, FSTYPE
 [ "$1" ] && DRV_NAME="$1"

 #ppPATTERN=' label="'"$ONEDRVNAME"'"'
 #v411 rerwin: avoid icon getting duplicated if it is renamed...
 #ppPATTERN="$drvDir/drive_${ONEDRVNAME}<"
 #[ "`grep "$ppPATTERN" /root/Choices/ROX-Filer/PuppyPin`" != "" ] && return #precaution.

 free_coord_simple   #${ONEDRVNAME}

 [ "$DEBUG" ] && echo "Passing X='$COORD_X' Y='$COORD_Y' to rox -R"

 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$drvDir/drive_${DRV_NAME}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${DRV_NAME}</Label>
   <Args>${DRV_CATEGORY} ${FSTYPE}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R
}

probepart_func() {
PROBEPART=`probepart $* -k $@ | grep -iE 'not inserted|\|ext4\||\|ntfs\||\|msdos\||\|vfat\||\|.*fat.*\||\|ext2\||\|ext3\||\|iso9660\||\|xfs\||\|udf\||\|jfs\||\|reiser'`
}

#more_items(){
#
#
#
#}



create_icon_func() {
 [ "$1" ] && DEV_NAME="$1"
 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
 #if a passed param $1, then PROBEPART already known, inefficient to rerun here each time.

 #DRVINFO="$PART_NAME"'|0|0'

   if [ "$ICONDESK" = "false" ];then
    DRVINFO="/dev/$DEV_NAME"'|0|0'

 elif [ "$ICONPARTITIONS" = "false" ];then
    read SIZE </sys/block/$DEV_NAME
    FSTYPE=`guess_fstype /dev/$DEV_NAME`
    DRVINFO="/dev/${DEV_NAME}|${FSTYPE}|${SIZE}"

 elif [ "$ICONPARTITIONS" = "true" ];then

  #display an icon for each partition... w476 add ext4...
 # [ "$1" = 'startup' ] || { echo "VAR_1 not startup doing now probepart command (again)";probepart_func -d/dev/$DEV_NAME ;echo "$PROBEPART";echo "done"; } #probepart_func line 314
  probepart_func -d/dev/$DEV_NAME ;
  echo "$PROBEPART";
  echo "done";

  drvPATTERN="^/dev/${DEV_NAME}" #important, no space on end! #drvPATTERN='^/dev/'"${PART_NAME}"
  #DRVINFO=`echo "$PROBEPART" | grep -w "$drvPATTERN" | cut -f 1,2,3 -d '|' | tr '\n' ' '` # grep -w
  DRVINFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|'`

fi   ## was# ICONPARTITIONS true


 while read -r ONEDRVINFO
 do
  [ "$ONEDRVINFO" ] || continue

  PART_NAME=`echo -n "$ONEDRVINFO" | cut -f 1 -d '|' | cut -f 3 -d '/'`
  [ "$DEBUG" ] && echo "DEV_NAME=$DEV_NAME' PART_NAME=$PART_NAME'"

  FSTYPE=`echo -n "$ONEDRVINFO" | cut -f 2 -d '|'`
  [ "$DEBUG" ] && echo "FSTYPE=$FSTYPE'"

  SIZE=`echo -n "$ONEDRVINFO" | cut -f 3 -d '|'`

  drvPATTERN='^/dev/'"${PART_NAME}"' ' #important, a space on end!

  if [ ! -d $drvDir/drive_${PART_NAME} ];then
   mkdir -p $drvDir/drive_${PART_NAME}  ##sbin/pup_event_frontend_d: line 50: can't create : nonexistent directory
   cp -af /usr/local/bin/drive_all $drvDir/drive_${PART_NAME}/AppRun
  fi

   if [ "$FSTYPE" != 0 -a "$SIZE" != 0 ] ; then
    format_size_func #formats SIZE for display.
    INFO="Filesystem: $FSTYPE Size: ${SIZE}
${DRV_DESCRIPTION}"

   elif [ "$FSTYPE" = "0" -a "$SIZE" = "0" ];then #only one icon for all drives
     INFO="Puppy drive manager"
   else
     format_size_func #formats SIZE for display.
     INFO="${DRV_DESCRIPTION} Size: $SIZE"
   fi

   #v424 add item to unmount all partitions...
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${PART_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   create_appinfo_func $PART_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME or PART_NAME

  [ "$DEBUG" ] && echo "DBG drvPATTERN=$drvPATTERN"

 # if [ "$ICONDESK" = "true" ];then #see /etc/eventmanager.
 # [ "$DEBUG" ] && echo "ICONDESK true"
 if  [ "$ICONDESK" = "false" ];then
 icon_unmounted_func $PART_NAME $DRV_CATEGORY;add_pinboard_func $PART_NAME
 elif [ "$ICONPARTITIONS" = "true" ];then
      [ "$DEBUG" ] && echo "ICONPARTITIONS true"
    MNTSTATUS=`df | grep "$drvPATTERN"`
    if [ "$MNTSTATUS" = "" ];then
     icon_unmounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
    else
     [ "$DEBUG" ] && echo 'starting now icon_mounted_func'
     icon_mounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
     [ "$DEBUG" ] && echo 'returned from icon_mounted_func'
    fi
   add_pinboard_func $PART_NAME #needs ONEDRVNAME, DRV_CATEGORY, FSTYPE.
  else icon_unmounted_func $PART_NAME $DRV_CATEGORY;add_pinboard_func $PART_NAME
 fi
 done<<EOI
$(echo "$DRVINFO")
EOI

}

remove_pinboard_func() { #needs DEV_NAME (name of entire drive)
 [ "$1" ] && DRV_NAME="$1"
 case $DRV_NAME in
 hd*|sd*|mmc*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g' | sed 's/[0-9]*$//'`;;
 fd*|sr*|*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g'`;;
 esac

 #ppPATTERN=" label=\"$DEV_NAME"
 #ppPATTERN="${ppPATTERN}"'.*'
 #ppPATTERN=' label="'"$DEV_NAME"'.*'
  ppPATTERN='\.pup_event/drive_'"$DRV_NAME"'.*'

 #if [ ! "`grep "$ppPATTERN" /root/Choices/ROX-Filer/PuppyPin`" ]; then
 #return; fi

 #ALLNAMES=`grep -o "$ppPATTERN" /root/Choices/ROX-Filer/PuppyPin | cut -f 2 -d '"' | sort -r` #'geany
 ALLNAMES=`grep -o "$ppPATTERN" /root/Choices/ROX-Filer/PuppyPin | cut -f 3 -d '_' | cut -f 1 -d '<' | sort -r`

 for ONE_PART in $ALLNAMES
 do

  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$drvDir/drive_${ONE_PART}</Path>
  </PinboardRemove>
  <UnsetIcon>
   <Path>$drvDir/drive_${ONE_PART}</Path>
  </UnsetIcon>
 </env:Body>
</env:Envelope>"  | rox -R
 done
}

#note that init script in initrd takes care of restoring modules if enough space.
delete_func() { #called from free_func() and free_flash_func(). delete modules to create more free space.
 #passed param: /pup_rw=delete tmpfs top layer only.
 DEL_LAYER=$1
 #find out what modules are loaded, keep those...
 for ONEKEEP_MOD in `lsmod | cut -f 1 -d ' ' | grep -v 'Module'`
 do
  ONEKEEP_SPEC=`modinfo -F filename ${ONEKEEP_MOD}`
  ONEKEEP_PATH=`dirname $ONEKEEP_SPEC`
  mkdir -p /tmp${ONEKEEP_PATH}
  cp -af ${ONEKEEP_SPEC} /tmp${ONEKEEP_PATH}/
 done
 if [ "$DEL_LAYER" != "" ];then
  rm -rf ${DEL_LAYER}/lib/modules
 else
  if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then
   rm -rf ${SAVE_LAYER}/lib/modules
  fi
  rm -rf /lib/modules
 fi
 cp -af /tmp/lib/modules /lib/modules
 depmod -a
}

free_initrd_func() { #UniPup, runs entirely in initramfs.
 SIZEFREEK=`free | grep '^Total:' | tr -s ' ' | cut -f 4 -d ' '`
 SIZEFREEM=$(($SIZEFREEK / 1024))
 [ -s /tmp/pup_event_sizefreem ] && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 [ "$PREVSIZEFREEM" = "$SIZEFREEM" ] && return
 #save to a file, freememapplet can read this...
 echo "$SIZEFREEM" > /tmp/pup_event_sizefreem
}

free_func() { #called every 4 seconds.
 case $PUPMODE in
  6|12)
   SIZEFREEM=`df -m | grep -m1 ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
  *)
   SIZEFREEM=`df -m | grep -m1 ' /$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
 esac
 WARNMSG=""
 [ -s /tmp/pup_event_sizefreem ] && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 [ "$PREVSIZEFREEM" -eq $SIZEFREEM ] && return
 if [ "$SIZEFREEM" -lt 10 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   delete_func /initrd/pup_rw #save layer is at top, delete mods.
  else
   WARNMSG="WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$(($SIZEFREEM + $SIZE_MODS_M))
   VIRTUALFREEM=$(($VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 [ "$PUPMODE" -eq 5 -o "$PUPMODE" -eq 2 ] && return 0 #5=first boot, no msgs at top of screen.
 if [ "$WARNMSG" != "" ];then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
}

savepuppy_func(){
  yaf-splash -font "8x16" -outline 0 -margin 4 -bg orange -placement top -text "Saving RAM to 'pup_save' file..." &
  YAFPID=$!
  sync
  nice -n 19 /usr/sbin/snapmergepuppy
  kill $YAFPID
}

free_flash_func(){ #PUPMODE 3,7,13. called every 3 seconds.
 WARNMSG=""
 SIZEFREEM=`df -m | grep ' /initrd/pup_ro1$' | tr -s ' ' | cut -f 4 -d ' '`
 SIZETMPM=`df -m | grep ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`
 [ -s /tmp/pup_event_sizefreem ] && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 [ -s /tmp/pup_event_sizetmpm ] && PREVSIZETMPM=`cat /tmp/pup_event_sizetmpm`
 [ $PREVSIZEFREEM -eq $SIZEFREEM -a $PREVSIZETMPM -eq $SIZETMPM ] && return
 if [ $SIZEFREEM -lt 10 ];then
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   delete_func /initrd/pup_ro1 #delete modules in save layer only.
  else
   WARNMSG="WARNING: Personal storage file getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 if [ "$SIZETMPM" -lt 5 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   delete_func /initrd/pup_rw #delete modules in top tmpfs layer only.
  else
   WARNMSG="WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$(($SIZEFREEM + $SIZE_MODS_M))
   VIRTUALFREEM=$(($VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 echo "$SIZETMPM" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 if [ "$WARNMSG" != "" ];then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
savepuppy_func
}

######################################################################
#stuff to setup at entry...
probedisk2_func(){

PROBEDISK=`probedisk2`

PROBEDISK=`echo "$PROBEDISK" | tr " " "_" | sed 's/_$//g'` ##+- 2011-12-03
PROBEDISKinfo=`echo "$PROBEDISK" | cut -f 3 -d '|' | sed 's#^$#no_info_in_/sys/block/dev#g`

PROBEDISK=`echo "$PROBEDISK" | cut -f 1,2 -d '|'`

PROBEDISK=`echo "$PROBEDISK" | sed 's/$/|/'`

WCP=`echo "$PROBEDISK" | wc -l`
echo > /tmp/PROBEDISKnew.txt
COUNTER=0 ; i=0
while [[ "$COUNTER" != "$WCP" ]]; do # -lt doesn't work somehow
i=$(($i + 1))

PROBEDISKL=`echo "$PROBEDISK" | sed -n "$i"p`

PROBEDISKinfoL=`echo "$PROBEDISKinfo" | sed -n "$i"p`

PROBEDISKnew=`echo $PROBEDISKL  $PROBEDISKinfoL`

PROBEDISKnew=`echo $PROBEDISKnew | tr -d ' '`

echo $PROBEDISKnew >> /tmp/PROBEDISKnew.txt

if [ "$i" = "$WCP" ] ; then break ; fi
done
PROBEDISK=`cat /tmp/PROBEDISKnew.txt | sed '/^$/d'`
rm -f /tmp/PROBEDISKnew.txt
echo "$PROBEDISK"
}

clear_desk_icons_func(){
drives=`grep '/\.pup_event/drive_*' $HOME/Choices/ROX-Filer/PuppyPin | grep -o '/drive_.*<' | cut -f2 -d '_' | tr -d '<' | awk '{print $1}' | tr -d '[[:digit:]]' | sort -u | sort -r`

for item in $drives; do
DEV_NAME="$item"
echo "removing '$DEV_NAME'"
remove_pinboard_func $DEV_NAME
done
rm -fr "$drvDir"/*
echo "Finished clear_desk_icons_func
"
}
clear_desk_icons_func


pup_event_frontend_d_start_func(){
echo "pup_event_frontend_d_start_func BEGIN"

#build the desktop icons...
DRV_CATEGORY='drive'

probedisk2_func

#v407 ls120/zip floppy drives are probed every 4 secs...
DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
#v407 same thing for all optical drives...
DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`

if [ "$ICONDESK" = "false" ];then
echo "ICONDESK is false"
 #only show a single 'drives' icon on desktop...
 DEV_NAME='drives'
 DRV_CATEGORY='any' #see pmount.
 DRV_DESCRIPTION="all drives"

 test_func_out(){
 DRVINFO="$DEV_NAME"'|0|0'

 mkdir -p $drvDir/drive_${DEV_NAME}  ##sbin/pup_event_frontend_d: line 50: can't create : nonexistent directory
 cp -a --remove-destination /usr/local/bin/drive_all $drvDir/drive_${DEV_NAME}/AppRun
 INFO="Puppy drive manager"
 MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${DEV_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
 create_appinfo_func $DEV_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME or $1 or DRV_NAME
 icon_unmounted_func $DEV_NAME $DRV_CATEGORY
 add_pinboard_func $DEV_NAME
}
 create_icon_func $DEV_NAME

elif [ "$ICONPARTITIONS" = "false" ];then

  [ "$DEBUG" ] && echo 'Just Maindrives'
  for item in $PROBEDISK ; do

   DEV_NAME=`echo "$item" |cut -f 1 -d '|' | cut -f 3 -d '/'`
   DRV_CATEGORY=`echo "$item" |cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo "$item" |cut -f 3 -d '|'`
   [ "$DEBUG" ] && { echo $item;echo '***'; }

   test_func_out_2(){
   mkdir -p $drvDir/drive_${DEV_NAME}
   cp -a --remove-destination /usr/local/bin/drive_all $drvDir/drive_${DEV_NAME}/AppRun
   probepart_func -d/dev/$DEV_NAME
   FSTYPE=`echo "$PROBEPART" | grep -w "$DEV_NAME" | cut -f2 -d'|'`
   [ "$FSTYPE" ] || FSTYPE=' - '
   SIZE=`echo "$PROBEPART" | grep -w "$DEV_NAME" | cut -f3 -d'|'`
   SIZE=$SIZE format_size_func $SIZE
   INFO="Filesystem: $FSTYPE Size: ${SIZE}
${DRV_DESCRIPTION}"
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${DEV_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   create_appinfo_func $DEV_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
   if [ "`df | grep -w "$DEV_NAME"`" ] ; then
   icon_mounted_func $DEV_NAME $DRV_CATEGORY
   else
   icon_unmounted_func $DEV_NAME $DRV_CATEGORY
   fi
   add_pinboard_func $DEV_NAME
  }
  create_icon_func $DEV_NAME
  done

else
  [ "$DEBUG" ] && echo "ICONPARTITIONS='$ICONPARTITIONS'"

 #show all drives on desktop... w476 add ext4...

while read -r ONEDRV
 do
 [ "$ONEDRV" ] || continue
 [ "$DEBUG" ] && echo "ONEDRV=$ONEDRV'"

  DEV_NAME=`echo -n "$ONEDRV" | cut -f 1 -d '|' | cut -f 3 -d '/'`

  DRV_CATEGORY=`echo "$ONEDRV" | cut -f2 -d'|'`
  DRV_DESCRIPTION=`echo "$ONEDRV" | cut -f3 -d'|'`

  create_icon_func $DEV_NAME #startup #needs PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION, PROBEPART.

  #ONEDRVNAME="$DEV_NAME"
  if [ ! -d $drvDir/drive_${DEV_NAME} ] ; then
   mkdir -p $drvDir/drive_${DEV_NAME}
   cp -a --remove-destination /usr/local/bin/drive_all $drvDir/drive_${DEV_NAME}/AppRun
   INFO="Puppy drive manager"
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${DEV_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   create_appinfo_func $DEV_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
  fi

 done<<EOI
$(echo "$PROBEDISK")
EOI
fi    #;fi

}

pup_event_frontend_d_start_func

if [ "$BACKENDON" = "false" ];then #see /etc/eventmanager.
 killall hotplug2stdout #pup_event_backend_d #no module/firmware hotplug support.
 #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 [ "`pidof udevd`" ] && killall udevd #alternative to pup_event_backend_d.
 exit
fi
[ "$HOTPLUGON" = "false" ] && exit #turn off all frontend hotplug support. see /etc/eventmanager.



#bash-3.00# fuser -l
#HUP INT QUIT ILL TRAP ABRT IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM
#STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYS
#UNUSED

#  1 HUP        # 13 USR2               # 25 XCPU
#  2 INT        # 14 PIPE               # 26 XFSZ
#  3 QUIT       # 15 ALRM               # 27 VTALRM
#  4 ILL        # 16 TERM               # 28 PROF
#  5 TRAP       # 17 STKFLT             # 29 WINCH
#  6 ABRT       # 18 CHLD               # 30 IO
#  7 IOT        # 19 CONT               # 31 PWR
#  8 BUS        # 20 STOP               # 32 SYS
#  9 FPE        # 21 TSTP               # 33 UNUSED
# 10 KILL       # 22 TTIN
# 11 USR1       # 23 TTOU
# 12 SEGV       # 24 URG

#bash-3.00# trap -l
#  1) SIGHUP             2) SIGINT               3) SIGQUIT              4) SIGILL
#  5) SIGTRAP            6) SIGABRT              7) SIGBUS               8) SIGFPE
#  9) SIGKILL           10) SIGUSR1             11) SIGSEGV             12) SIGUSR2
# 13) SIGPIPE           14) SIGALRM             15) SIGTERM
# 17) SIGCHLD           18) SIGCONT             19) SIGSTOP             20) SIGTSTP
# 21) SIGTTIN           22) SIGTTOU             23) SIGURG              24) SIGXCPU
# 25) SIGXFSZ           26) SIGVTALRM   27) SIGPROF             28) SIGWINCH
# 29) SIGIO                     30) SIGPWR              31) SIGSYS
# 35) SIGRTMIN
# 36) SIGRTMIN+1
# 37) SIGRTMIN+2        38) SIGRTMIN+3  39) SIGRTMIN+4  40) SIGRTMIN+5
# 41) SIGRTMIN+6        42) SIGRTMIN+7  43) SIGRTMIN+8  44) SIGRTMIN+9
# 45) SIGRTMIN+10       46) SIGRTMIN+11 47) SIGRTMIN+12 48) SIGRTMIN+13
# 49) SIGRTMIN+14
# 50) SIGRTMAX-14       51) SIGRTMAX-13 52) SIGRTMAX-12
# 53) SIGRTMAX-11       54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8
# 57) SIGRTMAX-7        58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4
# 61) SIGRTMAX-3        62) SIGRTMAX-2  63) SIGRTMAX-1  64) SIGRTMAX

trap "kill_jobs;exit $?" HUP INT QUIT ABRT TRAP KILL TERM

function_ramsaveinterval(){
while [ running ] ; do
 SAVECNT=$((SAVECNT + 60))
 if [ "$SAVECNT" -gt "$RAMSAVEINTERVAL" ];then
  savepuppy_func
  SAVECNT=0
 fi
sleep 60
done
}

function_powertimeout(){
while [ running ] ; do

   CURPOS1=`getcurpos`
   [ "$CURPOS1" != "$CURPOS2" ] && MOUSECNT=0

   if [ "$MOUSECNT" -gt "$POWERTIMEOUT" ] ; then
   echo  MOUSECNT=$MOUSECNT POWERTIMEOUT=$POWERTIMEOUT
   aplay /usr/share/audio/2barks.au
   sleep 1s
   aplay /usr/share/audio/2barks.au
   xmessage -bg red -timeout 60 -buttons "YES:190,No:191" -fn "-misc-dejavu sans-*-*-*-*-*-*-*-*-*" 'Really powering off now ?'

    REPLY=$?
    echo $REPLY
    if [ "$REPLY" = "190" -o "$REPLY" = "0" ] ; then
    wmpoweroff &
    fi
   fi
 CURPOS2="$CURPOS1"
 sleep 60s
 MOUSECNT=$((MOUSECNT+60))
done
}
CURPOS1=1
CURPOS2=1
echo "POWERTIMEOUT=$POWERTIMEOUT'"
[ "$POWERTIMEOUT" -ne 0 ] && function_powertimeout &

case $PUPMODE in
3|7|13)
   FREE_FUNCTION='free_flash_func'
   echo "RAMSAVEINTERVAL=$RAMSAVEINTERVAL'"
   [ "$RAMSAVEINTERVAL" -ne 0 ] && function_ramsaveinterval &
 ;;
16|24|17|25) #unipup.
   FREE_FUNCTION='free_initrd_func'  ;;
  *)
   FREE_FUNCTION='free_func'  ;;
esac

echo here 0
PROBEDISK2_LOOP_NEW=`probedisk_simple`
PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW"
echo here 1

###################################################################
#now go into a two-second loop...
while [ 1 ]
do
 sleep 3

#########check hotplug block event##########

if [ "$PROBEDISK2_LOOP_NEW" != "$PROBEDISK2_LOOP_OLD" ] ; then
 ######### hotplug detected : #########
  echo "MAIN loop not same"
  BLOCKSADD=`echo "$PROBEDISK2_LOOP_NEW" | grep -v "$PROBEDISK2_LOOP_OLD"`
  BLOCKSREM=`echo "$PROBEDISK2_LOOP_OLD" | grep -v "$PROBEDISK2_LOOP_NEW"`
  echo "BLOCKSADD=$BLOCKSADD'"
  echo "BLOCKSREM=$BLOCKSREM'"

  if [ "$BLOCKSADD" ] ; then
   while read -r ADD ; do
   [ "$ADD" ]|| continue
   DEV_NAME=`echo -n "$ADD" | cut -f 1 -d '|' | cut -f3 -d'/'`
   DRV_CATEGORY=`echo -n "$ADD" | cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo -n "$ADD" | cut -f 3 -d '|' | tr -s ' '`

   [ "$ICONDESK" = "true" ] && create_icon_func $DEV_NAME
   #uses DEV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
   [ "$HOTPLUGNOISY" = "true" ] && $drvDir/drive_${PART_NAME}/AppRun ${DRV_CATEGORY} & #handler script.
  done<<EOI
$(echo "$BLOCKSADD")
EOI

  elif [ "$BLOCKSREM" ] ; then
   while read -r REM ; do
   [ "$REM" ] || continue
    DEV_NAME=`echo "$REM" | cut -f1 -d'|' | cut -f3 -d'/'`
    [ "$DEV_NAME" ] || continue
   if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, refresh it.
    killall gtkdialog_pmount
    sleep 0.1
    LANG=$OLDLANG pmount & #100613 fix from shinobar.
   fi
   remove_pinboard_func $DEV_NAME #needs DEV_NAME or DRV_NAME
   rm -rf $drvDir/drive_${DEV_NAME}*
  done<<EOI
$(echo "$BLOCKSREM")
EOI

  fi
fi
 ######### hotplug detected #########
 echo here 0
 PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW"
 PROBEDISK2_LOOP_NEW=`probedisk_simple`
 echo "PROBEDISK_LOOP_OLD=$PROBEDISK_LOOP_OLD'"
 echo "PROBEDISK_LOOP_NEW=$PROBEDISK_LOOP_NEW'"
 echo here 1
 #######four second timeout procesing#########

 if test -f "/tmp/pup_event_icon_change_flag" ;then #1
 clear_desk_icons_func
 [ -f /etc/eventmanager ] && . /etc/eventmanager
 POWERTIMEOUT=$(($POWERTIMEOUT * 60));RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60))
 pup_event_frontend_d_start_func
 sleep 1
 rm -f /tmp/pup_event_icon_change_flag
 fi #1

 #some apps should not be disturbed by this background stuff...
 RUNPS=`ps`
 #w482 add xorriso...
 [ "`echo "$RUNPS" | grep -Ew 'make|gcc|xorriso|xorrecord|xine|petget|wget|axel|dotpup|mplayer|gcurl|gimv|burniso2cd|growisofs|cdrecord|pcdripper|xfmedia|xmms|ripoff|pdvdrsab|pburn|mhwaveedit|installpkg\.sh|downloadpkgs\.sh'`" != "" ] && continue

 [ "$AUTOUNMOUNT" = "true" ] && auto_unmount_func #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).

 $FREE_FUNCTION

done
#3 second loop.

echo

exit $?

###END###
