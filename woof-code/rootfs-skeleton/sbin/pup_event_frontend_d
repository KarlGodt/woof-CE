#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#this is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
#This script is part of 'pup_event', my (very) light-weight alternative to udev.
#responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
#this script is launched from $HOME/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#v408 rewrite, now works by polling /sys/block.
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.
#091208 fine-tune placement of desktop drive icons.
#091223 partial fix, some interfaces, no change in /sys/block when insert/remove a card.
#100613 some locales (ex: nl_BE) have ',' instead of '.' in numeric, ex o/p of 'dc'.

########################################################################
#
#
#
#
#
# /dev/sda5:
# LABEL="MacPup430_F3"
# UUID="07443de5-1fab-4656-a3ab-7b1c14ccc8c8"
# TYPE="ext3"
# DISTRO_VERSION=430·#481·#416·#218·#478······#####change·this·as·required#####
# DISTRO_BINARY_COMPAT="puppy"·#"ubuntu"·#"puppy"·#####change·this·as·required#####
# case·$DISTRO_BINARY_COMPAT·in
# ubuntu)
# DISTRO_NAME="Jaunty·Puppy"
# DISTRO_FILE_PREFIX="upup"
# DISTRO_COMPAT_VERSION="jaunty"
# ;;
# debian)
# DISTRO_NAME="Lenny·Puppy"
# DISTRO_FILE_PREFIX="dpup"
# DISTRO_COMPAT_VERSION="lenny"
# ;;
# slackware)
# DISTRO_NAME="Slack·Puppy"
# DISTRO_FILE_PREFIX="spup"
# DISTRO_COMPAT_VERSION="12.2"
# ;;
# arch)
# DISTRO_NAME="Arch·Puppy"
# DISTRO_FILE_PREFIX="apup"
# DISTRO_COMPAT_VERSION="200904"
# ;;
# t2)
# DISTRO_NAME="T2·Puppy"
# DISTRO_FILE_PREFIX="tpup"
# DISTRO_COMPAT_VERSION="puppy5"
# ;;
# puppy)·#built·entirely·from·Puppy·v2.x·or·v3.x·or·4.x·pet·pkgs.
# DISTRO_NAME="Puppy"
# DISTRO_FILE_PREFIX="pup"·#"ppa"·#"ppa4"·#"pup2"··#pup4··###CHANGE·AS·REQUIRED,·recommend·limit·four·characters###
# DISTRO_COMPAT_VERSION="4"·#"2"··#4·····###CHANGE·AS·REQUIRED,·recommend·single·digit·5,·4,·3,·or·2###
# ;;
# esac
# PUPMODE=2
# KERNVER=2.6.30.6-KRG-i486
# ATADRIVES='·sda'
# USB_SATAD=''
# PUP_HOME='/'
# Linux·puppypc·2.6.30.6-KRG-i486·#1·SMP·Sun·Jan·2·20:32:12·GMT-1·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xvesa_stripped_upx9
# $LANG=en_US
# today=Mon·Oct·24·22:53:50·CEST·2011
# TODO1: floppy drives : fd0 shown instead of fd1
#
#
#
# TODO1: change path to /tmp/wmexitmode.txt
########################################################################

VERSION=1.2.0  # 2017-04-07 mainly code cleanups

test -f /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5
# BATCHMARKER01 - Marker for Line-Position to bulk insert code into.

[ "$DISPLAY" ] || _exit 1 "Need X running." #X not running.
DISP=${DISPLAY%.*}

trap "rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"; exit" INT QUIT ABRT KILL TERM

# ** VARIABLES ** #
DEBUG=1

__HOME(){  #KRG
home="$HOME"
[ "$home" = "/" ] && home="/root"
_debug "home='$home'"
}  #KRG

_set_home_var(){
case "$HOME" in ''|/) export HOME=/root;; esac
}
_set_home_var

OLDLANG=$LANG #100613
export LANG=C #w004

ACTION_DIR="$HOME"/.pup_event
TMP_DIR=/tmp/pup_event

_usage(){
MSG="$MY_SELF [ start|stop|restart ]

Script that creates drive icons on desktop
if supported desktop manager is running.
Currently supported desktop manager(s) : ROX-Filer .
If enabled as daemon, polls /sys/block for changes
if hotplug drives are inserted and removed
like USB Pendrives, ZIP-Floppy drives, CD-ROM drives.

Options:
start   : starts this program
stop    : stops this program
restart : restarts this program if already running
"
MSG=`gettext "$MSG"`
exit $?
}

_kill_me_not(){
    _debug "`ls -l /var/run/pup_event_frontend_d.pid."$DISP" 2>&1`"
    if test -s /var/run/pup_event_frontend_d.pid."$DISP"; then
    read pupPID </var/run/pup_event_frontend_d.pid."$DISP"
    fi
    if test "$pupPID"; then
     kill -9 $pupPID 2>>$ERR
     rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
    else
      echo 3 #DEBUG
      PIDS=`pidof -o $$ -o %PPID ${0##*/}`
      for pid in $PIDS; do
      kill -9 $pid   ; done
      rm $VERB -f /var/run/pup_event_frontend_d.pid*
    fi
}

case $1 in
*help) _usage 0;;
*stop)
_kill_me_not
exit
;;
*restart)
_kill_me_not
;;
*start|'') :;;
*) _exit 2 "Allowed parameters: start|stop|restart" ;;
esac

_check_if_already_running(){
##+++2012-04-02
#pidof -o $$ -o %PPID ${0##*/} && { _err "Already Running."; exit 1; }
if test -s /var/run/pup_event_frontend_d.pid."$DISP"
then read pupPID </var/run/pup_event_frontend_d.pid."$DISP"
 if test "$pupPID"; then
  if pidof pup_event_frontend_d | grep $Q -w "$pupPID"
  then _exit 1 "Already running on current DISPLAY '$DISPLAY' with PID '$pupPID'"
  fi
 fi
fi
}
_check_if_already_running

# ** VARIABLES ** #
TOGGLE=1
SAVECNT=0
MOUSECNT=0  #w007
MINUTECNT=0 #w007
cursPOS1="" #w007
#echo -n "" > /tmp/pup_event_frontend_d_curpos.log #w007

ZDRV='';ZDRVINIT='no' #these usually set in PUPSTATE.
. /etc/rc.d/PUPSTATE
PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"
KERNVER=`uname -r`
. /etc/eventmanager #has RAMSAVEINTERVAL, ICONDESK, HOTPLUGNOISY, ICONPARTITIONS, BACKENDON, POWERTIMEOUT
. /etc/rc.d/functions4puppy4
DEBUG=1

RAMSAVEINTERVAL=${RAMSAVEINTERVAL:-30}    #412
RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60)) #convert minutes to seconds.

POWERTIMEOUT=${POWERTIMEOUT:-0}     #w007
POWERTIMEOUT=$((POWERTIMEOUT * 60)) #convert minutes to seconds.

SIZE_MODS_M=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_M=`du -m -s /lib/modules | cut -f 1`
fi
RETVALm=1
PREVSIZETMPM=0
PREVSIZEFREEM=0

#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.

sleep 2 #let the dust settle after X has started.


 #v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_icon_change_flag
 #which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
 #however I think it would be good to test here also if X mode not yet settled on...
if [ -f /tmp/videomode ];then #only exists during X resolution setup.
 if [ "`readlink /usr/bin/X`" = "Xvesa" ];then
  while [ -f /tmp/videomode ];do
   sleep 1
  done
 fi
fi


__old_rox_delay__(){   #w471 slow cpus need more delay (well, rox does)...
 DELAYFACTOR=0
 CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
 [ "$CPUMHZ" ] && [ "$CPUMHZ" -gt 100 ] && DELAYFACTOR=$((1100 / CPUMHZ))
 [ "$DELAYFACTOR" -gt 0 ] && sleep $DELAYFACTOR
 }

__fix_rox__(){
read CWM </etc/windowmanager
case "$CWM" in 'enlightenment'*) :;;
*)
until test "`pidof ROX-Filer`"; do sleep 1s; done
;;
esac

pidof ROX-Filer >>$OUT || fixitup
##+++2012-04-02
}



_auto_unmount(){  #v424 experiment, automatic unmounting...
local STATUS=0
 for oneMNTPT in `grep '^/dev/' /proc/mounts | grep -vE '^/dev/loop|^/dev/ram' | cut -f 2 -d ' ' | grep -vE '^/initrd/|^/$'`
 do
  oneMNTPT=`echo -e "$oneMNTPT"`
  if [ "`fuser -v -m $oneMNTPT`" = "" ];then
   _sync
   _info "Attempt to unmount '$oneMNTPT' .."
   /bin/umount "$oneMNTPT" ; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ "$umVAL" -ne 0 ];then
    #ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | sed -e 's/  /|/g' | grep -v '|||' | cut -f 1 -d ' ' | tr '\n' ' '`
    #for oneZOMBIE in $ZOMBIES
    #do
    # kill $oneZOMBIE 2>/dev/null
    #done
    _killzombies # f4puppy5
    /bin/umount "$oneMNTPT"
   else
    true
   fi
   STATUS=$((STATUS+$?))
  else
  _info "_auto_unmount: '$oneMNTPT' is in use."
  fi
 done
return $STATUS
}

_free_initrd(){ #UniPup, runs entirely in initramfs.
 #SIZEFREEK=`free | grep '^Total:' | tr -s ' ' | cut -f 4 -d ' '` # old busybox free
 #SIZEFREEM=$((SIZEFREEK / 1024))
 SIZEFREE=`free -m | grep -E '.*Mem:|.*Swap:' | awk '{print $4}'`
 for one in $SIZEFREE; do
 SIZEFREEM=$((SIZEFREEM+one))
 done
 #[ -s /tmp/pup_event_sizefreem ]     && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 #[ "$PREVSIZEFREEM" = "$SIZEFREEM" ] && return  # unneeded, since it should change quite a lot
 #save to a file, freememapplet can read this... # could reduce writings tough
 echo "$SIZEFREEM" > /tmp/pup_event_sizefreem
}

_free(){ #called every 4 seconds.
 case $PUPMODE in
  6|12)
   SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`;;
  *)
   SIZEFREEM=`/bin/df -m | grep ' /$'              | tr -s ' ' | cut -f 4 -d ' '`;;
 esac
 WARNMSG=""
 [ -s /tmp/pup_event_sizefreem ] && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 [ "$PREVSIZEFREEM" -eq $SIZEFREEM ] && return
 if [ "$SIZEFREEM" -lt 10 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #save layer is at top, delete mods.
  else
   WARNMSG="WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ]; then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 [ "$PUPMODE" -eq 5 -o "$PUPMODE" -eq 2 ] && return 0 # 5=first boot, no msgs at top of screen.
 if [ "$WARNMSG" ]; then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
}

_free_flash(){ #PUPMODE 3,7,13. called every 4 seconds.
 WARNMSG=""
 SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_ro1$' | tr -s ' ' | cut -f 4 -d ' '`
  SIZETMPM=`/bin/df -m | grep ' /initrd/pup_rw$'  | tr -s ' ' | cut -f 4 -d ' '`
 [ -s /tmp/pup_event_sizefreem ] && PREVSIZEFREEM=`cat /tmp/pup_event_sizefreem`
 [ -s /tmp/pup_event_sizetmpm ]  &&  PREVSIZETMPM=`cat /tmp/pup_event_sizetmpm`
 [ "$PREVSIZEFREEM" -eq $SIZEFREEM -a "$PREVSIZETMPM" -eq $SIZETMPM ] && return 0
 if [ "$SIZEFREEM" -lt 10 ]; then
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_ro1 #delete modules in save layer only.
  else
   WARNMSG="WARNING: Personal storage file getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 if [ "$SIZETMPM" -lt 5 ]; then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #delete modules in top tmpfs layer only.
  else
   WARNMSG="WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ]; then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ]; then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 echo "$SIZETMPM" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 if [ "$WARNMSG" ]; then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
}

_savepuppy(){ #called every 4 seconds.
 if [ -f /tmp/snapmergepuppyrequest ]; then #by request.
  rm $VERB -f /tmp/snapmergepuppyrequest
  yaf-splash -font "8x16" -outline 0 -margin 4 -bg orange -placement top -text "Saving RAM to 'pup_save' file..." & YAFPID=$!
  _sync
  nice -n 19 /usr/sbin/snapmergepuppy
  kill $YAFPID 2>>$ERR
 fi
}

            #note that init script in initrd takes care of restoring modules if enough space.
_delete_drivers(){  #called from _free() and _free_flash(). delete modules to create more free space.
 #passed param: /pup_rw=delete tmpfs top layer only.
 DEL_LAYER=$1
 #find out what modules are loaded, keep those...
 for oneKEEP_MOD in `lsmod | cut -f 1 -d ' ' | grep -v 'Module'`
 do
  oneKEEP_SPEC=`modinfo -F filename ${oneKEEP_MOD}`
  oneKEEP_PATH=`dirname $oneKEEP_SPEC`
  mkdir $VERB -p /tmp${oneKEEP_PATH}
  cp $VERB -af ${oneKEEP_SPEC} /tmp${oneKEEP_PATH}/
 done
 if [ "$DEL_LAYER" ]; then
  rm $VERB -rf ${DEL_LAYER}/lib/modules
 else
  case "$PUPMODE" in 3|7|13)
   rm $VERB -rf ${SAVE_LAYER}/lib/modules
  ;; esac
  rm $VERB -rf /lib/modules
 fi
 cp $VERB -af /tmp/lib/modules /lib/modules
 depmod -a
}

      #v407 fixed so works for sr* and hd* optical...
_probe_optical(){  #passed param is sr<0-9> or hd<a-z>
 namePARTITION="$1"
 categoryDISK="optical"
 CDSTATUS2="0"
 opticalPATTERN='^/dev/'"${namePARTITION}"' '
 [ "`grep "$opticalPATTERN" /proc/mounts`" ] && return 0 #only check cd if unmounted.
 cddetect_quick -d/dev/${namePARTITION} >>$OUT 2>>$ERR  #very fast.
 #...returns 0 if disc inserted, else 255.
 CDSTATUS2="$?"
 [ "$CDSTATUS2" != "0" -a -d $ACTION_DIR/drive_${namePARTITION} ] && rm $VERB -rf $ACTION_DIR/drive_${namePARTITION} #v410 ensure no drive directory if drive empty.
 echo "$CDSTATUS2" > "$TMP_DIR"/frontend_identify2_${namePARTITION}
 [ -f "$TMP_DIR"/frontend_identify1_${namePARTITION} ] || cp $VERB "$TMP_DIR"/frontend_identify2_${namePARTITION} "$TMP_DIR"/frontend_identify1_${namePARTITION}
 CDSTATUS1=`cat "$TMP_DIR"/frontend_identify1_${namePARTITION}`
 [ "$CDSTATUS1" = "$CDSTATUS2" ] && return
 cp $VERB -f "$TMP_DIR"/frontend_identify2_${namePARTITION} "$TMP_DIR"/frontend_identify1_${namePARTITION}
 if [ "$CDSTATUS2" = "0" ];then
  #VENDOR="`cat /sys/block/${namePARTITION}/device/vendor | tr -s ' '`"
  #MODEL="`cat /sys/block/${namePARTITION}/device/model | tr -s ' '`"
  #DRV_DESCRIPTION="$VENDOR $MODEL"
  opticalPATTERN='^/dev/'"${namePARTITION}"'|'
  DRV_DESCRIPTION=`echo "$PROBEDISK" | grep "$opticalPATTERN" | cut -f 3 -d '|'`
  _create_icon #requires nameDISK, categoryDISK, DRV_DESCRIPTION.
  [ "$HOTPLUGNOISY" = "true" ] && {
test -e $ACTION_DIR/drive_${namePARTITION}/AppRun && $ACTION_DIR/drive_${namePARTITION}/AppRun optical &
                                        } #handler script.
#KRG else
#KRG  rm $VERB -rf $HOME/.pup_event/drive_${namePARTITION} 2>/dev/null
#KRG  _remove_pinboard #needs namePARTITION
 fi
}

                  #v407 detect ls120 and zip disc inserted...
_probe_floppy(){  #passed param is drive name (exs: hdc, sdc)
 namePARTITION="$1"
 kindDRIVE=`echo -n "$namePARTITION" | cut -c 1,2` #sd or hd.
 categoryDISK="floppy"
 floppyPATTERN="^/dev/$namePARTITION "
 [ "`grep "$floppyPATTERN" /proc/mounts`" ] && return 0 #mounted.
 if [ "$kindDRIVE" = "hd" ];then
  cat /proc/ide/${namePARTITION}/identify > "$TMP_DIR"/frontend_identify2_${namePARTITION}
 else
  #this method not as good, as only detects disc if it has a partition...
  floppyPATTERN=" ${namePARTITION}"
  grep "$floppyPATTERN" /proc/partitions > "$TMP_DIR"/frontend_identify2_${namePARTITION}
 fi
 [ -f "$TMP_DIR"/frontend_identify1_${namePARTITION} ] || cp $VERB "$TMP_DIR"/frontend_identify2_${namePARTITION} "$TMP_DIR"/frontend_identify1_${namePARTITION}
 [ "`diff -s "$TMP_DIR"/frontend_identify1_${namePARTITION} "$TMP_DIR"/frontend_identify2_${namePARTITION} | grep ' are identical'`" ] && return
 cp $VERB -f "$TMP_DIR"/frontend_identify2_${namePARTITION} "$TMP_DIR"/frontend_identify1_${namePARTITION}
 FLOPPYSTATUS=1
 [ "`disktype /dev/${namePARTITION} 2>&1 | grep 'I/O error'`" ] || FLOPPYSTATUS=0
 if [ "$FLOPPYSTATUS" = "0" ];then
  if [ "$kindDRIVE" = "hd" ];then
   DRV_DESCRIPTION=`cat /proc/ide/${namePARTITION}/model`
  else
   DRV_DESCRIPTION=`cat /sys/block/${namePARTITION}/device/model | tr -s ' '`
  fi
  _create_icon #requires nameDISK, categoryDISK, DRV_DESCRIPTION.
  [ "$HOTPLUGNOISY" = "true" ] && {
test -e $ACTION_DIR/drive_${namePARTITION}/AppRun && $ACTION_DIR/drive_${namePARTITION}/AppRun floppy &
                                        } #handler script.
#KRG else
#KRG  rm $VERB -rf $HOME/.pup_event/drive_${namePARTITION} 2>/dev/null
#KRG  _remove_pinboard #needs namePARTITION
 fi
}

_SCRN_VARS(){  #KRG
SCRNXY=`xwininfo -root | grep -o '\-geometry .*' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'` #orig
SCRN_X=`echo "$SCRNXY" | cut -f 1 -d 'x'` #orig
SCRN_Y=`echo "$SCRNXY" | cut -f 2 -d 'x'` #orig
} #KRG
_SCRN_VARS

_format_size(){
 SIZE=${SIZE:-0}
 if [ "$SIZE" -gt 1048576 ];then #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p` #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 elif [ "$SIZE" -gt 99 ];then
   SIZE="$((SIZE / 1024))MB"
 else
  SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`MB" #100613
 fi
 case "$SIZE" in "0.0MB"|"0,0MB") SIZE="0";; esac #100613
}

_create_appinfo(){  #needs INFO, categoryDISK, MOREITEMS, namePARTITION
   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${INFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${categoryDISK}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item>
   <Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>
   ${MOREITEMS}
  </AppMenu>
</AppInfo>" > $ACTION_DIR/drive_${namePARTITION}/AppInfo.xml
}

_JWM(){
#CWM=`cat /etc/windowmanager`
read CWM </etc/windowmanager

 case "$CWM" in *jwm*)
  JwmL=`grep -E -i 'Tray | autohide | insert | x | y | insert' $HOME/.jwmrc-tray`
  JWMTpos=`echo $JwmL | grep -o 'y=.*$' | cut -f 1 -d ' ' | cut -f 2 -d '"'`
  [ -z "$JWMTpos" ] && JWMTpos="-1"
  HEIGHT=`echo $JwmL | grep -o 'height=.*$' | tr -d ' ' | cut -f 2 -d '"'`
 ;; esac

 [ -z "$HEIGHT" ] && HEIGHT=28

 case "$HEIGHT" in
  "20"|"28") HP=1;;
  "34"|"42") HP=2;;
 esac
 case "$HP" in 1|2) :;; *) HP=1;; esac
}
_JWM

_ROX(){
 CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"
 PIN_GRID_STEP=`grep "pinboard_grid_step" $CONFFILEROX | sed -e "s/ *<[^>]*>//g"`
 [ -z "$PIN_GRID_STEP" ]    && PIN_GRID_STEP=16 #16=medium.
 [ "$PIN_GRID_STEP" -gt 0 ] || PIN_GRID_STEP=16 #precaution.

 _info "PIN_GRID_STEP='$PIN_GRID_STEP'"
 PIN_GRID_STEP2=$((PIN_GRID_STEP / 2))

 [ -z "$ICON_PLACE_START_GAP" ] && ICON_PLACE_START_GAP=32
##[ -z "$ICON_PLACE_EDGE_GAP" ] && ICON_PLACE_EDGE_GAP=64
 [ -z "$ICON_PLACE_ORIENTATION" ] && ICON_PLACE_ORIENTATION='bottom'
 if [ -z "$ICON_PLACE_SPACING" ] ; then
  ##case "$ICON_PLACE_ORIENTATION" in
  ##bottom)

 DriveIconsize=`grep -o 'DRVICON=.*' /etc/rc.d/functions4puppy4  | grep -o '[[:digit:]]*' | head -n 1`

 ICON_PLACE_SPACING=$(( (( DriveIconsize / PIN_GRID_STEP ) + 1 ) * PIN_GRID_STEP ))

_func_out(){
  case "$SCRN_Y" in
  480)  ICON_PLACE_SPACING=$(( ICON_PLACE_SPACING + ( PIN_GRID_STEP * 1 ) ))
  ;;
  600)  ICON_PLACE_SPACING=$(( ICON_PLACE_SPACING + ( PIN_GRID_STEP * 2 ) ))
  ;;
  768)  ICON_PLACE_SPACING=$(( ICON_PLACE_SPACING + ( PIN_GRID_STEP * 3 ) )) #24
  ;;
  1024) ICON_PLACE_SPACING=$(( ICON_PLACE_SPACING + ( PIN_GRID_STEP * 4 ) )) #32
  ;;
  1200) ICON_PLACE_SPACING=$(( ICON_PLACE_SPACING + ( PIN_GRID_STEP * 5 ) )) #40
  ;;
  esac
 }

 fi

 VALSY=$(( SCRN_Y / PIN_GRID_STEP ))
 for i in `seq 1 $VALSY` ; do PGSYvals="$PGSYvals `echo $( dc $i $PIN_GRID_STEP \* p )`" ; done
 echo "VALSY='$VALSY'"
 echo "PGSYvals='$PGSYvals'"

 VALSX=$(( SCRN_X / PIN_GRID_STEP ))
 for i in `seq 1 $VALSX` ; do PGSXvals="$PGSXvals `echo $( dc $i $PIN_GRID_STEP \* p )`" ; done
}
_ROX

_MAX_XY(){
MAX_X=`expr $SCRN_X`
}
_MAX_XY

_START_XY_ICON_VALUES(){   #KRG
case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   case "$JWMTpos" in
   0)
   COORD_YSt=$(( 0 + ICON_PLACE_START_GAP )) # ICON_PLACE_EDGE_GAP default 64, see /etc/eventmanager
   ;;
   *)
   COORD_YSt=`expr $SCRN_Y - $ICON_PLACE_EDGE_GAP - \( $PIN_GRID_STEP \* $HP \)` #default 64, see /etc/eventmanager
   if [ -z "`echo "$PGSYvals" | grep "$COORD_YSt"`" ] ; then
     for i in `seq 1 $PIN_GRID_STEP` ; do
     TEST=$(( COORD_YSt - i ))
     _debug "TEST='$TEST'"
     [ -n "`echo "$PGSYvals" | grep "$TEST"`" ] && { COORD_YSt=$TEST;break; }
     done
   fi
   ;;
   esac

   COORD_Y=$COORD_YSt
   _debug "COORD_Y='$COORD_Y'"
   #COORD_Y=`expr \( $COORD_Y - $PIN_GRID_STEP2 \) \/ $PIN_GRID_STEP '*'  $PIN_GRID_STEP` #430: - $PINgridSTEP2
   COORD_Y=$(( ( ( COORD_Y ) / PIN_GRID_STEP ) * PIN_GRID_STEP ))
   _debug "COORD_Y='$COORD_Y'"
   ;;


  top)
  COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
  case "$JWMTpos" in
   0)
   COORD_YSt=$(( ICON_PLACE_START_GAP + JWMT_Yvar )) ###ICON_PLACE_EDGE_GAP=64 too large at 1024x768
   ;;
   *)
   COORD_YSt=$ICON_PLACE_START_GAP
   ;;
   esac
   COORD_Y=$COORD_YSt
   #COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*'  $PIN_GRID_STEP`
   COORD_Y=$(( ( ( COORD_Y + ) / PIN_GRID_STEP ) * PIN_GRID_STEP ))
   ;;
   left)
   COORD_X=$ICON_PLACE_START_GAP #EDGEdefault 64, see /etc/eventmanager
   case "$JWMTpos" in
   0)
   COORD_YSt=$(( ICON_PLACE_START_GAP + JWMT_Yvar ))
   ;;
   *)
   COORD_YSt=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   ;;
   esac
   COORD_Y=$COORD_YSt
   COORD_Y=$(( ( ( COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP ) *  PIN_GRID_STEP ))
   ;;
   right)
   COORD_X=$(( SCRN_X - ( 2 * ICON_PLACE_SPACING ) - PIN_GRID_STEP2 )) #default 64, see /etc/eventmanager
   _debug "JWMTpos='$JWMTpos'"
   case "$JWMTpos" in
   0)
   COORD_YSt=$(( ICON_PLACE_START_GAP + JWMT_Yvar )) #default 32, see /etc/eventmanager
   ;;
   *)
   COORD_YSt=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   ;;
   esac
   COORD_Y=$COORD_YSt
   COORD_Y=$(( ( ( COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP ) * PIN_GRID_STEP ))
   _debug right COORD_Y=$COORD_Y
   ;;
esac
}
_START_XY_ICON_VALUES #KRG

_VAR_VARS(){
LINE=1
}
_VAR_VARS

_free_coord(){
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...
 #sleep 1
 COORDSGRID1=`grep -o ' x="[0-9]*" y="[0-9]*" ' $HOME/Choices/ROX-Filer/PuppyPin` # | sed 's/[0-9]"/"/g'`
 COORDSGRID2=`grep -o ' x="[0-9]*" y="[0-9]*" ' $HOME/Choices/ROX-Filer/PuppyPin`
 COORDSGRID=`echo "$COORDSGRID1"\n"$COORDSGRID2"`
 _debug "` echo "$COORDSGRID" | head -n 2`"

 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)

   _debug "X='$COORD_X' Y='$COORD_Y' '$namePARTITION'"
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.

   while :;do

    xgPATTERN=`echo -n "$xPATTERN"`  # | sed 's/[0-9]"/"/g'
    _debug "    xgPATTERN='$xgPATTERN'"

    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || { echo breaking now;break; }
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))

    if [ "$COORD_X" -gt "$MAX_X" ];then #start next line up.
     LINE=$(( LINE + 1 ))
     COORD_Y=$((COORD_Y - ICON_PLACE_SPACING - PIN_GRID_STEP))  ###- $PIN_GRID_STEP`  ### - $FONTSfac \( $LINE \* $FBUF \) - 8` #SCRN_Y@1024:-8
     if [ -z "`echo "$PGSYvals" | grep "$COORD_Y"`" ] ; then
     for i in `seq 1 $PIN_GRID_STEP` ; do
     TEST=$(( COORD_Y - i ))
     _debug "TEST='$TEST'"
     [ -n "`echo "$PGSYvals" | grep "$TEST"`" ] && COORD_Y=$TEST && break
     done
     fi
     COORD_X=$ICON_PLACE_START_GAP

     _debug "COORD_Y='$COORD_Y' COORD_X='$COORD_X' LINE='$LINE'"
    fi

    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "

   done
   #echo
  ;;
  top)

   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :;do
    xgPATTERN=`echo -n "$xPATTERN"` # |  sed 's/[0-9]"/"/g'`"
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))
    if [ "$COORD_X" -gt "$MAX_X" ];then #start next line down.

     COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  left)

   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :;do
    xgPATTERN=`echo -n "$xPATTERN"` # |  sed 's/[0-9]"/"/g'`"
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
    if [ "$COORD_Y" -gt "$MAX_Y" ];then #start next row.

     COORD_X=$((COORD_X + ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  right)

   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :;do
    xgPATTERN=`echo -n "$xPATTERN"` # |  sed 's/[0-9]"/"/g'`"
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
    if [ "$COORD_Y" -gt "$MAX_Y" ];then #start next row back.

     COORD_X=$((COORD_X - ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
 esac
}

_add_pinboard(){  #needs namePARTITION, categoryDISK, FSTYPE
 #ppPATTERN=' label="'"$namePARTITION"'"'
 #v411 rerwin: avoid icon getting duplicated if it is renamed...
 ppPATTERN="$ACTION_DIR/drive_${namePARTITION}<"
 ##[ "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" != "" -a -z "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" ] && return #precaution.
 [ "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" ] && return
 _free_coord
 _debug "X Pin='${COORD_X}' Y Pin='${COORD_Y}' '$namePARTITION'"
 #namePARTITIONlast="$namePARTITION"
 echo
 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$ACTION_DIR/drive_${namePARTITION}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${namePARTITION}</Label>
   <Args>${categoryDISK} ${FSTYPE}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R
}

#====== Wich File-Systems are Supported ? ====================================
while read oneFS
do
builtinFS="${builtinFS}|${oneFS}"
done<<EoI
`grep -v 'nodev' /proc/filesystems`
EoI

modulesFS=`modprobe -l | grep '/fs/' | grep -E 'udf|iso9660|ext[0-9]|btrfs|f2fs|hfs|hpfs|hfsplus|sysv|V7|xfs|jfs|ufs|zfs|msdos|vfat|ntfs|minix|reiserfs|reiser4' | sed 's!\(.*\)/\(.*\)\.ko*$!\2!'`
modulesFS=`echo "$modulesFS" | tr '\n' '|'`

allFS="${modulesFS}|${builtinFS}|fat[0-9]*"
allFS=`echo "$allFS" | sed 's/^|*//;s/|*$//' | tr -s '|'`
_info "Kernel has support for these file-systems:"
_info "$allFS"
allFS=`echo "$allFS" | sed 's/|/\\\||\\\|/g'`
_debug "$allFS"
allFS=`echo "$allFS" | sed 's!^!\\\|!;s!$!\\\|!'`
_debug "$allFS"

_create_icon(){
 _debug "_create_icon:'$*'"
 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables namePARTITION, categoryDISK, DRV_DESCRIPTION.
 #if a passed param $1, then PROBEPART already known, inefficient to rerun here each time.
 DRV_INFO="$nameDISK"'|0|0'
 if [ "$ICONPARTITIONS" = "true" ];then
  #display an icon for each partition... w476 add ext4...
  [ "$1" ] || PROBEPART=`probepart -k -d/dev/$nameDISK | grep -iE "$allFS"`
  drvPATTERN='^/dev/'"${nameDISK}" #important, no space on end!
  DRV_INFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|' | tr '\n' ' '`
  _debug "DRV_INFO='$DRV_INFO'"
  #w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update...
  diCNT=0
  if [ "`echo -n "$nameDISK" | grep -E '^sd|^mmc|^sr'`" ]; then
   while [ ! "$DRV_INFO" ];do
    diCNT=$((diCNT + 1))
    [ "$diCNT" -gt 3 ] && break
    sleep 1
    PROBEPART=`probepart -k -d/dev/$nameDISK | grep -iE "$allFS"`
    DRV_INFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|' | tr '\n' ' '`
   done
  fi
 _debug "DRV_INFO='$DRV_INFO'"
 fi

 for oneDRV_INFO in $DRV_INFO
 do

  namePARTITION=`echo "$oneDRV_INFO" | cut -f 1 -d '|' | cut -f 3 -d '/'`
         FSTYPE=`echo "$oneDRV_INFO" | cut -f 2 -d '|'`
           SIZE=`echo "$oneDRV_INFO" | cut -f 3 -d '|'`
  drvPATTERN='^/dev/'"${namePARTITION}"' ' #important, a space on end!
  _debug "namePARTITION='$namePARTITION' FSTYPE='$FSTYPE' SIZE='$SIZE'"

  if [ ! -d $ACTION_DIR/drive_${namePARTITION} ];then
   mkdir $VERB $ACTION_DIR/drive_${namePARTITION}
   cp $VERB -af /usr/local/bin/drive_all $ACTION_DIR/drive_${namePARTITION}/AppRun

   if [ -e /sys/block/${namePARTITION} ];then
    #device is an entire drive. ie sr0
    SIZE=`cat /sys/block/${namePARTITION}/size`
    SIZE=$(($SIZE/2)) #get KB.
    _format_size #formats SIZE for display.
    INFO="Description: ${DRV_DESCRIPTION} Size: ${SIZE}"
   elif [ "$FSTYPE" = "0" -a "$SIZE" = "0" ];then
     INFO="Puppy drive manager"
   else
     #pPATTERN=' '"$namePARTITION"'$'
     #SIZE=`grep "$pPATTERN" /proc/partitions | tr -s ' ' | cut -f 4 -d ' '`
     _format_size #formats SIZE for display.
     INFO="Filesystem: $FSTYPE Size: $SIZE"
   fi

   #v424 add item to unmount all partitions...
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${namePARTITION} (if currently mounted)</Label></Item>
   <Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   _create_appinfo #needs INFO, categoryDISK, MOREITEMS, namePARTITION
  fi
  if [ "$ICONDESK" = "true" ];then #see /etc/eventmanager.
   MNTSTATUS=`/bin/df | grep "$drvPATTERN"`
   _debug "namePARTITION='$namePARTITION' categoryDISK='$categoryDISK'"
   if [ "$MNTSTATUS" = "" ];then
    icon_unmounted_func $namePARTITION $categoryDISK #see functions4puppy4.
   else
    icon_mounted_func $namePARTITION $categoryDISK #see functions4puppy4.
   fi
   if test "$CWM" != 'enlightenment_start'; then
   _debug "starting _add_pinboard..."
   _add_pinboard #needs namePARTITION, categoryDISK, FSTYPE.
   fi
  fi
 done

 #always create a handler for entire drive, even if no icon displayed...
 if [ ! -d $ACTION_DIR/drive_${nameDISK} ];then
  if [ -e /sys/block/${nameDISK} ];then
   mkdir $VERB $ACTION_DIR/drive_${nameDISK}
   cp $VERB -af /usr/local/bin/drive_all $ACTION_DIR/drive_${nameDISK}/AppRun
   SIZE=`cat /sys/block/${nameDISK}/size`
   SIZE=$(($SIZE/2)) #get KB.
   _format_size #formats SIZE for display.
   INFO="Description: ${DRV_DESCRIPTION} Size: ${SIZE}"
   #v424 add item to unmount all mounted partitions...
   #MOREITEMS="</Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   MOREITEMS="<Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   namePARTITION="$nameDISK"
   _create_appinfo #needs INFO, categoryDISK, MOREITEMS, namePARTITION
  fi
 fi
}

_remove_pinboard(){  #needs nameDISK (name of entire drive)
 if test "$CWM" != 'enlightenment_start'; then
 ppPATTERN=' label="'"$nameDISK"'.*" '
 ##[ -z "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" -o -z "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" ] && echo "returning from _remove_pinboard wo any Changes" && return
 [ -z "`grep "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin`" ] && return  ##+2011_11_05 added space before closing ]
 ALLNAMES=`grep -o "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin | cut -f 2 -d '"' | tr '\n' ' '`
 #ALLNAMESH=`grep -o "$ppPATTERN" $HOME/Choices/ROX-Filer/PuppyPin | cut -f 2 -d '"' | tr '\n' ' '`
 #ALLNAMES="$ALLNAMES $ALLNAMESH"
 for namePARTITION in $ALLNAMES
 do
 _debug "_remove_pinboard:Removing '$namePARTITION'"
 rm $VERB -rf $ACTION_DIR/drive_$namePARTITION
 case $ICON_PLACE_ORIENTATION in
 top|bottom)
 COORD_X=$((COORD_X-ICON_PLACE_SPACING));;
 right|left)
 COORD_Y=$((COORD_Y-ICON_PLACE_SPACING-PIN_GRID_STEP));;
 esac
  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$ACTION_DIR/drive_${namePARTITION}</Path>
  </PinboardRemove>
 </env:Body>
</env:Envelope>"  | rox -R
 done
 fi
}


_old_clear_desk_icons_func(){
 PROBEDISK=`probedisk2`
 BlockDrives=`echo "$PROBEDISK" | cut -f 1 -d '|' | /bin/sort -r`
 if [ "$BlockDrives" ] ; then #1.1.1
  echo "Blockdrives not empty"
  for nameDISK in $BlockDrives ; do
  _remove_pinboard
  done
 fi
 FloppyDrives=`ls /sys/block 2>/dev/null | grep -w 'fd[0-9]*'`
 FDRV=`echo "$FloppyDrives"`
 if [ "$FDRV" ]; then
      for nameDISK in $FDRV
      do
      _remove_pinboard
      done

 fi
}

_clear_desk_icons(){
while read line
do test "$line" || continue
   DRV=`echo "$line" | grep -o 'drive_[^<]*'`
   test "$DRV" || continue
#_debug "$DRV"
   DRV="${DRV/drive_/}"
#_debug "$DRV"
 case $DRV in
sr*|fd*) nameDISK=$DRV _remove_pinboard;;
sd*)     test "${OLD_DRV:0:3}" = "${DRV:0:3}" && continue
         nameDISK=${DRV:0:3} _remove_pinboard
;;
*)       nameDISK=$DRV _remove_pinboard;;
 esac
   OLD_DRV=$DRV
done<$HOME/Choices/ROX-Filer/PuppyPin
unset DRV OLD_DRV line namePARTITION
}
_clear_desk_icons

_START_XY_ICON_VALUES

_start(){
######################################################################
#stuff to setup at entry...
mkdir $VERB -p $ACTION_DIR

#build the desktop icons...
categoryDISK='drive'
#KRGPROBEDISK="`probedisk2`"
echo > /tmp/PROBEDISK2.txt #KRG
probedisk2 | grep -v -i -E 'DBG|dbg|DEBUG|debug' | sed '/^$/d' | while read line; do
L=`echo $line | sed 's#|$#|DiskWontSay#'`
echo "$L" >> /tmp/PROBEDISK2.txt
done
if [ -d /proc/ide ] ; then
PROBEDISK=`cat /tmp/PROBEDISK2.txt | sort -g`
else
PROBEDISK=`cat /tmp/PROBEDISK2.txt`
fi #KRG
#v407 ls120/zip floppy drives are probed every 4 secs...
DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
#v407 same thing for all optical drives...
DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
if [ "$ICONDESK" = "false" ];then
 #only show a single 'drives' icon on desktop...
 namePARTITION='drives'
  categoryDISK='any' #see pmount.
 DRV_DESCRIPTION="all drives"
 _create_icon #needs nameDISK, categoryDISK, DRV_DESCRIPTION.
else
 #show all drives on desktop... w476 add ext4...
 PROBEPART=`probepart -k | grep -iE "$allFS"`
 if [ "$FD0ICON" = "true" ];then #see /etc/eventmanager

 for f in `ls -1 /sys/block | grep '^fd' | /bin/sort -r` ; do #KRG
   PROBEDISK="/dev/$f|floppy|Legacy floppy drive
$PROBEDISK"
   PROBEPART="/dev/$f|vfat|1440
$PROBEPART"
done #KRG

 fi
 for oneDRV in `echo "$PROBEDISK" | cut -f 1,2,3 -d '|' | tr ' ' '_'`
 do
         nameDISK=`echo "$oneDRV" | cut -f 1 -d '|' | cut -f 3 -d '/'`
     categoryDISK=`echo "$oneDRV" | cut -f 2 -d '|'`
  DRV_DESCRIPTION=`echo "$oneDRV" | cut -f 3 -d '|' | tr '_' ' '`
  [ "`echo "$PROBEPART" | grep "^/dev/${nameDISK}"`" ] || continue #precaution (such as CD not inserted).
  _create_icon startup #needs nameDISK, categoryDISK, DRV_DESCRIPTION, PROBEPART.
 done
fi
}
_start # this creates icon(s) on desktop

_do_break(){
echo "$*"
break
}

_PUPEVENTDAEMON(){

mkdir $VERB -p "$TMP_DIR"

echo "$$" >/var/run/pup_event_frontend_d.pid."$DISP"

ls -1 /sys/block | grep -vE '^zram|^ram|^loop|^md|^mtd|^nbd' > "$TMP_DIR"/frontend_block2."$DISP"
[ -f "$TMP_DIR"/frontend_block1."$DISP" ] || cp $VERB "$TMP_DIR"/frontend_block2."$DISP" "$TMP_DIR"/frontend_block1."$DISP"
cursPOS2=`getcurpos`
[ "$cursPOS1" ] || cursPOS1="$cursPOS2"

###################################################################
#now go into a two/two-second loop...
#while [ ! -f /tmp/xwin/wmexitmode.txt ]
#while [ ! -f /tmp/xwin/wmexitmode."$DISP" ]
while :;
do
 sleep 2

 #graceful exit if shutdown X (see /usr/X11R7/bin/restartwm,wmreboot,wmpoweroff)...
 #[ -f /tmp/xwin/wmexitmode.txt ] && _do_break "test -f /tmp/xwin/wmexitmode.txt" ##+2011-11-07 changed path to /tmp/xwin
 [ -f /tmp/xwin/wmexitmode."$DISP" ] && _do_break "test -f /tmp/xwin/wmexitmode.$DISP" ##+2015-12-29 changed filename

 #test for any change in /sys/block...
 #ls -1 --hide=ram* --hide=loop* /sys/block > "$TMP_DIR"/frontend_block2
 ls -1 /sys/block | grep -vE '^zram|^ram|^loop|^md|^mtd|^nbd' > "$TMP_DIR"/frontend_block2."$DISP"

 unset REMOVEBLOCK BLOCKS2 BLOCKDIFF BLOCKSPROBE oneTESTDRV BLOCKSADD BLOCKSREM

 if [ -f /tmp/pup_event_frontend_block_request ]; then #w015 (see gparted_shell, puppyinstaller, bootflash)
  sleep 0.1
  REMOVEBLOCK='^'"`cat /tmp/pup_event_frontend_block_request`"'$'
  BLOCKS2=`grep -v "$REMOVEBLOCK" /tmp/pup_event_frontend_block2."$DISP"`
  echo "$BLOCKS2" > /tmp/pup_event_frontend_block2."$DISP"
  rm $VERB -f /tmp/pup_event_frontend_block_request
 fi
 #[ -f "$TMP_DIR"/frontend_block1 ] || cp $VERB "$TMP_DIR"/frontend_block2 "$TMP_DIR"/frontend_block1
 BLOCKDIFF=`diff -u "$TMP_DIR"/frontend_block1."$DISP" "$TMP_DIR"/frontend_block2."$DISP"`

 #091223 some interfaces, no change in /sys/block when insert/remove a card...
 #note, /proc/partitions can be very slow to update, particularly when remove a card.
 #note, /sys/block/sd*/sd* shows card insertion but may not update on removal -- rox will remove an invalid drive icon in right-click menu .
 if [ ! "$BLOCKDIFF" ];then
  BLOCKSPROBE=""
  for oneTESTDRV in `grep '^sd' "$TMP_DIR"/frontend_block2."$DISP"`
  do
   [ "`echo "$ATADRIVES" | grep "$oneTESTDRV"`" ] && continue
   [ "`cat /sys/block/${oneTESTDRV}/removable 2>/dev/null`" = "0" ] && continue
   if [ ! -e /sys/block/${oneTESTDRV}/${oneTESTDRV}1 ];then #drive exists, but no partition (no card plugged in).
    #try force kernel to update.
    ( true </dev/$oneTESTDRV ) >>$OUT 2>>$ERR
    [ -d $ACTION_DIR/drive_${oneTESTDRV}1 ] && BLOCKSPROBE="${BLOCKSPROBE}-${oneTESTDRV}:"
   else
    [ -d $ACTION_DIR/drive_${oneTESTDRV}1 ] || BLOCKSPROBE="${BLOCKSPROBE}+${oneTESTDRV}:"
   fi
  done
  [ "$BLOCKSPROBE" ] && BLOCKDIFF=`echo "$BLOCKSPROBE" | tr ':' '\n'`
 fi

 #########hotplug block event##########
 if [ "$BLOCKDIFF" ]; then

  cp $VERB -f "$TMP_DIR"/frontend_block2."$DISP" "$TMP_DIR"/frontend_block1."$DISP"

  BLOCKSADD=`echo "$BLOCKDIFF" | grep -E '^\+[[:alnum:]]+' | tr -d '\+'`
  BLOCKSREM=`echo "$BLOCKDIFF" | grep -E '^\-[[:alnum:]]+' | tr -d '\-'`
  _debug "BLOCKSADD='$BLOCKSADD'"
  _debug "BLOCKSREM='$BLOCKSREM'"

  for nameDISK in $BLOCKSADD
  do
   [ -e /sys/block/$nameDISK ] || continue #precaution
   namePARTITION=$nameDISK
   odPATTERN='^/dev/'"$nameDISK"'|'
   PROBEDISK=`probedisk2`
   DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'` #update
    DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|'  | cut -f 1 -d '|' | cut -f 3 -d '/'` #update
   categoryDISK=`echo "$PROBEDISK" | grep "$odPATTERN" | cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo "$PROBEDISK" | grep "$odPATTERN" | cut -f 3 -d '|' | tr -s ' '`
   _debug "blockadd:ICONDESK='$ICONDESK' nameDISK='$nameDISK' categoryDISK='$categoryDISK' DRV_DESCRIPTION='$DRV_DESCRIPTION'"
   [ "$ICONDESK" = "true" ] && _create_icon #uses nameDISK, categoryDISK, DRV_DESCRIPTION
   [ "$HOTPLUGNOISY" = "true" ] && {
    if test "`echo "$nameDISK" | grep -vE 'fd.*|sr.*|scd.*'`"; then
     if test -f $ACTION_DIR/drive_${nameDISK}/AppRun; then
      _debug "Launching handler for '$nameDISK'"
      $ACTION_DIR/drive_${nameDISK}/AppRun ${categoryDISK} & #handler script.
     fi
    fi
    }
  done

  for nameDISK in $BLOCKSREM
  do
   DRVS_OPTICAL=`echo "$DRVS_OPTICAL" | grep -vw "$nameDISK"` #update
    DRVS_FLOPPY=`echo "$DRVS_FLOPPY"  | grep -vw "$nameDISK"` #update
   if [ "`pidof gtkdialog_pmount`" ]; then #if pmount running, refresh it.
    killall gtkdialog_pmount
    sleep 0.1
    LANG=$OLDLANG pmount & #100613 fix from shinobar.
   fi
   #namePARTITION=$nameDISK
   _debug "blockrem: nameDISK='$nameDISK'"
   _remove_pinboard #needs nameDISK
   rm $VERB -rf $ACTION_DIR/drive_${nameDISK}*
  done

 fi

 [ "$TOGGLE" = 0 ] && { # slow code below down to every 4 seconds.
  TOGGLE=1; continue; } || TOGGLE=0

 ####### four second timeout processing #########
 SAVECNT=$((SAVECNT + 4))
 if [ "$RAMSAVEINTERVAL" -ne 0 -a "$SAVECNT" -gt $RAMSAVEINTERVAL ];then
  touch /tmp/snapmergepuppyrequest #request to _savepuppy .
  SAVECNT=0
 fi
 if [ "$POWERTIMEOUT" -ne 0 ];then #w007 power-off computer after inactivity.
   MOUSECNT=$((MOUSECNT + 4 ))
  MINUTECNT=$((MINUTECNT + 4))
  if [ "$MINUTECNT" -gt 59 ];then #come in here every minute...
   MINUTECNT=0
   cursPOS2=`getcurpos`
   [ "$cursPOS1" = "$cursPOS2" ] || MOUSECNT=0
   cursPOS1="$cursPOS2"
   [ "$MOUSECNT" -gt $POWERTIMEOUT ] && wmpoweroff & break
  fi
 fi
 #some apps should not be disturbed by this background stuff...
 RUNPS=`ps`
 #w482 add xorriso...
 [ "`echo "$RUNPS" | grep -E 'xorriso|xorrecord|xine|petget|wget|axel|dotpup|mplayer|gcurl|gimv|burniso2cd|growisofs|cdrecord|pcdripper|xfmedia|xmms|ripoff|pdvdrsab|pburn|mhwaveedit|installpkg\.sh|downloadpkgs\.sh'`" ] && continue

 [ "$AUTOUNMOUNT" = "true" ] && _auto_unmount #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).

 #monitor free memory, periodic save of tmpfs top layer...
 case $PUPMODE in
  3|7|13)
   _free_flash
   _savepuppy
  ;;
  16|24|17|25) #unipup.
   _free_initrd
  ;;
  *)
   _free
  ;;
 esac

 if [[ -f /tmp/pup_event_icon_change_flag ]]; then  #KRG
    ##if [[ "`cat /tmp/pup_event_icon_change_flag`" = "ICONWIPE" ]]; then
    Floppies=`ls -1v /sys/block | grep '^fd[0-9]*' | /bin/sort -r`
    if [ -d /proc/ide ] ; then
    Drives=`ls -1v /sys/block | grep -E '^sd|^hd|^sr|^mmc|^scd' | /bin/sort -r`
    else
    Drives=`ls -1v /sys/block | grep -E '^sd|^hd|^sr|^mmc|^scd'`
    fi
    for nameDISK in $Drives; do
    _remove_pinboard
    done
    for nameDISK in $Floppies; do
    _remove_pinboard
    done
    . /etc/eventmanager
    _SCRN_VARS
    ##JWMTASKBAR_func
    _JWM
    _ROX
    _MAX_XY
    _START_XY_ICON_VALUES
    #PUPEVENTSTART_func
    _start
    sleep 1
    rm $VERB -f /tmp/pup_event_icon_change_flag
    ##fi
 fi  #KRG

 [ "$ICONDESK" = "false" ] && continue #v405 see /etc/eventmanager
 #unfortunately, we have to poll at regular intervals to see if a cd is inserted...
 for oneOPTICAL in $DRVS_OPTICAL
 do
  [ "$oneOPTICAL" ] || continue #precaution
  _probe_optical $oneOPTICAL
 done
 #v407 poll to see if a ls120 or zip floppy diskette inserted...
 for oneFLOPPY in $DRVS_FLOPPY
 do
  [ "$oneFLOPPY" ] || continue #precaution
  _probe_floppy $oneFLOPPY
 done

_old_placement_flag(){
if [[ -f /tmp/pup_event_icon_change_flag ]]; then  #KRG
    ##if [[ "`cat /tmp/pup_event_icon_change_flag`" = "ICONWIPE" ]]; then
    Floppies=`ls -1v /sys/block | grep '^fd[0-9]*' | /bin/sort -r`
    if [ -d /proc/ide ] ; then
    Drives=`ls -1v /sys/block | grep -E '^sd|^hd|^sr|^mmc|^scd' | /bin/sort -r`
    else
    Drives=`ls -1v /sys/block | grep -E '^sd|^hd|^sr|^mmc|^scd'`
    fi
    for nameDISK in $Drives; do
    _remove_pinboard
    done
    for nameDISK in $Floppies; do
    _remove_pinboard
    done

    . /etc/eventmanager
    _SCRN_VARS
    ##JWMTASKBAR_func
    _JWM
    _ROX
    _MAX_XY
    _START_XY_ICON_VALUES
    #PUPEVENTSTART_func
    _start
    sleep 1
    rm $VERB -f /tmp/pup_event_icon_change_flag
    ##fi
fi  #KRG
}

_debug "Reached end of main daemon func"
done #2 second loop.
}

STATUS=0
if [ "$BACKENDON" = "false" ];then #see /etc/eventmanager.
  #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 if _pidof $Q hotplug2stdout; then
  killall hotplug2stdout 2>>$ERR # pup_event_backend_d # no module/firmware hotplug support.
  STATUS=$((STATUS+$?))
 fi
 if _pidof $Q udevd; then
  killall udevd 2>>$ERR #alternative to pup_event_backend_d.
  STATUS=$((STATUS+$?))
 fi
fi
[ "$HOTPLUGON" = "false" ] && exit $STATUS #turn off all frontend hotplug support. see /etc/eventmanager.

test -d /sys/block || _exit 2 "Directory /sys/block missing."

_notice "Starting main daemon function..."
_PUPEVENTDAEMON; STATUS=$((STATUS+$?))
_notice "Returned from main daemon func."
rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
STATUS=$((STATUS+$?))
_info "END"
exit $STATUS
###END###
