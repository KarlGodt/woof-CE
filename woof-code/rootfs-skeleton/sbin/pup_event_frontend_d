#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
# This is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
# This script is part of 'pup_event', my (very) light-weight alternative to udev.
# Responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
# This script is launched from /root/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#
#v408 REWRITE, now works by polling /sys/block.
#
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.
#
#091208 fine-tune placement of desktop drive icons.
#091223 partial fix, some interfaces, no change in /sys/block when insert/remove a card.
#100613 some locales (ex: nl_BE) have ',' instead of '.' in numeric, ex o/p of 'dc'.

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"

Version='1.2.1-kill Macpup_Opera_2-Puppy_Linux_431-KRG'

usage(){
MSG="
$0 [ help | version ]
$0 [ debug | verbose ] [ start | restart ]
$0 [ stop | status ]
$0 [ codecheck ]
Puppy Daemon to manage the Drive Icons on the desktop.
Is configurable by /usr/sbin/eventmanager gtkdialog GUI.

Help Options :
-V|version) show version information
-h|help) show this usage information

Development Options :
codecheck)    run with set -n
-d|debug)     run with set -x
-v|verbose) show variables to stdout

Main Options :
stop ) stop
start) start
restart) stop and start
status) say if already running
"

[ "$2" ] && "MSG=$MSG
$2
"

echo "$MSG"

exit $1
}

OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=--quiet;DBG='';

while getopts Vhvd opt; do
 case $opt in
  V) echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0;;
  h) usage 0;;
  v) VERBOSE=$((VERBOSE+1));VERB="$VERB -v";L_VERB="$L_VERB --verbose";A_VERB="$A_VERB -verbose";
      OUT=/dev/stdout;ERR=/dev/stderr;
      DEBUG=$((DEBUG+1));DBG="$DBG -d";L_DBG="$L_DBG --debug";
      unset Q QUIET
      ;;
  d) set -x;;
  *) :;;
  esac
done


ME_PROGRAM=`realpath "$0"`  ##+-2013-08-10 should be readlink -e but busybox readlink treats -f as -e option
ME_PID=$$
ME_OTHER_PIDS=`pidof -o $$ -o %PPID ${ME_PROGRAM##*/}`

[ "$*" ] || set - start  ##+++2014-11-08
PARAMETER_LINE="$@"

while [ "$1" ]; do
CASEPARAM=$1;shift

case "$CASEPARAM" in
*help|-h) usage 0
;;
*version|-V)
echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0
;;
*check*)
#BASH set -n
bn=${0##*/}
cp $VERB $0 /tmp/
sed -i '1d' /tmp/"$bn"
sed -i '1i\#!/bin/bash -n' /tmp/"$bn"
/tmp/"$bn" $PARAMETER_LINE
echo "<$?>"
echo "Codecheck finished"
echo "Attention :
Normally uses ash, this had been done in bash,
because ash has no -n parameter"
exit 0
;;
*debug|-d) set -x
;;
*verbose|-v) VERBOSE=$((VERBOSE+1))
VERB="$VERB -v";L_VERB="$L_VERB --verbose";A_VERB="$A_VERB -verbose";
OUT=/dev/stdout;ERR=/dev/stderr;
DEBUG=$((DEBUG+1));DBG="$DBG -d";L_DBG="$L_DBG --debug";
unset Q QUIET
;;

*stop)
 pidof -o $$ -o %PPID ${ME_PROGRAM##*/} || { echo " NOT Running.";exit 0; }
  for pid in $ME_OTHER_PIDS; do
   kill $pid
    RETVAL=$((RETVAL+$?))
     done
    test "$RETVAL" || RETVAL=0
   pidof -o $$ -o %PPID ${ME_PROGRAM##*/} && RETVAL=1
  echo
 exit "$RETVAL"
;;

*restart)
for pid in $ME_OTHER_PIDS; do
 echo $pid
  kill $pid
   done
  sleep 3
 echo
  pidof  ${ME_PROGRAM##*/}
 echo
  pidof -o $$ -o %PPID ${ME_PROGRAM##*/}
  pidof -o $$ -o %PPID ${ME_PROGRAM##*/} && { echo " Already Running.";exit 1; }
 break
;;

*start|"")
 pidof -o $$ -o %PPID ${ME_PROGRAM##*/} && { echo " Already Running.";exit 1; }
  break
;;

*status)
echo -n "$ME_PROGRAM : "
 [ "`echo $ME_OTHER_PIDS | wc -w`" = 1 ] && IS=is || IS=are
  [ "$ME_OTHER_PIDS" ] && echo "$ME_OTHER_PIDS $IS already running." || echo "not already running."
   exit 0
;;
*) echo "UNHANDLED CASEPARAM '$CASEPARAM'";
exit 4;
;;
esac
done
### OPTIONS ###


_get_jobs_pids(){
ps-FULL -o ppid,lwp,tty,start,s,psr,pcpu,args -C ${ME_PROGRAM##*/} --no-headers | while read PPid Pid rest; do
Pids="$Pids
$Pid"
echo "$Pids" | grep $Q -w "$PPid" && echo "$Pid"
done
}

_kill_jobs(){
JOBS=`_get_jobs_pids`
for Pid in $JOBS ; do
/bin/ps -p "$Pid" && kill $Pid
done
}

_probedisk_simple(){
[ "${VERBOSE}" ] && echo "$0:_probedisk_simple: Probing for drives..." >>/dev/stderr
ALLDRIVES=`ls -1 /sys/block | grep -vE 'ram|loop|mtd|md|nbd'`
for drive_ in $ALLDRIVES ; do
unset REMOVABLE KIND VEND MODL
[ -f /sys/block/$drive_/removable ] && read REMOVABLE </sys/block/$drive_/removable
[ "$REMOVABLE" ] || REMOVABLE=0
case $drive_ in
sd*)
[ "`readlink /sys/block/$drive_ | grep '/usb[/0-9]*/'`" ] && KIND=usbdrv
if test ! "$KIND"; then
[ "$REMOVABLE" = 0 ] && KIND=drive || KIND=usbdrv
fi
  ;;
sr*)
[ "`readlink /sys/block/$drive_ | grep '/usb[/0-9]*/'`" ] && KIND=optical #KIND=usbcd
if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=usbdrv
fi
  ;;
fd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=floppy || KIND=floppy
fi
  ;;
hd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 0 ] && KIND=drive || KIND=usbdrv
fi
   ;;
scd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=usbdrv
fi
   ;;
mmc*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=card || KIND=usbdrv
fi
  ;;
esac
[ -f /sys/block/$drive_/device/vendor ] && read VEND </sys/block/$drive_/device/vendor
[ -f /sys/block/$drive_/device/model ]  && read MODL </sys/block/$drive_/device/model
[ "$VEND" ] || VEND=Unknown
[ "$MODL" ] || MODL=Unknown
#PARTS=`ls -1 /sys/block/$drive/$drive[0-9]* 2>$ERR | grep -o -e '[0-9]*' |tr '\n' ' '`
echo "$drive_|$KIND|$VEND $MODL"
done
[ "${VERBOSE}" ] && echo " $0: Done probing." >>/dev/stderr
}

[ "$VERBOSE" ] && echo "$0: Header END"

### CODE ###

[ "$DISPLAY" ] || exit 0 #X not running.
OLDLANG=$LANG #100613
export LANG=C #w004

#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.

sleep 2 #let the dust settle after X has started.

#w471 slow cpus need more delay (well, rox does)...
DELAYFACTOR=0
CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
[ "$CPUMHZ" -a "$CPUMHZ" -gt 100 ] && DELAYFACTOR=$(( 1100 / CPUMHZ ))
[ "$DELAYFACTOR" -gt 0 ] && sleep $DELAYFACTOR
_sleep_=0
until [ "`pidof ROX-Filer`" ]; do
sleep 2
_sleep_=$((_sleep_+1))
[ "$_sleep_" = 9 ] && break
done
until [ "`awk -F '.' '{print $1}' /proc/loadavg`" -lt 2 ];do sleep 5;done


#v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_icon_change_flag
#which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
#however I think it would be good to test here also if X mode not yet settled on...
if [ -f /tmp/videomode ];then #only exists during X resolution setup.
 if [ "`readlink /usr/bin/X`" = "Xvesa" ];then
  while [ -f /tmp/videomode ]; do
_count_=$((_count_+1))
   sleep 3
[ "$_count_" = 100 ] && { echo "/tmp/videomode still exist after 5 minutes. Exit.";exit 0; }
  done
 fi
fi

### VARIABLES
POLL_INTERVALL=2 #seconds
SAVECNT=0
MOUSECNT=0  #w007
MINUTECNT=0 #w007
CURPOS1=""  #w007

KERNVER=`uname -r`
ZDRV='';ZDRVINIT='no' #these usually set in PUPSTATE.
test -f /etc/rc.d/PUPSTATE         && . /etc/rc.d/PUPSTATE
test -f /etc/rc.d/functions4puppy4 && . /etc/rc.d/functions4puppy4
test -f /etc/rc.d/f4puppy5         && . /etc/rc.d/f4puppy5

###<KRG>
stateDIR="$HOME/Choices/Puppy"
drive_iconDIR="$stateDIR"/pup_event
mkdir $VERB -p "$drive_iconDIR"
FLAGFILE=/tmp/pup_event_icon_change.flg
[ "$CONFFILE" ] || CONFFILE=/etc/eventmanager.cfg
test -f "$CONFFILE" && . "$CONFFILE"
PUPPY_PIN="$HOME/Choices/ROX-Filer/PuppyPin"

SCRNXY=`xwininfo -root | grep -o '\-geometry .*' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'`
SCRN_X=`echo -n "$SCRNXY" | cut -f 1 -d 'x'`
SCRN_Y=`echo -n "$SCRNXY" | cut -f 2 -d 'x'`

[ "$RAMSAVEINTERVAL" ] || RAMSAVEINTERVAL=30 #412
RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60)) #convert minutes to seconds.

[ "$POWERTIMEOUT" ] || POWERTIMEOUT=0 #w007
POWERTIMEOUT=$((POWERTIMEOUT * 60)) #convert minutes to seconds.

SIZE_MODS_M=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_M=`du -m -s /lib/modules | cut -f 1`
fi
RETVALm=1
PREVSIZETMPM=0
PREVSIZEFREEM=0

#v424 experiment, automatic unmounting...
auto_unmount_func() {
 [ "$AUTOUNMOUNT" = true ] || return
 for oneMNTPT in `grep '^/dev/' /proc/mounts | grep -vE '^/dev/loop|^/dev/ram|^/dev/zram|^/dev/mtd|^/dev/nbd|^/dev/md' | cut -f 3 -d ' ' | grep -v '^/initrd/' | grep -v '^/$'`
 do
  if [ ! "`fuser -v -m $oneMNTPT`" ];then
   pidof sync >>$OUT || sync
   /bin/umount $oneMNTPT ; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ $umVAL -ne 0 ];then
    ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | grep -v 'grep' | sed 's#^ *##;s/  /|/g' | grep -v '|||' | awk '{print $1}'`
    for oneZOMBIE in $ZOMBIES
    do
     /bin/ps --no-header -p $oneZOMBIE >$OUT && kill $oneZOMBIE
    done
    /bin/umount "$oneMNTPT" ; umVAL=$?
   fi
  fi
 done
}

_format_size() {
 [ "$SIZE" ] || SIZE=0
 if [ "$SIZE" -gt 1048576 ];then               #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p`   #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 else
  if [ "$SIZE" -gt 1024 ];then
   SIZE="`expr $SIZE \/ 1024`MB"
  else
   #SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
   SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`KB" #100613
  fi
 fi
 [ "${SIZE//[[:alpha:][:punct:]]/}" = '00' ] && SIZE=0
}

_create_appinfo() { #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
   [ "$1" ] && DRV_NAME="$1"
   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${INFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${DRV_CATEGORY}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item>
   <Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>
   ${MOREITEMS}
  </AppMenu>
</AppInfo>" > $drive_iconDIR/drive_${DRV_NAME}/AppInfo.xml
}

 PIN_GRID_STEP=`grep "pinboard_grid_step" $HOME/.config/rox.sourceforge.net/ROX-Filer/Options | sed -e "s/ *<[^>]*>//g"`
 [ $PIN_GRID_STEP ]       || PIN_GRID_STEP=16 #2=fine 16=medium 32=coarse
 [ $PIN_GRID_STEP -le 0 ] && PIN_GRID_STEP=16 #precaution.
 PIN_GRID_STEP2=$((PIN_GRID_STEP / 2))
 MAX_X=$((SCRN_X - 96))
 MAX_Y=$((SCRN_Y - 96))
_debug "PIN_GRID_STEP=$PIN_GRID_STEP PIN_GRID_STEP2=$PIN_GRID_STEP2"




__free_coord_normal__(){
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...
 COORDSGRID=`grep -o -e ' x="[0-9]*" y="[0-9]*" ' "$PUPPY_PIN" | sed 's/[0-9]"/"/g'`
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   COORD_Y=$((SCRN_Y - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP ) * PIN_GRID_STEP))
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))
    if [ $COORD_X -gt $MAX_X ];then #start next line up.
     xyCNT=$((xyCNT + 1))
     #[ $xyCNT -gt 1 ] && break
     COORD_Y=$((COORD_Y - ICON_PLACE_SPACING))
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  top)
   COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))
    if [ $COORD_X -gt $MAX_X ];then #start next line down.
     xyCNT=$((xyCNT + 1))
     #[ $xyCNT -gt 1 ] && break
     COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  left)
   COORD_X=$ICON_PLACE_EDGE_GAP  #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    #xgPATTERN="`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`"
    xgPATTERN="${xPATTERN//[0-9]\"/\"}"
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y+ICON_PLACE_SPACING))
    if [ $COORD_Y -gt $MAX_Y ];then #start next row. ##FIXME
     xyCNT=$((xyCNT+1))
     #[ $xyCNT -gt 1 ] && break ##FIXME
     COORD_X=$((COORD_X+ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  right)
   COORD_X=$((SCRN_X - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP             #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
    if [ $COORD_Y -gt $MAX_Y ];then #start next row back.
     xyCNT=$((xyCNT + 1))
     COORD_X=$((COORD_X - ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
 esac
}

_free_coord_simple(){
 #DRIVE_NAME="$1"
 #LAST_PLACE=`grep -m1 -w "\.pup_event/drive_${OLD_DRV_NAME}" /root/Choices/ROX-Filer/PuppyPin`
 LAST_PLACE=`grep -m1 '\pup_event/drive_' "$PUPPY_PIN"`
 [ "$LAST_PLACE" ] && { COORD_X=`echo "$LAST_PLACE" | cut -f2 -d'"'`; COORD_Y=`echo "$LAST_PLACE" | cut -f4 -d'"'`; }
 #echo "'$OLD_DRV_NAME' $DRIVE_NAME
_debug "'$LAST_PLACE'
$COORD_X $COORD_Y"
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   [ "$COORD_Y" ] || COORD_Y=$((SCRN_Y - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y - ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  top)
   [ "$COORD_Y" ] || COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  left)
   [ "$COORD_X" ] || COORD_X=$ICON_PLACE_EDGE_GAP #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X + ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  right)
   [ "$COORD_X" ] || COORD_X=$((SCRN_X - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X - ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
   esac
#OLD_DRV_NAME="$DRIVE_NAME"
}

_add_pinboard() { #needs oneDRVNAME, DRV_CATEGORY, FSTYPE
 [ "$1" ] && DRV_NAME="$1"
 [ "`grep "/drive_${DRV_NAME}</icon>$" "$PUPPY_PIN"`" ] && return
 _free_coord_simple   #${oneDRVNAME}

 _debug "Passing X='$COORD_X' Y='$COORD_Y' to rox -R"

 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$drive_iconDIR/drive_${DRV_NAME}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${DRV_NAME}</Label>
   <Args>${DRV_CATEGORY} ${FSTYPE}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R
}

_probepart() {
PROBEPART=`probepart $* -k | grep -iE 'not inserted|\|ext4\||\|ntfs\||\|msdos\||\|vfat\||\|.*fat.*\||\|ext2\||\|ext3\||\|iso9660\||\|xfs\||\|udf\||\|jfs\||\|reiser'`
}

_create_icon() {
    DEBUG=1
 [ "$1" ] && DEV_NAME="$1"

 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
 #if a passed param $1, then PROBEPART already known, inefficient to rerun here each time.

   if [ "$ICONDESK" = "false" ];then
    DRVINFO="/dev/$DEV_NAME"'|0|0' #we show one icon though for all drives and partitions

 elif [ "$ICONPARTITIONS" = "false" ];then
    read SIZE </sys/block/$DEV_NAME
    FSTYPE=`guess_fstype /dev/$DEV_NAME`
    DRVINFO="/dev/${DEV_NAME}|${FSTYPE}|${SIZE}"

 elif [ "$ICONPARTITIONS" = "true" ];then

  #display an icon for each partition... w476 add ext4...
  _probepart -d/dev/$DEV_NAME ;
  _debug "$PROBEPART"
  _debug "Done."

  drvPATTERN="^/dev/${DEV_NAME}" #important, no space on end! #drvPATTERN='^/dev/'"${PART_NAME}"
  DRVINFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|'`

 fi   ## was# ICONPARTITIONS true

_debug "$DRVINFO"

 while read -r oneDRVINFO
 do
  [ "$oneDRVINFO" ] || continue

  PART_NAME=`echo -n "$oneDRVINFO" | cut -f 1 -d '|' | cut -f 3 -d '/'`
  _debug "DEV_NAME=$DEV_NAME' PART_NAME=$PART_NAME'"

  FSTYPE=`echo -n "$oneDRVINFO" | cut -f 2 -d '|'`
  _debug "FSTYPE=$FSTYPE'"

  SIZE=`echo -n "$oneDRVINFO" | cut -f 3 -d '|'`

  drvPATTERN='^/dev/'"${PART_NAME}"' ' #important, a space on end!

  if [ ! -d $drive_iconDIR/drive_${PART_NAME} ]; then
   mkdir $VERB -p $drive_iconDIR/drive_${PART_NAME}  ##sbin/pup_event_frontend_d: line 50: can't create : nonexistent directory
   /bin/cp $VERB -a --remove-destination /usr/local/bin/drive_all $drive_iconDIR/drive_${PART_NAME}/AppRun
  else
    echo -e "\\033[1;33m""$drive_iconDIR/drive_${DEV_NAME} EXTST ...""\\033[0;39m"
  fi

   if [ "$FSTYPE" != 0 -a "$SIZE" != 0 ] ; then
    _format_size #formats SIZE for display.
    INFO="Filesystem: $FSTYPE Size: ${SIZE}
${DRV_DESCRIPTION}"
   elif [ "$FSTYPE" = "0" -a "$SIZE" = "0" ];then #only one icon for all drives
     INFO="Puppy drive manager"
   else
     _format_size #formats SIZE for display.
     INFO="${DRV_DESCRIPTION} Size: $SIZE"
     #v424 add item to unmount all partitions...
   fi

   case $PART_NAME in *[0-9])
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${PART_NAME} (if currently mounted)</Label></Item>
   <Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>
   <Item option=\"mountro\" icon=\"gtk-harddisk\"><Label>Read-Only (re)mount of ${PART_NAME}</Label></Item>
   <Item option=\"fsck_$FSTYPE\" icon=\"gtk-execute\"><Label>Fsck ${PART_NAME} (if not mounted)</Label></Item>"
   ;;
   esac

   _create_appinfo $PART_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME or PART_NAME
   unset MOREITEMS

  _debug "DBG drvPATTERN=$drvPATTERN"

 if  [ "$ICONDESK" = "false" ];then
 icon_unmounted_func $PART_NAME $DRV_CATEGORY;_add_pinboard $PART_NAME
 elif [ "$ICONPARTITIONS" = "true" ];then
      _debug "ICONPARTITIONS true"
    MNTSTATUS=`/bin/df | grep -m1 "$drvPATTERN"`
    if [ ! "$MNTSTATUS" ];then
     icon_unmounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
    else
     _debug 'starting now icon_mounted_func'
     icon_mounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
     _debug 'returned from icon_mounted_func'
    fi
   _add_pinboard $PART_NAME #needs oneDRVNAME, DRV_CATEGORY, FSTYPE.
  else icon_unmounted_func $PART_NAME $DRV_CATEGORY;_add_pinboard $PART_NAME
 fi
 done<<EOI
$(echo "$DRVINFO")
EOI

}

_remove_pinboard() { #needs DEV_NAME (name of entire drive)
 [ "$1" ] && DRV_NAME="$1"
 case $DRV_NAME in
 hd*|mmc*|scd*|sd*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g' | sed 's/[0-9]*$//'`;;
 fd*|sr*|*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g'`;;
 esac

 ppPATTERN='\pup_event/drive_'"$DRV_NAME"'.*'

 ALLNAMES=`grep -o "$ppPATTERN" "$PUPPY_PIN" | cut -f 3 -d '_' | cut -f 1 -d '<' | sort -r`

 for ONE_PART in $ALLNAMES
 do

  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$drive_iconDIR/drive_${ONE_PART}</Path>
  </PinboardRemove>
  <UnsetIcon>
   <Path>$drive_iconDIR/drive_${ONE_PART}</Path>
  </UnsetIcon>
 </env:Body>
</env:Envelope>"  | rox -R
 done
}

#note that init script in initrd takes care of restoring modules if enough space.
_delete_drivers() { #called from _free() and _free_flash(). delete modules to create more free space.
 #passed param: /pup_rw=delete tmpfs top layer only.
 DEL_LAYER=$1
 #find out what modules are loaded, keep those...
 for oneKEEP_MOD in `lsmod | cut -f 1 -d ' ' | grep -v 'Module'`
 do
  oneKEEP_SPEC=`modinfo -F filename ${oneKEEP_MOD}`
  oneKEEP_PATH-${oneKEEP_SPEC%/*}
  test -d /tmp${oneKEEP_PATH} || mkdir $VERB -p /tmp${oneKEEP_PATH}
  cp $VERB -af ${oneKEEP_SPEC} /tmp${oneKEEP_PATH}/
 done
 if [ "$DEL_LAYER" ];then
  rm $VERB -rf ${DEL_LAYER}/lib/modules
 else
  if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then
   rm $VERB -rf ${SAVE_LAYER}/lib/modules
  fi
  rm $VERB -rf /lib/modules
 fi
 cp $VERB -af /tmp/lib/modules /lib/modules
 depmod -a
}

_free_initrd() { #UniPup, runs entirely in initramfs.
 SIZEFREEK=`free | grep '^Total:' | tr -s ' ' | cut -f 4 -d ' '`
 test "$SIZEFREEK" || {
    SIZEFREEM_=`free -m |  awk '{ if (match($1, "Mem.*")) || (match($1, "Swap.*")) print $4}'`
   for m_ in $SIZEFREEM_; do SIZEFREEM=$((SIZEFREEM+m_)); done
 }
 test "$SIZEFREEM" || {
    test "$SIZEFREEK" || {
        SIZEFREEK_=`free |  awk '{ if (match($1, "Mem.*")) || (match($1, "Swap.*")) print $4}'`
         for k_ in $SIZEFREEK_; do SIZEFREEK=$((SIZEFREEK+m_)); done
    }
      test "$SIZEFREEK" &&  SIZEFREEM=$((SIZEFREEK / 1024))
 }

 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" = "$SIZEFREEM" ] && return
 #save to a file, freememapplet can read this...
 echo "$SIZEFREEM" > /tmp/pup_event_sizefreem
}

_free() { #called every 4 seconds.
 case $PUPMODE in
  6|12)
   SIZEFREEM=`/bin/df -m | grep -m1 ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
  *)
   SIZEFREEM=`/bin/df -m | grep -m1 ' /$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
 esac
 WARNMSG=""
 PREVSIZEFREEM=0
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" -eq $SIZEFREEM ] && return
 if [ "$SIZEFREEM" -lt 10 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #save layer is at top, delete mods.
  else
   WARNMSG="WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 [ "$PUPMODE" -eq 5 -o "$PUPMODE" -eq 2 ] && return 0 #5=first boot, no msgs at top of screen.
 if [ "$WARNMSG" ];then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
}

_savepuppy(){
  yaf-splash -font "8x16" -outline 0 -margin 4 -bg orange -placement top -text "Saving RAM to 'pup_save' file..." &
  YAFPID=$!
  pidof sync >>$OUT || sync
  nice -n 19 /usr/sbin/snapmergepuppy
  kill $YAFPID
}

_free_flash(){ #PUPMODE 3,7,13. called every 3 seconds.
 WARNMSG=""
 SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_ro1$' | tr -s ' ' | cut -f 4 -d ' '`
  SIZETMPM=`/bin/df -m | grep ' /initrd/pup_rw$'  | tr -s ' ' | cut -f 4 -d ' '`
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ -s /tmp/pup_event_sizetmpm ]  && read PREVSIZETMPM  </tmp/pup_event_sizetmpm
 [ $PREVSIZEFREEM -eq $SIZEFREEM -a $PREVSIZETMPM -eq $SIZETMPM ] && return
 if [ $SIZEFREEM -lt 10 ];then
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_ro1 #delete modules in save layer only.
  else
   WARNMSG="WARNING: Personal storage file getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 if [ "$SIZETMPM" -lt 5 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #delete modules in top tmpfs layer only.
  else
   WARNMSG="WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 echo "$SIZETMPM" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 if [ "$WARNMSG" ];then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
_savepuppy
}

######################################################################
#stuff to setup at entry...


_probedisk2(){
    PROBEDISK=`probedisk2`
 _debug "$PROBEDISK"
}

_clear_desk_icons(){
drives=`grep '/\pup_event/drive_*' "$PUPPY_PIN" | grep -o '/drive_.*<' | cut -f2 -d '_' | tr -d '<' | awk '{print $1}' | tr -d '[[:digit:]]' | sort -u | sort -r`

for item in $drives; do
DEV_NAME="$item"
_debugx "removing '$DEV_NAME'"
_remove_pinboard $DEV_NAME
done
rm $VERB -fr "$drive_iconDIR"/*
_debugx "Finished _clear_desk_icons
"
}
_clear_desk_icons


_start_pup_event_frontend_d(){
_debug "_start_pup_event_frontend_d BEGIN"

PROBEDISK2_LOOP_NEW=`_probedisk_simple`
PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW"

_probedisk2

#build the desktop icons...
DRV_CATEGORY='drive'
#v407 ls120/zip floppy drives are probed every 4 secs...
DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
#v407 same thing for all optical drives...
DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`

if [ "$ICONDESK" = "false" ];then
_info "ICONDESK is false"
 #only show a single 'drives' icon on desktop...
     DEV_NAME='drives'
 DRV_CATEGORY='any' #see pmount.
 DRV_DESCRIPTION="all drives"

 _create_icon $DEV_NAME

elif [ "$ICONPARTITIONS" = "false" ];then

  _info 'Just Maindrives'
  #for item in $PROBEDISK ; do
  while read -r item; do

          DEV_NAME=`echo "$item" |cut -f 1 -d '|' | cut -f 3 -d '/'`
      DRV_CATEGORY=`echo "$item" |cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo "$item" |cut -f 3 -d '|'`
   _debug $item
   _create_icon $DEV_NAME

  done <<EoI
`echo "$PROBEDISK"`
EoI

else
  _debug "ICONPARTITIONS='$ICONPARTITIONS'"

 #show all drives on desktop... w476 add ext4...

while read -r oneDRV
#IFS='|' while read -r DRV_NAME DRV_CATEGORY DRV_DESCRIPTION
 do
 [ "$oneDRV" ] || continue

 _debug "oneDRV=$oneDRV'"

         DEV_NAME=`echo "$oneDRV" | cut -f1 -d'|' | cut -f 3 -d '/'`
     DRV_CATEGORY=`echo "$oneDRV" | cut -f2 -d'|'`
  DRV_DESCRIPTION=`echo "$oneDRV" | cut -f3 -d'|'`

  _create_icon $DEV_NAME #startup #needs PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION, PROBEPART.
  #_create_icon $DRV_NAME

  if [ ! -d $drive_iconDIR/drive_${DEV_NAME} ]; then
   mkdir $VERB -p $drive_iconDIR/drive_${DEV_NAME}
   /bin/cp $VERB -a --remove-destination /usr/local/bin/drive_all $drive_iconDIR/drive_${DEV_NAME}/AppRun
   INFO="Puppy drive manager"
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${DEV_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   _create_appinfo $DEV_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
   else
    echo -e "\\033[1;31m""$drive_iconDIR/drive_${DEV_NAME} EXTST ...""\\033[0;39m"
  fi

 done<<EOI
$(echo "$PROBEDISK")
EOI
fi    #;fi
_debug "_start_pup_event_frontend_d  END "
}

_start_pup_event_frontend_d

if [ "$BACKENDON" = "false" ];then #see /etc/eventmanager.
 killall hotplug2stdout #pup_event_backend_d #no module/firmware hotplug support.
 #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 [ "`pidof udevd`" ] && killall udevd #alternative to pup_event_backend_d.
fi
#[ "$HOTPLUGON" = "false" ] && exit #turn off all frontend hotplug support. see /etc/eventmanager.

trap "_kill_jobs;exit $?" HUP INT QUIT ABRT TRAP KILL TERM

_do_ramsaveinterval(){
while :; do
 SAVECNT=$((SAVECNT + 60))
 if [ "$SAVECNT" -gt "$RAMSAVEINTERVAL" ];then
  _savepuppy
  SAVECNT=0
 fi
sleep 60
done
}

_do_powertimeout(){
while :; do

 ##some apps should not be disturbed by this background stuff...
 #RUNPS=`ps`
 ##w482 add xorriso...
 #[ "`echo "$RUNPS" | grep -Ew 'make|gcc|xorriso|xorrecord|xine|petget|wget|axel|dotpup|mplayer|gcurl|gimv|burniso2cd|growisofs|cdrecord|pcdripper|xfmedia|xmms|ripoff|pdvdrsab|pburn|mhwaveedit|installpkg\.sh|downloadpkgs\.sh'`" != "" ] && return
   pidof make gcc xorriso xorrecord xine petget wget axel dotpup mplayer gcurl gimv burniso2cd growisofs cdrecord pcdripper xfmedia xmms ripoff pdvdrsab pburn mhwaveedit installpkg.sh downloadpkgs.sh >$OUT && return

   CURPOS1=`getcurpos`
   [ "$CURPOS1" = "$CURPOS2" ] || MOUSECNT=0

   if [ "$MOUSECNT" -gt "$POWERTIMEOUT" ] ; then
   _debug MOUSECNT=$MOUSECNT POWERTIMEOUT=$POWERTIMEOUT
   aplay /usr/share/audio/2barks.au
   sleep 1s
   aplay /usr/share/audio/2barks.au
   xmessage -bg red -timeout 60 -buttons "YES:190,No:191" -fn "-misc-dejavu sans-*-*-*-*-*-*-*-*-*" 'Really powering off now ?'

    REPLY=$?
    echo $REPLY
    if [ "$REPLY" = "190" -o "$REPLY" = "0" ] ; then
    exec wmpoweroff &
    fi
   fi
 CURPOS2="$CURPOS1"
 sleep 60s
 MOUSECNT=$((MOUSECNT+60))
done
}

CURPOS1=1
CURPOS2=1
[ "$VERBOSE" ] && echo "POWERTIMEOUT='$POWERTIMEOUT'"
[ "$POWERTIMEOUT" -ne 0 ] && _do_powertimeout &

case $PUPMODE in
3|7|13)
   FREE_FUNCTION='_free_flash'
   _debug "RAMSAVEINTERVAL='$RAMSAVEINTERVAL'"
   [ "$RAMSAVEINTERVAL" -ne 0 ] && _do_ramsaveinterval &
 ;;
16|24|17|25) #unipup.
   FREE_FUNCTION='_free_initrd'  ;;
  *)
   FREE_FUNCTION='_free'  ;;
esac

_which_hotplug(){

_check_hotplug_event(){
    :
 }

if test "$HOTPLUGON" = true; then
_check_hotplug_event(){
DEBUG=1
if [ "$PROBEDISK2_LOOP_NEW" != "$PROBEDISK2_LOOP_OLD" ] ; then
 ######### hotplug detected : #########
  _debug "MAIN loop not same"
  BLOCKSADD=`echo "$PROBEDISK2_LOOP_NEW" | /bin/grep -v "$PROBEDISK2_LOOP_OLD"`
  BLOCKSREM=`echo "$PROBEDISK2_LOOP_OLD" | /bin/grep -v "$PROBEDISK2_LOOP_NEW"`
  _debug "BLOCKSADD=$BLOCKSADD'"
  _debug "BLOCKSREM=$BLOCKSREM'"

  if [ "$BLOCKSADD" ] ; then
   while read -r aADD; do
   [ "$aADD" ] || continue
          DEV_NAME=`echo -n "$aADD" | cut -f 1 -d '|' | cut -f3 -d'/'`
      DRV_CATEGORY=`echo -n "$aADD" | cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo -n "$aADD" | cut -f 3 -d '|' | tr -s ' '`
   _debug "_check_hotplug_event:DEV_NAME=$DEV_NAME DRV_CATEGORY=$DRV_CATEGORY DRV_DESCRIPTION=$DRV_DESCRIPTION"
   [ "$ICONDESK" = "true" ] && _create_icon $DEV_NAME
   #uses DEV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
   [ "$HOTPLUGNOISY" = "true" ] && $drive_iconDIR/drive_${PART_NAME}/AppRun ${DRV_CATEGORY} & #handler script.
  done<<EoI
$(echo "$BLOCKSADD")
EoI

  elif [ "$BLOCKSREM" ] ; then
   while read -r aREM; do
   [ "$aREM" ] || continue
    DEV_NAME=`echo "$aREM" | cut -f1 -d'|' | cut -f3 -d'/'`
    [ "$DEV_NAME" ] || continue
   if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, refresh it.
    killall gtkdialog_pmount
    sleep 0.1
    LANG=$OLDLANG pmount & #100613 fix from shinobar.
   fi
   _remove_pinboard $DEV_NAME #needs DEV_NAME or DRV_NAME
   rm $VERB -rf $drive_iconDIR/drive_${DEV_NAME}*
  done<<EOI
$(echo "$BLOCKSREM")
EOI

  fi
fi

 ######### hotplug detected #########
 _debug "$0:Hotplug detected ?:"
 PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW"
 PROBEDISK2_LOOP_NEW=`_probedisk_simple`
 _debug "PROBEDISK_LOOP_OLD='$PROBEDISK_LOOP_OLD'"
 _debug "PROBEDISK_LOOP_NEW='$PROBEDISK_LOOP_NEW'"
 _debug ""
 ####### POLL_INTERVAL second timeout procesing #########
 }
fi
}

_which_hotplug

###################################################################
#now go into a three-second loop...
while :;
do
# sleep $POLL_INTERVALL

#########check hotplug block event##########

 _check_hotplug_event
 $FREE_FUNCTION

 if test -f "/tmp/pup_event_icon_change.flg" ;then #1
 #[ "$HOTPLUGON" = true ] && {
     _clear_desk_icons
     unset COORD_X COORD_Y
 #}
 [ -f "$CONFFILE" ] && . "$CONFFILE"
 POWERTIMEOUT=$((POWERTIMEOUT * 60));RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60))
 _which_hotplug
 _start_pup_event_frontend_d
 sleep 1
 rm $VERB -f /tmp/pup_event_icon_change.flg
 fi #1

 [ "$AUTOUNMOUNT" = "true" ] && auto_unmount_func #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).
 sleep $POLL_INTERVALL

done
# POLL_INTERVALL loop

echo

exit $?

###END###
