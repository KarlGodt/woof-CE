#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
# This is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
# This script is part of 'pup_event', my (very) light-weight alternative to udev.
# Responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
# This script is launched from /root/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#
#v408 REWRITE, now works by polling /sys/block.
#
#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.
#
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.
#
#091208 fine-tune placement of desktop drive icons.
#091223 partial fix, some interfaces, no change in /sys/block when insert/remove a card.
#100613 some locales (ex: nl_BE) have ',' instead of '.' in numeric, ex o/p of 'dc'.

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"

OLDLANG=$LANG #100613
export LANG=C #w004

test -f /etc/rc.d/PUPSTATE         && . /etc/rc.d/PUPSTATE
test -f /etc/rc.d/functions4puppy4 && . /etc/rc.d/functions4puppy4
test -f /etc/rc.d/f4puppy5         && . /etc/rc.d/f4puppy5

### VARIABLES
test "$KERNVER" || KERNVER=`uname -r`
[ "$ZDRV" ]     || ZDRV='';
[ "$ZDRVINIT" ] || ZDRVINIT='no' #these usually set in PUPSTATE

ME_PROGRAM=`realpath "$0"`  ##+-2013-08-10 should be readlink -e but busybox readlink treats -f as -e option
ME_PID=$$
ME_OTHER_PIDS=`pidof -o $$ -o %PPID ${ME_PROGRAM##*/}`

FS_SUPPORT='audio btrfs cddb ext[2-4] f2fs jfs iso9660 minix msdos ntfs reiser4 reiserfs udf vfat xfs'
gFSSUPPORT=`echo "$FS_SUPPORT" | sed 's! !\\\\||\\\\|!g'`
_debug "FS_SUPPORT=$gFSSUPPORT"

Version='1.3.0-kill Macpup_Opera_2-Puppy_Linux_431-KRG'

POLL_INTERVAL=2 #seconds
#w471 slow cpus need more delay (well, rox does)...
DELAYFACTOR=2   #seconds

###<KRG>
stateDIR="$HOME/Choices/Puppy"
drive_iconDIR="$stateDIR"/pup_event
mkdir $VERB -p "$drive_iconDIR"
FLAGFILE=/tmp/pup_event_icon_change.flg
PUPPY_PIN="$HOME/Choices/ROX-Filer/PuppyPin"
ROX_CONFIG_FILE="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"

[ "$CONFFILE" ] || CONFFILE=/etc/eventmanager.cfg
test -f "$CONFFILE" && . "$CONFFILE"

[ "$RAMSAVEINTERVAL" ] || RAMSAVEINTERVAL=30 #412
RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60)) #convert minutes to seconds.

[ "$POWERTIMEOUT" ] || POWERTIMEOUT=0 #w007
POWERTIMEOUT=$((POWERTIMEOUT * 60)) #convert minutes to seconds.

SIZE_MODS_M=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_M=`du -m -s /lib/modules | cut -f 1`
fi
RETVALm=1
PREVSIZETMPM=0
PREVSIZEFREEM=0

SAVECNT=0
MOUSECNT=0  #w007
MINUTECNT=0 #w007
CURPOS1=""  #w007

usage(){
MSG="
$0 [ help | version ]
$0 [ debug | verbose ] [ start | restart ]
$0 [ stop | status ]
$0 [ codecheck ]
Puppy Daemon to manage the Drive Icons on the desktop.
Is configurable by /usr/sbin/eventmanager gtkdialog GUI.

Help Options :
-V|version) show version information
-h|help) show this usage information

Development Options :
codecheck)    run with set -n
-d|debug)     run with set -x
-v|verbose) show variables to stdout

Main Options :
stop ) stop
start) start
restart) stop and start
status) say if already running
"

[ "$2" ] && "MSG=$MSG
$2
"

echo "$MSG"

exit $1
}

OUT=/dev/null;ERR=$OUT;Q=-q;QUIET=--quiet;DBG='';

while getopts Vhvd opt; do
 case $opt in
  V) echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0;;
  h) usage 0;;
  v) VERBOSE=$((VERBOSE+1));VERB="$VERB -v";L_VERB="$L_VERB --verbose";A_VERB="$A_VERB -verbose";
      OUT=/dev/stdout;ERR=/dev/stderr;
      DEBUG=$((DEBUG+1));DBG="$DBG -d";L_DBG="$L_DBG --debug";
      unset Q QUIET
      ;;
  d) set -x;;
  *) :;;
  esac
done

[ "$*" ] || set - start  ##+++2014-11-08
PARAMETER_LINE="$@"

while [ "$1" ]; do
CASEPARAM=$1;shift

case "$CASEPARAM" in
*help|-h) usage 0
;;
*version|-V)
echo -e "\n$0: Version '$Version'\nTry -h for more info.\n";exit 0
;;
*check*)
#BASH set -n
bn=${0##*/}
cp $VERB $0 /tmp/
sed -i '1d' /tmp/"$bn"
sed -i '1i\#!/bin/bash -n' /tmp/"$bn"
/tmp/"$bn" $PARAMETER_LINE
echo "<$?>"
echo "Codecheck finished"
echo "Attention :
Normally uses ash, this had been done in bash,
because ash has no -n parameter"
exit 0
;;
*debug|-d) set -x
;;
*verbose|-v) VERBOSE=$((VERBOSE+1))
VERB="$VERB -v";L_VERB="$L_VERB --verbose";A_VERB="$A_VERB -verbose";
OUT=/dev/stdout;ERR=/dev/stderr;
DEBUG=$((DEBUG+1));DBG="$DBG -d";L_DBG="$L_DBG --debug";
unset Q QUIET
;;

*stop)
 pidof -o $$ -o %PPID ${ME_PROGRAM##*/} >>$OUT || { _err " NOT Running.";exit 0; }
  for pid in $ME_OTHER_PIDS; do
   kill -9 $pid
    RETVAL=$((RETVAL+$?))
     done
    test "$RETVAL" || RETVAL=0
   pidof -o $$ -o %PPID ${ME_PROGRAM##*/} >>$OUT && RETVAL=1
  #echo
 exit "$RETVAL"
;;

*restart)
for pid in $ME_OTHER_PIDS; do
 _debug "pid='$pid'"
  kill -9 $pid
   done
  sleep 3
 #echo
  _pidof ${ME_PROGRAM##*/}
 #echo
  _pidof -o $$ -o %PPID ${ME_PROGRAM##*/}
  pidof -o $$ -o %PPID ${ME_PROGRAM##*/} >>$OUT && { _err " Already Running.";exit 1; }
 break
;;

*start|"")
 pidof -o $$ -o %PPID ${ME_PROGRAM##*/} >>$OUT && { _err " Already Running.";exit 1; }
  break
;;

*status)
echo -n "$ME_PROGRAM : "
 [ "`echo $ME_OTHER_PIDS | wc -w`" = 1 ] && IS=is || IS=are
  [ "$ME_OTHER_PIDS" ] && echo "$ME_OTHER_PIDS $IS already running." || echo "Not running."
   exit 0
;;
*) echo "UNHANDLED CASEPARAM '$CASEPARAM'";
exit 4;
;;
esac
done
### OPTIONS ###


_get_jobs_pids(){
(
ps-FULL -o ppid,lwp,tty,start,s,psr,pcpu,args -C ${ME_PROGRAM##*/} --no-headers |
while read PPid Pid rest; do
Pids="$Pids
$Pid"
echo "$Pids" | grep -q -w "$PPid" && echo "$Pid"
done
)
}

_kill_jobs(){
(
JOBS=`_get_jobs_pids`
for Pid in $JOBS ; do
/bin/ps --no-header -p "$Pid" && kill -9 $Pid
done
) >>$OUT 2>>$ERR
}

_check_partition_change(){

{ ASK_PARTS=`ls -d /sys/block/${drive_}/${drive_}[0-9]*`; }  #seems to hang code if 2>$ERR

__trigger_partitions__(){
#kernel 2.6.31 does not update using true </dev/device if card removed
#insert works....
# 2.6.31.14-i386-Edel-dirty
# try this triggering each partition, does not work, even with dd
#  2.6.31.14-i386-Edel-dirty
for p in $ASK_PARTS
do
d=${p##*/}
[ -b /dev/$d ] || continue
(true </dev/$d)>>$OUT 2>&1
done
}

drive__=$drive_
ASK_PARTS=`echo $ASK_PARTS`  #ASK_PARTS=$ASK_PARTS keeps formatting without double quotes
echo $ASK_PARTS >/tmp/parts_$drive__
read OLD_PARTS </tmp/parts_old_$drive__
_debugx "ASK_PARTS='$ASK_PARTS'"
_debugx "OLD_PARTS='$OLD_PARTS'"
test "$ASK_PARTS" = "$OLD_PARTS"
case $? in 0) _debug "$drive__:"'STILL SAME';;
1) _notice "$drive__:"'****PARTITION LAYOUT CHANGE****'
drive_="+-${drive_}"  #we add +- and remove the whole line afterwards
#echo "$drive_"
;;
2) _warn  "$drive__:"'!!! TEST ERROR !!!';;
*) _alert "$drive__:"'??? TEST RETURNED neither 0-2 ???';;
esac
echo $ASK_PARTS >/tmp/parts_old_$drive__
}

_probedisk_simple(){
(
[ "${VERBOSE}" ] && echo "$0:_probedisk_simple: Probing for drives..." >>/dev/stderr
ALLDRIVES=`ls -1 /sys/block | grep -vE 'ram|loop|mtd|md|nbd'`
for drive_ in $ALLDRIVES ; do
unset REMOVABLE KIND VEND MODL
[ -f /sys/block/$drive_/removable ] && read REMOVABLE </sys/block/$drive_/removable
[ "$REMOVABLE" ] || REMOVABLE=0
case $drive_ in
sd*)
[ "`readlink /sys/block/$drive_ | grep '/usb[/0-9]*/'`" ] && { (true </dev/$drive_);
_check_partition_change; KIND=usbdrv; }
if test ! "$KIND"; then
[ "$REMOVABLE" = 0 ] && KIND=drive || { (true </dev/$drive_); KIND=usbdrv; }
fi
  ;;
sr*)
[ "`readlink /sys/block/$drive_ | grep '/usb[/0-9]*/'`" ] && KIND=optical #KIND=usbcd
if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=optical
fi
  ;;
fd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=floppy || KIND=floppy
fi
  ;;
hd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 0 ] && KIND=drive || KIND=optical
fi
   ;;
scd*)

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=optical || KIND=optical
fi
   ;;
mmc*)

(true </dev/$drive_)
_check_partition_change

if test ! "$KIND"; then
[ "$REMOVABLE" = 1 ] && KIND=card || KIND=drive
fi
  ;;
*) _warn "Unknown device $drive_"
  ;;
esac
[ -f /sys/block/$drive_/device/vendor ] && read VEND </sys/block/$drive_/device/vendor
[ -f /sys/block/$drive_/device/model ]  && read MODL </sys/block/$drive_/device/model
[ "$VEND" ] || VEND=Unknown
[ "$MODL" ] || MODL=Unknown
#PARTS=`ls -1 /sys/block/$drive/$drive[0-9]* 2>$ERR | grep -o -e '[0-9]*' |tr '\n' ' '`
test "$KIND" || _warn "Could not provide a device kind"
echo "$drive_|$KIND|$VEND $MODL" >&1
done
[ "${VERBOSE}" ] && echo " $0: Done probing." >&2
) 2>>$ERR
}

[ "$VERBOSE" ] && echo "$0: Header END"

### CODE ###

# REM : Switch yaf-splash
#       If DISPLAY do yaf-splash message
#       If NO DISPLAY just echo
_yaf_splash(){

[ "$DISPLAY" ] && {
 yaf-splash $genYAFOPS "$@" & _yPID=$!
#yaf-splash "$@"
 trap "kill $_yPID; return" INT
  true
 } || {
 if test "$startVT"; then
 echo "${*##*-text}" >/dev/tty$startVT
 else
 echo "${*##*-text}"
 fi
 }
}

# REM : _xmessage() to switch if no DISPLAY
#       if DISPLAY then run xmessage
#       if NO DISPLAY then use echo
_xmessage(){

[ "$DISPLAY" ] && {
 xmessage "$@" & _xPID=$!
 trap "kill $_xPID; return" INT
 true
 } || {
 if test "$startVT"; then
 echo "${*##*-title}" >/dev/tty$startVT
 else
 echo "${*##*-title}"
 fi
 }
}

_switch_to_free_terminal(){
# REM: Needs fgconsole enabled in BBCONFIG of busybox
#       fgconsole works also without controlling tty
#       Need that value because openvt -sw does not work for me
#       to automatically switch back after script exits
which fgconsole >>$OUT && { startVT=`fgconsole`; fgconRV=$?; }
test "$fgconRV" = 0 || unset startVT
which tty >>$OUT && { TTY=`tty`; ttyRV=$?; }
test "$ttyRV" = 0 || unset TTY
openvt -s
}

_poweroff_menu(){ #BEGIN

local RV SELECT
unset RV SELECT

[ "$DISPLAY" ] && {
 xmessage "$@"
 return $?
 } || {

# openvt -s

cat >/tmp/poweroff_menu.sh <<EoI
#!/bin/ash
. /etc/rc.d/f4puppy5
echo "${*##*-title}"
 echo "
$BUTTONS_GUI
"

while [ selecting ];
 do
  echo -e '\033[1;33m'
  read -t 60 -p "Select one of the above numbers #: " SELECT
   RV=\$?
  echo -e '\033[0;39m'
   if [ ! "\$SELECT" ]; then
    case \$RV in
    0) continue;;
    1) exit 0;;  #timeout reached
    *) _err "RV=\$RV"; continue;;
    esac
   else
    case \$SELECT in
     190|191) break;;
     *) _err "wrong entry '\$SELECT'";;
    esac
   fi
  sleep 1
 done
exit \$SELECT

EoI


chmod $VERB 0754 /tmp/poweroff_menu.sh

#_switch_to_free_terminal

which fgconsole >>$OUT && { startVT=`fgconsole`; fgconRV=$?; }
test "$fgconRV" = 0 || unset startVT
which tty >>$OUT && { TTY=`tty`; ttyRV=$?; }
test "$ttyRV" = 0 || unset TTY

# REM openvt needs -w to gain input
openvt -s -w /tmp/poweroff_menu.sh
menuRV=$?
case $startVT in
[0-9]*) chvt $startVT;;
esac
sleep 1

return $menuRV

__code__(){
 sleep 1
 echo "${*##*-title}"
 echo "
$BUTTONS_GUI
"
 while [ selecting ];
 do
  echo -e '\033[1;33m'
  read -t 60 -p "Select one of the above numbers #: " SELECT
   RV=$?
  echo -e '\033[0;39m'
   if [ ! "$SELECT" ]; then
    case $RV in
    0) continue;;
    1) return 0;;  #timeout reached
    *) _err "RV=$RV"; continue;;
    esac
   else
    case $SELECT in
     190|191) break;;
     *) _err "wrong entry '$SELECT'";;
    esac
   fi
  sleep 1
 done
return $SELECT

   } ##_code__(){ #END
 }

}  ###_poweroff_menu(){ #END

#[ "$DISPLAY" ] || exit 0 #X not running.
sleep $DELAYFACTOR       #let the dust settle after X has started.

#CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
 CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | awk -F'[. ]' '{print $3}'`
 DELAYFACTOR=$(( 1100 / CPUMHZ ))
 sleep $DELAYFACTOR

__wait_for_rox__(){
_sleep_=0
until [ "`pidof ROX-Filer`" ]; do
sleep 2
_sleep_=$((_sleep_+1))
[ "$_sleep_" = 9 ] && break
done
}
until [ "`awk -F '.' '{print $1}' /proc/loadavg`" -lt 2 ];do sleep 5;done


#v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_icon_change_flag
#which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
#however I think it would be good to test here also if X mode not yet settled on...
 case `readlink /usr/bin/X` in *Xvesa*)
  while [ -f /tmp/videomode ];  #only exists during X resolution setup.
  do
   _count_=$((_count_+1))
   sleep 3
   [ "$_count_" = 100 ] && { echo "/tmp/videomode still exist after 5 minutes. Exit.";exit 0; }
  done
 ;;
 esac

SCRNXY=`xwininfo -root | grep -o '\-geometry .*' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'`
SCRN_X=`echo -n "$SCRNXY" | cut -f 1 -d 'x'`
SCRN_Y=`echo -n "$SCRNXY" | cut -f 2 -d 'x'`

 PIN_GRID_STEP=`grep "pinboard_grid_step" "$ROX_CONFIG_FILE" | sed -e "s/ *<[^>]*>//g"`
 [ $PIN_GRID_STEP ]       || PIN_GRID_STEP=16 #2=fine 16=medium 32=coarse
 [ $PIN_GRID_STEP -le 0 ] && PIN_GRID_STEP=16 #precaution.
 PIN_GRID_STEP2=$((PIN_GRID_STEP / 2))
 MAX_X=$((SCRN_X - 96))
 MAX_Y=$((SCRN_Y - 96))
_debug "PIN_GRID_STEP=$PIN_GRID_STEP PIN_GRID_STEP2=$PIN_GRID_STEP2"


#v424 experiment, automatic unmounting...
auto_unmount_func() {
(
 [ "$AUTOUNMOUNT" = true ] || return
 for oneMNTPT in `grep '^/dev/' /proc/mounts | grep -vE '^/dev/loop|^/dev/ram|^/dev/zram|^/dev/mtd|^/dev/nbd|^/dev/md' | cut -f 2 -d ' ' | grep -vE '^/initrd/|^/$' | tac`
 do
  [ "`fuser -m $oneMNTPT`" ] && continue
   pidof sync || sync
   /bin/umount $oneMNTPT ; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ $umVAL -ne 0 ];then
    ZOMBIES=`/bin/ps -H -A | grep '<defunct>' | grep -v 'grep' | sed 's#^ *##;s/  /|/g' | grep -v '|||' | awk '{print $1}'`
    for oneZOMBIE in $ZOMBIES
    do
     /bin/ps --no-header -p $oneZOMBIE && kill -9 $oneZOMBIE
    done
    /bin/umount "$oneMNTPT" ; umVAL=$?
   fi
 done
) >>$OUT 2>>$ERR
}

_format_size() {
 [ "$SIZE" ] || SIZE=0
 if [ "$SIZE" -gt 1048576 ];then               #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p`   #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 elif [ "$SIZE" -gt 1024 ];then
   SIZE="$((SIZE / 1024))MB"
 else
   #SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
   SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`KB" #100613
 fi
 [ "${SIZE//[[:alpha:][:punct:]]/}" = '00' ] && SIZE=0
}

_create_appinfo() { #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
   [ "$1" ] && DRV_NAME="$1"
(
   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${dINFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${DRV_CATEGORY}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item>
   <Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>
   ${MOREITEMS}
  </AppMenu>
</AppInfo>" > $drive_iconDIR/drive_${DRV_NAME}/AppInfo.xml
)
}


__free_coord_normal__(){
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...
 COORDSGRID=`grep -o -e ' x="[0-9]*" y="[0-9]*" ' "$PUPPY_PIN" | sed 's/[0-9]"/"/g'`
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   COORD_Y=$((SCRN_Y - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP ) * PIN_GRID_STEP))
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))
    if [ $COORD_X -gt $MAX_X ];then #start next line up.
     xyCNT=$((xyCNT + 1))
     #[ $xyCNT -gt 1 ] && break
     COORD_Y=$((COORD_Y - ICON_PLACE_SPACING))
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  top)
   COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))
    if [ $COORD_X -gt $MAX_X ];then #start next line down.
     xyCNT=$((xyCNT + 1))
     #[ $xyCNT -gt 1 ] && break
     COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
     COORD_X=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  left)
   COORD_X=$ICON_PLACE_EDGE_GAP  #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    #xgPATTERN="`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`"
    xgPATTERN="${xPATTERN//[0-9]\"/\"}"
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y+ICON_PLACE_SPACING))
    if [ $COORD_Y -gt $MAX_Y ];then #start next row. ##FIXME
     xyCNT=$((xyCNT+1))
     #[ $xyCNT -gt 1 ] && break ##FIXME
     COORD_X=$((COORD_X+ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
  right)
   COORD_X=$((SCRN_X - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$ICON_PLACE_START_GAP             #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   xyCNT=0 #precaution.
   while :; do
    xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
    [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || break
    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))
    if [ $COORD_Y -gt $MAX_Y ];then #start next row back.
     xyCNT=$((xyCNT + 1))
     COORD_X=$((COORD_X - ICON_PLACE_SPACING))
     COORD_Y=$ICON_PLACE_START_GAP
    fi
    xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
   done
  ;;
 esac
}

_free_coord_simple(){
 #DRIVE_NAME="$1"
 #LAST_PLACE=`grep -m1 -w "\.pup_event/drive_${OLD_DRV_NAME}" /root/Choices/ROX-Filer/PuppyPin`
 LAST_PLACE=`grep -m1 '\pup_event/drive_' "$PUPPY_PIN"`
 [ "$LAST_PLACE" ] && { COORD_X=`echo "$LAST_PLACE" | cut -f2 -d'"'`; COORD_Y=`echo "$LAST_PLACE" | cut -f4 -d'"'`; }
 #echo "'$OLD_DRV_NAME' $DRIVE_NAME
_debug "'$LAST_PLACE'
$COORD_X $COORD_Y"
 case $ICON_PLACE_ORIENTATION in #see /etc/eventmanager
  bottom)
   [ "$COORD_Y" ] || COORD_Y=$((SCRN_Y - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y - ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  top)
   [ "$COORD_Y" ] || COORD_Y=$ICON_PLACE_EDGE_GAP
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2 ) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_X" ] && COORD_X=$((COORD_X + ICON_PLACE_SPACING)) || COORD_X=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   [ "$COORD_X" -gt $MAX_X ] && { COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) ; COORD_X=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  left)
   [ "$COORD_X" ] || COORD_X=$ICON_PLACE_EDGE_GAP #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y+PIN_GRID_STEP2)/PIN_GRID_STEP)*PIN_GRID_STEP))
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X + ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
  right)
   [ "$COORD_X" ] || COORD_X=$((SCRN_X - ICON_PLACE_EDGE_GAP)) #default 64, see /etc/eventmanager
   [ "$COORD_Y" ] && COORD_Y=$((COORD_Y + ICON_PLACE_SPACING)) || COORD_Y=$ICON_PLACE_START_GAP #default 32, see /etc/eventmanager
   COORD_Y=$(( ((COORD_Y + PIN_GRID_STEP2) / PIN_GRID_STEP) * PIN_GRID_STEP))
   [ "$COORD_Y" -gt $MAX_Y ] && { COORD_X=$((COORD_X - ICON_PLACE_SPACING)) ; COORD_Y=$ICON_PLACE_START_GAP ; }
   _debug COORD_X=$COORD_X COORD_Y=$COORD_Y #DEBUG
  ;;
   esac
#OLD_DRV_NAME="$DRIVE_NAME"
}

_add_pinboard() { #needs oneDRVNAME, DRV_CATEGORY, FSTYPE
 [ "$1" ] && DRV_NAME="$1"
 [ "`grep "/drive_${DRV_NAME}</icon>$" "$PUPPY_PIN"`" ] && return
 _free_coord_simple   #${oneDRVNAME}

 _debug "_add_pinboard: X='$COORD_X' Y='$COORD_Y' for rox -R"

(
 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$drive_iconDIR/drive_${DRV_NAME}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${DRV_NAME}</Label>
   <Args>${DRV_CATEGORY} ${FSTYPE}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R
)
}


_probepart() {
gFSSUPPORT=`echo "$FS_SUPPORT" | sed 's! !\\\\||\\\\|!g'`
PROBEPART=`probepart $* -k | grep -iE "not inserted|$gFSSUPPORT"`
}

_create_icon() {
 [ "$1" ] && DEV_NAME="$1"

 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
 #if a passed param $1, then PROBEPART already known, inefficient to rerun here each time.
(

   if [ "$ICONDESK" = "false" ];then
    DRVINFO="/dev/$DEV_NAME"'|0|0' #we show one icon though for all drives and partitions

 elif [ "$ICONPARTITIONS" = "false" ];then
    read SIZE </sys/block/$DEV_NAME
    FSTYPE=`guess_fstype /dev/$DEV_NAME`
    DRVINFO="/dev/${DEV_NAME}|${FSTYPE}|${SIZE}"

 elif [ "$ICONPARTITIONS" = "true" ];then

  #display an icon for each partition... w476 add ext4...
  _probepart -d/dev/$DEV_NAME ;
  _debug "$PROBEPART"
  _debug "_create_icon"

  drvPATTERN="^/dev/${DEV_NAME}" #important, no space on end! #drvPATTERN='^/dev/'"${PART_NAME}"
  DRVINFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|'`

 fi   ## was# ICONPARTITIONS true

_debug "_create_icon:
$DRVINFO
"

 while read -r oneDRVINFO
 do
  [ "$oneDRVINFO" ] || continue

  PART_NAME=`echo -n "$oneDRVINFO" | cut -f 1 -d '|' | cut -f 3 -d '/'`
  _debug "_create_icon:DEV_NAME=$DEV_NAME' PART_NAME=$PART_NAME'"

  FSTYPE=`echo -n "$oneDRVINFO" | cut -f 2 -d '|'`
  _debug "_create_icon:FSTYPE=$FSTYPE'"

  SIZE=`echo -n "$oneDRVINFO" | cut -f 3 -d '|'`

  drvPATTERN='^/dev/'"${PART_NAME}"' ' #important, a space on end!

  #if [ ! -d $drive_iconDIR/drive_${PART_NAME} ]; then
   mkdir $VERB -p $drive_iconDIR/drive_${PART_NAME}  ##sbin/pup_event_frontend_d: line 50: can't create : nonexistent directory
   /bin/cp $VERB -a --remove-destination /usr/local/bin/drive_all $drive_iconDIR/drive_${PART_NAME}/AppRun
  #else
  #  echo -e "\\033[1;33m""$drive_iconDIR/drive_${DEV_NAME} EXIST ...""\\033[0;39m"
  #fi

   if [ "$FSTYPE" != 0 -a "$SIZE" != 0 ] ; then
    _format_size #formats SIZE for display.
    dINFO="Filesystem: $FSTYPE Size: ${SIZE}
${DRV_DESCRIPTION}"
   elif [ "$FSTYPE" = "0" -a "$SIZE" = "0" ];then #only one icon for all drives
     dINFO="Puppy drive manager"
   else
     _format_size #formats SIZE for display.
     dINFO="${DRV_DESCRIPTION} Size: $SIZE"
     #v424 add item to unmount all partitions...
   fi

   case $PART_NAME in *[0-9])
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${PART_NAME} (if currently mounted)</Label></Item>
   <Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>
   <Item option=\"mountro\" icon=\"gtk-harddisk\"><Label>Read-Only (re)mount of ${PART_NAME}</Label></Item>
   <Item option=\"fsck_$FSTYPE\" icon=\"gtk-execute\"><Label>Fsck ${PART_NAME} (if not mounted)</Label></Item>"
   ;;
   esac

   _create_appinfo $PART_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME or PART_NAME
   unset MOREITEMS

  _debug "_create_icon:drvPATTERN=$drvPATTERN"

 if  [ "$ICONDESK" = "false" ];then
 icon_unmounted_func $PART_NAME $DRV_CATEGORY;_add_pinboard $PART_NAME
 elif [ "$ICONPARTITIONS" = "true" ];then
      _debug "_create_icon:ICONPARTITIONS true"
    MNTSTATUS=`/bin/df | grep -m1 "$drvPATTERN"`
    if [ ! "$MNTSTATUS" ];then
     icon_unmounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
    else
     _debug 'starting now icon_mounted_func'
     icon_mounted_func $PART_NAME $DRV_CATEGORY #see functions4puppy4.
     _debug 'returned from icon_mounted_func'
    fi
   _add_pinboard $PART_NAME #needs oneDRVNAME, DRV_CATEGORY, FSTYPE.
  else icon_unmounted_func $PART_NAME $DRV_CATEGORY;_add_pinboard $PART_NAME
 fi
 done<<EOI
$(echo "$DRVINFO")
EOI

)
}

_remove_pinboard() { #needs DEV_NAME (name of entire drive)
 [ "$1" ] && DRV_NAME="$1"
(
 case $DRV_NAME in
 hd*|mmc*|scd*|sd*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g' | sed 's/[0-9]*$//'`;;
 fd*|sr*|*)
 DRV_NAME=`echo $DRV_NAME | tr -d '/' | sed 's#dev##g'`;;
 esac

 ppPATTERN='\pup_event/drive_'"$DRV_NAME"'.*'

 ALLNAMES=`grep -o "$ppPATTERN" "$PUPPY_PIN" | cut -f 3 -d '_' | cut -f 1 -d '<' | sort -r`

 for ONE_PART in $ALLNAMES
 do

  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$drive_iconDIR/drive_${ONE_PART}</Path>
  </PinboardRemove>
  <UnsetIcon>
   <Path>$drive_iconDIR/drive_${ONE_PART}</Path>
  </UnsetIcon>
 </env:Body>
</env:Envelope>"  | rox -R

 done
)
}

#note that init script in initrd takes care of restoring modules if enough space.
_delete_drivers() { #called from _free() and _free_flash(). delete modules to create more free space.
 #passed param: /pup_rw=delete tmpfs top layer only.
 DEL_LAYER=$1
(
 #find out what modules are loaded, keep those...
 for oneKEEP_MOD in `lsmod | cut -f 1 -d ' ' | grep -v 'Module'`
 do
  oneKEEP_SPEC=`modinfo -F filename ${oneKEEP_MOD}`
  oneKEEP_PATH-${oneKEEP_SPEC%/*}
  test -d /tmp${oneKEEP_PATH} || mkdir $VERB -p /tmp${oneKEEP_PATH}
  cp $VERB -af ${oneKEEP_SPEC} /tmp${oneKEEP_PATH}/
 done
 if [ "$DEL_LAYER" ];then
  rm $VERB -rf ${DEL_LAYER}/lib/modules
 else
  if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then
   rm $VERB -rf ${SAVE_LAYER}/lib/modules
  fi
  rm $VERB -rf /lib/modules
 fi
 cp $VERB -af /tmp/lib/modules /lib/modules
 depmod -a
)
}

_free_initrd() { #UniPup, runs entirely in initramfs.
(
 SIZEFREEK=`free | grep '^Total:' | tr -s ' ' | cut -f 4 -d ' '`
 test "$SIZEFREEK" || {
    SIZEFREEM_=`free -m |  awk '{ if (match($1, "Mem.*")) || (match($1, "Swap.*")) print $4}'`
   for m_ in $SIZEFREEM_; do SIZEFREEM=$((SIZEFREEM+m_)); done
 }
 test "$SIZEFREEM" || {
    test "$SIZEFREEK" || {
        SIZEFREEK_=`free |  awk '{ if (match($1, "Mem.*")) || (match($1, "Swap.*")) print $4}'`
         for k_ in $SIZEFREEK_; do SIZEFREEK=$((SIZEFREEK+m_)); done
    }
      test "$SIZEFREEK" &&  SIZEFREEM=$((SIZEFREEK / 1024))
 }

 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" = "$SIZEFREEM" ] && return
 #save to a file, freememapplet can read this...
 echo "$SIZEFREEM" > /tmp/pup_event_sizefreem
)
}

_free() { #called every 4 seconds.
(
 case $PUPMODE in
  6|12)
   SIZEFREEM=`/bin/df -m | grep -m1 ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
  *)
   SIZEFREEM=`/bin/df -m | grep -m1 ' /$' | tr -s ' ' | cut -f 4 -d ' '`
  ;;
 esac
 WARNMSG=""
 PREVSIZEFREEM=0
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" -eq $SIZEFREEM ] && return
 if [ "$SIZEFREEM" -lt 10 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #save layer is at top, delete mods.
  else
   WARNMSG="WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 [ "$PUPMODE" -eq 5 -o "$PUPMODE" -eq 2 ] && return 0 #5=first boot, no msgs at top of screen.
 if [ "$WARNMSG" ];then
  killall yaf-splash
  _yaf_splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi
)
}

_savepuppy(){
(
case $PUPMODE in 13)
     MESSAGE_SAVE=`gettext "Saving RAM to 'pup_save' file..."`     ;;
3|7) MESSAGE_SAVE=`gettext "Saving RAM to 'home' partition.."`;;
esac
BG=orange

if test "$WARNMSG"; then
MESSAGE_SAVE="$WARNMSG
$MESSAGE_SAVE"
BG=red
fi
  _yaf_splash -font "8x16" -outline 0 -margin 4 -bg $BG -placement top -text "$MESSAGE_SAVE" &
  YAFPID=$!
  pidof sync >>$OUT || sync
  nice -n 19 /usr/sbin/snapmergepuppy
  /bin/ps --no-header -p $YAFPID >>$OUT && kill $YAFPID
WARNMSG=""
)
}

_free_flash(){ #PUPMODE 3,7,13. called every 3 seconds.
(
 WARNMSG=""
 SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_ro1$' | tr -s ' ' | cut -f 4 -d ' '`
  SIZETMPM=`/bin/df -m | grep ' /initrd/pup_rw$'  | tr -s ' ' | cut -f 4 -d ' '`
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ -s /tmp/pup_event_sizetmpm ]  && read PREVSIZETMPM  </tmp/pup_event_sizetmpm
 [ $PREVSIZEFREEM -eq $SIZEFREEM -a $PREVSIZETMPM -eq $SIZETMPM ] && return
 if [ $SIZEFREEM -lt 10 ];then
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_ro1 #delete modules in save layer only.
  else
   WARNMSG="WARNING: Personal storage file getting full, strongly recommend you resize it or delete files!"
  fi
 fi
 if [ "$SIZETMPM" -lt 5 ];then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #delete modules in top tmpfs layer only.
  else
   WARNMSG="WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
  fi
 fi
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ];then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$((SIZEFREEM + SIZE_MODS_M))
   VIRTUALFREEM=$((VIRTUALFREEM - 1)) #allow for some mods will not be deleted.
  fi
 fi
 echo "$SIZETMPM" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 if [ "$WARNMSG" ];then
  #killall yaf-splash
  #yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15" -outline 0 -text "$WARNMSG" &
  _savepuppy
 fi
#_savepuppy
)
}

######################################################################
#stuff to setup at entry...


_probedisk2(){
    PROBEDISK_=`probedisk2`
    # REM: Order the drives
    for k in card usbdrv optical drive floppy
    do
    S=`echo "$PROBEDISK_" | grep "|$k|"`
    test "$S" || continue
    test "$PROBEDISK" && PROBEDISK="$S
$PROBEDISK" || PROBEDISK="$S"
    done
 _debug "$PROBEDISK"
}

_clear_desk_icons(){
(
drives=`grep '/\pup_event/drive_*' "$PUPPY_PIN" | grep -o '/drive_.*<' | cut -f2 -d '_' | tr -d '<' | awk '{print $1}' | tr -d '[[:digit:]]' | sort -u | sort -r`

for item in $drives; do
DEV_NAME="$item"
_debugx "removing '$DEV_NAME'"
_remove_pinboard $DEV_NAME
done
rm $VERB -fr "$drive_iconDIR"/*
_debugx "Finished _clear_desk_icons
"
)
}
_clear_desk_icons


_start_pup_event_frontend_d(){
_debug "_start_pup_event_frontend_d BEGIN"

PROBEDISK2_LOOP_NEW=`_probedisk_simple`
PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW"

_probedisk2

#build the desktop icons...
DRV_CATEGORY='drive'
#v407 ls120/zip floppy drives are probed every 4 secs...
DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
#v407 same thing for all optical drives...
DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`

if [ "$ICONDESK" = "false" ];then
_info "ICONDESK is false"
 #only show a single 'drives' icon on desktop...
     DEV_NAME='drives'
 DRV_CATEGORY='any' #see pmount.
 DRV_DESCRIPTION="all drives"

 _create_icon $DEV_NAME

elif [ "$ICONPARTITIONS" = "false" ];then

  _info 'Just Maindrives'
  #for item in $PROBEDISK ; do
  while read -r item; do

          DEV_NAME=`echo "$item" |cut -f 1 -d '|' | cut -f 3 -d '/'`
      DRV_CATEGORY=`echo "$item" |cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo "$item" |cut -f 3 -d '|'`
   _debug $item
   _create_icon $DEV_NAME

  done <<EoI
`echo "$PROBEDISK"`
EoI

else
  _debug "ICONPARTITIONS='$ICONPARTITIONS'"

 #show all drives on desktop... w476 add ext4...

while read -r oneDRV
#IFS='|' while read -r DRV_NAME DRV_CATEGORY DRV_DESCRIPTION
 do
 [ "$oneDRV" ] || continue

 _debug "oneDRV=$oneDRV'"

         DEV_NAME=`echo "$oneDRV" | cut -f1 -d'|' | cut -f 3 -d '/'`
     DRV_CATEGORY=`echo "$oneDRV" | cut -f2 -d'|'`
  DRV_DESCRIPTION=`echo "$oneDRV" | cut -f3 -d'|'`

  _create_icon $DEV_NAME #startup #needs PART_NAME, DRV_CATEGORY, DRV_DESCRIPTION, PROBEPART.
  #_create_icon $DRV_NAME

  if [ ! -d $drive_iconDIR/drive_${DEV_NAME} ]; then
   mkdir $VERB -p $drive_iconDIR/drive_${DEV_NAME}
   /bin/cp $VERB -a --remove-destination /usr/local/bin/drive_all $drive_iconDIR/drive_${DEV_NAME}/AppRun
   INFO="Puppy drive manager"
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${DEV_NAME} (if currently mounted)</Label></Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   _create_appinfo $DEV_NAME #needs INFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
   else
    echo -e "\\033[1;31m""$drive_iconDIR/drive_${DEV_NAME} EXIST ...""\\033[0;39m"
  fi

 done<<EOI
$(echo "$PROBEDISK")
EOI
fi    #;fi
_debug "_start_pup_event_frontend_d  END "
}

_start_pup_event_frontend_d


if [ "$BACKENDON" = "false" ];then #see /etc/eventmanager.
 killall hotplug2stdout >>$OUT 2>>$ERR #pup_event_backend_d #no module/firmware hotplug support.
 #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 [ "`pidof udevd`" ] && killall udevd #alternative to pup_event_backend_d.
fi
#[ "$FRONTEND_HOTPLUGON" = "false" ] && exit #turn off all frontend hotplug support. see /etc/eventmanager.

trap "_kill_jobs;exit $?" INT

_do_ramsaveinterval(){
(
while :; do
 SAVECNT=$((SAVECNT + 60))
 if [ "$SAVECNT" -ge "$RAMSAVEINTERVAL" ];then
  _savepuppy
  SAVECNT=0
 fi
sleep 60
done
)
}

_do_powertimeout(){
(
while :; do

 CURPOS2="$CURPOS1"
 sleep 60s
 CURPOS1=`getcurpos`
 MOUSECNT=$((MOUSECNT+60))

 ##some apps should not be disturbed by this background stuff...
 #RUNPS=`ps`
 ##w482 add xorriso...
 #[ "`echo "$RUNPS" | grep -Ew 'rsync |cp|mv|mksquashfs|unsquashfs|git-fetch|git-push|svn|make|gcc|xorriso|xorrecord|gxine|xine|pupzip|petget|xarchive|wget|axel|dotpup|gnome-mplayer|gmplayer|mplayer|gcurl|gimv|burniso2cd|growisofs|cdrecord|pcdripper|xfmedia|xmms|ripoff|pdvdrsab|pburn|mhwaveedit|installpkg\.sh|downloadpkgs\.sh'`" != "" ] && return
 #  pidof rsync cp mv mksquashfs unsquashfs git-fetch git-push svn make gcc xorriso xorrecord gxine xine pupzip petget xarchive wget axel dotpup gnome-mplayer gmplayer mplayer gcurl gimv burniso2cd growisofs cdrecord pcdripper xfmedia xmms ripoff pdvdrsab pburn mhwaveedit installpkg.sh downloadpkgs.sh >$OUT && return

 pidof axel burniso2cd cdrecord cp dotpup downloadpkgs.sh gcc gcurl gimv git-fetch git-push gmplayer gnome-mplayer growisofs gxine installpkg.sh make mhwaveedit mksquashfs mplayer mv pburn pcdripper pdvdrsab petget pupzip ripoff rsync svn unsquashfs wget xarchive xfmedia xine xmms xorrecord xorriso >>$OUT && continue

 #CURPOS1=`getcurpos`
   [ "$CURPOS1" = "$CURPOS2" ] || MOUSECNT=0

   if [ "$MOUSECNT" -ge "$POWERTIMEOUT" ] ; then
   _debug MOUSECNT=$MOUSECNT POWERTIMEOUT=$POWERTIMEOUT
   MOUSECNT=0
   aplay $Q $VERB /usr/share/audio/2barks.au
   sleep 1s
   aplay $Q $VERB /usr/share/audio/2barks.au
   #_xmessage -bg red -timeout 60 -buttons "YES:190,No:191" -fn "-misc-dejavu sans-*-*-*-*-*-*-*-*-*" -title 'POWERTIMEOUT' 'Really powering off now ?'
    BUTTONS_GUI="YES:190,No:191"
    _poweroff_menu -bg red -timeout 60 -buttons "$BUTTONS_GUI" -fn "-misc-dejavu sans-*-*-*-*-*-*-*-*-*" -title 'POWERTIMEOUT' 'Really powering off now ?'
    REPLY=$?
    _debug "REPLY='$REPLY'"
    if [ "$REPLY" = "190" -o "$REPLY" = "0" ] ; then
    [ "$DISPLAY" ] && { exec wmpoweroff force & :;} || { exec /sbin/poweroff force & :; }
    fi
   fi
 #CURPOS2="$CURPOS1"
 #sleep 60s
 #MOUSECNT=$((MOUSECNT+60))
done
)
}

CURPOS1=1
CURPOS2=1
[ "$VERBOSE" ] && echo "POWERTIMEOUT='$POWERTIMEOUT'"
[ "$POWERTIMEOUT" -ne 0 ] && _do_powertimeout &

case $PUPMODE in
3|7|13)
   FREE_FUNCTION='_free_flash'
   _debug "RAMSAVEINTERVAL='$RAMSAVEINTERVAL'"
   [ "$RAMSAVEINTERVAL" -gt 0 ] && _do_ramsaveinterval &
 ;;
16|24|17|25) #unipup.
   FREE_FUNCTION='_free_initrd'  ;;
  *)
   FREE_FUNCTION='_free'  ;;
esac

_which_hotplug(){

_check_hotplug_event(){
    :
 }

if test "$FRONTEND_HOTPLUGON" = true; then
_check_hotplug_event(){

DEBUG=1
if [ "$PROBEDISK2_LOOP_NEW" != "$PROBEDISK2_LOOP_OLD" ] ; then #if +- or deleted line, then change
 ######### hotplug detected : #########
  _debug "MAIN loop: Drives not same.."
  BLOCKSADD=`echo "$PROBEDISK2_LOOP_NEW" | /bin/grep -v "$PROBEDISK2_LOOP_OLD"` #device with new +- still would fit to be grep'd -v
                                                                                #device missing will now be left
  BLOCKSREM=`echo "$PROBEDISK2_LOOP_OLD" | /bin/grep -v "$PROBEDISK2_LOOP_NEW"` #device with new +- would be left
                                                                                #device missing cannot be left
  _debug "BLOCKSADD=$BLOCKSADD'"
  _debug "BLOCKSREM=$BLOCKSREM'"

  if [ "$BLOCKSREM" ] ; then
   while read -r aREM; do
   [ "$aREM" ] || continue
    DEV_NAME=`echo "$aREM" | cut -f1 -d'|' | cut -f3 -d'/' | sed 's!^+-!!'`
    [ "$DEV_NAME" ] || continue
   if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, refresh it.
    killall gtkdialog_pmount
    sleep 0.1
    LANG=$OLDLANG pmount & #100613 fix from shinobar.
   fi
   _remove_pinboard $DEV_NAME #needs DEV_NAME or DRV_NAME
   rm $VERB -rf $drive_iconDIR/drive_${DEV_NAME}*
  done<<EOI
$(echo "$BLOCKSREM")
EOI
  fi
  if [ "$BLOCKSADD" ] ; then
   while read -r aADD; do
   [ "$aADD" ] || continue
          DEV_NAME=`echo -n "$aADD" | cut -f 1 -d '|' | cut -f3 -d'/' | sed 's!^+-!!'`
      DRV_CATEGORY=`echo -n "$aADD" | cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo -n "$aADD" | cut -f 3 -d '|' | tr -s ' '`
   _debug "_check_hotplug_event:DEV_NAME=$DEV_NAME DRV_CATEGORY=$DRV_CATEGORY DRV_DESCRIPTION=$DRV_DESCRIPTION"
   [ "$ICONDESK" = "true" ] && {
   ## REM: Even when triggered, the kernel 2.6.32.14 does not
   ##       update sysfs files for a drive that is a card reader
   ##       when a card is removed.
   ##       Probably also for other drives if using fdisk to delete partitions.
   ##      When a new card is inserted, the sysfs directories and files
   ##       are updated . So need to remove from pinboard and $drive_iconDIR
   ##       beforehand ....
   #    NO, run BLOCKSREM before BLOCKSADD
   #    _remove_pinboard $DEV_NAME #needs DEV_NAME or DRV_NAME
   #    rm $VERB -rf $drive_iconDIR/drive_${DEV_NAME}*
       _create_icon $DEV_NAME
   }
   #uses DEV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
   [ "$HOTPLUGNOISY" = "true" ] && $drive_iconDIR/drive_${PART_NAME}/AppRun ${DRV_CATEGORY} & #handler script.
  done<<EoI
$(echo "$BLOCKSADD")
EoI

  fi
PROBEDISK2_LOOP_NEW=`echo "$PROBEDISK2_LOOP_NEW" | sed 's!^+-.*!!'` #line with +- will be deleted
                                                                    #OLD with missing device will be updated
                                                                    #NEW if no +-
fi

 ######### hotplug detected #########
 _debug "$0:Hotplug detected ?:"
 #PROBEDISK2_LOOP_NEW=`echo "$PROBEDISK2_LOOP_NEW" | sed 's!^+-!!'`
 #PROBEDISK2_LOOP_NEW=`echo "$PROBEDISK2_LOOP_NEW" | sed 's!^+-.*!!'`
 PROBEDISK2_LOOP_OLD="$PROBEDISK2_LOOP_NEW" #if NEW have had +- that device will be deleted
 PROBEDISK2_LOOP_NEW=`_probedisk_simple`
 _debugx "PROBEDISK_LOOP_OLD='
$PROBEDISK2_LOOP_OLD
'"
 _debugx "PROBEDISK_LOOP_NEW='
$PROBEDISK2_LOOP_NEW
'"
 _debugx ""
 ####### POLL_INTERVAL second timeout procesing #########
 }  ##_check_hotplug_event(){ #END
fi
}

_which_hotplug

###################################################################
(
#now go into a three-second loop...
while :;
do
# sleep $POLL_INTERVAL

#########check hotplug block event##########

 _check_hotplug_event
 $FREE_FUNCTION

 if test -f "$FLAGFILE" ;then #1
 #[ "$FRONTEND_HOTPLUGON" = true ] && {
     _clear_desk_icons
     unset COORD_X COORD_Y
 #}
 [ -f "$CONFFILE" ] && . "$CONFFILE"
 POWERTIMEOUT=$((POWERTIMEOUT * 60));RAMSAVEINTERVAL=$((RAMSAVEINTERVAL * 60))
 _which_hotplug
 _start_pup_event_frontend_d
 sleep 1
 rm $VERB -f "$FLAGFILE"
 fi #1

 #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).
 [ "$AUTOUNMOUNT" = "true" ] && auto_unmount_func
 sleep $POLL_INTERVAL

done
# POLL_INTERVAL loop
)

echo
exit $?
###END###
