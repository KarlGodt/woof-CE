#!/bin/ash
#
# New header by Karl Reimer Godt, September 2014
  _TITLE_="Pup_event_frontend_d"
_VERSION_=1.0omega
_COMMENT_="$_TITLE_:Puppy Linux ash shell script daemon
to handle free space in RAM and Save-File
and Drive Icons on Desktop"

MY_SELF="/sbin/pup_event_frontend_d"
MY_PID=$$

test -f /etc/rc.d/f4puppy5 && {
[ "$HAVE_F4PUPPY5" ] || . /etc/rc.d/f4puppy5

ADD_PARAMETER_LIST=""
ADD_PARAMETERS=""
_provide_basic_parameters

TWO_HELP='1'; TWO_VERSION='1'; TWO_VERBOSE=''; TWO_DEBUG=''; ## Set to anything if code requires further down (ie. custom usage or version message)
ADD_HELP_MSG="$_COMMENT_"
_parse_basic_parameters "$@"
[ "$DO_SHIFT" ] && [ ! "${DO_SHIFT//[[:digit:]]/}" ] && {
  for oneSHIFT in `seq 1 1 $DO_SHIFT`; do shift; done; }

_trap

}
# End new header
#
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#this is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
#This script is part of 'pup_event', my (very) light-weight alternative to udev.
#responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
#this script is launched from $HOME/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#v408 rewrite, now works by polling /sys/block.
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.
#091208 fine-tune placement of desktop drive icons.
#091223 partial fix, some interfaces, no change in /sys/block when insert/remove a card.
#100613 some locales (ex: nl_BE) have ',' instead of '.' in numeric, ex o/p of 'dc'.

########################################################################
#
# CHANGES by Karl Reimer Godt :
# 01.0 : Implemented parameters start,stop,restart .
# 02.0 : Added support for recognition of /tmp/pup_event_change_icons.flg
#        to support redraw of drive icons without having to restart X .
# 03.0 : Added support for recognition of jwm tray height ...
#        STILL TODO !! ie now have
#           Xdialog --backtitle "JWM Taskbar Configuration" \
#           --title "Taskbar" \
#           --spinbox "Choose the Tray Height" 0 0 10 48 $SET_NOW 'Tray height:' 2>$TMP
#        in /usr/local/jwmconfig2/taskbarHeight .
#
# 04.0 : Display all filesystems except unknown and such.
#
# 05.0 : Totally reworked some of my code ..
#        Invented ZCDPOLL var also in /usr/sbin/eventmanager .
#        Renamed HOTPLUGON to DESKDAEMON .
#        Took care of single 'drives' icon.
#        Introduced /tmp/pup_event_manager.flg
#         prior to /tmp/pup_event_change_icons.flg .
#
# 06.0 : Added support for battery check.
# 07.0 : Added _clean_desk_icons() to
#        redraw desktop drive icons each time at startup.
#
#  Added xmessage GUI warning if powertimeout reached.
#  Removed powertimeout MOUSE logfile.
#  Floppy drive icon and CD icon stay on desktop even if nothing inserted.
#  Reordered to code of _free*() functions to lauch resizepfile.sh in case PUPMODE 12|13 .
#  Say warnmessage even in PUPMODE 2|5 if not enough space .
#  Run _savepuppy after _check_disturb* .
#  Added _check_disturb*() functions.
#  The ugly code of ps | grep is 2-5 times more leightweight than using pidof $DO_NOT_DISTURB  .
#
########################################################################

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"
OLDLANG=$LANG #100613
export LANG=C #w004

get_lineno(){  #workaround to grep line number in ash script since ash has no LINENO
    if [ "$1" ] ; then
    echo `grep -n -w -m1 "$1" "$programname" |cut -f1 -d':'`
    else
    echo 'UNKNOWN'
    fi
}
_get_home_var(){
#KRG
test "$HOME" = '/' && export HOME=/root
}
_get_home_var

########### check program ##############
###++2012-01-21
programname='/sbin/pup_event_frontend_d'
if [ "$0" != "$programname" ];then
if [ ! -f "$programname" ];then
echo "ERROR : `basename $programname` should be installed into /sbin
exiting now "
#define ENOENT       2  /* No such file or directory */
return 2 || exit 2
else
echo "ERROR : $programname is not $0 ..
Maybe sourced ?? exiting ."
#define EPERM        1  /* Operation not permitted */
return 1 || exit 1
fi;fi
###++2012-01-21
########### check program ##############

#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.

# Polling. The lesser , the more CPU usage
POLL_FREE_MEMORY=6  # seconds to check free space in /
POLL_PLUG_DEVICE=2  # seconds to check for plugged USB drives
#POLL_REMOVABLE=3   # seconds to poll for CD/Floppy insertitons ZCDPOLL=true
TOGGLE=1
SAVECNT=0
MOUSECNT=0  #w007
MINUTECNT=0 #w007
#CURPOS1="" #w007
CURRPOS1='-1 -1' ##+++2012-01-18 moved here for not testing it inside DAEMON all the time

ZDRV='';ZDRVINIT='no' #these usually set in PUPSTATE.
. /etc/rc.d/PUPSTATE
KERNEL_RELEASE=`uname -r`
[ "$CONFFILE" ] || CONFFILE=/etc/eventmanager.cfg
test -f "$CONFFILE" && . "$CONFFILE" #has RAMSAVEINTERVAL, ICONDESK, HOTPLUGNOISY, ICONPARTITIONS, BACKENDON, POWERTIMEOUT
. /etc/rc.d/functions4puppy4
SIZE_MODS_MB=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_MB=`du -m -s /lib/modules | cut -f 1`
fi
RETVALm=1
PREVSIZETMPM=0
PREVSIZEFREEM=0

### *** ROX-Filer Pinboard *** ###
STATE_DIR="$HOME/Choices/Puppy"
EXE_DIR='pup_event'
PUP_EVENT_DIR="$STATE_DIR/$EXE_DIR"
#PUP_EVENT_DIR="$HOME/Choices/Puppy/pup_event"
#PUP_EVENT_DIR="$HOME/.pup_event"
DRIVE_ICON_DIR="/usr/local/lib/X11/pixmaps"
CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"
  PUPPY_PIN="$HOME/Choices/ROX-Filer/PuppyPin"

### *** do not check for powertimeout if these apps are running *** #
# space delimited for loops and pidof
 DO_NOT_DISTURB='axel burniso2cd cdrecord curl dotpup downloadpkgs.sh gcc gcurl gimv growisofs grub '\
' installpkg.sh make mksquashfs pburn pcdripper pdvdrsab petget ppm puppyinstaller pupzip ripoff unsquashfs wget xorrecord xorriso xarchive'\
'' #SED more into MARKER
# staff delimited and regular expr escaped by \ for grep -E ; max 15 chars
DO_NOT_DISTURB2='axel|burniso2cd|cdrecord|curl|dotpup|downloadpkgs\.sh|gcc|gcurl|gimv|growisofs|grub'\
'|installpkg\.sh|make|mksquashfs|pburn|pcdripper|pdvdrsab|petget|ppm|puppyinstaller|pupzip|ripoff|unsquashfs|wget|xorrecord|xorriso|xarchive'\
'' #SED more into MARKER

 DO_NOT_DISTURB_MM='ffplay gimv gmplayer gnome-mplayer gxine mhwaveedit mplayer vlc xfmedia xine xmms'
DO_NOT_DISTURB_MM2='ffplay|gimv|gmplayer|gnome-mplayer|gxine|mhwaveedit|mplayer|vlc|xfmedia|xine|xmms'


########### battery ##########################
#support warning for low battery
BAT_0_info_file=/proc/acpi/battery/BAT0/info
BAT_0_state_file=/proc/acpi/battery/BAT0/state
BAT_0='0'
if [ -f "$BAT_0_info_file" ];then

BAT_0_LAST_CAPACITY=`grep 'last full capacity:' "$BAT_0_info_file"`
BAT_0_LAST_CAPACITY="${BAT_0_LAST_CAPACITY//[^[:digit:]]/}"

BAT_0_WARN_CAPACITY=$((BAT_0_LAST_CAPACITY/15))

BAT_0_CURRENT=`grep 'remaining capacity:' "$BAT_0_state_file"`
BAT_0_CURRENT="${BAT_0_CURRENT//[^[:digit:]]/}"

[ "$BAT_0_LAST_CAPACITY" -a "$BAT_0_CURRENT" ] && BAT_0='1'
fi
########### battery #########################################

_log_trap
# Signal names and numbers are defined in bits/signum.h ( error codes in asm/errno-base.h and asm/errno.h )
# killall is part of code in busybox procps/kill.c

 trap "echo '$0:PID=$$:2:Stop.';exit 2"    INT  SIGINT   2  #does work in X when controlling terminal (started in xterm);
                                                            #does not work from kernel console; does not work in exitpromt called by plogout
 trap "echo '$0:PID=$$:Got signal 3:'"     QUIT SIGQUIT  3  #no respose with controlling terminal ( bash buildin is only kill )
 trap "echo '$0:PID=$$:4:Stop.';exit 4"    ILL  SIGILL   4  #works with and without controlling terminal, works in kernel console
# #define SIGILL 4 /* Illegal instruction (ANSI). */ #define ESPIPE 29 /* Illegal seek */ #define EILSEQ 84 /* Illegal byte sequence */
 trap "echo '$0:PID=$$:5:Stop.';exit 5"    TRAP SIGTRAP  5
 trap "echo '$0:PID=$$:6:Stop.';exit 6"    ABRT SIGABRT  6  #works
 trap "echo '$0:PID=$$:Got signal 7:'"     BUS  SIGBUS   7
 trap "echo '$0:PID=$$:Got signal 8:'"     FPE  SIGFPE   8
#trap "echo '$0:PID=$$:9:Stop.';exit 9"    KILL SIGKILL  9  #works
 trap "echo '$0:PID=$$:9:Stop wo exit.'"   KILL SIGKILL  9  #GetÃ¶tet
#10 needs terminal
 trap "echo '$0:PID=$$:Got signal 11:'"    SEGV SIGSEGV 11
#12 needs terminal
 trap "echo '$0:PID=$$:Got signal 13:'"    PIPE SIGPIPE 13
 trap "echo '$0:PID=$$:Got signal 14:'"    ALRM SIGALRM 14
 trap "echo '$0:PID=$$:15:Stop.';exit 15"  TERM SIGTERM 15  #works

# xinit sends -SIGHUP to Xorg and .xinitrc, resulting to end up here too
# trying WINCH
trap "echo '$0:PID=$$:WINCH';echo WINCH >/tmp/pup_event_manager.flg; echo WINCH >/tmp/pup_event_change_icons.flg"  WINCH SIGWINCH 28

trap "echo '$0:PID=$$:STOP';echo STOP >/tmp/pup_event_manager.flg;"  RTMIN+1 SIGRTMIN+1 36
trap "echo '$0:PID=$$:CONT';echo CONT >/tmp/pup_event_manager.flg;"  RTMAX-1 SIGRTMAX-1 63

OUT=/dev/null;ERR=$OUT
[ "$DEBUG" ] && { OUT=/dev/stdout;ERR=/dev/stderr; }
[ "$DEBUG" = "2" ] && set -x

Version='1.7-simple Macpup_F3-Puppy_Linux-430/2 KRG'
usage(){
MSG="
$0 [help|version|start|stop|restart|reload]

Script daemon to run in background to manage the
Puppy specific drive icons on the desktop.
The eventmanager GUI in the system menu alters the
configuration file $CONFFILE, which is read
by this script. Other configuration files used :
/etc/rc.d/PUPSTATE /etc/rc.d/functions4puppy4
"
echo "$MSG"
[ "$DISPLAY" ] && xmessage -title "FRONTEND_D HELP" -bg blue3 "$MSG"
exit $1
}

########### parameters start stop restart ##############

#DEBUG=1
_stop_frontends(){
 local aPID c
 _debug "\$\$='$$'"
 MY_PIDS=`pidof -o $$ -o %PPID ${0##*/}`
 for aPID in $MY_PIDS; do
 [ $aPID = 1 ] && continue
 c=$((c+1))
 kill -15 $aPID # needs 15 to kill functions in ash
 done
 sleep 3
 if test "$c"; then
 pidof -o $$ -o %PPID ${0##*/} && return 4 || return 0
 else return 1
 fi
}

[ "$VERBOSE" ] && echo "
$PID $0 $*
"

case "$1" in
*stop)
    _stop_frontends
    RV=$?;if [ "$RV" = '0' ];then
           echo 'stopped .';
        elif [ "$RV" = '1' ];then
            echo 'was not running.'
        else echo 'error occurred !';
        fi
return "$RV" || exit "$RV";;

*restart)
    _stop_frontends
    RV="$?";if [ "$RV" = '0' ];then
               echo 'stopped .';
            elif [ "$RV" = '1' ];then
                echo 'was not running.'
            else echo 'error occurred !';
                 return "$RV" || exit "$RV";
            fi;;

*start|"")
sleep 2;;

*reload) MY_PIDS=`pidof -o $$ -o %PPID ${0##*/}`
         test "$MY_PIDS" || _exit 1 "Not running."
         echo WINCH  >/tmp/pup_event_manager.flg
         echo reload >/tmp/pup_event_change_icons.flg;
         exit $?;;

*help) usage 0;;
*version) echo -e "\n$0: Version '$Version'\nTry help for more info\n";exit 0;;

*)
echo "Implemented parameters : help|version|stop|restart|start|NOTHING(means start)
"
#define EINVAL      22  /* Invalid argument */
return 22 || exit 22;;
esac
########### parameters start stop restart ##############

################# check if already running ############################
###+++2012-01-19

prog=$(basename $0)
DAEMONS=`ps-FULL -f --no-headers -C "$prog"| grep -v '<defunct>'`
PROGPID=$$
_debug "
.............
$PROGPID
$DAEMONS
............."
PIDS=`echo "$DAEMONS" |awk '{print $2" "$3}'`
while [ "$PIDS" ]; do

pids1=`echo "$PIDS"  |sed -n "1 p"`
 pid1=`echo "$pids1" |awk '{print $1}'`
ppid1=`echo "$pids1" |awk '{print $2}'`
pids2=`echo "$PIDS"  |sed -n "2 p"`
_debug "pids1='$pids1'"
_debug "pids2='$pids2'"
[ "$pids2" ] || break
if [ ! "`echo "$pids2" | grep -w "$pid1"`" -a ! "`echo "$pids2" | grep -w "$ppid1"`" ];then

echo "Another $0 already running .
Refusing to start .
Try > $0 restart
"
#define EBUSY       16  /* Device or resource busy */
return 16 || exit 16
fi
PIDS=`echo "$PIDS" |sed '1 d'`
done
################# check if already running ############################

################# ORIG #########################################################
#v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_change_icons.flg
#which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
#however I think it would be good to test here also if X mode not yet settled on...
if [ -f /tmp/videomode ];then #only exists during X resolution setup.
 if [ "`readlink /usr/bin/X`" = "Xvesa" ]; then
  while [ -f /tmp/videomode ]; do
   sleep 1
  done
 fi
else
################# ORIG #####################################
#w471 slow cpus need more delay (well, rox does)...
DELAYFACTOR=0
#CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
 CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d '[:blank:]' | cut -f 2 -d ':' | cut -f 1 -d '.'`
 [ "$CPUMHZ" -a $CPUMHZ -gt 100 ] && DELAYFACTOR=$(( 1100 / CPUMHZ ))
 [ $DELAYFACTOR -gt 0 ] && sleep $DELAYFACTOR
fi

################# ORIG ######################################
#v424 experiment, automatic unmounting...
_auto_unmount(){
 for oneMNTPT in `grep '^/dev/[fhms]\{1\}[mcd]\{1,2\}' /proc/mounts | grep -vE '^/dev/md|/initrd/' | awk '{print $2}'`
 do
  oneMNTPT=`echo -e "$oneMNTPT"`
  if [ ! "`fuser -v -m $oneMNTPT`" ]; then
   pidof sync >>$OUT || sync
   /bin/umount $VERB "$oneMNTPT"; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ "$umVAL" -ne 0 ];then

    while read pid status; do
     [ "$pid" -a "$status" ] || continue
      case $status in
      Z*) :;;
      *) continue;;
      esac
      case $pid in
      1|$$|$PPID) continue;;
      esac
     kill -9 $pid
done << EoI
$(ps -o pid,stat | grep -w Z)
EoI

    /bin/umount $VERB -r "$oneMNTPT"; umVAL=$?
   fi
  fi
 done
}

_free_initrd(){  #_free_ram
#UniPup, runs entirely in initramfs.

 __old_freekm__(){
 SIZEFREEK=`free | grep -o '^Total:.*' | tr -s ' ' | cut -f 4 -d ' '` #BusyBox v1.4.2 initrd.gz
 SIZEFREEM=$((SIZEFREEK/1024))
 }

 local SIZEFREEM SIZEFREEM_
 unset SIZEFREEM SIZEFREEM_

 SIZEFREEM_=`free -m | awk '{if (match($1, "Mem:") || match($1, "Swap:")) print $4}'`
 for aVAL in $SIZEFREEM_; do SIZEFREEM=$((SIZEFREEM+aVAL)); done

 #save to a file, freememapplet can read this...
 echo "$SIZEFREEM" >/tmp/pup_event_sizefreem
}

_free(){  # _free_savefile _free_rootfs
#called every POLL_PLUG_DEVICE seconds.
 case $PUPMODE in
  6|12) #frugal to whole partition|frugal to save-file (on HDD)
    SIZEFREESAVE_MB=`/bin/df -m | awk '{if ($NF == "/initrd/pup_rw") print $4}' | tail -n1`
  ;;
  *) # 2|5
    SIZEFREESAVE_MB=`/bin/df -m | awk '{if ($NF == "/") print $4}' | tail -n1`
  ;;
 esac
 WARNMSG=""
 [ "$SIZEFREESAVE_MB" ] || WARNMSG="Could not determine free space using df plus filters"
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ $PREVSIZEFREEM -eq $SIZEFREESAVE_MB ] && return
 if [ $SIZEFREESAVE_MB -lt 10 ];then
  WARNMSG="$WARNMSG
   WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   case $PUPMODE in 6|12)
   _delete_drivers /initrd/pup_rw #save layer is at top, delete mods.
   ;;
   esac
  else
    :
  fi
  case $PUPMODE in 12)
   pidof resizepfile.sh >>$OUT || resizepfile.sh &
  ;;
  esac
 fi

 if [ "$WARNMSG" ];then
  killall yaf-splash >>$OUT 2>>$ERR
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi

 VIRTUALFREEM=$SIZEFREESAVE_MB

 if [ "$ZDRVINIT" = "yes" ];then                         #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ];then #have not yet deleted modules.
     #calc the "virtual" free space (would have if modules not there...)
     VIRTUALFREEM=$(( SIZEFREESAVE_MB + SIZE_MODS_MB ))
     #allow for some mods will not be deleted.
     VIRTUALFREEM=$(( VIRTUALFREEM - 1 ))
  fi
 fi

 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" >/tmp/pup_event_sizefreem
 #[ $PUPMODE -eq 5 -o $PUPMODE -eq 2 ] && return 0 #5=first boot, no msgs at top of screen. 2=full install

}

_free_flash(){
#PUPMODE 3,7,13. called every PULL_PLUG_DEVICE seconds. 3=full on internal flash, 7 frugal to whole partition, 13=frugal to save-file
# WARNMSG=""

  SIZEFREESAVE_MB=`/bin/df -m | awk '{if ($NF == "/initrd/pup_ro1") print $4}' | tail -n1`

   SIZEFREETMP_MB=`/bin/df -m | awk '{if ($NF == "/initrd/pup_rw") print $4}' | tail -n1`

 WARNMSG=""
 [ "$SIZEFREESAVE_MB" ] || WARNMSG="Could not determine free space in save-file using df and filters"
  [ "$SIZEFREETMP_MB" ] || WARNMSG="$WARNMSG
Could not determine free space in /tmp layer"

 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ -s /tmp/pup_event_sizetmpm ]  && read PREVSIZETMPM  </tmp/pup_event_sizetmpm
 [ "$PREVSIZEFREEM" = $SIZEFREESAVE_MB -a "$PREVSIZETMPM" = $SIZEFREETMP_MB ] && return

 if [ $SIZEFREESAVE_MB -lt 10 ]; then
  WARNMSG="$WARNMSG
   WARNING: Personal storage file getting full, strongly recommend you resize it and reboot or delete files!"
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_ro1 #delete modules in save layer only.
  WARNMSG="$WARNMSG
  NOTE: Have removed drivers and firmware in /initrd/pup_ro1/lib/modules"
  else
   :
  fi
  case $PUPMODE in 13)
  pidof resizepfile.sh >>$OUT || resizepfile.sh &
  ;;
  esac
 fi

 # REM: try freeing ^unused^ RAM
 if [ $SIZEFREETMP_MB -lt 5 ]; then
  echo '3' >/proc/sys/vm/drop_caches && {
  sleep 2;
  SIZEFREETMP_MB=`/bin/df -m | awk '{if ($NF == "/initrd/pup_rw") print $4}' | tail -n1`
  }
 fi

 if [ $SIZEFREETMP_MB -lt 5 ]; then
  WARNMSG="$WARNMSG
   WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ];then
   _delete_drivers /initrd/pup_rw #delete modules in top tmpfs layer only.
   WARNMSG="$WARNMSG
   NOTE: Have removed drivers and firmware in /initrd/pup_rw/lib/modules"
  else
  :
  fi
  case $PUPMODE in 13)
  pidof resizepfile.sh >>$OUT || resizepfile.sh &
  ;;
  esac
 fi

 if [ "$WARNMSG" ]; then
  killall yaf-splash >>$OUT 2>>$ERR
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
 fi

 VIRTUALFREEM=$SIZEFREESAVE_MB
 if [ "$ZDRVINIT" = "yes" ]; then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ];then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
     VIRTUALFREEM=$(( SIZEFREESAVE_MB + SIZE_MODS_MB ))
   #allow for some mods will not be deleted.
     VIRTUALFREEM=$(( VIRTUALFREEM - 1 ))
  fi
 fi

 echo "$SIZEFREETMP_MB" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem

}

_savepuppy(){
#called every POLL_PLUG_DEVICE seconds.
 #if [ -f /tmp/snapmergepuppyrequest ]; then #by request.
  #rm $VERB -f /tmp/snapmergepuppyrequest
  SAVECNT=$((SAVECNT + POLL_PLUG_DEVICE))
  [ "$SAVECNT" -ge $RAMSAVEINTERVAL -o -f /tmp/snapmergepuppyrequest ] || return 0
  SAVECNT=0
  rm $VERB -f /tmp/snapmergepuppyrequest
  yaf-splash -font "8x16" -outline 0 -margin 4 -bg orange -placement top -text "Saving RAM to 'pup_save' file..." &
  YAFPID=$!
  pidof sync >>$OUT || sync
  nice -n 19 /usr/sbin/snapmergepuppy
  kill $YAFPID >>$OUT 2>>$ERR
 #fi
}

#note that init script in initrd takes care of restoring modules if enough space.
_delete_drivers(){
# Called from _free() and _free_flash().
# Deletes modules to create more free space.
# passed param: /pup_rw=delete tmpfs top layer only.
 [ "$*" ] || return
 DEL_LAYER=$1
 #find out what modules are loaded, keep those...
 for oneKEEP_MOD in `cut -f 1 -d ' ' /proc/modules`
 do
  oneKEEP_SPEC=`modinfo -F filename ${oneKEEP_MOD}`
  oneKEEP_PATH=${oneKEEP_SPEC%/*}
  mkdir $VERB -p /tmp/${oneKEEP_PATH}
  cp $VERB -af ${oneKEEP_SPEC} /tmp/${oneKEEP_PATH}/
 done
 if [ "$DEL_LAYER" ];then
  rm $VERB -rf ${DEL_LAYER}/lib/modules
 else
  if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then  #flash
   rm $VERB -rf ${SAVE_LAYER}/lib/modules
  fi
  rm $VERB -rf /lib/modules
 fi
 cp $VERB -af /tmp/lib/modules /lib/modules
 depmod $VERB -a
}

#v407 fixed so works for sr* and hd* optical...
_probe_optical(){
#passed param is sr<0-9> or hd<a-z>
 _debug "_probe_optical:$*"
 [ "$*" ] || return
 DRV_NAME="$1"
 DRV_CATEGORY="optical"
 CDSTATUS2="0"

 opticalPATTERN='^/dev/'"${DRV_NAME}"' '
 [ "`grep "$opticalPATTERN" /proc/mounts`" ] && return #only check cd if unmounted.
 cddetect_quick -d/dev/${DRV_NAME} >>$OUT 2>>$ERR #very fast.
 #...returns 0 if disc inserted, else 255.
 CDSTATUS2="$?"
 echo "$CDSTATUS2" > /tmp/pup_event_frontend_identify2_${DRV_NAME}
 [ -f /tmp/pup_event_frontend_identify1_${DRV_NAME} ] || cp $VERB /tmp/pup_event_frontend_identify2_${DRV_NAME} /tmp/pup_event_frontend_identify1_${DRV_NAME}
 CDSTATUS1=`cat /tmp/pup_event_frontend_identify1_${DRV_NAME}`
 [ "$CDSTATUS1" = "$CDSTATUS2" ] && return

 cp $VERB -f /tmp/pup_event_frontend_identify2_${DRV_NAME} /tmp/pup_event_frontend_identify1_${DRV_NAME}
 if [ "$CDSTATUS2" = "0" ]; then
  #VENDOR=`cat /sys/block/${DRV_NAME}/device/vendor | tr -s ' '`
  #MODEL=`cat /sys/block/${DRV_NAME}/device/model | tr -s ' '`
  #DRV_DESCRIPTION="$VENDOR $MODEL"
  #opticalPATTERN='^/dev/'"${DRV_NAME}"'|'
  #DRV_DESCRIPTION=`echo "$_PROBEDISK_" | grep "$opticalPATTERN" | cut -f 3 -d '|'`
  #test "$DRV_DESCRIPTION" || DRV_DESCRIPTION='unknown'
  #_create_icon "$DRV_NAME" "$DRV_CATEGORY" "$DRV_DESCRIPTION" #requires DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
  [ "$HOTPLUGNOISY" = "true" ] && "$PUP_EVENT_DIR"/drive_${DRV_NAME}/AppRun optical & #handler script.

 fi
unset DRV_NAME DRV_CATEGORY DRV_DESCRIPTION
}

#v407 detect ls120 and zip disc inserted...
_probe_floppy(){
#passed param is whole drive name (exs: hdc, sdc)
 _debug "_probe_floppy:$*"
 [ "$*" ] || return
 DRV_NAME="$1"
 DRVMAIN=`echo -n "$DRV_NAME" | cut -c 1,2` #sd or hd.
 DRV_CATEGORY="floppy"

 floppyPATTERN="^/dev/$DRV_NAME "
 [ "`grep "$floppyPATTERN" /proc/mounts`" ] && return #mounted.

 if [ "$DRVMAIN" = "hd" ];then
  cat /proc/ide/${DRV_NAME}/identify > /tmp/pup_event_frontend_identify2_${DRV_NAME}
 else
  #this method not as good, as only detects disc if it has a partition...
  floppyPATTERN=" ${DRV_NAME}"
  grep "$floppyPATTERN" /proc/partitions > /tmp/pup_event_frontend_identify2_${DRV_NAME}
 fi

 [ -f /tmp/pup_event_frontend_identify1_${DRV_NAME} ] || cp $VERB /tmp/pup_event_frontend_identify2_${DRV_NAME} /tmp/pup_event_frontend_identify1_${DRV_NAME}
 [ "`diff -s /tmp/pup_event_frontend_identify1_${DRV_NAME} /tmp/pup_event_frontend_identify2_${DRV_NAME} | grep ' are identical'`" ] && return
 cp $VERB -f /tmp/pup_event_frontend_identify2_${DRV_NAME} /tmp/pup_event_frontend_identify1_${DRV_NAME}

 FLOPPYSTATUS=1
 [ "`disktype /dev/${DRV_NAME} 2>&1 | grep 'I/O error'`" ] || FLOPPYSTATUS=0

 if [ "$FLOPPYSTATUS" = "0" ];then
  #if [ "$DRVMAIN" = "hd" ]; then
  # [ -f /proc/ide/${DRV_NAME}/model ] && read DRV_DESCRIPTION </proc/ide/${DRV_NAME}/model
  #else
  # [ -f /sys/block/${DRV_NAME}/device/model ] && read DRV_DESCRIPTION </sys/block/${DRV_NAME}/device/model
  #fi
  #test "${DRV_DESCRIPTION// /}" || DRV_DESCRIPTION='unknown'
  #_create_icon "$DRV_NAME" "$DRV_CATEGORY" "$DRV_DESCRIPTION" #requires DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
  [ "$HOTPLUGNOISY" = "true" ] && "$PUP_EVENT_DIR"/drive_${DRV_NAME}/AppRun floppy & #handler script.
 fi

unset DRV_NAME DRVMAIN DRV_CATEGORY floppyPATTERN FLOPPYSTATUS DRV_DESCRIPTION
}

################# ORIG #####################################


################# orig to function #################
_get_screen_vars(){
#KRG

# REM: -e PATTERN, --regexp=PATTERN
#              Use  PATTERN as the pattern.
#              This is useful to protect patterns
#              beginning with hyphen-minus (-).
#              (-e is specified by POSIX.)

SCRNXY=`xwininfo -root 2>&1 | grep -oe '-geometry .\+' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'` #orig
case "$SCRNXY" in *unable*to*open*display*) _exit 177 "'$SCRNXY'";; esac
SCRN_X=`echo -n "$SCRNXY" | cut -f 1 -d 'x'` #orig
SCRN_Y=`echo -n "$SCRNXY" | cut -f 2 -d 'x'` #orig

} #KRG
_get_screen_vars

_get_ram_power_vars(){
[ "$RAMSAVEINTERVAL" ] || RAMSAVEINTERVAL=30 #412
#convert minutes to seconds.
 RAMSAVEINTERVAL=$(( RAMSAVEINTERVAL * 60 ))

[ "$POWERTIMEOUT" ] || POWERTIMEOUT=0 #w007
#convert minutes to seconds.
 POWERTIMEOUT=$(( POWERTIMEOUT * 60 ))
}
_get_ram_power_vars
################# orig to function #################################


################# ORIG #####################################

_format_size(){
 SIZE="$1"
 [ $SIZE ] || SIZE=0
 if [ $SIZE -gt 1048576 ];then #1024*1024
  SIZE=`LANG=$OLDLANG dc $SIZE 1048576 \/ p` #100613 dc o/p '.' if LANG=C.
  SIZE="`LANG=$OLDLANG printf "%.1f" $SIZE`GB" #100613
 elif [ $SIZE -gt 1024 ];then
  SIZE="$(( SIZE / 1024 ))"'MB'
 else
   SIZE=`LANG=$OLDLANG dc $SIZE 1024 \/ p` #100613
   SIZE="`LANG=$OLDLANG printf "%.3f" $SIZE`MB" #100613
 fi
 [ "$SIZE" = "0.0MB" ] && SIZE="0"
 [ "$SIZE" = "0,0MB" ] && SIZE="0" #100613
}

_create_appinfo(){
_debug "_create_appinfo:$*"
test "$*" || return

dINFO="$1"
DISK_CATEGORY="$2"
MOREITEMS="$3"
oneDRVNAME="$4"

#needs dINFO, DISK_CATEGORY, MOREITEMS, oneDRVNAME
   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${INFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${DISK_CATEGORY}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item>
   <Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>
   ${MOREITEMS}
  </AppMenu>
</AppInfo>" > "$PUP_EVENT_DIR"/drive_${oneDRVNAME}/AppInfo.xml
[ $? = 0 ] && { _info "_create_appinfo:Created $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml"; true; } || _warn "_create_appinfo:Could not create $PUP_EVENT_DIR/drive_${oneDRVNAME}/AppInfo.xml"
#unset dINFO DISK_CATEGORY MOREITEMS oneDRVNAME
}
################# ORIG #####################################


################# new functions ###############


_get_jwm_vars(){
    local DEBUG=1
read CWM </etc/windowmanager
if [ "$CWM" = "jwm" ]; then
jwmL=`grep -E -i 'Tray | autohide=| insert=| x=| y=| insert=' $HOME/.jwmrc-tray | grep -vE '<!\-\-|\-\->$' | tail -n1`
# REM: using cut cut
jwmTPOS=`echo "$jwmL" | grep -o ' y=.*$' | cut -f 2 -d ' ' | cut -f 2 -d '"'`
[ -z "$jwmTPOS" ] && jwmTPOS="-1"
# REM: using tr cut
jwmHEIGHT=`echo "$jwmL" | grep -o ' height=.*$' | tr -d ' ' | cut -f 2 -d '"'`
fi
[ -z "$jwmHEIGHT" ] && jwmHEIGHT=28

#jwmT_Yvar=10
#jwmT_Yvar=$(((SCRN_Y/500)*jwmHEIGHT))
jwmT_Yvar=$jwmHEIGHT
_debug "jwmT_Yvar='$jwmT_Yvar'"
}
_get_jwm_vars


_get_rox_vars(){
# REM: filter comment lines
PIN_GRID_STEP=`sed -n '/<!--/,/-->/!p' "$CONFFILEROX" | grep -m1 "pinboard_grid_step" | sed -e "s/ *<[^>]*>//g"`
case $PIN_GRID_STEP in 2|16|32) :;;
*) PIN_GRID_STEP=32;;
esac
[ -z "$PIN_GRID_STEP" ]    && PIN_GRID_STEP=32 #2=fine 16=medium 32=coarse.
[ "$PIN_GRID_STEP" -le 0 ] && PIN_GRID_STEP=32 #precaution.

_debug "PIN_GRID_STEP='$PIN_GRID_STEP'"
#[ -z "$ICON_PLACE_START_X_GAP" ] && ICON_PLACE_START_X_GAP=32
[ -z "$ICON_PLACE_ORIENTATION" ] && ICON_PLACE_ORIENTATION='bottom'

if [ -z "$ICON_PLACE_SPACING" ] ; then
#DriveIconsize=`grep -o 'DRVICON=.*' /etc/rc.d/functions4puppy4  | grep -o -e '[[:digit:]]*' | head -n 1`  ##+2012-11-05 added -e to grep -o
# REM: was under the impression, that --regex would mean someting special, but is not...
#      * is short for {0,}
#      + is short for {1,}
DriveIconsize=`grep -o 'DRVICON=.*' /etc/rc.d/functions4puppy4  | grep -o '[[:digit:]]\+' | head -n 1`

ICON_PLACE_SPACING=$(( (( DriveIconsize + 1 ) / PIN_GRID_STEP ) * PIN_GRID_STEP ))
fi

#ICON_PLACE_START_X_GAP=32;ICON_PLACE_START_Y_GAP=32;
##ICON_PLACE_START_X_GAP=2;ICON_PLACE_START_Y_GAP=2; #x gets half off screen @right)

ICON_PLACE_SPACING=$(( ((ICON_PLACE_SPACING + 1) / PIN_GRID_STEP ) * PIN_GRID_STEP ))
}
_get_rox_vars

# REM: want the effective usable X and Y of screen
#      fontsize may be very big and clash with jwm taskbar/tray
_get_max_xy(){

_get_screen_vars

##CONFFILEROX="$HOME/.config/rox.sourceforge.net/ROX-Filer/Options"  #also deeper down in script
#FONT_SIZE=`grep 'name="label_font">.*<' "$CONFFILEROX" |sed 's|\(.*\)>\(.*\)<\(.*\)|\2|' |rev |awk '{print $1}' |rev`
#_debug "FONTSIZE='$FONT_SIZE'"

## REM: ROX-Filer handles icons from middle of icon, not start of icon ( or end of icon )
#ICON_X=48;icon_x=$((ICON_X/2))
#ICON_Y=$((FONT_SIZE+48));icon_y=$((ICON_Y/2))

##+++2012-01-19
#MAX_X=$((SCRN_X-icon_x))  #24 half icon size of 48
#MAX_Y=$((SCRN_Y-icon_y))  #49 full iconsize, 24 label

MAX_X=$SCRN_X
MAX_Y=$SCRN_Y
}
_get_max_xy


_get_icon_xy_values(){
#KRG
case $ICON_PLACE_ORIENTATION in #see "$CONFFILE"

  bottom)

    COORD_X=$((0 + (ICON_PLACE_SPACING/2) ))
    COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
    COORD_X=$(( COORD_X - ICON_PLACE_SPACING )) # gets ICON_PLACE_SPACING added again in free_coord

    case "$jwmTPOS" in
     0)  #top
      jwmT_Yvar=0 ;;
     *) :;;
    esac

      COORD_Y=$(( MAX_Y - jwmT_Yvar ))
      COORD_Y=$(( COORD_Y - (ICON_PLACE_SPACING/2) ))
      COORD_Y=$(( ((COORD_Y - 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
   _debug "_get_icon_xy_values:bottom: COORD_Y='$COORD_Y'"
   ;;

  top)
  [ "$DEBUG" ] && { LINEP=D0511;echo "`[ $LINENO ] && echo $LINENO || get_lineno $LINEP` _get_icon_xy_values"; }

   COORD_X=$((0 + (ICON_PLACE_SPACING/2) ))
   COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
   COORD_X=$(( COORD_X - ICON_PLACE_SPACING )) # gets ICON_PLACE_SPACING added again in free_coord

    case "$jwmTPOS" in
     0)
       _debug "_get_icon_xy_values:top jwmTPOS='$jwmTPOS' ICON_PLACE_START_X_GAP='$ICON_PLACE_START_X_GAP' ICON_PLACE_START_Y_GAP='$ICON_PLACE_START_Y_GAP' jwmT_Yvar='$jwmT_Yvar'"
       :;;
     *)
     _debug "_get_icon_xy_values:top: jwmTPOS='$jwmTPOS'"
     jwmT_Yvar=0;;
    esac

    COORD_Y=$(( 0 + jwmT_Yvar ))
    COORD_Y=$(( COORD_Y + (ICON_PLACE_SPACING/2) ))
    test $COORD_Y -lt 48 && COORD_Y=48
    COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

   [ "$DEBUG" ] && { LINEP=D0512;echo "`[ $LINENO ] && echo $LINENO || get_lineno $LINEP`"; }
   ;;

   left)

   COORD_X=$((0 + (ICON_PLACE_SPACING/2) ))
   COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    case "$jwmTPOS" in
     0)  #TOP
       :;;
     *)
     MAX_Y=$((MAX_Y-jwmT_Yvar));
     MAX_Y=$((MAX_Y - 48))
     jwmT_Yvar=0;;
    esac

    COORD_Y=$(( 0 + jwmT_Yvar ))
    COORD_Y=$(( COORD_Y + (ICON_PLACE_SPACING/2) ))
    test $COORD_Y -lt 64 && COORD_Y=64 #min 48@16, 64@32
    COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
    COORD_Y=$(( COORD_Y - ICON_PLACE_SPACING )) # gets ICON_PLACE_SPACING added again in free_coord

   ;;
   right)

   COORD_X=$((MAX_X - (ICON_PLACE_SPACING/2) )) #range 64-160 /2
   COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
   _debug right:COORD_X=$COORD_X
   _debug "_get_icon_xy_values:right: jwmTPOS='$jwmTPOS'"
    case "$jwmTPOS" in
     0) #TOP
        :;;
     *)
     MAX_Y=$((MAX_Y-jwmT_Yvar));
     MAX_Y=$((MAX_Y - 48))
     jwmT_Yvar=0;;
    esac

   COORD_Y=$(( 0 + jwmT_Yvar ))
   COORD_Y=$(( COORD_Y + (ICON_PLACE_SPACING/2) ))
   test $COORD_Y -lt 64 && COORD_Y=64  # 48/16=3*16=48 | 48/32=1*32=32
   COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))
   COORD_Y=$(( COORD_Y - ICON_PLACE_SPACING )) # gets ICON_PLACE_SPACING added again in free_coord
   _debug "_get_icon_xy_values:right: COORD_Y='$COORD_Y'"
   ;;
esac
}
_get_icon_xy_values #KRG

[ "$DEBUG" ] && { LINEP=D002;echo "`[ $LINENO ] && echo $LINENO || get_lineno $LINEP`"; }

_free_coord() {
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...

 local DEBUG=1
 _debug "_free_coord:$*:$COORD_X $COOD_Y"

 case $ICON_PLACE_ORIENTATION in #see "$CONFFILE"
  bottom)

    _debug "bottom: X='$COORD_X' Y='$COORD_Y' '$oneDRVNAME'"
    COORD_X=$(( COORD_X + ICON_PLACE_SPACING ))

    if [ "$COORD_X" -gt "$MAX_X" ];then #start next line up.
    _notice "new X Y coordinates"

    COORD_Y=$((COORD_Y - ICON_PLACE_SPACING))

    COORD_X=$((0 + (ICON_PLACE_SPACING/2) ))
    COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "bottom:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
  ;;

  top)

    _debug "top:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
    COORD_X=$((COORD_X + ICON_PLACE_SPACING))

    if [ $COORD_X -gt $MAX_X ];then #start next line down.
    _notice "new X Y coordinates"

    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))

    COORD_X=$((0 + (ICON_PLACE_SPACING/2) ))
    COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "top:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
  ;;

  left)

    _debug "left: ' x=\"${COORD_X}\" y=\"${COORD_Y}\" '"
    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))

    if [ $COORD_Y -ge $MAX_Y ];then #start next row.
     _notice "new X Y coordinates"

     COORD_X=$((COORD_X + ICON_PLACE_SPACING))

     COORD_Y=$(( 0 + jwmT_Yvar ))
     COORD_Y=$(( COORD_Y + (ICON_PLACE_SPACING/2) ))
     test $COORD_Y -lt 64 && COORD_Y=64
     COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "left:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"

  ;;

  right)
    _debug "right:COORD_X=$COORD_X COORD_Y=$COORD_Y"
    COORD_Y=$(( COORD_Y + ICON_PLACE_SPACING ))
    if [ "$COORD_Y" -ge "$MAX_Y" ];then #start next row back.
    _notice "new X Y coordinates"

    COORD_X=$(( COORD_X - ICON_PLACE_SPACING ))

    COORD_Y=$(( 0 + jwmT_Yvar ))
    COORD_Y=$(( COORD_Y + (ICON_PLACE_SPACING/2) )) # 32 too low
   #COORD_Y=$(( COORD_Y + ICON_PLACE_SPACING ))    # 64 too much
    test $COORD_Y -lt 64 && COORD_Y=64
    COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "right:COORD_X=$COORD_X COORD_Y=$COORD_Y"
  ;;

 esac
}
_free_coord_rem() {
 #find a free place on desktop. v410 avoid exact overlapping icons...
 #091208 finetune placement, also any side of screen...
 #read the coords grid, code from shinobar...

 local DEBUG=1
 _debug "_free_coord_rem:$*:$COORD_X $COOD_Y '$oneDRVNAME'"

 case $ICON_PLACE_ORIENTATION in #see "$CONFFILE"
  bottom)

    _debug "bottom: COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
    COORD_X=$(( COORD_X - ICON_PLACE_SPACING ))
    if [ "$COORD_X" -lt 64 ];then #start next line up.
    _notice "New X and Y coordinates.."

    COORD_Y=$((COORD_Y + ICON_PLACE_SPACING))

    COORD_X=$(( MAX_X - (ICON_PLACE_SPACING/2) ))
    COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "bottom:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
  ;;

  top)

    _debug "top:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
    COORD_X=$((COORD_X - ICON_PLACE_SPACING))

    if [ $COORD_X -lt 64 ];then #start next line down.
    _notice "New X and Y coordinates.."

    COORD_Y=$((COORD_Y - ICON_PLACE_SPACING))

    COORD_X=$(( MAX_X - (ICON_PLACE_SPACING/2) ))
    COORD_X=$(( ((COORD_X + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "top:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
  ;;

  left)

    _debug "left: COORD_X=${COORD_X} COORD_Y=${COORD_Y}"
    COORD_Y=$((COORD_Y - ICON_PLACE_SPACING))

    if [ $COORD_Y -lt 64 ];then #start next row.
     _notice "New X and Y coordinates.."

     COORD_X=$((COORD_X - ICON_PLACE_SPACING))

     COORD_Y=$(( MAX_Y - jwmT_Yvar ))
     COORD_Y=$(( COORD_Y - (ICON_PLACE_SPACING/2) ))
     test $COORD_Y -lt 64 && COORD_Y=64
     COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "left:COORD_X='$COORD_X' COORD_Y='$COORD_Y'"

  ;;

  right)

    _debug "right:COORD_X=$COORD_X COORD_Y=$COORD_Y"
    COORD_Y=$(( COORD_Y - ICON_PLACE_SPACING ))

    if [ "$COORD_Y" -lt 64 ];then #start next row back.
    _notice "New X and Y coordinates.."

    COORD_X=$(( COORD_X + ICON_PLACE_SPACING ))

    COORD_Y=$(( MAX_Y - jwmT_Yvar ))
    COORD_Y=$(( COORD_Y - (ICON_PLACE_SPACING/2) )) # 32 too low
   #COORD_Y=$(( COORD_Y - ICON_PLACE_SPACING ))    # 64 too much
    test $COORD_Y -lt 64 && COORD_Y=64
    COORD_Y=$(( ((COORD_Y + 1) / PIN_GRID_STEP) * PIN_GRID_STEP ))

    fi
    _debug "right:COORD_X=$COORD_X COORD_Y=$COORD_Y"
  ;;

 esac
}

_remove_pinboard(){
#needs DRV_NAME (name of entire drive)
 _debug  "_remove_pinboard:$@"
 [ "$*" ] || return
 DRV_NAME="$1"
 _debug  "DRV_NAME=$DRV_NAME'"
 ppPATTERN=' label="'"$DRV_NAME"'.*" '
 _debug  "ppPATTERN=$ppPATTERN"

 [ -z "`grep "$ppPATTERN" "$PUPPY_PIN"`" ] && return
 allNAMES=`grep -o "$ppPATTERN" "$PUPPY_PIN" | cut -f 2 -d '"'`
 [ "$DISPLAY" ] || return
 for oneDRVNAME in $allNAMES
 do

 # Reset COORD_X COORD_Y
 #COORD_X=`grep "$ppPATTERN" "$PUPPY_PIN" | grep -oE ' x="[0-9]+"' | cut -f2 -d '"'`
 #COORD_Y=`grep "$ppPATTERN" "$PUPPY_PIN" | grep -oE ' y="[0-9]+"' | cut -f2 -d '"'`

 [ "$2" = startup ] || _free_coord_rem

  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$PUP_EVENT_DIR/drive_${oneDRVNAME}</Path>
  </PinboardRemove>
 </env:Body>
</env:Envelope>"  | rox -R  2>>$ERR
 [ $? = 0 ] && { _info "${oneDRVNAME}: Removed from PuppyPin ."; true; } || _warn "Could not remove ${oneDRVNAME} from PuppyPin ."
 done
unset oneDRVNAME allNAMES ppPATTERN DRV_NAME
}

_clean_desk_icons(){
while read part;do
 DRV_NAME=$part
 _remove_pinboard "$DRV_NAME" startup #$DRV_NAME
done << _EOI
$(grep -o "/$EXE_DIR/drive.*" "$PUPPY_PIN" |sed -r 's,(.*)(drives)(.*),\2,;s,(.*drive_)(.*)(<.*),\2,')
_EOI
rm $VERB -rf "$PUP_EVENT_DIR"/*
rm $VERB -f /tmp/pup_event_change_icons.flg
rm $VERB -f /tmp/pup_event_manager.flg
unset DRV_NAME part
}
_clean_desk_icons


[ "$DEBUG" ] && { LINEP=D003;echo "`[ $LINENO ] && echo $LINENO || get_lineno $LINEP`"; }
_add_pinboard(){
[ "$DISPLAY" ] || return
#needs oneDRVNAME, DRV_CATEGORY, FSTYPE
_debug "_add_pinboard:$@"
test "$*" || return
oneDRVNAME="$1"
DRV_CATEGORY="$2"
FSTYPE="$3"
case $FSTYPE in
*not*inserted*|*none*) FSTYPE='';;
esac

 #v411 rerwin: avoid icon getting duplicated if it is renamed...
 ppPATTERN="$EXE_DIR/drive_${oneDRVNAME}<" ##++2012-01-18
 [ "`grep "$ppPATTERN" "$PUPPY_PIN"`" ] && return
 _free_coord

 _info "X for ROX : '${COORD_X}' Y for ROX : '${COORD_Y}' :for: '$oneDRVNAME'"
 _debugx ""

 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$PUP_EVENT_DIR/drive_${oneDRVNAME}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${oneDRVNAME}</Label>
   <Args>${DRV_CATEGORY} ${FSTYPE}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R  2>>$ERR
[ $? = 0 ] && { _info "_add_pinboard:Added to PuppyPin: $PUP_EVENT_DIR/drive_${oneDRVNAME}"; true; } || _warn "_add_pinboard:Could not add $PUP_EVENT_DIR/drive_${oneDRVNAME} to PuppyPin"

# want to check if rox actually uses COORD_X and COORD_Y passed
# rox has its own logic and may put the icon nearby if another icon
# is there already
sleep 0.1
aENTRY=`grep "/drive_${oneDRVNAME}</icon>" "$PUPPY_PIN" | tail -n1`
aX=`echo "$aENTRY" | cut -f2 -d'"'`
aY=`echo "$aENTRY" | cut -f4 -d'"'`
test $aX = $COORD_X || _warn "ROX-Filer ignored '$COORD_X' passed, uses '$aX' instead.."
test $aY = $COORD_Y || _warn "ROX-Filer ignored '$COORD_Y' passed, uses '$aY' instead.."

unset oneDRVNAME DRV_CATEGORY FSTYPE aENTRY aX aY
}


_create_icon(){
    local DEBUG=
    _debug  "_create_icon:$@"
    #echo "DRV_NAME='$DRV_NAME' DRV_CATEGORY='$DRV_CATEGORY' DRV_DESCRIPTION='$DRV_DESCRIPTION'"
    _debug  "DISK_NAME='$DISK_NAME' DISK_CATEGORY='$DISK_CATEGORY' DISK_DESCRIPTION='$DISK_DESCRIPTION'"
    test "$1" -a "$2" -a "$3" || return
 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
 #if a passed param $4, then _PROBEPART_ already known, inefficient to rerun here each time.

 DISK_NAME="$1"
 DISK_CATEGORY="$2"
 DISK_DESCRIPTION="$3"

 DISK_PARTITIONS="${DISK_NAME}|0|0"

 if [ "$ICONPARTITIONS" = "true" ];then
  #display an icon for each partition... w476 add ext4...
  [ "$4" = startup ] && { shift; true; } || _PROBEPART_=`probepart -k $NO_FLOPPY | grep -iEv "loop[0-9p]\||ram[0-9p]\||mtdblock[0-9p]\||nbd[0-9p]\||\|swap\||\|unknown\||\|extended\||ext'd.*\||\|none detected\||\|none\||\|skipped\|"`
  diskPATTERN='^/dev/'"${DISK_NAME}" #important, no space on end!
  DISK_PARTITIONS=`echo "$_PROBEPART_" | grep "$diskPATTERN" | cut -f 1,2,3 -d '|'`

  #w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update...
  diCNT=0
  if [ "`echo "$DISK_NAME" | grep -E '^sd|^mmc|^sr|^scd'`" ];then
   while [ "$DISK_PARTITIONS" = "" ];   # May be a Card reader without inserted card - difficult to detect
   do
    diCNT=$((diCNT+1))
    [ "$diCNT" -gt 13 ] && break ##+-=2013-07-07
    sleep 2  ##ZTE MODEM sr2 slow in updating values > increased count 3>13, sleep 1>2
    _PROBEPART_=`probepart -k $NO_FLOPPY | grep -iEv "loop[0-9p]\||ram[0-9p]\||mtdblock[0-9p]\||nbd[0-9p]\||\|swap\||\|unknown\||\|extended\||ext'd.*\||\|none detected\||\|none\||\|skipped\|"`
    DISK_PARTITIONS=`echo "$_PROBEPART_" | grep "$diskPATTERN" | cut -f 1,2,3 -d '|'`
    unset HAVE_PARTITION
    case $DISK_NAME in
    sd*)
    for p in 1 2 3 4; do
    test -e /sys/block/$DISK_NAME/${DISK_NAME}$p  && HAVE_PARTITION=1
    done
    [ "$HAVE_PARTITION" ] || break
    ;;
    mmc*)
    for p in 1 2 3 4; do
    test -e /sys/block/$DISK_NAME/${DISK_NAME}p$p && HAVE_PARTITION=1
    done
    [ "$HAVE_PARTITION" ] || break
    ;;
    sr*|scd*) break;; #:;;
    *)        break;; #:;;
    esac
   done
  fi
 _debug  "DISK_PARTITIONS=$DISK_PARTITIONS"
 fi

 oldIFS="$IFS"
 IFS=$'\n'
 for onePART in $DISK_PARTITIONS
 do
  _debugx "onePART='$onePART'"
  oneDRVNAME=`echo "$onePART" | cut -f 1 -d '|' | cut -f 3 -d '/'`
      FSTYPE=`echo "$onePART" | cut -f 2 -d '|'`
        SIZE=`echo "$onePART" | cut -f 3 -d '|'`
  partPATTERN='^/dev/'"${oneDRVNAME}"' ' #important, a space on end!
  if [ ! -d "$PUP_EVENT_DIR"/drive_${oneDRVNAME} ];then
      mkdir $VERB "$PUP_EVENT_DIR"/drive_${oneDRVNAME}
   cp $VERB -af /usr/local/bin/drive_all "$PUP_EVENT_DIR"/drive_${oneDRVNAME}/AppRun
   if [ -e /sys/block/${oneDRVNAME}/size ];then
    #device is an entire drive.
    read SIZE </sys/block/${oneDRVNAME}/size
    SIZE=$((SIZE/2)) #get KB.
    _format_size $SIZE #formats SIZE for display.
    dINFO="Description: ${DISK_DESCRIPTION} Size: ${SIZE}"
   elif [ "$FSTYPE" = "0" -a "$SIZE" = "0" ];then
     dINFO="Puppy drive manager"
   else
    _format_size $SIZE #formats SIZE for display.
    dINFO="Filesystem: $FSTYPE Size: $SIZE"
   fi
   #v424 add item to unmount all partitions... 2014-10-16 item for ro mount
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${oneDRVNAME} (if currently mounted)</Label></Item>
   <Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"

   case $FSTYPE in btrfs|ext[2-4]|f2fs|jfs|xfs|*reiser*|*fat*|ntfs)
   MOREITEMS="$MOREITEMS
   <Item option=\"mountro\" icon=\"gtk-harddisk\"><Label>Toggle Read-Only/Read-Write (re)mount of ${oneDRVNAME}</Label></Item>"
   ;;
   esac
   case $FSTYPE in btrfs|ext[2-4]|f2fs|jfs|xfs|*reiser*)
   MOREITEMS="$MOREITEMS
   <Item option=\"fsck_$FSTYPE\" icon=\"gtk-execute\"><Label>Fsck ${oneDRVNAME} (if not mounted)</Label></Item>"
   ;;
   esac

   _create_appinfo "$INFO" "$DISK_CATEGORY" "$MOREITEMS" "$oneDRVNAME" #needs dINFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
  fi

  if [ "$ICONDESK" = "true" ];then             #see "$CONFFILE".
   MNTSTATUS=`DEBUG='' /bin/df | grep -w "^/dev/$oneDRVNAME"`
   _debug  "MNTSTATUS='$MNTSTATUS' for partPATTERN='$partPATTERN'"

   if [ "$MNTSTATUS" ];then
    _icon_mounted   "$oneDRVNAME" "$DISK_CATEGORY"   #see functions4puppy4.
   else
    _icon_unmounted "$oneDRVNAME" "$DISK_CATEGORY"   #see functions4puppy4.
   fi

   _add_pinboard "$oneDRVNAME" "$DISK_CATEGORY" "$FSTYPE" #needs oneDRVNAME, DRV_CATEGORY, FSTYPE.

  else #for single universal icon
   _icon_unmounted drives any
   _add_pinboard "$oneDRVNAME" "$DISK_CATEGORY" "$FSTYPE" #needs oneDRVNAME, DRV_CATEGORY, FSTYPE. for single universal icon
  fi

  sleep 0.03
 done
 IFS="$oldIFS"

 #always create a handler for entire Drive and Partition1, even if no icon displayed...
 for aP in "" 1 2 3 4;
 do
 #if [ ! -d "$PUP_EVENT_DIR"/drive_${DISK_NAME}$aP ];then
     [ -d "$PUP_EVENT_DIR"/drive_${DISK_NAME}$aP ] && continue
  if [ -e /sys/block/${DISK_NAME}$aP/size ]; then

   read SIZE </sys/block/${DISK_NAME}$aP/size
   SIZE=$((SIZE/2))     #get KB.

  elif   [ -e /sys/block/${DISK_NAME}/${DISK_NAME}$aP/size ]; then
   read SIZE </sys/block/${DISK_NAME}/${DISK_NAME}$aP/size
   SIZE=$((SIZE/2))     #get KB.

  else _debugx "Kernel did not create ${DISK_NAME}$aP/size"; continue
  fi

   _format_size $SIZE #formats SIZE for display.

   mkdir $VERB -p "$PUP_EVENT_DIR"/drive_${DISK_NAME}$aP
   cp $VERB -af /usr/local/bin/drive_all "$PUP_EVENT_DIR"/drive_${DISK_NAME}$aP/AppRun

   dINFO="Description: ${DISK_DESCRIPTION} Size: ${SIZE}"
   #v424 add item to unmount all mounted partitions...
   MOREITEMS="<Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   oneDRVNAME="${DISK_NAME}$aP"
   _create_appinfo "$INFO" "$DISK_CATEGORY" "$MOREITEMS" "$oneDRVNAME" #needs dINFO, DRV_CATEGORY, MOREITEMS, oneDRVNAME
 #fi
 done
unset DISK_PARTITIONS diskPATTERN onePART MNTSTATUS
unset oneDRVNAME DISK_NAME DISK_CATEGORY partPATTERN FSTYPE dINFO SIZE MOREITEMS
}

_pup_event_startup(){
######################################################################
#stuff to setup at entry...

mkdir $VERB -p "$PUP_EVENT_DIR"
#build the desktop icons...
DISK_CATEGORY='drive'

##+++2013-07-07
ls -1v /sys/block | grep -vE '^loop|^md|^mtd|^nbd|^*ram' > /tmp/pup_event_frontend_block2
cp $VERB /tmp/pup_event_frontend_block2 /tmp/pup_event_frontend_block1
##+++2013-07-07
_PROBEDISK_=`probedisk2`

#v407 ls120/zip floppy drives are probed every 4 secs...
 DISK_FLOPPY=`echo "$_PROBEDISK_" | grep '|floppy|'  | cut -f 1 -d '|' | cut -f 3 -d '/'`
#v407 same thing for all optical drives...
DISK_OPTICAL=`echo "$_PROBEDISK_" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`

if [ "$ICONDESK" = "false" ]; then
 #only show a single 'drives' icon on desktop...
 DISK_NAME='drives'
 DISK_CATEGORY='any' #see pmount.
 DISK_DESCRIPTION="all drives"
 _create_icon "$DISK_NAME" "$DISK_CATEGORY" "$DISK_DESCRIPTION" #needs DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
else
 #show all drives on desktop... w476 add ext4...
  _PROBEPART_=`probepart -k $NO_FLOPPY | grep -viE "loop[0-9p]\||ram[0-9p]\||mtdblock[0-9p]\||nbd[0-9p]\||\|swap\||\|unknown\||\|extended\||ext'd.*\||\|none detected\||\|none\||\|skipped\|"`

 if [ "$FD0ICON" = "true" ]; then #see "$CONFFILE"
 :
 fi

 for oneDISK in `echo "$_PROBEDISK_"   | cut -f 1,2,3 -d '|' | tr ' ' '_'`
 do
  DISK_NAME=`echo -n "$oneDISK"        | cut -f 1 -d '|' | cut -f 3 -d '/'`
  DISK_CATEGORY=`echo -n "$oneDISK"    | cut -f 2 -d '|'`
  DISK_DESCRIPTION=`echo -n "$oneDISK" | cut -f 3 -d '|' | tr '_' ' '`
  _debug  "DISK_NAME=$DISK_NAME DISK_CATEGORY=$DISK_CATEGORY DISK_DESCRIPTION=$DISK_DESCRIPTION"
  [ "`echo "$_PROBEPART_" | grep "$DISK_NAME"`" ] || continue #precaution (such as CD not inserted).
  _debug  "'$DISK_NAME' in _PROBEDISK_ and _PROBEPART_"
  _create_icon "$DISK_NAME" "$DISK_CATEGORY" "$DISK_DESCRIPTION" startup #needs DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION, _PROBEPART_.
 sleep 0.3
 done

fi
}
_pup_event_startup


_stop_daemon_exit_on(){
if [ "$BACKENDON" = "false" ];then #see "$CONFFILE".
 killall hotplug2stdout >>$OUT 2>>$ERR #pup_event_backend_d #no module/firmware hotplug support.
 #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 [ "`pidof udevd`" ] && killall udevd >>$OUT 2>>$ERR
 [ "`pidof pup_event_backend_modprobe_protect`" ] && pup_event_backend_modprobe_protect --stop
 #exit ##+-2012-01-18
fi
#[ "$HOTPLUGON" = "false" ] && exit
#define EEXIST      17  /* File exists */
[ "$DESKDAEMON" = "false" ] && exit 17 #turn off all frontend hotplug support. see "$CONFFILE".
}
_stop_daemon_exit_on


LINEP=D005;echo "$0 line '`[ $LINENO ] && echo $LINENO || get_lineno $LINEP`' POWERTIMEOUT='$POWERTIMEOUT'"

_which_check_battery(){

_check_battery(){
     : #STUB
 }

if test "$BAT_0" = '1'; then
_check_battery(){

  BAT_0_CURRENT=`grep 'remaining capacity:' "$BAT_0_state_file"`
  BAT_0_CURRENT="${BAT_0_CURRENT//[^[:digit:]]/}"
    if [ $BAT_0_CURRENT -le $BAT_0_WARN ];then
    aplay /usr/share/audio/2barks.au;aplay /usr/share/audio/2barks.au
    pupmessage -bg red -timeout 30 "Battery State is: $BAT_0_CURRENT
better to plug in ac adapter or poweroff the laptop "
    fi #warn

 }
fi

}
_which_check_battery

_which_autounmount(){

_autounmount(){
     : #STUB
 }

if [ "$AUTOUNMOUNT" = "true" ]; then
_autounmount(){
  _auto_unmount
 }
fi

}
_which_autounmount

_which_powertimeout(){ #w007 power-off computer after inactivity.

_powertimeout(){
 :  #STUB if all of the below are disabled
 }

#if [ "$POWERTIMEOUT" != '0' -o "$AUTOUNMOUNT" = "true" -o "$BAT_0" = '1' ];then
if [ "$POWERTIMEOUT" != '0' ]; then
__powertimeout(){
   MINUTECNT=$((MINUTECNT + POLL_PLUG_DEVICE))
  [ $MINUTECNT -ge 60 ] || return 0 #come in here every minute...
    MINUTECNT=0
  # BATTERY
   if [ "$BAT_0" = '1' ];then
  BAT_0_CURRENT=`grep 'remaining capacity:' "$BAT_0_state_file"`
  BAT_0_CURRENT="${BAT_0_CURRENT//[^[:digit:]]/}"
    if [ $BAT_0_CURRENT -le $BAT_0_WARN ];then
    aplay /usr/share/audio/2barks.au;aplay /usr/share/audio/2barks.au
    pupmessage -bg red -timeout 30 "Battery State is: $BAT_0_CURRENT
better to plug in ac adapter or poweroff the laptop "
    fi #warn
   fi #bat
   # AUTOUNMOUNT
   #[ "$AUTOUNMOUNT" = "true" ] && _auto_unmount #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).
   # POWERTIMEOUT
   if [ "$POWERTIMEOUT" -gt '0' ];then
   MOUSECNT=$((MOUSECNT+60))
   CURPOS2=`getcurpos`
   #just a log file without any further purpose :
   [ "$CURPOS1" != "$CURPOS2" ] && MOUSECNT=0
   CURPOS1="$CURPOS2"
    #[ $MOUSECNT -gt $POWERTIMEOUT ] && wmpoweroff &
    if [ "$MOUSECNT" -gt $POWERTIMEOUT ];then
     aplay /usr/share/audio/2barks.au
     sleep 1
     aplay /usr/share/audio/2barks.au
     xmessage -title "FRONTEND_D POWERTIMEOUT" -timeout 60 -bg '#F213AD' -buttons "OK_poweroff :100, NO_KEEP_PUPPY_RUNNING:101" "Choosen POWERTIMEOUT reached of
     $((POWERTIMEOUT/60)) min .

If you think it is unapropriate , please go to
> Puppy Eventmanager
in the
> System Menu
and change this value .
"
      if [ "$?" -lt '101' ];then
      exec wmpoweroff &
      fi
    fi
   fi
 }

_powertimeout(){
   MINUTECNT=$((MINUTECNT + POLL_PLUG_DEVICE))
   [ $MINUTECNT -ge 60 ] || return 0 #come in here every minute...
   MINUTECNT=0
   if [ "$POWERTIMEOUT" -gt '0' ];then
   MOUSECNT=$((MOUSECNT+60))
   CURPOS2=`getcurpos`
   #just a log file without any further purpose :
   [ "$CURPOS1" != "$CURPOS2" ] && MOUSECNT=0
   CURPOS1="$CURPOS2"
    #[ $MOUSECNT -gt $POWERTIMEOUT ] && wmpoweroff &
    if [ "$MOUSECNT" -gt $POWERTIMEOUT ];then
     aplay /usr/share/audio/2barks.au
     sleep 1
     aplay /usr/share/audio/2barks.au
     xmessage -title "FRONTEND_D POWERTIMEOUT" -timeout 60 -bg '#F213AD' -buttons "OK_poweroff :100, NO_KEEP_PUPPY_RUNNING:101" "Choosen POWERTIMEOUT reached of
     $((POWERTIMEOUT/60)) min .

If you think it is unapropriate , please go to
> Puppy Eventmanager
in the
> System Menu
and change this value .
"
      if [ "$?" -lt '101' ];then
      exec wmpoweroff &
      fi
    fi
   fi
 }

fi
}
_which_powertimeout

_check_disturb_ps_grep(){ # 25-50% less CPU signature than pidof
local RUNPS=`ps -o comm`
echo "$RUNPS" | grep -vw 'grep' | grep $Q -E "$DO_NOT_DISTURB2"
}

_check_disturb_pidof(){ # same heavy as for pidof done
pidof $DO_NOT_DISTURB >$OUT
}

_check_disturb_for(){  # same heavy as pidof LONG_LINE
for a in $DO_NOT_DISTURB
do
pidof $a >$OUT && return 0
done
false
}

_check_disturb_ps_c(){  #heaviest
for a in $DO_NOT_DISTURB
do
/bin/ps --no-heading -C $a >$OUT && return 0
done
false
}

_which_check_video(){

_check_disturb_video(){
false
 }

if test "$DISTURB_VIDEO" = "true" ; then
_check_disturb_video(){
local RUNPS=`ps -o comm`
echo "$RUNPS" | grep -vw 'grep' | grep $Q -E "$DO_NOT_DISTURB_MM2"
 }
fi

}
_which_check_video

_check_restarts(){
if [ -f /tmp/pup_event_manager.flg ];then ###2012-01-18
 read sigNAL </tmp/pup_event_manager.flg
 rm $VERB /tmp/pup_event_manager.flg
 case $sigNAL in
 CONT) return 0;;
 STOP) while :
       do
       sleep $POLL_PLUG_DEVICE
       [ -f /tmp/pup_event_manager.flg ] && {
           read sigNAL2 </tmp/pup_event_manager.flg
           rm $VERB /tmp/pup_event_manager.flg
           case $sigNAL2 in CONT) break;; esac
       }
       done
 ;;

 WINCH|reload|*) . "$CONFFILE" ###2012-01-18
    _stop_daemon_exit_on
    _get_ram_power_vars
    _which_powertimeout
 ;;
 esac
 unset sigNAL sigNAL2
 if [ -f /tmp/pup_event_change_icons.flg ]; then  #KRG

    Floppies=`ls /sys/block | grep 'fd[0-9]\+' | sort -r`

    if [ -d /proc/ide ] ; then
    Drives=`ls /sys/block | grep -E '^sd|^hd|^sr|^scd|^mmc' | sort -r`
    else
    Drives=`ls /sys/block | grep -E '^sd|^hd|^sr|^scd|^mmc'`
    fi

    for DRV_NAME in $Drives drives; do
    _remove_pinboard "$DRV_NAME"
    done
    unset DRV_NAME
    for DRV_NAME in $Floppies; do
    _remove_pinboard "$DRV_NAME"
    done
    unset DRV_NAME

    _get_screen_vars
    _get_jwm_vars
    _get_rox_vars
    _get_max_xy
    _get_icon_xy_values
    _pup_event_startup
    sleep 1
    rm $VERB -f /tmp/pup_event_change_icons.flg

fi;fi
}

_pup_event_daemon(){
###################################################################
#now go into a two-second two-second loop...
while :
do
 sleep $POLL_PLUG_DEVICE

 #test for any change in /sys/block...
 ls -1 /sys/block | grep -vE '^loop|^md|^mtd|^nbd|^*ram' > /tmp/pup_event_frontend_block2
 if [ -f /tmp/pup_event_frontend_block_request ];then #w015 (see gparted_shell, puppyinstaller, bootflash)
  sleep 0.1
  REMOVEBLOCK='^'"`cat /tmp/pup_event_frontend_block_request`"'$'
  BLOCKS2=`grep -v "$REMOVEBLOCK" /tmp/pup_event_frontend_block2`
  echo "$BLOCKS2" > /tmp/pup_event_frontend_block2
  rm $VERB -f /tmp/pup_event_frontend_block_request
 fi

 BLOCKDIFF=`diff /tmp/pup_event_frontend_block1 /tmp/pup_event_frontend_block2`
 _debugx "BLOCKDIFF=$BLOCKDIFF"

 #091223 some interfaces, no change in /sys/block when insert/remove a card...
 #note, /proc/partitions can be very slow to update, particularly when remove a card.
 #note, /sys/block/sd*/sd* shows card insertion but may not update on removal -- /usr/local/bin/drive_all will remove an invalid drive icon if clicked on.
 if [ ! "$BLOCKDIFF" ];then
  #BLOCKSPROBE=""
  for oneTESTDRV in `grep -E '^sd|^mmc' /tmp/pup_event_frontend_block2` ##+-+2013-07-07
  do
   [ -d /sys/block/${oneTESTDRV} ] || continue
   [ -b /dev/$oneTESTDRV ]         || continue
   #[ "`echo "$ATADRIVES" | grep -w "$oneTESTDRV"`" ] && continue
    realpath /sys/block/${oneTESTDRV} | grep $Q 'usb' || continue
    grep $Q -w '0' /sys/block/${oneTESTDRV}/removable && continue

       #try force kernel to update:
       (true </dev/$oneTESTDRV) >>$OUT 2>>$ERR
   for p in 1 2 3 4; do #check all possible primary partitions, since at least one primary must exist
   if [ -e /sys/block/${oneTESTDRV}/${oneTESTDRV}$p ]; then #drive exists, but no partition (no card plugged in).
    [ -d "$PUP_EVENT_DIR"/drive_${oneTESTDRV}$p ] && HAVE_PARTITION=1 || BLOCKSPROBE="${BLOCKSPROBE}+${oneTESTDRV}:"
    #dd if=/dev/${oneTESTDRV} of=/dev/null bs=512 count=1 >>$OUT 2>>$ERR #try force kernel to update.
   elif [ -d "$PUP_EVENT_DIR"/drive_${oneTESTDRV}$p ]; then
    BLOCKSPROBE="${BLOCKSPROBE}-${oneTESTDRV}:"
   fi
   done
   if [ "$HAVE_PARTITION" ]; then
   unset BLOCKSPROBE HAVE_PARTITION
   fi

  done
  [ "$BLOCKSPROBE" ] && BLOCKDIFF=`echo "$BLOCKSPROBE" | tr ':' '\n' | sort -u` #sort sorts + above -
 fi

 _debugx "BLOCKDIFF='$BLOCKDIFF'"
 #########hotplug block event##########
 if [ "$BLOCKDIFF" ];then
 _notice "Got hotplug event.."
  cp $VERB -f /tmp/pup_event_frontend_block2 /tmp/pup_event_frontend_block1

   BLOCKSADD=`echo "$BLOCKDIFF" | grep -o '^\+[[:alnum:]]\+' | sed 's%^\+%%'`
   BLOCKSREM=`echo "$BLOCKDIFF" | grep -o '^\-[[:alnum:]]\+' | sed 's%^\-%%'`

   case $BLOCKSADD in
   ''|fd*) :;;
   *) NO_FLOPPY=--ignore-floppy;; # option for probepart in _create_icon()
   esac

   _PROBEDISK_=`probedisk2`
   DISK_OPTICAL=`echo "$_PROBEDISK_" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'` #update
    DISK_FLOPPY=`echo "$_PROBEDISK_" | grep '|floppy|'  | cut -f 1 -d '|' | cut -f 3 -d '/'` #update

  for oneDISK_NAME in $BLOCKSADD
  do
   [ -e /sys/block/$oneDISK_NAME ] || continue #precaution
   odPATTERN='^/dev/'"$oneDISK_NAME"'|'
   IFS='|' read DISK_NAME DISK_CATEGORY DISK_DESCRIPTION DISK_SIZE PARTS <<_EOI
$(echo "$_PROBEDISK_" | grep "$odPATTERN")
_EOI
   DISK_NAME="${DISK_NAME##*/}"
   [ "$DISK_NAME" ] || continue
   [ "$ICONDESK" = "true" ]     && _create_icon "$DISK_NAME" "$DISK_CATEGORY" "$DISK_DESCRIPTION"  #uses DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
   #[ "$HOTPLUGNOISY" = "true" ] && "$PUP_EVENT_DIR"/drive_${DISK_NAME}/AppRun ${DISK_CATEGORY} &  #handler script.
  done

  for oneDISK_NAME in $BLOCKSREM
  do
   if [ "`pidof gtkdialog_pmount`" ];then #if pmount running, refresh it.
    killall gtkdialog_pmount >>$OUT 2>>$ERR
    sleep 0.1
    LANG=$OLDLANG pmount & #100613 fix from shinobar.
   fi
   _remove_pinboard "$oneDISK_NAME"   #needs DRV_NAME
   rm $VERB -rf "$PUP_EVENT_DIR"/drive_${oneDISK_NAME}*
  done

 fi

 unset NO_FLOPPY oneDISK_NAME DISK_NAME DISK_CATEGORY DISK_DESCRIPTION
 unset BLOCKDIFF BLOCKSPROBE REMOVEBLOCK BLOCKS2 BLOCKSADD BLOCKSREM _PROBEDISK_

 #monitor free memory, periodic save of tmpfs top layer...
 case $PUPMODE in
  3|7|13)  #flash
     _free_flash;;
  5|16|24|17|25) #unipup. 2015-10-14 testing PUPMODE 5 set here
     _free_initrd;;
  *) #2|5 6|12 #normal harddrive
     _free;;
 esac

_check_restarts
_check_battery

__poll_cd_fd__(){ # since driveicons stay on desktop, only usefull for AUTOHANDLER
                  # on desktops that do not support rox pinboard (e17)
if [ "$ZCDPOLL" != "false" ];then
 #unfortunately, we have to poll at regular intervals to see if a cd is inserted...
 for oneOPTICAL in $DISK_OPTICAL
 do
  [ "$oneOPTICAL" ] || continue #precaution
  _probe_optical $oneOPTICAL
 done
 #v407 poll to see if a ls120 or zip floppy diskette inserted...
 for oneFLOPPY in $DISK_FLOPPY
 do
  [ "$oneFLOPPY" ] || continue #precaution
  _probe_floppy $oneFLOPPY
 done
fi
}

#_autounmount

[ "$1" ] && { echo "$0:$$: daemon started ."; shift; }

 #some apps should not be disturbed by this background stuff...
 # pidof is much much more heavy on CPU in xosview, than ps, echo | grep ..
 _check_disturb_ps_grep && continue

 case $PUPMODE in 3|7|13)
   [ "$RAMSAVEINTERVAL" -ge 1 -o -f /tmp/snapmergepuppyrequest ] && _savepuppy
   ;;
 esac

 _check_disturb_video && continue
 _powertimeout

done #2*2 second loop.
}
_pup_event_daemon start
RV="$?"
echo "$0 stopped with exitcode '$RV'"
exit "$RV"
###END###
