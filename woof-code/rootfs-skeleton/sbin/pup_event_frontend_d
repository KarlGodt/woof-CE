#!/bin/ash
#(c) Copyright 2008 Barry Kauler puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#this is /sbin/pup_event_frontend_d, created June 2008 for Puppy Linux 4.x, by Barry Kauler.
#This script is part of 'pup_event', my (once) (very) light-weight alternative to udev.
#(was) responds to events posted to /tmp/pup_event_backend_s by /sbin/pup_event_backend_d.
#this script is launched from /root/.xinitrc.
#v407 added hotplug support for zip and ls120 diskettes.
#v407 hotplug fix for /dev/hd* optical drives.
#v408 fix for k2.6.21.7, does not set DEVTYPE.
#v408 rewrite, now works by polling /sys/block.
#v410 rerwin: detect optical disc not inserted.
#v410 avoid exact overlapping icons.
#v411 rerwin: avoid icon getting duplicated if it is renamed
#v412 workaround, someone had RAMSAVEINTERVAL not set.
#w004 LANG=C, faster. /bin/ash, even faster.
#w007 mouse inactivity computer power-down.
#w015 handle request to update one drives icons.
#w471 fix for slow rox startup on slow cpus.
#w476 add support for ext4 f.s.
#w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update.
#v424 add right-click menu item to unmount all mounted partitions.
#v424 experimental automatic unmounting.
#v431 shinobar: fix for overlapping icons at some screen resolutions.

########################################################################
#
# CHANGES by Karl Reimer Godt
# 01.0 : added stop|start|restart parameter ( still to observe )
# 02.0 :
# 03.0 : probepart_func
# 04.0 : added support for not need doing /usr/bin/restartwm
#        if /tmp/pup_event_icon_change_flag == ICONWIPE
#        restartwm actually does
#               #/sbin/pup_event_frontend_d will quit if this file exists...
#                echo -n "$NEXTWM" > /tmp/wmexitmode.txt
#        and sleeps up to 30 sec if still ps -C pup_event_frontend_d
#                kill `pidof xfce4-panel`
#                kill -9 `pidof $PREVIOUSWM`
#                exec killall -9 X
#        AND relies xwin reading /tmp/wmexitmode.txt to restart xwin
#   .1 : changed if /tmp/wmexitmode.txt break to exit to look if that cures
#        the <defunct> in ps -C pup_event_frontend_d
#        and the [pup_event_front] in ps appearence
#
# /dev/hda8:
# LABEL="MacPup431_O2"
# UUID="6d9a8e91-c301-4ff8-9875-97ec708cbee8"
# TYPE="ext3"
# DISTRO_NAME='Puppy'
# DISTRO_VERSION=431
# DISTRO_BINARY_COMPAT='puppy'
# DISTRO_FILE_PREFIX='pup'
# DISTRO_COMPAT_VERSION='4'
# PUPMODE=2
# KERNVER=2.6.37.4-KRG-i486-StagingDrivers-2
# PUP_HOME='/'
# SATADRIVES='·'
# USBDRIVES='·sda·'
# Linux·puppypc·2.6.37.4-KRG-i486-StagingDrivers-2·#4·SMP·Thu·Mar·17·06:05:58·GMT-8·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xorg
# $LANG=de_DE@euro
# today=Fr·28.·Okt·11:55:04·GMT-1·2011
# TODO1: remove the kill functions , evtl clean the code
#
#
#
#
########################################################################
PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11R7/bin"
test -s /etc/rc.d/f4puppy5 && . /etc/rc.d/f4puppy5
# BATCHMARKER01 - Marker for Line-Position to bulk insert code into.

VERSION=1.2.1

PROG='/sbin/pup_event_frontend_d'  # used in POWERTIMEOUT xmessage
#sleep 2s # done further down
PIDPROG=$$
_debug PIDPROG=$PIDPROG

DISP=${DISPLAY%.*}
_debug DISPLAY=$DISPLAY
_debug DISP=$DISP

trap "rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"; exit" INT QUIT ABRT KILL TERM

CASEPARAM="$1"
[ -z "$1" ] && CASEPARAM="start"
case "$CASEPARAM" in
*start|*stop|*restart|*help) :;;
*) exit 1;;
esac
_debug "$CASEPARAM"

_usage(){
MSG="
$MY_SELF [ start|stop|restart ]

Script that creates drive icons on desktop
if supported desktop manager is running.
Currently supported desktop manager(s) : ROX-Filer .
If enabled as daemon, polls /sys/block for changes
if hotplug drives are inserted and removed
like USB Pendrives, ZIP-Floppy drives, CD-ROM drives.

Options:
start   : starts this program
stop    : stops this program
restart : restarts this program if already running
"
MSG=`gettext "$MSG"`
echo "$MSG"
exit $?
}


case "$CASEPARAM" in
*help) _usage 0;;
*stop)

kill_func(){ # unused

##PP1=$(( $PIDPROG + 1 ))
PM1=$(( PIDPROG - 1 ))
##PIDS=`echo -e $PIDPROG"\n"$PP1"\n"$PM1`
PIDS=`echo -e $PIDPROG"\n"$PM1`
_debug "$PIDS"

_debugx "`ps`"
PSP=`pidof pup_event_frontend_d | tr ' ' '\n' | /bin/grep -v "$PIDS" | sort -n | tr '\n' ' '`
_debug "PSP=$PSP"
_debugx "`ps`"
for i in $PSP ; do
echo "$i " `ps | sed 's#^\ *##g' | grep "^$i"`
sleep 2
[ -n "`ps | sed 's#^\ *##g' | grep "^$i"`" ] && kill $i  ###s>/dev/null
sleep 2
done
}

echo 'pup_event_frontend_d stop' > /tmp/wmexitmode.txt
echo 'pup_event_frontend_d stop' > /tmp/xwin/wmexitmode."$DISP"
###+++2011-11-12
echo "$0 : Countdown for $CASEPARAM"
for n in `seq 9 -1 1` ; do
echo -n "$n "
sleep 1s
done
echo
###+++2011-11-12

rm $VERB -f /tmp/wmexitmode.txt
rm $VERB -f /tmp/xwin/wmexitmode."$DISP"
rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
exit
;;
*restart)

echo 'pup_event_frontend_d stop' > /tmp/wmexitmode.txt
echo 'pup_event_frontend_d stop' > /tmp/xwin/wmexitmode."$DISP"
###+++2011-11-12
#sleep 9s
echo "$0 : Countdown for $CASEPARAM"
for n in `seq 9 -1 1` ; do
echo -n "$n "
sleep 1s
done
echo
###+++2011-11-12

rm $VERB -f /tmp/wmexitmode.txt
rm $VERB -f /tmp/xwin/wmexitmode."$DISP"
rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
exec pup_event_frontend_d &

exit
;;
*start) :;;
*) _warn "TODO: Unhandled option '$CASEPARAM'"; exit 3;;
esac

if test -s /var/run/pup_event_frontend_d.pid."$DISP"; then
read PUPPID </var/run/pup_event_frontend_d.pid."$DISP"
echo "$0: Already running as process nr. '$PUPPID' ."
exit 2
fi

[ "$DISPLAY" ] || _exit 2 "Need X running in current vt." #X not running.
export LANG=C #w004

echo $PIDPROG >/var/run/pup_event_frontend_d.pid."$DISP"

#v408 when testing k2.6.21.7, no DEVTYPE, had to modify udev rules which causes udevd to
#do multiple overlapping writes to /tmp/pup_event_backend_s. Even with 2.6.25.x, plugging
#in two USB drives at once can cause this. So, dropping that, going back to primitive,
#simple polling loop.

sleep 2 #let the dust settle after X has started.
#w471 slow cpus need more delay (well, rox does)...
DELAYFACTOR=0
CPUMHZ=`grep -m 1 -i '^cpu MHz' /proc/cpuinfo | tr -d ' ' | cut -f 2 -d ':' | cut -f 1 -d '.'`
[ "$CPUMHZ" ] && [ "$CPUMHZ" -gt 100 ] && DELAYFACTOR=$(( 1100 / CPUMHZ ))
sleep $DELAYFACTOR

echo "$0 $CASEPARAM"  ##+++2011-11-12

#v404 /usr/sbin/video-wizard (Xvesa) does create /tmp/pup_event_icon_change_flag
#which /sbin/clean_desk_icons reads via .xinirc when X starts, to wipe all drive icons.
#however I think it would be good to test here also if X mode not yet settled on...
if [ -f /tmp/videomode ];then #only exists during X resolution setup.
 if [ "`readlink /usr/bin/X`" = "Xvesa" ];then
  while [ -f /tmp/videomode ];do
   sleep 1
  done
 else true
 fi
else true
fi

. /etc/rc.d/functions4puppy4

_get_pupstate_vars(){
ZDRV='';ZDRVINIT='no' #these usually set in PUPSTATE.
. /etc/rc.d/PUPSTATE
KERNVER=${KERNVER:-`uname -r`}
SIZE_MODS_M=0
if [ "$ZDRVINIT" = "yes" ];then
 #all mods were in initrd at bootup, then moved to main f.s.
 SIZE_MODS_M=`du -m -s /lib/modules | cut -f 1` # du and bb du use TAB as delimiter
else true
fi
}
_get_pupstate_vars

eventmanager_func(){
if test -s /etc/eventmanager."$DISP".conf; then
. /etc/eventmanager."$DISP".conf
else
. /etc/eventmanager #has RAMSAVEINTERVAL, ICONDESK, HOTPLUGNOISY, ICONPARTITIONS, BACKENDON, POWERTIMEOUT
fi

RAMSAVEINTERVAL=${RAMSAVEINTERVAL:-30} #412 minutes
RAMSAVEINTERVAL=$(( RAMSAVEINTERVAL * 60 )) #convert minutes to seconds.

POWERTIMEOUT=${POWERTIMEOUT:-0} #w007
POWERTIMEOUT=$(( POWERTIMEOUT * 60 )) #convert minutes to seconds.

_notice "POWERTIMEOUT='$POWERTIMEOUT'"
_info "ICON_PLACE_SPACING='$ICON_PLACE_SPACING'"
return 0
}
eventmanager_func


#v424 experiment, automatic unmounting...
auto_unmount_func() {
local STATUS=0
 for oneMNTPT in `grep '^/dev/' /proc/mounts | grep -vE '/loop|/ram' | cut -f 2 -d ' ' | grep -vE '^/initrd/|^/$'`
 do
  if [ "`fuser -v -m $oneMNTPT`" = "" ];then
   _sync
   _info "Attempt to unmount '$oneMNTPT' .."
   /bin/umount $VERB "$oneMNTPT" ; umVAL=$?
   #code from pmount: fix zombie process prevents partition unmount, invisible to fuser...
   if [ "$umVAL" -ne 0 ];then
    _killzombies # f4puppy5
    /bin/umount $VERB "$oneMNTPT"
   else true
   fi
   STATUS=$((STATUS+$?))
  else
   _info "Mountpoint '$oneMNTPT' in use."
  fi
 done
return $STATUS
}

format_size_func() {
local sizeLOCAL SIZE1 SIZE2
_debugx "format_size_func Begin" #DBG
    sizeLOCAL=$1
    sizeLOCAL=${sizeLOCAL:-"$SIZE"}
    sizeLOCAL=${sizeLOCAL:-0}

 if [ "$sizeLOCAL" -gt 1048576 ];then #1024*1024
  sizeLOCAL=`dc $sizeLOCAL 1048576 \/ p`
  sizeLOCAL=`echo $sizeLOCAL | tr ',' '.'`
  SIZE1=`echo $sizeLOCAL | cut -f 1 -d '.'`
  SIZE2=`echo $sizeLOCAL | cut -f 2 -d '.'`
  SIZE2=`echo $SIZE2 | sed -r 's/(.)/\1 /g`
  SIZE2=`echo "$SIZE2" | cut -f 1 -d ' '`
  SIZE="`printf "%s"','"%s" $SIZE1 $SIZE2`GB"
  #SIZE=`echo "scale=0; $SIZE * 1" | bc`
 elif [ "$SIZE" -gt 99 ];then
   SIZE="$((sizeLOCAL / 1024))MB"
 else
   SIZE1=`dc $sizeLOCAL 1024 \/ p`
   SIZE2=`echo $SIZE1 | tr ',' '.'`
   SIZE1=`echo $SIZE2 | cut -f 1 -d '.'`
   SIZE2=`echo $SIZE1 | cut -f 2 -d '.'`
   SIZE2=`echo $SIZE2 | sed -r 's/(.)/\1 /g`
   SIZE2=`echo "$SIZE2" | cut -f 1 -d ' '`
   SIZE="`printf "%s"','"%s" $SIZE1 $SIZE2`GB"
   #SIZE="`printf "%.1f" $SIZE`MB"
 fi
 case "$SIZE" in 0.0MB|0,0MB) SIZE="0";; esac
_debugx "format_size_func End" #DBG
test "$SIZE" # global variable
}

pingridstep_func(){
PIN_GRID_STEP=`grep "pinboard_grid_step" $HOME/.config/rox.sourceforge.net/ROX-Filer/Options | sed -e "s/ *<[^>]*>//g"`
[ -z "$PIN_GRID_STEP" ]    && PIN_GRID_STEP=16
[ "$PIN_GRID_STEP" -ge 0 ] || PIN_GRID_STEP=16
PIN_GRID_STEP=$(( ( PIN_GRID_STEP + 1 ) / 2 * 2 )) ##case 1,3,5....
return $PIN_GRID_STEP
}

jwm_taskbar_func() {
local DEBUG=${DEBUG:-1}
pingridstep_func
case $PIN_GRID_STEP in
2)
 read CWM </etc/windowmanager."$DISP"
 case "$CWM" in *jwm*)
  JwmL=`grep -E -i 'Tray | autohide | insert | x | y | insert' "$HOME"/.jwmrc-tray`
  Position=`echo $JwmL | grep -o 'y=.*$' | cut -f 1 -d ' ' |  cut -f 2 -d '"'`
  if [ "$Position" = "-1" ] ; then ## -1=BOTTOM ; 0=TOP
   #Height=`echo $JwmL | grep -o 'height=.*$' | tr -d ' ' | tr -d '>'`
   #HEIGHT=`echo $Height | cut -f2 -d '"'`
   HEIGHT=`echo $JwmL | grep -o 'height=.*$' | tr -d ' ' | cut -f 2 -d '"'`
   case "$HEIGHT" in "20") JPV_Y=-8;;   ## 748
   "28") JPV_Y=1 ;;   ##                   740 top of bottom panel
   "34") JPV_Y=8 ;;   ## getcurpos :       724 16
   "42") JPV_Y=16;;   ##                   716 24
   *)    JPV_Y=1 ;;
   esac
  elif [ "$Position" = "0" ] ; then ## -1=BOTTOM ; 0=TOP
   HEIGHT=`echo $JwmL | grep -o 'height=.*$' | tr -d ' ' | cut -f 2 -d '"'`
   case "$HEIGHT" in "20") JPV_Y=-8;;   ## 748
   "28") JPV_Y=1 ;;   ##                   740 top of bottom panel
   "34") JPV_Y=8 ;;   ## getcurpos :       724 16
   "42") JPV_Y=16;;   ##                   716 24
   *)    JPV_Y=1 ;;
   esac
 else true
 fi
 ;;
 esac
;;
esac
[ -n "$JPV_Y" ] || JPV_Y=2
#JPV_Y=$(( ( (JPV_Y + PIN_GRID_STEP) * PIN_GRID_STEP ) / PIN_GRID_STEP))
_debug "JPV_Y='$JPV_Y'"
}
jwm_taskbar_func #KRG to get variables

screen_start_func() {
SCRNXY="`xwininfo -root | grep -o '\-geometry .*' | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '+'`"
SCRN_X=`echo -n "$SCRNXY" | cut -f 1 -d 'x'` # =${SCRNXY%%x*}
SCRN_Y=`echo -n "$SCRNXY" | cut -f 2 -d 'x'` # =${SCRNXY#*x}
V_Y_S=64
V_X_S=32
Lines_Y=1
COORD_X=$ICON_PLACE_START_GAP
MAX_X=$(( SCRN_X - V_X_S ))
MAX_X_shift=$(( MAX_X - 32 ))
V_X_add=$(( V_X_S * 2 ))
}
screen_start_func

__grep_panel_func__() {  # used in add_pinboard_func, grep now done in jwm_taskbar_func
_debug "grep_panel_func start" #DBG
#CWM=`cat /etc/windowmanager`
#qaz(){ if [ "$CWM" = "jwm" ]; then
#JwmL=`grep -E -i 'Tray | autohide | insert | x | y | insert' "$HOME"/.jwmrc-tray`
#Height=`echo $JwmL | grep -o 'height=.*$' | tr -d ' ' | tr -d '>'`
#HEIGHT=`echo $Height | cut -f2 -d '"'`
#[ "$HEIGHT" = "20" ] && JPV_Y=-8   ##          748
#[ "$HEIGHT" = "28" ] && JPV_Y=0  ##            740 top of bottom panel
#[ "$HEIGHT" = "34" ] && JPV_Y=8   ## getcurpos :724 16
#[ "$HEIGHT" = "42" ] && JPV_Y=16   ##          716 24
#fi }

V_Y=$(( V_Y_S + JPV_Y ))
_debug V_Y=$V_Y #DBG
v_y=$(( Lines_Y - 1 ))
_debug v_y=$v_y #DBG
v_y_panel=$(( v_y * JPV_Y ))
_debug v_y_panel=$v_y_panel #DBG
_debug "grep_panel_func end" #DBG
#fi
}

__free_coord__() {

 #[ "$Lines" -eq 1 ] && __grep_panel_func__
 #find a free place on desktop. v410 avoid exact overlapping icons...
 COORDSGRID=`grep -o ' x="[0-9]*" y="[0-9]*" ' "$HOME"/Choices/ROX-Filer/PuppyPin | sed 's/[0-9]"/"/g'`
 _debugx Lines_Y=$Lines_Y #DBG
 _debugx COORD_X=$COORD_X #DBG
 Line_Y=$(( V_Y * Lines_Y ))
 _debugx Line_Y=$Line_Y #DBG
 Line_Y=$(( Line_Y - v_y_panel ))
 _debugx Line_Y=$Line_Y #DBG
 COORD_Y=$(( SCRN_Y - Line_Y ))
 _debugx COORD_Y=$COORD_Y #DBG
 #MAX_X=`expr $SCRN_X - $V_X_S`
 xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
 _debug "$xPATTERN"
 while :;do
  xgPATTERN=`echo -n "$xPATTERN" |  sed 's/[0-9]"/"/g'`
  _debug "$xgPATTERN" #DBG
  [ "`echo "$COORDSGRID" | grep "$xgPATTERN"`" ] || { echo "DBG: breaking now"; break; }
  COORD_X=$(( COORD_X + V_X_add ))
  _debug COORD_X=$COORD_X #DBG
  #[ $COORD_X -gt $MAX_X ] && break
  if [ $COORD_X -gt $MAX_X ]; then
  _debugx COORD_X=$COORD_X MAX_X=$MAX_X #DBG
  Lines_Y=$(( Lines_Y + 1 ))
  _debugx Lines_Y=$Lines_Y #DBG
  Line_Y=$(( V_Y * Lines_Y ))
  _debugx Line_Y=$Line_Y #DBG
  COORD_Y=$(( SCRN_Y - Line_Y ))
  _debugx COORD_Y=$COORD_Y #DBG
  COORD_X=$V_X_S
  else true
  fi
  xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
 done
}
#v431 shinobar: fix for overlapping icons at some screen resolutions...

_free_coord_x(){
 COORD_Y=$(( (( COORD_Y $ADD PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
 COORD_X=$ICON_PLACE_START_GAP
 MAX_X=$(( SCRN_X - 96 ))
 xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
 _debug "COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
 _debug "xPATTERN='$xPATTERN'"

 while :;do
  xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"/"/g'`
  #xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"//g'`
  _debug "xgPATTERN='$xgPATTERN'"
  echo "$COORDSGRID" | grep $Q "$xgPATTERN" || break
  COORD_X=$(( COORD_X + ICON_PLACE_SPACING + PIN_GRID_STEP ))
  ##xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
  if [ "$COORD_X" -gt "$MAX_X" ] ; then
  COORD_Y=$(( COORD_Y $ADD PIN_GRID_STEP $ADD ICON_PLACE_SPACING )) ##64 is devideable 32 16 2
  COORD_X=$ICON_PLACE_START_GAP
  else true
  fi
  xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
  _debug "xPATTERN='$xPATTERN'"
 done
}

_free_coord_y(){
 COORD_X=$(( (( COORD_X $ADD PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
 COORD_Y=$ICON_PLACE_START_GAP
 MAX_Y=$(( SCRN_Y - 96 ))
 xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
 _debug "COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
 _debug "xPATTERN='$xPATTERN'"

 while :;do
  xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"/"/g'`
  #xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"//g'`
  _debug "xgPATTERN='$xgPATTERN'"
  echo "$COORDSGRID" | grep $Q "$xgPATTERN" || break
  COORD_Y=$(( COORD_Y + ICON_PLACE_SPACING + PIN_GRID_STEP ))
  ##xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
  if [ "$COORD_Y" -gt "$MAX_Y" ] ; then
  COORD_X=$(( COORD_X $ADD PIN_GRID_STEP $ADD ICON_PLACE_SPACING )) ##64 is devideable 32 16 2
  COORD_Y=$ICON_PLACE_START_GAP
  else true
  fi
  xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
  _debug "xPATTERN='$xPATTERN'"
 done
}

_free_coord_bottom(){
COORD_Y=$(( SCRN_Y - JPV_Y - 64 ))
#COORD_Y=$(( (( COORD_Y - PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
ADD='-'
_free_coord_x
}

_free_coord_top(){
COORD_Y=$(( 0 + JPV_Y + 32 ))
#COORD_Y=$(( (( COORD_Y + PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
ADD='+'
_free_coord_x
}

_free_coord_right(){
COORD_X=$(( SCRN_X - 32 ))
#COORD_X=$(( (( COORD_X - PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
ADD='-'
_free_coord_y
}

_free_coord_left(){
COORD_X=$(( 0 + 32 ))
#COORD_X=$(( (( COORD_X + PIN_GRID_STEP ) / PIN_GRID_STEP) * PIN_GRID_STEP ))
ADD='+'
_free_coord_y
}

free_coord() {
local DEBUG=${DEBUG:-1}
#find a free place on desktop. v410 avoid exact overlapping icons...
 COORDSGRID=`grep -o ' x="[0-9]*" y="[0-9]*" ' "$HOME"/Choices/ROX-Filer/PuppyPin | sed 's/[0-9]"/"/g'`
_debug "
$COORDSGRID"
_debug "shinos pingrid='$PIN_GRID_STEP'"

 case $ICON_PLACE_ORIENTATION in
 bottom)  _free_coord_bottom;;
 top)     _free_coord_top;;
 right)   _free_coord_right;;
 left)    _free_coord_left;;
 esac
 # import from v4.20p1JP 5Jun09, 18aug09 by Masaki Shinomiya : snap on the grid

# _debug "shinos pingrid='$PIN_GRID_STEP'"

# #if [ "$PIN_GRID_STEP" ] && [ $PIN_GRID_STEP -gt 0 ];then
#   # PIN_GRID_STEP2=$(( $PIN_GRID_STEP / 2 ))
#   #COORD_Y=`expr \( $COORD_Y + $PIN_GRID_STEP2 \) / $PIN_GRID_STEP '*'  $PIN_GRID_STEP`
# #fi
# ##[ -z "$JPV_Y" ] && JPV_Y=1

# #COORD_Y=$(( (( COORD_Y + PIN_GRID_STEP ) * PIN_GRID_STEP) / PIN_GRID_STEP ))
# COORD_X=$ICON_PLACE_START_GAP
# MAX_X=$(( SCRN_X - 96 ))
# xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
# _debug "COORD_X='$COORD_X' COORD_Y='$COORD_Y'"
# _debug "xPATTERN='$xPATTERN'"

# while :;do
#  xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"/"/g'`
#  #xgPATTERN=`echo "$xPATTERN" | sed 's/[0-9]"//g'`
#  _debug "xgPATTERN='$xgPATTERN'"
#  echo "$COORDSGRID" | grep $Q "$xgPATTERN" || break
#  COORD_X=$(( COORD_X + ICON_PLACE_SPACING + PIN_GRID_STEP ))
#  ##xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
#  if [ "$COORD_X" -gt "$MAX_X" ] ; then
#  COORD_Y=$(( COORD_Y - PIN_GRID_STEP - ICON_PLACE_SPACING )) ##64 is devideable 32 16 2
#  COORD_X=$ICON_PLACE_START_GAP
#  else true
#  fi
#  xPATTERN=" x=\"${COORD_X}\" y=\"${COORD_Y}\" "
#  _debug "xPATTERN='$xPATTERN'"
# done

}



add_pinboard_func() { #needs ONEDRVNAME, DRV_CATEGORY, FSTYPE
local DEBUG=${DEBUG:-1}
_debug "add_pinboard_func:$*"

 local partNAME diskCATEGORY partFS
 partNAME=$1
 diskCATEGORY=$2
 partFS=$3
 partNAME=${partNAME:-"$ONEDRVNAME"}
 diskCATEGORY=${diskCATEGORY:-"$DRV_CATEGORY"}
 partFS=${partFS:-"$FSTYPE"}

 #ppPATTERN=' label="'"$ONEDRVNAME"'"'
 #v411 rerwin: avoid icon getting duplicated if it is renamed...
 _debug "add_pinboard_func begin"
 _debugx Lines_Y=$Lines_Y #DBG

 #if [ "$Lines_Y" -eq 1 ]; then
 __grep_panel_func__
 #else
 #V_Y=$V_Y_S
 #fi
 _debugx V_Y=$V_Y #DBG

 ppPATTERN=""$HOME"/.pup_event/drive_${partNAME}<"
 grep $Q "$ppPATTERN" "$HOME"/Choices/ROX-Filer/PuppyPin && return 1 #precaution already listed

 free_coord

 case $CWM in enlightenment*) return 0;; esac

 _debug "X=${COORD_X} Y=${COORD_Y} for PinBoard for $partNAME"

 echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardAdd>
   <Path>$HOME/.pup_event/drive_${partNAME}</Path>
   <X>${COORD_X}</X>
   <Y>${COORD_Y}</Y>
   <Label>${partNAME}</Label>
   <Args>${diskCATEGORY} ${partFS}</Args>
  </PinboardAdd>
 </env:Body>
</env:Envelope>"  | rox -R

_debug $COORD_X $MAX_X $MAX_X_shift #DBG
if [ "$COORD_X" -gt $MAX_X_shift -a "$Lines_Y" -eq 1 ]; then
 _debugx COORD_X=$COORD_X MAX_X=$MAX_X #DBG
 Lines_Y=$(( Lines_Y + 1 ))
 COORD_X=32
else true
fi
_debug Lines_Y=$Lines_Y #DBG
_debug "add_pinboard_func end" #DBG
}

create_icon_func() {
local DEBUG=${DEBUG:-1}
 _debug "create_icon_func:$*"

 #create desktop icon, and directory with handler script, icon and help...
 #requires global variables DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
 #if a passed param $1, then PROBEPART already known, inefficient to rerun here each time.
 local startUP diskNAME DRV_INFO oneDRVINFO
 case $1 in startup) shift;;
 *) probepart_func;;
 esac
 diskNAME=$1
 diskNAME=${diskNAME:-"$DRV_NAME"}
 DRV_INFO="$diskNAME"'|0|0'
 if [ "$ICONPARTITIONS" = "true" ]; then
  #display an icon for each partition... w476 add ext4...
#  [ "$startUP" = "startup" ] || probepart_func
  drvPATTERN='^/dev/'"${diskNAME}" #important, no space on end!
  DRV_INFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|'`

  #w482 k2.6.25.16 /proc/partitions (read by probepart) can be slow to update...
  diCNT=0
  if [ "`echo -n "$diskNAME" | grep -E '^sd|^mmc'`" ]; then
   until [ "$DRV_INFO" ]; do
    diCNT=$(( diCNT + 1 ))
    [ $diCNT -gt 3 ] && break
    sleep 1
    probepart_func
    DRV_INFO=`echo "$PROBEPART" | grep "$drvPATTERN" | cut -f 1,2,3 -d '|' | tr '\n' ' '`
   done
  else true
  fi
  _info "DRV_INFO='$DRV_INFO'"

 else true
 fi

 for oneDRV_INFO in $DRV_INFO
 do
  _debug "oneDRV_INFO='$oneDRV_INFO'"
  read -r partNAME partFS partSIZE <<EOI
$(echo "$oneDRV_INFO" | tr ' ' '_' | tr '|' ' ')
EOI
   partNAME=${partNAME##*/}
   [ "$partNAME" ] || continue
   _debug "partNAME='$partNAME'"
  if [ ! -d "$HOME"/.pup_event/drive_${partNAME} ]; then
   mkdir $VERB "$HOME"/.pup_event/drive_${partNAME}
   cp $VERB -af /usr/local/bin/drive_all "$HOME"/.pup_event/drive_${partNAME}/AppRun
   if [ -e /sys/block/${partNAME} ]; then
    read SIZE </sys/block/${partNAME}/size || continue
    SIZE=$((SIZE/2)) #get KB.
    format_size_func $SIZE #formats SIZE for display.
    dINFO="Description: ${DRV_DESCRIPTION} Size: ${SIZE}"
   elif [ "$partFS" = "0" -a "$SIZE" = "0" ];then
     dINFO="Puppy drive manager"
   else
     format_size_func $partSIZE #formats SIZE for display.
     dINFO="Filesystem: $partFS Size: $SIZE"
   fi
   #v424 add item to unmount all partitions...
   MOREITEMS="<Item option=\"unmount\" icon=\"gtk-harddisk\"><Label>Unmount ${partNAME} (if currently mounted)</Label></Item>
   <Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   create_appinfo_func $partNAME $diskCATEGORY "$dINFO" "$MOREITEMS"  #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
  else true
  fi
   drvPATTERN='^/dev/'"${partNAME}"' ' #important, a space on end!
   MNTSTATUS=`/bin/df | grep "$drvPATTERN"`

   if test -L /dev/root; then
    if test "`/bin/df | grep -m1 -Fw '/' | grep -v '^/dev/root'`"; then
    rootdrv=`ls -l /dev/root | grep -o '\->.*' | cut -f 2 -d ' '`
     if test "${rootdrv:0:5}" = "$partNAME" ; then
      MNTSTATUS="RootDrive"
     else true
     fi
    else true
    fi
   else true
   fi
   _debug "MNTSTATUS='$MNTSTATUS'"
   if [ "$MNTSTATUS" ]; then
      icon_mounted_func $partNAME $diskCATEGORY # see functions4puppy4.
   else
    icon_unmounted_func $partNAME $diskCATEGORY # see functions4puppy4.
   fi
   add_pinboard_func $partNAME $diskCATEGORY $partFS # needs ONEDRVNAME, DRV_CATEGORY, FSTYPE.
 done
 # always create a handler for entire drive, even if no icon displayed...
 if [ ! -d "$HOME"/.pup_event/drive_${diskNAME} ]; then
  if [ -e /sys/block/${diskNAME} ]; then
   mkdir $VERB "$HOME"/.pup_event/drive_${diskNAME}
   cp $VERB -af /usr/local/bin/drive_all "$HOME"/.pup_event/drive_${diskNAME}/AppRun
   read SIZE </sys/block/${diskNAME}/size || continue
   SIZE=$((SIZE/2)) #get KB.
   format_size_func $SIZE #formats SIZE for display.
   dINFO="Description: ${DRV_DESCRIPTION} Size: ${diskSIZE}"
   # v424 add item to unmount all mounted partitions...
   MOREITEMS="</Item><Item option=\"unmountall\" icon=\"gtk-harddisk\"><Label>Unmount ALL mounted partitions</Label></Item>"
   create_appinfo_func $diskNAME $diskCATEGORY "$dINFO" "$MOREITEMS" # needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
  else false
  fi
 else true
 fi
 local diskNAME diskCATEGORY partNAME dINFO MOREITEMS SIZE MNTSTATUS partFS rootdrv
}

remove_pinboard_func() { # needs DRV_NAME (name of entire drive)
local DEBUG=${DEBUG:-1}
 _debug "remove_pinboard_func:$*"
 local diskNAME partNAME ppPATTERN ALLNAMES
 diskNAME=$1
 diskNAME=${diskNAME:-"$DRV_NAME"}

 ppPATTERN=' label="'"$diskNAME"'.*" '
 grep $Q "$ppPATTERN" "$HOME"/Choices/ROX-Filer/PuppyPin || return 0 # not listed

 ALLNAMES=`grep -o "$ppPATTERN" "$HOME"/Choices/ROX-Filer/PuppyPin | cut -f 2 -d '"'`

 case $CWM in enlightenment*) return 0;; esac

 for partNAME in $ALLNAMES
 do
  echo "<?xml version=\"1.0\"?>
<env:Envelope xmlns:env=\"http://www.w3.org/2001/12/soap-envelope\">
 <env:Body xmlns=\"http://rox.sourceforge.net/SOAP/ROX-Filer\">
  <PinboardRemove>
   <Path>$HOME/.pup_event/drive_${partNAME}</Path>
  </PinboardRemove>
 </env:Body>
</env:Envelope>"  | rox -R
 done
}

#note that init script in initrd takes care of restoring modules if enough space.
delete_func() { #called from free_func() and free_flash_func(). delete modules to create more free space.
 #passed param: /pup_rw=delete tmpfs top layer only.
 local DEL_LAYER oneKEEP_MOD oneKEEP oneKEEP_SPEC oneKEEP_PATH STATUS=0
 DEL_LAYER=$1
 #find out what modules are loaded, keep those...
 for oneKEEP_MOD in `cut -f 1 -d ' ' /proc/modules`
 do
  oneKEEP_SPEC=`modinfo -F filename ${oneKEEP_MOD}`
  oneKEEP_PATH=`dirname $oneKEEP_SPEC`
  mkdir $VERB -p /tmp${oneKEEP_PATH}
  cp $VERB -af ${oneKEEP_SPEC} /tmp${oneKEEP_PATH}/
  STATUS=$((STATUS+$?))
 done
 if [ "$DEL_LAYER" ]; then
  rm $VERB -rf ${DEL_LAYER}/lib/modules
 else
  if [ "$PUPMODE" = 3 -o "$PUPMODE" = 7 -o "$PUPMODE" = 13 ]; then
   rm $VERB -rf ${SAVE_LAYER}/lib/modules
  fi
  STATUS=$((STATUS+$?))
  rm $VERB -rf /lib/modules
 fi
 STATUS=$((STATUS+$?))
 cp $VERB -af /tmp/lib/modules /lib/modules
 STATUS=$((STATUS+$?))
 depmod -a
 STATUS=$((STATUS+$?))
return $STATUS
}

free_initrd_func() { #UniPup, runs entirely in initramfs.
 local SIZEFREEK SIZEFREEM PREVSIZEFREEM
 SIZEFREEM=`free -m | grep -i -v 'Total' | awk '{print $4}' | head -n 1`
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" = "$SIZEFREEM" ] || echo "$SIZEFREEM" > /tmp/pup_event_sizefreem
                                     #save to a file, freememapplet can read this...
}

# only free pupsave or rootpartition
free_func() { #called every 4 seconds.
local STATUS=0
local WARNMSG=""
 case $PUPMODE in
  6|12) SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_rw$' | awk '{print $4}'`;;
  *)    SIZEFREEM=`/bin/df -m | grep ' /$'              | awk '{print $4}'`;;
 esac
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ "$PREVSIZEFREEM" = $SIZEFREEM ] && return 0
 if [ "$SIZEFREEM" -lt 10 ]; then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ]; then
   delete_func /initrd/pup_rw #save layer is at top, delete mods.
  else
   WARNMSG="WARNING: Personal storage getting full, strongly recommend you resize it or delete files!"
   true
  fi
 else true
 fi
 STATUS=$((STATUS+$?))
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ]; then #full set of modules present, moved from initrd.
  if [ -d /initrd/pup_rw/lib/modules/all-firmware ]; then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$(( SIZEFREEM + SIZE_MODS_M ))
   VIRTUALFREEM=$(( VIRTUALFREEM - 1 )) #allow for some mods will not be deleted.
  else true
  fi
 else true
 fi
 STATUS=$((STATUS+$?))
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 [ "$PUPMODE" = 5 -o "$PUPMODE" = 2 ] && return $STATUS #5=first boot, no msgs at top of screen.
 if [ "$WARNMSG" ]; then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
  false
 else true
 fi
 STATUS=$((STATUS+$?))
return $STATUS
}

free_flash_func() { #PUPMODE 3,7,13. called every 4 seconds.
local STATUS=0
local WARNMSG=""
 SIZEFREEM=`/bin/df -m | grep ' /initrd/pup_ro1$' | awk '{print $4}'`
  SIZETMPM=`/bin/df -m | grep ' /initrd/pup_rw$'  | awk '{print $4}'`
 [ -s /tmp/pup_event_sizefreem ] && read PREVSIZEFREEM </tmp/pup_event_sizefreem
 [ -s /tmp/pup_event_sizetmpm ]  && read PREVSIZETMPM  </tmp/pup_event_sizetmpm
 [ "$PREVSIZEFREEM" = $SIZEFREEM -a "$PREVSIZETMPM" = $SIZETMPM ] && return 0
 if [ "$SIZEFREEM" -lt 10 ]; then
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ]; then
   delete_func /initrd/pup_ro1 #delete modules in save layer only.
  else
   WARNMSG="WARNING: Personal storage file getting full, strongly recommend you resize it or delete files!"
   true
  fi
 else true
 fi
 STATUS=$((STATUS+$?))
 if [ "$SIZETMPM" -lt 5 ]; then
  if [ -d /initrd/pup_rw/lib/modules/all-firmware -a "$ZDRVINIT" = "yes" ]; then
   delete_func /initrd/pup_rw #delete modules in top tmpfs layer only.
  else
   WARNMSG="WARNING: RAM working space only ${SIZETMPM}MB, recommend a reboot which will flush the RAM"
   true
  fi
 else true
 fi
 STATUS=$((STATUS+$?))
 VIRTUALFREEM=$SIZEFREEM
 if [ "$ZDRVINIT" = "yes" ]; then #full set of modules present at bootup.
  if [ -d /initrd/pup_ro1/lib/modules/all-firmware ]; then #have not yet deleted modules.
   #calc the "virtual" free space (would have if modules not there...)
   VIRTUALFREEM=$(( SIZEFREEM + SIZE_MODS_M ))
   VIRTUALFREEM=$(( VIRTUALFREEM - 1 )) #allow for some mods will not be deleted.
  else true
  fi
 else true
 fi
 STATUS=$((STATUS+$?))
 echo "$SIZETMPM" > /tmp/pup_event_sizetmpm
 #save to a file, freememapplet can read this...
 echo "$VIRTUALFREEM" > /tmp/pup_event_sizefreem
 if [ "$WARNMSG" ]; then
  killall yaf-splash
  yaf-splash -margin 2 -bg red -bw 0 -placement top -font "9x15B" -outline 0 -text "$WARNMSG" &
  false
 else true
 fi
 STATUS=$((STATUS+$?))
return $STATUS
}

savepuppy_func() {
local STATUS
  yaf-splash -font "8x16" -outline 0 -margin 4 -bg orange -placement top -text "Saving RAM to 'pup_save' file..." & YAFPID=$!
  _sync
  nice -n 19 /usr/sbin/snapmergepuppy
  STATUS=$?
  kill $YAFPID 2>>$ERR
return $STATUS
}

_check_ramsave_interval(){ #called every 4 seconds. case PUPMODE 3|7|13
[ "$RAMSAVEINTERVAL" -gt 0 ] || return 0
[ "$IMPORTANT_PROGS" ] && return 0
 SAVECNT=$(( SAVECNT + 4 ))
 [ "$SAVECNT" -gt $RAMSAVEINTERVAL ] || return 0
  savepuppy_func
  SAVECNT=0
}


#v407 fixed so works for sr* and hd* optical...
probe_optical_func() { #passed param is sr<0-9> or hd<a-z>
 local diskNAME diskCATEGORY DRV_DESCRIPTION
 diskNAME="$1"
 diskCATEGORY="optical"
 CDSTATUS2="0"
 opticalPATTERN='^/dev/'"${diskNAME}"' '
 _debug "probe_optical_func:$diskNAME '$*'"
 [ "`grep "$opticalPATTERN" /proc/mounts`" ] && return 0 #only check cd if unmounted.
 cddetect_quick -d/dev/${diskNAME} >>$OUT 2>>$ERR #very fast.
 #...returns 0 if disc inserted, else 255.
 CDSTATUS2="$?"
 [ "$CDSTATUS2" != "0" -a -d "$HOME"/.pup_event/drive_${diskNAME} ] && rm $VERB -rf "$HOME"/.pup_event/drive_${diskNAME} #v410 ensure no drive directory if drive empty.
 echo "$CDSTATUS2" > /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP"

 [ -f /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP" ] || {
     _debugx "copying pup_event_frontend_identify2_${diskNAME}.$DISP        pup_event_frontend_identify1_${diskNAME}.$DISP"
        cp $VERB /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP" /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP"
    }

 read CDSTATUS1 </tmp/pup_event_frontend_identify1_${diskNAME}."$DISP"
 [ "$CDSTATUS1" = "$CDSTATUS2" ] && { echo "probe_optical_func:$CDSTATUS1 = $CDSTATUS2"; return 0; }

 _debug "Updating /tmp/pup_event_frontend_identify2_${diskNAME}.$DISP   /tmp/pup_event_frontend_identify1_${diskNAME}.$DISP ."
      cp $VERB -f /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP" /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP"

 if [ "$CDSTATUS2" = "0" ]; then
   _debugx "CDSTATUS2 is 0"

  opticalPATTERN='^/dev/'"${diskNAME}"'|'
  DRV_DESCRIPTION=`echo "$PROBEDISK" | grep "$opticalPATTERN" | cut -f 3 -d '|'`

  _debug "Running create_icon_func $diskNAME $diskCATEGORY $DRV_DESCRIPTION"
  create_icon_func $diskNAME $diskCATEGORY "$DRV_DESCRIPTION" #requires DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
  _debug "Returned from create_icon_func $diskNAME $diskCATEGORY $DRV_DESCRIPTION"
  [ "$HOTPLUGNOISY" = "true" ] && "$HOME"/.pup_event/drive_${diskNAME}/AppRun optical & #handler script.
  true
 else
#KRG  rm -rf "$HOME"/.pup_event/drive_${DRV_NAME} 2>/dev/null
#KRG  remove_pinboard_func #needs DRV_NAME
 true
 fi
}

#v407 detect ls120 and zip disc inserted...
probe_floppy_func() { #passed param is drive name (exs: hdc, sdc)
 local diskNAME diskMAIN diskCATEGORY FLOPPYSTATUS DRV_DESCRIPTION
 diskNAME="$1"
 diskMAIN=`echo -n "$DRV_NAME" | cut -c 1,2` #sd or hd.
 diskCATEGORY="floppy"
 floppyPATTERN="^/dev/$diskNAME"
 [ "`grep "$floppyPATTERN" /proc/mounts`" ] && return 0 #mounted.
 if [ "$diskMAIN" = "hd" ]; then
  cat /proc/ide/${diskNAME}/identify > /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP"
 else
  #this method not as good, as only detects disc if it has a partition...
  floppyPATTERN=" ${diskNAME}"
  grep "$floppyPATTERN" /proc/partitions > /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP"
 fi
 [ -f /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP" ] || cp $VERB /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP" /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP"
  diff $Q -s /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP" /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP" && return 0
 cp $VERB -f /tmp/pup_event_frontend_identify2_${diskNAME}."$DISP" /tmp/pup_event_frontend_identify1_${diskNAME}."$DISP"
 FLOPPYSTATUS=1
 [ "`disktype /dev/${diskNAME} 2>&1 | grep 'I/O error'`" ] || FLOPPYSTATUS=0
 if [ "$FLOPPYSTATUS" = "0" ]; then
  if [ "$diskMAIN" = "hd" ];then
   read DRV_DESCRIPTION </proc/ide/${DRV_NAME}/model
  else
   DRV_DESCRIPTION=`tr -s ' ' </sys/block/${DRV_NAME}/device/model`
  fi
  create_icon_func $diskNAME $diskCATEGORY "$DRV_DESCRIPTION" #requires DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
  [ "$HOTPLUGNOISY" = "true" ] && "$HOME"/.pup_event/drive_${diskNAME}/AppRun floppy & #handler script.
  true
 else
#KRG  rm -rf "$HOME"/.pup_event/drive_${DRV_NAME} 2>/dev/null
#KRG  remove_pinboard_func #needs DRV_NAME
  true
 fi
}

_poll_removable_devices(){
 [ "$ICONDESK" = "true" ] || return 0 #v405 see /etc/eventmanager
 #unfortunately, we have to poll at regular intervals to see if a cd is inserted...
 for oneOPTICAL in $DRVS_OPTICAL
 do
  [ "$oneOPTICAL" ] || continue #precaution
  probe_optical_func $oneOPTICAL
 done
 #v407 poll to see if a ls120 or zip floppy diskette inserted...
 for oneFLOPPY in $DRVS_FLOPPY
 do
  [ "$oneFLOPPY" ] || continue #precaution
  probe_floppy_func $oneFLOPPY
 done
}

create_appinfo_func() { #needs INFO, DRV_CATEGORY, MOREITEMS, ONEDRVNAME
   local partNAME diskCATEGORY INFO MOREITEMS
   partNAME=$1
   partNAME=${partNAME:-"$ONEDRVNAME"}
   diskCATEGORY=$2
   diskCATEGORY=${diskCATEGORY:-"$DRV_CATEGORY"}
   dINFO="$3"
   MOREITEMS="$4"

   echo "<?xml version=\"1.0\"?>
<AppInfo>
  <Summary>${dINFO}</Summary>
  <About>
   <Purpose>Drive icons are part of Puppy Event Manager, see System menu</Purpose>
   <Authors>Barry Kauler LGPL 2008</Authors>
  </About>
  <AppMenu>
   <Item option=\"pmount_${diskCATEGORY}\" icon=\"gtk-harddisk\"><Label>Run Pmount Puppy Drive Mounter</Label></Item>
   <Item option=\"eventmanager\" icon=\"gtk-execute\"><Label>Run Desktop Drive Icon Manager</Label></Item>
   ${MOREITEMS}
  </AppMenu>
</AppInfo>" > "$HOME"/.pup_event/drive_${partNAME}/AppInfo.xml
}

legacy_floppies_func() {
#v407 ls120/zip floppy drives are probed every 4 secs...
[ "$FD0ICON" = "true" ] || return 0 #see /etc/eventmanager
local LEG_FLOPPY oneFD
LEG_FLOPPY=`ls -1vr /sys/block | grep 'fd[0-9]\+'`
  for oneFD in $LEG_FLOPPY ; do
   PROBEDISK="/dev/$oneFD|floppy|Legacy_floppy_drive
$PROBEDISK"
   PROBEPART="/dev/$oneFD|vfat|1440
$PROBEPART"
  done
}

probedisk_func() {
local PROBEDISK2 dINFO PROBED P3 i j U H O
PROBEDISK2=`probedisk2`
dINFO=`echo "$PROBEDISK2" | cut -f3 -d '|' | sed 's#^ [[:blank:]]$#info not avail#' | tr ' ' '_' | sed 's#_*$##'`
PROBEDISK2=`echo "$PROBEDISK2" | cut -f1,2 -d '|'`
j=0; PROBED= ; PROBEDISK=
for i in $PROBEDISK2; do
j=$((j + 1))
P3=`echo "$dINFO" | sed -n "$j"p`
PROBED="$i|$P3 $PROBED"
done
PROBEDISK2=`echo "$PROBED" | tr ' ' '\n'`

U=`echo "$PROBEDISK2" | grep 'usbdrv'  | sort`
H=`echo "$PROBEDISK2" | grep 'drive'   | sort`
O=`echo "$PROBEDISK2" | grep 'optical' | sort`
PROBEDISK="$H $O $U"
PROBEDISK=`echo "$PROBEDISK" | tr ' ' '\n'`
test "$PROBEDISK"
}

probepart_func() {
#PROBEPART="`probepart -k | grep -i -E '\|FAT.*|\|ext4|\|ntfs|\|msdos|\|vfat|\|ext2|\|ext3|\|iso9660|\|xfs|\|reiser'`"
PROBEPART=`probepart -k | grep -viE "swsuspend|none|unknown|swap|Ext'd|Extended|not inserted|\|0\||\|\|"`
test "$PROBEPART"
}

_create_icons() {
_debug "_create_icons:$*"
while read -r diskNAME diskCATEGORY DRV_DESCRIPTION
do
_debugx "$diskNAME $diskCATEGORY $DRV_DESCRIPTION"
[ "$diskNAME" -a "$diskCATEGORY" -a "$DRV_DESCRIPTION" ] || continue
_debug "$diskNAME $diskCATEGORY $DRV_DESCRIPTION"
[ "`echo "$PROBEPART" | grep "$diskNAME"`" ] || continue #precaution (such as CD not inserted).
create_icon_func $1 $diskNAME $diskCATEGORY "$DRV_DESCRIPTION" #needs DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
done<<EOI
$(echo "$PROBEDISK" | cut -f 1,2,3 -d '|' | sed 's%^/dev/%%' | tr ' ' '_' | tr '|' ' ')
EOI
}


######################################################################
drive_icon_func() {
_debug "drive_icon_func:$*"
#stuff to setup at entry...
mkdir $VERB -p "$HOME"/.pup_event

#build the desktop icons...
diskCATEGORY='drive'
probedisk_func  # get global PROBEDISK variable
#v407 ls120/zip floppy drives are probed every 4 secs...
DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
#DRVS_FLOPPY=`ls /sys/block | grep 'fd[0-9]' | sort -r`
#v407 same thing for all optical drives...
DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|' | cut -f 1 -d '|' | cut -f 3 -d '/'`
if [ "$ICONDESK" = "false" ];then
 #only show a single 'drives' icon on desktop...
 diskNAME='drives'
 diskCATEGORY='any' #see pmount.
 DRV_DESCRIPTION="all drives"
 create_icon_func $diskNAME $diskCATEGORY "$DRV_DESCRIPTION" # needs DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION.
else
 #show all drives on desktop... w476 add ext4...
 probepart_func       # get global PROBEPART variable, needed by create_icon_func
 legacy_floppies_func # add floppy to PROBEPART and PROBEDISK variable
 _create_icons $1     # uses PROBEDISK variable
fi
}
drive_icon_func startup


hotplug_prove_func() {
if [ "$BACKENDON" = "false" ];then #see /etc/eventmanager.
 killall hotplug2stdout 2>>$ERR #pup_event_backend_d #no module/firmware hotplug support.
 #...kill hotplug2stdout, as that will cause pup_eventd_backend_d to die.
 pidof udevd >>$OUT || true && killall udevd 2>>$ERR #alternative to pup_event_backend_d.
else true
fi
if [ "$HOTPLUGON" = "false" ]; then
rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
exit 0 #turn off all frontend hotplug support. see /etc/eventmanager.
else true
fi
}
hotplug_prove_func

_redo_config(){
  local DEBUG=${DEBUG:-1}
  _debug "_redo_config:$*"
  screen_start_func
  Floppies=`ls -1v /sys/block | grep 'fd[0-9]*' | sort -r`  #`mut drivelist | grep -o fd[0-9]`
    Drives=`ls -1v /sys/block | grep -E '^sd|^hd|^sr|^mmc|^scd' | sort -r`
  if [ "$Drives" ]; then
  for diskNAME in $Drives; do
  remove_pinboard_func $diskNAME; done
  else true
  fi

  if [ "$Floppies" ]; then
  for diskNAME in $Floppies; do
  remove_pinboard_func $diskNAME; done;
  else true
  fi

  remove_pinboard_func "drives"

  sleep 1
  eventmanager_func # re-reads /etc/eventmanager
  jwm_taskbar_func
  screen_start_func

   drive_icon_func # at startup called with parameter 'startup'
   # checks variable 'ICONDESK'
   # switches between create_icon_func if ICONDESK false
   # and _create_icons if ICONDESK not false

  _sync
} #_redo_config

_check_powertimeout_interval(){
 [ "$POWERTIMEOUT" -gt 0 ] || return 0 #w007 power-off computer after inactivity.
 [ "$IMPORTANT_PROGS" ] && return 0
  MOUSECNT=$(( MOUSECNT + 4 ))
  MINUTECNT=$(( MINUTECNT + 4 ))
  [ "$MINUTECNT" -gt 59 ] || return 0 #come in here every minute...
   MINUTECNT=0
   _debug "CURPOS1=$CURPOS1"
   CURPOS2=`getcurpos`
   _debug "CURPOS2=$CURPOS2"
   [ "$DEBUG" ] && echo "MOUSECNT=$MOUSECNT CURPOS2=$CURPOS2" >> /tmp/pup_event_frontend_d_curpos.log."$DISP"
   #[ "$CURPOS1" ] || CURPOS1="$CURPOS2"
   [ "$CURPOS1" = "$CURPOS2" ] || MOUSECNT=0
   CURPOS1="$CURPOS2"
   _debug "MOUSECNT=$MOUSECNT" "POWERTIMEOUT=$POWERTIMEOUT"
   [ "$MOUSECNT" -gt "$POWERTIMEOUT" ] || return 0
    aplay /usr/share/audio/2barks.au
    sleep 1s
    aplay /usr/share/audio/2barks.au
    xmessage -bg red -timeout 60 -buttons "YES:190,No:191" -fn "-misc-dejavu sans-*-*-*-*-*-*-*-*-*" "Message from
$PROG
and `which eventmanager`
Really powering off now ?
$PIDPROG"
     REPLY=$?
    echo $REPLY
    if [ "$REPLY" = "190" -o "$REPLY" = "0" ] ; then
    exec wmpoweroff &
    else true
    fi
}

TOGGLE=1
SAVECNT=0
MOUSECNT=0  #w007
MINUTECNT=0 #w007
CURPOS1="-1 -1"  #w007
[ "$DEBUG" ] && echo -n "" > /tmp/pup_event_frontend_d_curpos.log."$DISP" #w007
ls -1v /sys/block | grep -vE 'loop|md|mtd|nbd|ram' >/tmp/pup_event_frontend_block1."$DISP"

pup_event_frontend_d_main() {
###################################################################
#now go into a two-second loop...
while :
do
 sleep 2

 #graceful exit if shutdown X (see /usr/X11R7/bin/restartwm,wmreboot,wmpoweroff)...
 #[ -f /tmp/wmexitmode.txt ] && exit
 #[ -f /tmp/wmexitmode.txt ] && break  ##+++2011-10-28 test
 [ -f /tmp/xwin/wmexitmode."$DISP" ] && break

 #test for any change in /sys/block...
 #ls -1 --hide=ram* --hide=loop* /sys/block > /tmp/pup_event_frontend_block2
 ls -1v /sys/block | grep -vE 'loop|md|mtd|nbd|ram' >/tmp/pup_event_frontend_block2."$DISP"
 if [ -f /tmp/pup_event_frontend_block_request ];then #w015
  sleep 0.1
  REMOVEBLOCK='^'"`cat /tmp/pup_event_frontend_block_request`"'$'
  BLOCKS2=`grep -v "$REMOVEBLOCK" /tmp/pup_event_frontend_block2."$DISP"`
  echo "$BLOCKS2" > /tmp/pup_event_frontend_block2."$DISP"
  rm $VERB -f /tmp/pup_event_frontend_block_request
 else true
 fi

 #########hotplug block event##########
 BLOCKDIFF=`diff -u /tmp/pup_event_frontend_block1."$DISP" /tmp/pup_event_frontend_block2."$DISP"`
 if [ "$BLOCKDIFF" ]; then

  cp $VERB -f /tmp/pup_event_frontend_block2."$DISP" /tmp/pup_event_frontend_block1."$DISP"

  BLOCKSADD=`echo "$BLOCKDIFF" | grep '^\+[[:alpha:]].*' | tr -d '\+'`
  BLOCKSREM=`echo "$BLOCKDIFF" | grep '^\-[[:alpha:]].*' | tr -d '\-'`

  ACTION=add
  SUBSYSTEM=block
  DEVTYPE=disk
  for diskNAME in $BLOCKSADD
  do
   [ -e /sys/block/$diskNAME ] || continue #precaution
   DEVPATH=/block/$diskNAME
   odPATTERN='^/dev/'"$diskNAME"'|'
   PROBEDISK=`probedisk2`
   DRVS_OPTICAL=`echo "$PROBEDISK" | grep '|optical|'  | cut -f 1 -d '|' | cut -f 3 -d '/'` #update
    DRVS_FLOPPY=`echo "$PROBEDISK" | grep '|floppy|'   | cut -f 1 -d '|' | cut -f 3 -d '/'`  #update
   diskCATEGORY=`echo "$PROBEDISK" | grep "$odPATTERN" | cut -f 2 -d '|'`
   DRV_DESCRIPTION=`echo "$PROBEDISK" | grep "$odPATTERN" | cut -f 3 -d '|' | tr -s ' '`
   [ "$ICONDESK" = "true" ] && create_icon_func $diskNAME $diskCATEGORY "$DRV_DESCRIPTION" # uses DRV_NAME, DRV_CATEGORY, DRV_DESCRIPTION
   [ "$HOTPLUGNOISY" = "true" ] && "$HOME"/.pup_event/drive_${diskNAME}/AppRun ${diskCATEGORY} & #h andler script.
   true
  done

  ACTION=remove
  for diskNAME in $BLOCKSREM
  do
   #[ -e /sys/block/$DRV_NAME ] && continue # precaution. w015 must remove.
   DRVS_OPTICAL=`echo "$DRVS_OPTICAL" | grep -v "$diskNAME"` #update
   DRVS_FLOPPY="`echo "$DRVS_FLOPPY" | grep -v "$diskNAME"`" #update
   DEVPATH=/block/$diskNAME
   if [ "`pidof gtkdialog_pmount`" ];then # if pmount running, refresh it.
    killall gtkdialog_pmount 2>>$ERR
    sleep 0.1
    exec pmount &
   else true
   fi
   remove_pinboard_func $diskNAME # needs DRV_NAME
   rm $VERB -rf "$HOME"/.pup_event/drive_${diskNAME}*
  done
 else true
 fi

 [ "$TOGGLE" = 0 ] && { TOGGLE=1 ; continue; } || TOGGLE=0

 #######four second timeout procesing#########

 #some apps should not be disturbed by background stuff...
 #w482 add xorriso...
 IMPORTANT_PROGS=`ps | grep $Q -E 'make|gcc|g\+\+|scons|burniso2cd|cdrecord|growisofs|pburn|pcdripper|pdvdrsab|ripoff|xorrecord|xorriso|gimv|mhwaveedit|mplayer|vlc|xfmedia|xine|xmms|axel|curl|wget|dotpup|petget|installpkg\.sh|downloadpkgs\.sh'` # && continue

 #monitor free memory, periodic save of tmpfs top layer...
 case $PUPMODE in
  3|7|13)      free_flash_func
               #savepuppy_func;;
               _check_ramsave_interval;;
  16|24|17|25) free_initrd_func;;  #unipup.
  *)           free_func;;
 esac

    if test -f /tmp/pup_event_icon_change_flag."$DISP" ; then
   _redo_config
   rm $VERB -f /tmp/pup_event_icon_change_flag."$DISP"
# elif test -f /tmp/pup_event_icon_change_flag ; then
#  _redo_config
#  rm $VERB -f /tmp/pup_event_icon_change_flag
 else true
 fi

 [ "$AUTOUNMOUNT" = "true" ] && auto_unmount_func #v424 automatially unmount a partition if no longer being used (AUTOUNMOUNT set in eventmanager).

 _poll_removable_devices

 _check_powertimeout_interval


done #2 second loop.
}
pup_event_frontend_d_main
#;;  # start
#esac
rm $VERB -f /var/run/pup_event_frontend_d.pid."$DISP"
echo "$0:Stopped."
###END###
