#!/bin/ash
#BK 2006 www.puppylinux.com
#2007 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
#v407 fix for floppy drive icon.
#v409 gparted create ext3 part. failed, fixed by making /etc/mtab a symlink.

########################################################################
#
#
#
#
#
# /dev/sda5:
# LABEL="MacPup430_F3"
# UUID="07443de5-1fab-4656-a3ab-7b1c14ccc8c8"
# TYPE="ext3"
# DISTRO_VERSION=430·#481·#416·#218·#478······#####change·this·as·required#####
# DISTRO_BINARY_COMPAT="puppy"·#"ubuntu"·#"puppy"·#####change·this·as·required#####
# case·$DISTRO_BINARY_COMPAT·in
# ubuntu)
# DISTRO_NAME="Jaunty·Puppy"
# DISTRO_FILE_PREFIX="upup"
# DISTRO_COMPAT_VERSION="jaunty"
# ;;
# debian)
# DISTRO_NAME="Lenny·Puppy"
# DISTRO_FILE_PREFIX="dpup"
# DISTRO_COMPAT_VERSION="lenny"
# ;;
# slackware)
# DISTRO_NAME="Slack·Puppy"
# DISTRO_FILE_PREFIX="spup"
# DISTRO_COMPAT_VERSION="12.2"
# ;;
# arch)
# DISTRO_NAME="Arch·Puppy"
# DISTRO_FILE_PREFIX="apup"
# DISTRO_COMPAT_VERSION="200904"
# ;;
# t2)
# DISTRO_NAME="T2·Puppy"
# DISTRO_FILE_PREFIX="tpup"
# DISTRO_COMPAT_VERSION="puppy5"
# ;;
# puppy)·#built·entirely·from·Puppy·v2.x·or·v3.x·or·4.x·pet·pkgs.
# DISTRO_NAME="Puppy"
# DISTRO_FILE_PREFIX="pup"·#"ppa"·#"ppa4"·#"pup2"··#pup4··###CHANGE·AS·REQUIRED,·recommend·limit·four·characters###
# DISTRO_COMPAT_VERSION="4"·#"2"··#4·····###CHANGE·AS·REQUIRED,·recommend·single·digit·5,·4,·3,·or·2###
# ;;
# esac
# PUPMODE=2
# KERNVER=2.6.30.6-KRG-i486
# ATADRIVES='·sda'
# USB_SATAD=''
# PUP_HOME='/'
# Linux·puppypc·2.6.30.6-KRG-i486·#1·SMP·Sun·Jan·2·20:32:12·GMT-1·2011·i686·GNU/Linux
# Xserver=/usr/X11R7/bin/Xvesa_stripped_upx9
# $LANG=en_US
# today=Mon·Oct·24·22:55:49·CEST·2011
#
#
#
#
#
########################################################################


#mount-FULL, umount-FULL, losetup-FULL are the full versions.
#The Busybox versions of mount and umount are available but only by:
# # busybox mount ...
# # busybox umount ...
#mount and umount are now scripts.
#if an ntfs partition, puppy uses user-mode ntfs-3g driver.
#the mount and umount scripts allow seamless mounting and unmounting of ntfs f.s.

LANG=C
[ "$1" ] || exec busybox mount


echo "$0:$*" >&2
j=0
for i in `seq 1 $#`; do
j=$((j+1))
PARAM=`echo "$*" | cut -f $i -d ' '`
[ "$VERBOSE" = 1 ] && echo "\$j='$PARAM'" >&2
eval PARAME$j='\\'"${PARAM}"
eval echo "\$PARAME$j" >&2
if [ -n "`echo $PARAM | grep '/' | grep -v /dev/`" ] ; then
[ -e "$PARAM" ] || { echo 'Folder '"$PARAM"' does not exists. Creating now ...' >&2; mkdir -p "$PARAM"; }
fi
done

# I realised this script has to allow reentrancy. So, all temp file now unique,
# using ${$} which is pid of script.
MYPID=${$}
. /etc/rc.d/functions4puppy4 #v4.02


ALREADYMOUNTED=`cut -f1 -d ' ' /proc/mounts`
SIMPLEMOUNT=''
[ "$VERBOSE" = 1 ] && echo 'Simple mount begin' >&2
echo "$1" >&2
echo "$1" | /bin/grep -Ee '/dev/|/mnt/' >&2
echo >&2
echo "'$@'" = "'$1'" >&2
echo "'$2'" >&2
if [[ -n "`echo "$1" | grep -E '/dev/|/mnt/'`" ]] && [[ "`echo "$@"`" = "$1" ]] && [[ -z "$2" ]] ; then
#GREPPARAM=`echo "$1" | sed 's#-#\\\-#g'`
#GREPPARAM=`echo "$1" | sed 's/\([[:punct:]]\)/\\\\\1/g; s/\\\\\\\\\\\/\\\/g'`
## from /sbin/init      sed 's/\([[:punct:]]\)/\\\\\1/g; s/\\\\/\\/g ; s#\ #\\\ #g ; s/ $// ; s/\\$//'
GREPPARAM=$(echo "$1" | sed 's/\([[:punct:]]\)/\\\\\1/g ; s/\(\\\\\\\)*$//' | tr -s '\\')
[ "$VERBOSE" = 1 ] && echo 'if #1' >&2
echo GREPPARAM="$GREPPARAM"
if [ ! -f /etc/fstab ] || [ -z "`grep -w "$GREPPARAM" /etc/fstab | grep -v -E -e '^#|^[[:blank:]]*#'`" ]; then
[ "$VERBOSE" = 1 ] && echo 'if #2' >&2
simpledriveandpartitionname=`echo "$1" | sed 's#^/dev/##;s#^/mnt/##'`
[ -d "/mnt/$simpledriveandpartitionname" ] || mkdir "/mnt/$simpledriveandpartitionname"
SIMPLEMOUNT="/dev/$simpledriveandpartitionname /mnt/$simpledriveandpartitionname"
fi
fi


[ "$VERBOSE" = 1 ] && echo 'Part -a begin' >&2
echo "'$@'" >&2
opt_a_PATTERN=`echo " $@" | grep -w -E -e '\ \-[a-z]*a[a-z]*|\ \-a[a-z]*|\ \-[a-z]*a|\ \-a' | sed 's#^ *##' | tr -s ' '`
echo opt_a_PATTERN="$opt_a_PATTERN" >&2

if [[ -n "$opt_a_PATTERN" ]] ; then
### option -a given
### filer other params
[ "$VERBOSE" = 1 ] && echo 'line:131' >&2
count_PARAMS=$(( $(echo "$opt_a_PATTERN" | wc -c) - 2 ))
[ "$VERBOSE" = 1 ] && echo "count_PARAMS='$count_PARAMS'" >&2

for i in `seq 0 $count_PARAMS`; do
[ "$VERBOSE" = 1 ] && echo $i >&2
PARAM=${opt_a_PATTERN:$i:1}
[ "$PARAM" = " " ] && PARAM=''
[ "$VERBOSE" = 1 ] && echo "'$PARAM'" >&2
[ -z ${PARAM} ] || [ ${PARAM} = "a" ] && continue
PARAMETERLINE="$PARAMETERLINE ${PARAM}"
done

PARAMETERLINE=`echo "$PARAMETERLINE" | sed 's# ##g ; s#-##g ; s#^#-#'`
[ "$PARAMETERLINE" = "-" ] && PARAMETERLINE=''
echo "PARAMETERLINE='$PARAMETERLINE'"
[ "$VERBOSE" = 1 ] && echo 'if #3' >&2

if [ -n `readlink -f /etc/fstab` ]; then
[ "$VERBOSE" = 1 ] && echo 'if #4' >&2
FSTAB=`cat $(readlink -f /etc/fstab) | grep -E '^/dev/|^no' | grep -v -E -e 'noauto|^#|^[[:blank:]]*#' | tr '\t' ' ' | tr -s ' ' | sed 's/^[[:blank:]]*//'`
MOUNTDIRS=`echo "$FSTAB" | cut -f 2 -d ' '`
for i in $MOUNTDIRS ; do
[ -d "$i" ] || { [ "$VERBOSE" = 1 ] && echo 'if #5' >&2;mkdir -p "$i"; }
done

###first simple attempt###
FSTYPES=`echo "$FSTAB" | cut -f 3 -d ' '`
[ -n "`echo "$FSTYPES" | grep 'ntfs'`" ] && { [ "$VERBOSE" = 1 ] && echo 'if #6' >&2;SPECIALOPT='1'; }

###second loop attempt###
for i in $MOUNTDIRS ; do
DEVICE=`echo "$FSTAB" | grep "$i" | cut -f 1 -d ' '`
[ "$DEVICE" ] || { echo -e "\e[31mError, no device specified for '$i'\e[39m" >&2;continue; }
FSTYPE=`echo "$FSTAB" | grep "$i" | cut -f 3 -d ' '`
[ "$FSTYPE" ] || { echo -e "\e[31mError, no file system type specified for '$i'\e[39m" >&2;continue; }
OPTION=`echo "$FSTAB" | grep "$i" | cut -f 4 -d ' '`
[ "$OPTION" ] || { echo -e "\e[31mError, no option(s) specified for '$i'\e[39m" >&2;continue; }

MOUNTLINE="${PARAMETERLINE} -t ${FSTYPE} -o ${OPTION} ${DEVICE} $i"

if [ -z "`busybox mount | grep "$i"`" ] ; then
mount-FULL $MOUNTLINE  #no double quotes at least for ash here ; this seems to sqeeze multiple following spaces into one space
RETVAL=$?
if [ "$RETVAL" != "0" ]; then
echo "$0:ERROR mounting '$MOUNTLINE'" >&2
fi
#mount-FULL "$PARAMETERLINE" "$DEVICE" "$i" -t "$FSTYPE" -o "$OPTION"
fi
done
else
echo -e "\\033[0;31m""Error, option '-a' given but /etc/fstab does not exist.""\\033[0;39m" >&2
exit
fi
#######original part :
else
[ "$VERBOSE" = 1 ] && echo 'if #3 else' >&2
#v2.12 discovered difference between $@ and $*. Replaced all $@ with $* in this script...

#extract all the '-' options, on separate lines... do NOT use $@!!!!...
#v3.93 eliminate ' -- ' and all past it...
DASHOPTS=`echo -n " $*" | tr '\t' ' ' | tr -s '[[:blank:]]' | sed 's/\(  *\)--\(  *\)/\1\2/g ; s#--$##' | tr ' ' '\n' | grep '^\-'` ##  ; s# *-- *##g## NOT needed anymore
[ "$VERBOSE" = 1 ] && echo "DASHOPTS='$DASHOPTS'" >&2
#needs an explicit '-t ntfs', does not work with /etc/fstab...
if [ "`echo "$*" | grep 'ntfs'`" = "" ];then
[ "$VERBOSE" = 1 ] && echo 'if #7' >&2

  if test -n "$SIMPLEMOUNT" ; then
  [ "$VERBOSE" = 1 ] && echo 'if #8' >&2
  mount-FULL -n $SIMPLEMOUNT  ## does not work within double quotes
  RETVAL=$?
  [ "$VERBOSE" = 1 ] && echo "mount-FULL simplemount RETVAL='$RETVAL'" >&2 #DBG
  else
  [ "$VERBOSE" = 1 ] && echo 'if #8 else' >&2
  mount-FULL -n ${@}
  RETVAL=$?
  [ "$VERBOSE" = 1 ] && echo "mount-FULL normal RETVAL='$RETVAL'" >&2 #DBG
 #fi
 fi
else
 #screen out all the options...
 CMDPRMS=`echo -n "$*" | tr '\t' ' ' | tr -s ' ' | tr ' ' '\n' | grep '^/' | tr '\n' ' '`
 #kirk advised these options so Rox will not complain about file
 #permissions when copy a file to a ntfs partition...
 [ -f /tmp/ntfsmnterr${MYPID}.txt ] && rm -f /tmp/ntfsmnterr${MYPID}.txt
 echo "CMDPRMS='$CMDPRMS'"
 ntfs-3g $CMDPRMS -o umask=0,no_def_opts 2>/tmp/ntfsmnterr${MYPID}.txt
 RETVAL=$?
 [ "$VERBOSE" = 1 ] && echo "ntfs-3g RETVAL='$RETVAL'" >&2
 #v2.16 ntfs-3g v1.417, part. scheduled for check, failed with value 10...
 #v4.00 ntfs-3g v1.2412 does not have 4,10, has 15 for dirty f.s., 14 hiberneted...
 if [ $RETVAL -eq 4 -o $RETVAL -eq 10 -o $RETVAL -eq 15 -o $RETVAL -eq 14 ];then  #try to force it...
  if [ $RETVAL -eq 14 ];then
   #ntfs-3g $CMDPRMS -o umask=0,no_def_opts,remove_hiberfile 2>/tmp/ntfsmnterr${MYPID}.txt
   #RETVAL=$?
   echo > /dev/null
  else
   ntfs-3g $CMDPRMS -o force,umask=0,no_def_opts 2>/tmp/ntfsmnterr${MYPID}.txt
   RETVAL=$?
   ERRMSG1=`cat /tmp/ntfsmnterr${MYPID}.txt`
   echo "ntfs-3gretval#4,10,15# RETVAL='$RETVAL'"
   [ "$VERBOSE" = 1 ] && echo "$ERRMSG1"
   if [ $RETVAL -eq 0 ];then
    echo "WARNING: NTFS f.s. mounted read/write but corrupted."
    [ "`pidof X`" = "" ] || nohup gxmessage -bg red -center -title "NTFS WARNING" "The ntfs-3g driver was able to mount the NTFS
partition but returned this error message:
$ERRMSG1

It is mounted read/write, but advice is only write
to it in emergency situation. Recommendation is
boot Windows and fix the filesystem first!!!" &
   fi
  fi
 fi
 [ "$VERBOSE" = 1 ] && echo "ntfs-3g_after_check_error_code RETVAL='$RETVAL'" >&2
 #ntfs-3g plays very safe and will not mount if thinks anything
 #wrong with ntfs f.s. But, we may want to recover files from a
 #damaged windows. So, fall back to the kernel ntfs driver...
 if [ ! $RETVAL -eq 0 ];then
  #mount read-only...
  busybox mount -r -t ntfs $CMDPRMS
  RETVAL=$?
  [ "$VERBOSE" = 1 ] && echo "ntfs-3g switch to busybox mount RETVAL='$RETVAL'" >&2
  ERRMSG1=`cat /tmp/ntfsmnterr${MYPID}.txt`
  [ "$VERBOSE" = 1 ] && echo "$ERRMSG1" >&2
  if [ $RETVAL -eq 0 ];then
   echo "WARNING: NTFS f.s. mounted read-only."
   [ "`pidof X`" = "" ] || nohup gxmessage -bg red -center -title "NTFS WARNING" "The ntfs-3g driver was unable to mount the NTFS
partition and returned this error message:
$ERRMSG1

So, the inbuilt kernel NTFS driver has been used
to mount the partition read-only." &
  fi
 fi
fi
fi
echo "final mount RETVAL='$RETVAL'" >&2
[ "$VERBOSE" = 1 ] && echo "DISPLAY='$DISPLAY'" >&2
#v4.02 if there is a desktop icon (see pup_eventd), then refresh it...
##if [ "$RETVAL" -eq 0 -a "$DISPLAY" != "" ];then
if [ -n "$DISPLAY" ] ; then  ##1
 ##DEVNAME="`busybox mount | tail -n 1 | grep '^/dev/' | cut -f 1 -d ' ' | cut -f 3 -d '/'`"
 #DEVNAMES="`busybox mount | cut -f 1 -d " " | /bin/grep -v -w "$ALREADYMOUNTED"`"
 DEVNAMES=`cut -f 1 -d ' ' /proc/mounts | /bin/grep -v -F -w "$ALREADYMOUNTED"`
 [ "$VERBOSE" = 1 ] && echo "DEVNAMES='$DEVNAMES'" >&2
 ##if [ "$DEVNAME" != "" ];then  ##2
  for i in $DEVNAMES ; do
  DEVNAME=`basename $i`
  DRVNAME=`echo -n "$DEVNAME" | cut -c 1-3`
  [ "$VERBOSE" = 1 ] && echo "DRVNAME='$DRVNAME'" >&2
  #special case, SD card /dev/mmcblk0p1...
  [ "$DRVNAME" = "mmc" ] && DRVNAME=`echo -n "$DEVNAME" | sed -e 's/p[0-9]$//'`
  xDRVNAME="$DRVNAME" #v404
  [ "$VERBOSE" = 1 ] && echo "xDRVNAME='$xDRVNAME'" >&2
  [ -d /root/.pup_event/drive_${DEVNAME} ] && DRVNAME="$DEVNAME" #icon for each partition.
  [ "$VERBOSE" = 1 ] && echo "DRVNAME='$DRVNAME'" >&2
  if [ -d /root/.pup_event/drive_${DRVNAME} ];then  ##3
   [ "$VERBOSE" = 1 ] && echo "/root/.pup_event/drive_'$DRVNAME' exists" >&2
   case $DRVNAME in #v407
    fd*)
     DRV_CATEGORY="floppy"
     [ "$VERBOSE" = 1 ] && echo "DRV_CATEGORY='$DRV_CATEGORY'" >&2
    ;;
    *)
     dnPATTERN='/dev/'"${xDRVNAME}"'|'
     DRV_CATEGORY=`probedisk2 | grep "$dnPATTERN" | cut -f 2 -d '|'`
     [ "$VERBOSE" = 1 ] && echo "dnPATTERN='$dnPATTERN' DRV_CATEGORY='$DRV_CATEGORY'" >&2
    ;;
   esac
   [ "$VERBOSE" = 1 ] && echo 'starting icon_mounted_func ...' >&2
   icon_mounted_func $DRVNAME $DRV_CATEGORY #see functions4puppy4
   echo '... returned from icon mounted func' >&2
  fi  ##3
 done
## fi  ##2
fi  ##1
echo "finishing now '$0' ..." >&2
#v409 now have /etc/mtab a symlink to /proc/mounts so this section not needed...
##note, it is a long story here. Busybox can be configured to
##support /etc/mtab, however the information it writes to mtab
##is incomplete, different, and breaks my scripts.

#v409, instead just make sure the symlink stays there...
if [ ! -L /etc/mtab ];then
 rm -f /etc/mtab
 ln -s /proc/mounts /etc/mtab
fi
echo "RETVAL='$RETVAL'" >&2
[ "$RETVAL" = 0 ] || {
[ "$simpledriveandpartitionname" -a -d "/mnt/$simpledriveandpartitionname" ] && rmdir "/mnt/$simpledriveandpartitionname"; }
[ "$VERBOSE" = 1 ] && echo "... '$0' ...finished." >&2

exit $RETVAL
