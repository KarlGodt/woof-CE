#!/bin/bash
# Karl Reimer Godt June 2013
# Thanks to L18L for testing and confirming that ntfs-3g could need a patch to
# ignore unused common Linux/GNU mount options

[ "$*" ] || exec busybox mount

echo "$0:$#:$*"

FILER=rox
FAT_DEF_OPS="-o shortname=mixed,quiet" #vfat default mount options

_get_codepage(){
       FATMOUNT=YES;CPAGE=437;IOCSET=iso8859-1        # Windows FATXY
       IFS='.' read KM rest </etc/keymap #|| KM=us
       case $KM in
       de|be|br|dk|es|fi|fr|it|no|se|pt)         CPAGE=850 ;;
       slovene|croat|hu101|hu|cz-lat2|pl|ro_win) CPAGE=852 ; IOCSET=iso8859-2 ;;
       esac
}

[ $# = 1 -a -b "$1" ] &&  #simple mount: invoke it as `mount /dev/sdaXY'
{
    FSTYPE=`guess_fstype "$1"`
    [ "$FSTYPE" != unknown -a "$FSTYPE" != "" ] && OP="-t $FSTYPE"
    [ "$FSTYPE" = ntfs ] && OP="-t ntfs-3g"
    [ "$FSTYPE" = vfat ] && { _get_codepage; OP="$FAT_DEF_OPS -o codepage=${CPAGE},iocharset=$IOCSET"; }
    [ -d /mnt/"${1##*/}" ] || mkdir -p /mnt/"${1##*/}"
    mount-FULL $OP "$1" /mnt/"${1##*/}"
    RETVAL=$?
    case $RETVAL in 0) :;;
    *) mount-FULL "$1" /mnt/"${1##*/}"
       RETVAL=$?;;
    esac
} || {  # OR more then 1 arg OR arg[1] not block device :

ARGS=`set | grep 'BASH_ARG'`                          #parse arguments to script
ARGV=`echo "$ARGS" | grep 'ARGV' | grep -o '\[.*"'`
ARGC=`echo "$ARGS" | grep 'ARGC' |cut -f2 -d'"'`
c=$ARGC
while read p
do
P[$c]="${p#*=}"
P[$c]="${P[$c]/#\"}"
P[$c]="${P[$c]/%\"}"
[ "${P[$c]}" = ntfs ] && P[$c]='ntfs-3g' #use -t ntfs-3g mount ops instead of -t ntfs
case ${P[$c]} in                         #to be able to avoid call to ntfs-3g directly
 ntfs-3g) NTFSMOUNT=YES;;                             # Windows NTFS
 vfat) _get_codepage
       #FATMOUNT=YES;CPAGE=437;IOCSET=iso8859-1        # Windows FATXY
       #IFS='.' read KM rest </etc/keymap #|| KM=us
       #case $KM in
       #de|be|br|dk|es|fi|fr|it|no|se|pt)         CPAGE=850 ;;
       #slovene|croat|hu101|hu|cz-lat2|pl|ro_win) CPAGE=852 ; IOCSET=iso8859-2 ;;
       #esac
       ;;
esac

(( c-- ))
done<<EOI
$(echo "$ARGV" | sed 's%" \[%"\n\[%g' )
EOI

 # try to create directory if not already exist . Quite simple assumption ...
d=0
for opt in ${P[@]}; do
(( d++ ))
echo "'$opt' '$d' '${P[$d]}'"
test "$markOPTARG" = 1 && { markOPTARG=0; continue; }
case $opt in
-U|-t|-p|-o|-O|-L)      markOPTARG=1;;
-a|-f|-F|-h|-i|-l|-r|-s|-v|-V|-w)  :;;   # above L: OPTARG options
--bind|--move)                     :;;
/dev/*|nodev|none|*fs) :;;               # *fs for *filesystem could error below...
*) [ -e ${P[$d]} ] || { mkdir -p ${P[$d]}; newMNTP="${P[$d]}"; } ;;
esac
#(( d++ ))
done
}

[ "$RETVAL" ] ||         #if simple mount , then RETVAL exists, otherwise
{                        #do this code below:
 if [ "$NTFSMOUNT" ] ; then {             #first test if both windows bits are set
    #     echo "using mount-FULL ${P[@]}" #if transforming from -t ntfs to -t ntfs-3g successfull, then...
    mount-FULL ${P[@]} && RETVAL=$? || {  #otherwise use original args
    #     echo "using mount-FULL ${*}"    #would use -t ntfs or -t ntfs-3g then if given
    mount-FULL ${*} && { RETVAL=$? ; NTFSRO=YES ; } || RETVAL=$? ; } ; }
elif [ "$FATMOUNT" ] ; then { mount-FULL ${P[@]} -o shortname=mixed,quiet,codepage=${CPAGE},iocharset=$IOCSET ; RETVAL=$? ; }
else { mount-FULL ${P[@]} ; RETVAL=$? ; }  # windows bits are not set
fi
}

[ "$DISPLAY" -a "$RETVAL" = 0 ] || exit $RETVAL
[ "$NTFSRO" ] && xmessage -bg orange "NTFS mount
$0 $*
as
mount-FULL $[P{@]}
failed to mount read-write .
The kernel NTFS driver was used to mount
mount-FULL ${*} at least read-only ." &

read device rest <<EOI
$(tail -n1 /proc/mounts)
EOI

PARTNAME=${device##*/}

_exit(){ which "$FILER" && { sleep 0.1;
 test -d "$newMNTP" && { sleep 0.1; $FILER -x "${newMNTP%/*}" -x "$newMNTP" -d "$newMNTP"; }
 test "/mnt/$PARTNAME" = "$newMNTP" || $FILER -x "`pwd`" -x /mnt -x /mnt/$PARTNAME; }
 exit $RETVAL; }

[ -d /root/.pup_event/drive_${PARTNAME} ] || _exit $RETVAL

 case $PARTNAME in
 fd*)         DRV_CATEGORY=floppy ;;
 mmc*)     PARTNAME=${PARTNAME%p*} ; DRV_CATEGORY=card ;;
 scd*|sr*) DRV_CATEGORY=optical ;;
 hd*) : ;;  #either drive or optical
 sd*) : ;;  #either drive or usbdrv
 *) _exit $RETVAL ;; #loop devices etc.
 esac
#echo "'$PARTNAME' '$DRV_CATEGORY' '$device'"
[ "$DRV_CATEGORY" ] || DRV_CATEGORY=`probedisk2 | grep -m1 "^${device//[[:digit:]]/}|" |cut -f2 -d'|'`

. /etc/rc.d/functions4puppy4
icon_mounted_func "$PARTNAME" "$DRV_CATEGORY"

test -d "$newMNTP" -a "`which "$FILER"`" && { sleep 0.1; $FILER -x "${newMNTP%/*}" -x "$newMNTP" -d "$newMNTP"; }
#test -d /mnt/$PARTNAME -a "/mnt/$PARTNAME" != "$newMNTP" -a "`which "$FILER"`" && { sleep 0.1; $FILER -x /mnt -x /mnt/$PARTNAME -d /mnt/$PARTNAME; }
[ -L /etc/mtab ] || ln -sf /proc/mounts /etc/mtab
exit $RETVAL
